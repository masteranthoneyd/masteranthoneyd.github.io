<?xml version="1.0" encoding="utf-8"?><search><entry><title>基于Hexo搭建个人博客——进阶篇(从入门到入土)</title><url>/2017/build-blog-hexo-advanced/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/build-hexo/next.png" alt></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>好久没更新了, 因为懒- -<br>前面介绍了Hexo的一些基本搭建→<strong><em><a href="/2017/build-blog-hexo-base/">基于Hexo+github+coding搭建个人博客——基础篇(从菜鸟到放弃)</a></em></strong><br>对于追求装X的博主来说, 基本的搭建是满足不了的, 接下来整理了一下各方面的细节优化, 包括页面字体大小、配色、背景、SEO(搜索引擎优化)、域名绑定、DNS域名解析实现负载均衡等.<br>关于<code>NexT</code>主题的很多配置、插件都可以在<strong><em><a href="theme-next.iissnan.com/getting-started.html">官方文档</a></em></strong>找到答案, 那么博主只是整理了一些官方没怎么提及的细节优化. </p>
<a id="more"></a>
<h1 id="解决Hexo命令fs-SyncWriteStream问题"><a href="#解决Hexo命令fs-SyncWriteStream问题" class="headerlink" title="解决Hexo命令fs.SyncWriteStream问题"></a>解决Hexo命令fs.SyncWriteStream问题</h1><p>请看<strong><em><a href="/2017/build-blog-hexo-base/#解决Hexo命令fs-SyncWriteStream问题">解决Hexo命令fs.SyncWriteStream问题</a></em></strong></p>
<h1 id="高度定制优化篇"><a href="#高度定制优化篇" class="headerlink" title="高度定制优化篇"></a>高度定制优化篇</h1><h2 id="集成Mod分享组件"><a href="#集成Mod分享组件" class="headerlink" title="集成Mod分享组件"></a>集成Mod分享组件</h2><p><img src="https://cdn.yangbingdong.com/img/build-hexo/share-mod.png" alt></p>
<p>Step1、获取 AppKey<br>在 <em><a href="http://www.mob.com/" rel="external nofollow noopener noreferrer" target="_blank">Mob</a></em> 注册账号后, 点击头像进入后台, 选择 <code>shareSDK</code> 添加一个 <code>Web应用</code>: </p>
<p><img src="https://cdn.yangbingdong.com/img/build-hexo/mod-share.png" alt></p>
<p>Step2、在<strong>主题配置文件</strong>中添加配置:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mob_share:</span><br><span class="line">  enable: true</span><br><span class="line">  appkey: ********</span><br></pre></td></tr></table></figure></p>
<p>Step3、在<code>next/layout/_partials/share/</code>里面添加<code>mob_share.swig</code>:<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--MOB SHARE BEGIN--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"-hoofoo-share-title"</span>&gt;</span>分享到: <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"-hoofoo-share-buttons"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"-mob-share-weibo -hoofoo-share-weibo -hoofoo-share-ui-button"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-weibo"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"-mob-share-weixin -hoofoo-share-weixin -hoofoo-share-ui-button"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-weixin"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"-mob-share-qq -hoofoo-share-qq -hoofoo-share-ui-button"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-qq"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"-mob-share-twitter -hoofoo-share-twitter -hoofoo-share-ui-button"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-twitter"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"-hoofoo-share-more -hoofoo-share-ui-button -mob-share-open"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-ellipsis-h"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"-mob-share-ui"</span> <span class="attr">style</span>=<span class="string">"display: none"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"-mob-share-list"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"-mob-share-weibo"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>新浪微博<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"-mob-share-weixin"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>微信<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"-mob-share-qzone"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>QQ空间<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"-mob-share-qq"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>QQ好友<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"-mob-share-tencentweibo"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>腾讯微博<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"-mob-share-renren"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>人人网<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"-mob-share-kaixin"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>开心网<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"-mob-share-douban"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>豆瓣<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"-mob-share-youdao"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>有道云笔记<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"-mob-share-mingdao"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>明道<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"-mob-share-pengyou"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>朋友网<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"-mob-share-facebook"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>Facebook<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"-mob-share-twitter"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>Twitter<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"-mob-share-pocket"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>Pocket<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"-mob-share-google"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>Google+<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"-mob-share-tumblr"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>Tumblr<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"-mob-share-instapaper"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>Instapaper<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"-mob-share-linkedin"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>Linkedin<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"-mob-share-close"</span>&gt;</span>取消<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"-mob-share-ui-bg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">"-mob-share"</span> <span class="attr">src</span>=<span class="string">"http://f1.webshare.mob.com/code/mob-share.js?appkey=&#123;&#123;theme.mob_share.appkey&#125;&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--MOB SHARE END--&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>Step4、在<code>next/layout/post.swig</code>中添加条件分支:<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.jiathis %&#125;</span><br><span class="line">      &#123;% include '_partials/share/jiathis.swig' %&#125;</span><br><span class="line">    &#123;% elseif theme.baidushare %&#125;</span><br><span class="line">      &#123;% include '_partials/share/baidushare.swig' %&#125;</span><br><span class="line">    &#123;% elseif theme.add_this_id %&#125;</span><br><span class="line">      &#123;% include '_partials/share/add-this.swig' %&#125;</span><br><span class="line">    &#123;% elseif theme.duoshuo_shortname and theme.duoshuo_share %&#125;</span><br><span class="line">      &#123;% include '_partials/share/duoshuo_share.swig' %&#125;</span><br><span class="line">    &#123;% elseif theme.mob_share.enable %&#125;</span><br><span class="line">      &#123;% include '_partials/share/mob_share.swig' %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p>
<p>Step5、在<code>next/source/css/_common/components/third-party/</code>里添加样式文件<code>mob_share.styl</code>:<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.-hoofoo-share-buttons</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.-hoofoo-share-title</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.1em</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.-hoofoo-share-ui-button</span>&#123;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#555</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">24px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">transition</span>: background <span class="number">0.4s</span>;</span><br><span class="line">    <span class="attribute">-moz-transition</span>: background <span class="number">0.4s</span>;    <span class="comment">/* Firefox 4 */</span></span><br><span class="line">    <span class="attribute">-webkit-transition</span>: background <span class="number">0.4s</span>;    <span class="comment">/* Safari 和 Chrome */</span></span><br><span class="line">    <span class="attribute">-o-transition</span>: background <span class="number">0.4s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.-hoofoo-share-weibo</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#cf3f41</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.-hoofoo-share-weixin</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#18a01a</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.-hoofoo-share-qq</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#950c0c</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.-hoofoo-share-twitter</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#2ab3e6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.-hoofoo-share-more</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#777</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.-mob-share-weixin-qrcode-content</span>&#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">-webkit-box-shadow</span>: <span class="number">0</span> <span class="number">10px</span> <span class="number">25px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">    <span class="attribute">-moz-box-shadow</span>: <span class="number">0</span> <span class="number">10px</span> <span class="number">25px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">    <span class="attribute">-o-box-shadow</span>: <span class="number">0</span> <span class="number">10px</span> <span class="number">25px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">10px</span> <span class="number">25px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.-mob-share-weixin-qrcode</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">5%</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">90%</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">height</span>: auto <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.-mob-share-weixin-qrcode-close</span> &#123;</span><br><span class="line">    background-image: url('/lib/fancybox/source/fancybox_sprite.png') !important;//因为兼容问题把vendor改成了lib, 根据自己的路径修改</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.-mob-share-weixin-qrcode-close</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">100px</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">18px</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">right</span>: -<span class="number">18px</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">36px</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">36px</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">8040</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Retina graphics!*/</span></span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio:</span> <span class="number">1.5</span>),</span><br><span class="line">       <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">min--moz-device-pixel-ratio:</span> <span class="number">1.5</span>),</span><br><span class="line">       <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">min-device-pixel-ratio:</span> <span class="number">1.5</span>)&#123;</span><br><span class="line">    <span class="selector-class">.-mob-share-weixin-qrcode-close</span> &#123;</span><br><span class="line">        background-image: url('/lib/fancybox/source/fancybox_sprite@2x.png') !important;//因为兼容问题把vendor改成了lib, 根据自己的路径修改</span><br><span class="line">        <span class="selector-tag">background-size</span>: 44<span class="selector-tag">px</span> 152<span class="selector-tag">px</span> !<span class="selector-tag">important</span>; <span class="comment">/*The size of the normal image, half the size of the hi-res image*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.-mob-share-close</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">4em</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0.8em</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">4em</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#555</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Step6、同一目录下的 <code>third-party.styl</code> 中添加:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@import &quot;mob_share&quot;;</span><br></pre></td></tr></table></figure></p>
<p>Step7、在<code>next/layout/_scripts/third-party/</code>里添加脚本文件<code>mob_share.swig</code>: </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.mob_share.enable %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line">    //微信二维码点击背景关闭</span><br><span class="line">    $('body').delegate('.-mob-share-weixin-qrcode-bg','click', function()&#123;</span><br><span class="line">         $(".-mob-share-weixin-qrcode-close").trigger("click");</span><br><span class="line">    &#125;); </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>Step8、在<code>next/layout/_layout.swig</code>的<code>body</code>标签结束前添加:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% include &apos;_scripts/third-party/mob_share.swig&apos; %&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="添加顶部加载条"><a href="#添加顶部加载条" class="headerlink" title="添加顶部加载条"></a>添加顶部加载条</h2><p>打开<code>/themes/next/layout/_partials/head.swig</code>文件, 添加如下代码:<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn.bootcss.com/pace/1.0.2/pace.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>但是, 默认的是粉色的, 要改变颜色可以在<code>/themes/next/layout/_partials/head.swig</code>文件中添加如下代码（接在刚才link的后面）<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.pace</span> <span class="selector-class">.pace-progress</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-id">#ff009e</span>; <span class="comment">/*进度条颜色*/</span></span></span><br><span class="line">        height: 3px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.pace</span> <span class="selector-class">.pace-progress-inner</span> &#123;</span></span><br><span class="line"><span class="css">         <span class="selector-tag">box-shadow</span>: 0 0 10<span class="selector-tag">px</span> <span class="selector-id">#ff009e</span>, 0 0 5<span class="selector-tag">px</span> <span class="selector-id">#ff009e</span>; <span class="comment">/*阴影颜色*/</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.pace</span> <span class="selector-class">.pace-activity</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">border-top-color</span>: <span class="selector-id">#ff009e</span>;    <span class="comment">/*上边框颜色*/</span></span></span><br><span class="line"><span class="css">        <span class="selector-tag">border-left-color</span>: <span class="selector-id">#ff009e</span>;    <span class="comment">/*左边框颜色*/</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="文章加密访问"><a href="#文章加密访问" class="headerlink" title="文章加密访问"></a>文章加密访问</h2><p>打开<code>themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig</code>文件,插入这样一段代码:<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    (function()&#123;</span><br><span class="line">        if('&#123;&#123; page.password &#125;&#125;')&#123;</span><br><span class="line">            if (prompt('请输入文章密码') !== '&#123;&#123; page.password &#125;&#125;')&#123;</span><br><span class="line">                alert('密码错误！');</span><br><span class="line">                history.back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后在文章上写成类似这样:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">date: 2016/7/13 20:46:25</span><br><span class="line">categories:</span><br><span class="line">- Diary</span><br><span class="line">tags:</span><br><span class="line">  - Testing</span><br><span class="line">  - Another Tag</span><br><span class="line">password: 123456</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
<h2 id="博客更换Disqus评论"><a href="#博客更换Disqus评论" class="headerlink" title="博客更换Disqus评论"></a>博客更换Disqus评论</h2><p>由于多说即将关闭, 本站启用Disqus.<br>既然Disqus已被墙, 那么为了对没有梯子的同学标示友好, 我们可以选择点击加载Disqus评论的方式, 这个问题貌似也得到了主题作者的关注-&gt; <strong><em>(NexT5.2.0)[<a href="https://github.com/iissnan/hexo-theme-next/milestone/7]" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/iissnan/hexo-theme-next/milestone/7]</a></em></strong><br>具体做法如下:<br>打开<code>themes/next/layout/_partials/comments.swig</code>, 在文件内容 <code>&lt;div id=&quot;disqus_thread&quot;&gt;</code>前面加入下面内容:<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"text-align:center;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn"</span> <span class="attr">id</span>=<span class="string">"load-disqus"</span> <span class="attr">onclick</span>=<span class="string">"disqus.load();"</span>&gt;</span>加载 Disqus 评论<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>再打开<code>themes/next/layout/_scripts/third-party/comments/disqus.swig</code>, 需要替换原本的 Disqus 的加载的内容, 如果希望显示评论数量, 就保留 run_disqus_script(‘count.js’) 这一行, 这样页面载入时还会加载 disqus 的资源:<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">run_disqus_script('count.js');</span><br><span class="line">&#123;% if page.comments %&#125;</span><br><span class="line">  run_disqus_script('embed.js');</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p>
<p>替换为下面的内容:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> disqus = &#123;</span><br><span class="line">  load : <span class="function"><span class="keyword">function</span> <span class="title">disqus</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">typeof</span> DISQUS !== <span class="string">'object'</span>) &#123;</span><br><span class="line">        (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> s = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>); s.async = <span class="literal">true</span>;</span><br><span class="line">        s.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">        s.src = <span class="string">'//'</span> + disqus_shortname + <span class="string">'.disqus.com/embed.js'</span>;</span><br><span class="line">        (<span class="built_in">document</span>.getElementsByTagName(<span class="string">'HEAD'</span>)[<span class="number">0</span>] || <span class="built_in">document</span>.getElementsByTagName(<span class="string">'BODY'</span>)[<span class="number">0</span>]).appendChild(s);</span><br><span class="line">        &#125;());</span><br><span class="line">        $(<span class="string">'#load-disqus'</span>).html(<span class="string">"评论加载中, 请确保你有梯子, 若评论长时间未加载则你可能翻墙失败..."</span>).fadeOut(<span class="number">9000</span>); <span class="comment">//加载后移除按钮</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前面的 <code>function run_disqus_script(disqus_script){}</code>这一段, 不打算显示评论数量的话, 可以一起删掉, 不显示评论数量的话, 那么点击加载按钮之前, 网页是不会加载来自 Disqus 的资源的. </p>
<h2 id="NexT启用Disqus-Proxy-不翻墙也能使用Disqus"><a href="#NexT启用Disqus-Proxy-不翻墙也能使用Disqus" class="headerlink" title="NexT启用Disqus-Proxy 不翻墙也能使用Disqus"></a>NexT启用Disqus-Proxy 不翻墙也能使用Disqus</h2><p><img src="https://cdn.yangbingdong.com/img/disqus-proxy/disqus-proxy.png" alt></p>
<blockquote>
<p>多说于2017.06.01停止了服务, 不得不选择其他的第三方评论服务, 试了一下国内的服务发现不是麻烦（例如需要备案）就是不靠谱或者界面不炫酷（装X嫌疑…）</p>
<p>还是使用<strong><em><a href="https://disqus.com/" rel="external nofollow noopener noreferrer" target="_blank">Disqus</a></em></strong>吧…But, 这个早就被<strong><em><a href="https://baike.baidu.com/item/great%20firewall/4843556?fr=aladdin&amp;fromid=18582731&amp;fromtitle=GFW" rel="external nofollow noopener noreferrer" target="_blank">GWF</a></em></strong>隔离了, 虽然自己可以闪现过墙=.=, 但游客不一定都会这个技能…<br>那么问题来了, 怎么做一个公共的梯子实现人人翻墙？<br>在Gayhub全球最大同性交友网中发现, 早就有大神做了这样一个服务, 并选择了<em><a href="https://ycwalker.com/" rel="external nofollow noopener noreferrer" target="_blank">ciqulover</a></em>(在此感谢大神的鼎力相助)的<strong><em><a href="https://github.com/ciqulover/disqus-proxy" rel="external nofollow noopener noreferrer" target="_blank">Disque-Proxy</a></em></strong>项目作为梯子.<br>当然也还有其他的Disqus-Proxy -&gt; <strong><em><a href="https://github.com/fooleap/disqus-php-api" rel="external nofollow noopener noreferrer" target="_blank">fooleap</a></em></strong>、 <strong><em><a href="https://github.com/jiananshi/disqus-proxy" rel="external nofollow noopener noreferrer" target="_blank">jiananshi</a></em></strong></p>
</blockquote>
<h3 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h3><p>流程就没什么好说的了, 如上图, 在前端页面上测试 disqus 加载是否成功, 如果成功则显示 disqus 的评论框, 反之加载独立的评论框…<br>具体请看<strong><em><a href="https://ycwalker.com/2017/06/01/about-diqus-proxy/" rel="external nofollow noopener noreferrer" target="_blank">https://ycwalker.com/2017/06/01/about-diqus-proxy/</a></em></strong></p>
<h3 id="Get-Api-secret"><a href="#Get-Api-secret" class="headerlink" title="Get Api-secret"></a>Get Api-secret</h3><p><code>api-secret</code> 需要你在 <strong><em><a href="https://disqus.com/api/applications/" rel="external nofollow noopener noreferrer" target="_blank">Disqus Api</a></em></strong> 的官方网站上开启 <strong>API</strong> 权限, 申请成功后会得到这个秘钥.<br><img src="https://cdn.yangbingdong.com/img/disqus-proxy/disqus-api-applcation.png" alt></p>
<p>并且需要在后台的 <code>Settings</code> =&gt; <code>Community</code> 里开启访客评论:<br><img src="https://cdn.yangbingdong.com/img/disqus-proxy/disqus-admin-setting.png" alt></p>
<h3 id="Deploy-Disqus-Proxy"><a href="#Deploy-Disqus-Proxy" class="headerlink" title="Deploy Disqus-Proxy"></a>Deploy Disqus-Proxy</h3><p>首先你得有一台<strong>可以访问<a href="https://disqus.com/" rel="external nofollow noopener noreferrer" target="_blank">Disqus</a></strong>的VPS<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="basic footnote content">[1]</span></a></sup>… 博主用的是<strong><em><a href="www.linode.com">Linode</a></em></strong></p>
<p>Docker方式启动: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --name disqus-proxy --restart=always -p 5509:5509 \</span><br><span class="line">-e API_SECRECT=your_serect \</span><br><span class="line">-e SHORT_NAME=your_short_name \</span><br><span class="line">ycwalker/disqus-proxy-server</span><br></pre></td></tr></table></figure>
<p>更多方式请移步到 <strong><em><a href="https://github.com/ciqulover/disqus-proxy-server" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/ciqulover/disqus-proxy-server</a></em></strong></p>
<h3 id="NexT-Configuration"><a href="#NexT-Configuration" class="headerlink" title="NexT Configuration"></a>NexT Configuration</h3><h4 id="Copy-Static-File"><a href="#Copy-Static-File" class="headerlink" title="Copy Static File"></a>Copy Static File</h4><p>将<code>disqus-proxy</code>项目中<code>/build/static</code>文件复制到博客<code>../next/source/</code>下.<br><code>static</code>文件中应该包含<code>main.0d0338ae.js</code>和<code>main.0603c539.css</code>. </p>
<h4 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h4><p>在<strong>主题配置文件</strong>中添加:<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">disqus_proxy:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 如果 disqus 账号名没设置 那么 disqus_proxy 也不会生效</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">ookamiantd</span></span><br><span class="line">  <span class="comment"># 下面两项你需要更改为自己服务器的域名和端口</span></span><br><span class="line">  <span class="attr">server:</span> <span class="string">disqus-proxy.yangbingdong.com</span> </span><br><span class="line">  <span class="attr">port:</span> <span class="number">5509</span>  <span class="comment"># 端口号需要与后端设置一致</span></span><br><span class="line">  <span class="comment"># 头像路径设置</span></span><br><span class="line">  <span class="attr">defaultAvatar:</span> <span class="string">/images/avatar/avatar-default.jpg</span></span><br><span class="line">  <span class="attr">adminAvatar:</span> <span class="string">/images/avatar/avatar-admin.jpg</span></span><br><span class="line">  <span class="comment"># 脚本和 css 路径</span></span><br><span class="line">  <span class="attr">js:</span> <span class="string">/static/js/main.0d0338ae.js</span></span><br><span class="line">  <span class="attr">css:</span> <span class="string">/static/css/main.0603c539.css</span></span><br></pre></td></tr></table></figure></p>
<h4 id="comment-swig"><a href="#comment-swig" class="headerlink" title="comment.swig"></a>comment.swig</h4><p>修改<code>/next/layout/_partial/comment.swig</code>, 在最后一个<code>&lt;/div&gt;</code>钱加上: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">"disqus_proxy_thread"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div id="disqus_thread"&gt;&lt;/</span>div&gt;</span><br><span class="line">      &#123;% <span class="keyword">if</span> theme.disqus_proxy.enable %&#125;</span><br><span class="line">          &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">              <span class="built_in">window</span>.disqusProxy = &#123;</span><br><span class="line">                username: <span class="string">'&#123;&#123; theme.disqus_proxy.username &#125;&#125;'</span>,</span><br><span class="line">                server: <span class="string">'&#123;&#123; theme.disqus_proxy.server &#125;&#125;'</span>,</span><br><span class="line">                port: <span class="string">'&#123;&#123; theme.disqus_proxy.port &#125;&#125;'</span>,</span><br><span class="line">                defaultAvatar: <span class="string">'&#123;&#123; theme.disqus_proxy.defaultAvatar &#125;&#125;'</span>,</span><br><span class="line">                adminAvatar: <span class="string">'&#123;&#123; theme.disqus_proxy.adminAvatar &#125;&#125;'</span>,</span><br><span class="line">                identifier: <span class="string">'&#123;&#123; page.path &#125;&#125;'</span></span><br><span class="line">              &#125;;</span><br><span class="line">              <span class="built_in">window</span>.disqus_config = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.page.url = <span class="string">'&#123;&#123; page.permalink &#125;&#125;'</span>;</span><br><span class="line">                <span class="keyword">this</span>.page.identifier = <span class="string">'&#123;&#123; page.path &#125;&#125;'</span>;</span><br><span class="line">              &#125;;</span><br><span class="line">              <span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">var</span> s = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">                s.src = <span class="string">"&#123;&#123; theme.disqus_proxy.js &#125;&#125;"</span>;</span><br><span class="line">                s.async = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">document</span>.body.appendChild(s);</span><br><span class="line">              &#125;</span><br><span class="line">          &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">          &lt;link rel="stylesheet" href="&#123;&#123; theme.disqus_proxy.css &#125;&#125;"&gt;</span></span><br><span class="line"><span class="regexp">      &#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure>
<p>渲染效果:<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"disqus_proxy_thread"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"disqus_thread"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.disqusProxy = &#123;</span></span><br><span class="line"><span class="javascript">    username: <span class="string">'ookamiantd'</span>,</span></span><br><span class="line"><span class="javascript">    server: <span class="string">'disqus-proxy.yangbingdong.com'</span>,</span></span><br><span class="line"><span class="javascript">    port: <span class="string">'5509'</span>,</span></span><br><span class="line"><span class="javascript">    defaultAvatar: <span class="string">'/images/avatar/avatar-default.jpg'</span>,</span></span><br><span class="line"><span class="javascript">    adminAvatar: <span class="string">'/images/avatar/avatar-admin.jpg'</span>,</span></span><br><span class="line"><span class="javascript">    identifier: <span class="string">'2017/disqus-proxy/'</span></span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.disqus_config = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.page.url = <span class="string">'http://ookamiantd.top/2017/disqus-proxy/'</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">this</span>.page.identifier = <span class="string">'2017/disqus-proxy/'</span>;</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> s = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span></span><br><span class="line"><span class="javascript">    s.src = <span class="string">"/static/js/main.0d0338ae.js"</span>;</span></span><br><span class="line"><span class="javascript">    s.async = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.appendChild(s);</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/static/css/main.0603c539.css"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="custom-styl"><a href="#custom-styl" class="headerlink" title="custom.styl"></a>custom.styl</h4><p>可能由于改过样式还是本来就不兼容, 评论框一开始显示不出来, <em><a href="https://ycwalker.com/" rel="external nofollow noopener noreferrer" target="_blank">ciqulover</a></em>大神帮我加了个样式之后就好了. </p>
<p>在<code>/next/source/css/_custom/custom.styl</code>中添加:<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#disqus_proxy_thread</span> <span class="selector-class">.post</span>&#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: none <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">-webkit-box-shadow</span>: none <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>博主也对评论框乱入了一些样式例如头像旋转…具体请看<strong><em><a href="/static/css/main.0603c539.css">main.0603c539.css</a></em></strong></p>
<h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>博主使用了<code>hexo-all-minifier</code>进行静态文件压缩, 不明原因导致那两个评论框的js和css压缩之后会报错, 所以对压缩选项作设置, 在<strong>站点配置文件</strong>中添加:<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">html_minifier:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">exclude:</span> </span><br><span class="line"></span><br><span class="line"><span class="attr">css_minifier:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">exclude:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">'/home/ybd/GitRepo/blog/themes/next/source/static/css/main.0603c539.css'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">js_minifier:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mangle:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">output:</span></span><br><span class="line">  <span class="attr">compress:</span></span><br><span class="line">  <span class="attr">exclude:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">'/home/ybd/GitRepo/blog/themes/next/source/static/js/*.*.js'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">image_minifier:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">interlaced:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">multipass:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">optimizationLevel:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">pngquant:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">progressive:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Show"><a href="#Show" class="headerlink" title="Show"></a>Show</h3><p>这是翻墙状态:<br><img src="https://cdn.yangbingdong.com/img/disqus-proxy/comment02.png" alt><br>这是<code>disqus_proxy</code>:<br><img src="https://cdn.yangbingdong.com/img/disqus-proxy/comment01.png" alt></p>
<h2 id="修改文章页宽"><a href="#修改文章页宽" class="headerlink" title="修改文章页宽"></a>修改文章页宽</h2><p>打开<code>themes/next/source/css/_variables/base.styl</code>, 找到以下字段并修改为合适的宽度:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$content-desktop-large = 1000px</span><br></pre></td></tr></table></figure></p>
<h2 id="修改小型代码块颜色"><a href="#修改小型代码块颜色" class="headerlink" title="修改小型代码块颜色"></a>修改小型代码块颜色</h2><p>修改<code>\themes\next\source\css\ _variables\base.styl</code>文件, 加入自定义颜色:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$black-deep   = #222</span><br><span class="line">$red          = #ff2a2a</span><br><span class="line">$blue-bright  = #87daff</span><br><span class="line">$blue         = #0684bd</span><br><span class="line">$blue-deep    = #262a30</span><br><span class="line">$orange       = #fc6423</span><br><span class="line">// 下面是我自定义的颜色</span><br><span class="line">$my-code-foreground = #dd0055  // 用``围出的代码块字体颜色</span><br><span class="line">$my-code-background = #eee  // 用``围出的代码块背景颜色</span><br></pre></td></tr></table></figure></p>
<p>修改<code>$code-background</code>和<code>$code-foreground</code>的值:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Code &amp; Code Blocks // 用``围出的代码块 // -------------------------------------------------- </span><br><span class="line">$code-font-family               = $font-family-monospace </span><br><span class="line">$code-font-size                 = 15px </span><br><span class="line">$code-background                = $my-code-background </span><br><span class="line">$code-foreground                = $my-code-foreground </span><br><span class="line">$code-border-radius             = 4px</span><br></pre></td></tr></table></figure></p>
<h2 id="文章末尾追加版权信息"><a href="#文章末尾追加版权信息" class="headerlink" title="文章末尾追加版权信息"></a>文章末尾追加版权信息</h2><p>找到<code>themes/next/layout/_macro/post.swig</code>, 在<code>footer</code>之前添加如下代码(添加之前确保已添加<strong><em><a href="#%E5%A5%BD%E7%8E%A9%E7%9A%84%E6%A0%B7%E5%BC%8F">样式</a></em></strong>):<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"div-border-left-red"</span>&gt;</span></span><br><span class="line">	   <span class="tag">&lt;<span class="name">b</span>&gt;</span>本文基于<span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">title</span>=<span class="string">"Creative Commons Attribution-ShareAlike 4.0 International (CC BY-SA 4.0)"</span> <span class="attr">href</span>=<span class="string">"http://creativecommons.org/licenses/by-sa/4.0/"</span>&gt;</span> 知识共享署名-相同方式共享 4.0 <span class="tag">&lt;/<span class="name">a</span>&gt;</span>国际许可协议发布<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">b</span>&gt;</span>本文地址: <span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; url_for(page.path) &#125;&#125;"</span> <span class="attr">title</span>=<span class="string">"&#123;&#123; page.title &#125;&#125;"</span>&gt;</span>&#123;&#123; page.permalink &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>转载请注明出处, 谢谢！<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="添加文章结束标记"><a href="#添加文章结束标记" class="headerlink" title="添加文章结束标记"></a>添加文章结束标记</h2><p>同样在<code>themes/next/layout/_macro/post.swig</code>中, 在<code>wechat-subscriber.swig</code>之前添加如下代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;---------------- The End ----------------&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="添加热度"><a href="#添加热度" class="headerlink" title="添加热度"></a>添加热度</h2><p>在<code>/themes/hexo-theme-next/layout/_macro/post.swig</code>里面的下面的位置加上如下代码:<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if post.categories and post.categories.length %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-category"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- 在下面的位置加上如下代码 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_page_pv"</span>&gt;</span></span><br><span class="line">      <span class="symbol">&amp;nbsp;</span> | <span class="symbol">&amp;nbsp;</span> 热度<span class="symbol">&amp;nbsp;</span> <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_page_pv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>°C</span><br><span class="line">      <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 在上面的位置加上如上代码 --&gt;</span>    </span><br><span class="line">  </span><br><span class="line">      &#123;% if post.comments %&#125;</span><br><span class="line">        &#123;% if (theme.duoshuo and theme.duoshuo.shortname) or theme.duoshuo_shortname %&#125;</span><br><span class="line">          <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-comments-count"</span>&gt;</span></span><br><span class="line">            <span class="symbol">&amp;nbsp;</span> | <span class="symbol">&amp;nbsp;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; url_for(post.path) &#125;&#125;#comments"</span> <span class="attr">itemprop</span>=<span class="string">"discussionUrl"</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-comments-count ds-thread-count"</span> <span class="attr">data-thread-key</span>=<span class="string">"&#123;&#123; post.path &#125;&#125;"</span> <span class="attr">itemprop</span>=<span class="string">"commentsCount"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>但是这有一个<strong>缺陷</strong>. 就是我们会发现在主页时显示的热度和进入博客后的热度不一样, 那是因为在主页时他显示的是主页这个页面的阅读量, 而不是博客的阅读量, 所以我们需要改变一些: </p>
<p>我们在<code>/themes/hexo-theme-next/layout/_macro/</code>目录下新建<code>post-article.swig</code>,把这些<code>post.swig</code>中的内容复制过去, 而且加上上面的统计代码, 然后在<code>/themes/hexo-theme-next/layout/post.swig</code>上面<code>% import &#39;_macro/post.swig&#39; as post_template %</code>中的<code>post.swig</code>改成<code>post-article.swig</code>, 这样子就解决啦. 就是在主页上的博客名字下面不会有阅读人数, 进入博客才能看见</p>
<h2 id="添加Fork-me-on-GitHub"><a href="#添加Fork-me-on-GitHub" class="headerlink" title="添加Fork me on GitHub"></a>添加Fork me on GitHub</h2><p>去网址<em><a href="https://github.com/blog/273-github-ribbons" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/blog/273-github-ribbons</a></em>挑选自己喜欢的样式, 并复制代码, 添加到<code>themes\next\layout\_layout.swig</code>的<code>body</code>标签之内即可<br><strong>记得把里面的url换成自己的!</strong></p>
<h2 id="把侧边栏头像变成圆形-并且鼠标停留在上面发生旋转效果"><a href="#把侧边栏头像变成圆形-并且鼠标停留在上面发生旋转效果" class="headerlink" title="把侧边栏头像变成圆形, 并且鼠标停留在上面发生旋转效果"></a>把侧边栏头像变成圆形, 并且鼠标停留在上面发生旋转效果</h2><p>﻿修改<code>themes\next\source\css\_common\components\sidebar\sidebar-author.styl</code>:<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.site-author-image</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">padding</span>: $site-author-image-padding;</span><br><span class="line">  <span class="attribute">max-width</span>: $site-author-image-width;</span><br><span class="line">  <span class="attribute">height</span>: $site-author-image-height;</span><br><span class="line">  <span class="attribute">border</span>: site-author-image-border-color;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* start*/</span></span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span></span><br><span class="line">  webkit-transition: <span class="number">1.4s</span> all;</span><br><span class="line">  <span class="attribute">moz-transition</span>: <span class="number">1.4s</span> all;</span><br><span class="line">  <span class="attribute">ms-transition</span>: <span class="number">1.4s</span> all;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">1.4s</span> all;</span><br><span class="line">  <span class="comment">/* end */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* start */</span></span><br><span class="line"><span class="selector-class">.site-author-image</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#55DAE1</span>;</span><br><span class="line">  <span class="attribute">webkit-transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>) <span class="built_in">scale</span>(<span class="number">1.1</span>);</span><br><span class="line">  <span class="attribute">moz-transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>) <span class="built_in">scale</span>(<span class="number">1.1</span>);</span><br><span class="line">  <span class="attribute">ms-transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>) <span class="built_in">scale</span>(<span class="number">1.1</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>) <span class="built_in">scale</span>(<span class="number">1.1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* end */</span></span><br></pre></td></tr></table></figure></p>
<h2 id="修改链接文字样式"><a href="#修改链接文字样式" class="headerlink" title="修改链接文字样式"></a>修改链接文字样式</h2><p>打开<code>themes\next\source\css\_common\components\post\post.styl</code>添加以下代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.post-body p a&#123;</span><br><span class="line"></span><br><span class="line"> color: #0593d3;</span><br><span class="line"> border-bottom: none;</span><br><span class="line"> &amp;:hover &#123;</span><br><span class="line">   color: #ff106c;</span><br><span class="line">   text-decoration: underline;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>themes/next/source/css/_common/components/post/post-title.styl</code>修改为: </p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.posts-expand</span> <span class="selector-class">.post-title-link</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">border-bottom</span>: none;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.2</span>;</span><br><span class="line">  <span class="attribute">vertical-align</span>: top;</span><br><span class="line"></span><br><span class="line">  &amp;::before &#123;</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure>
<h2 id="为next主题的主页文章添加阴影效果"><a href="#为next主题的主页文章添加阴影效果" class="headerlink" title="为next主题的主页文章添加阴影效果"></a>为next主题的主页文章添加阴影效果</h2><p>打开<code>themes/next/source/css/_custom/custom.styl</code>文件添加:<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.post</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">25px</span>;</span><br><span class="line">  <span class="attribute">-webkit-box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">203</span>, <span class="number">203</span>, .<span class="number">5</span>);</span><br><span class="line">  <span class="attribute">-moz-box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">203</span>, <span class="number">204</span>, .<span class="number">5</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="为next主题添加nest背景特效"><a href="#为next主题添加nest背景特效" class="headerlink" title="为next主题添加nest背景特效"></a>为next主题添加nest背景特效</h2><p>背景的几何线条是采用的<code>nest</code>效果, 一个基于<code>html5 canvas</code>绘制的网页背景效果, 非常赞！来自github的开源项目<code>canvas-nest</code></p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>不依赖任何框架或者内库, 比如不依赖jQuery, 使用原生的javascript. </li>
<li>非常小, 只有1.66kb, 如果开启gzip, 可以更小. </li>
<li>非常容易实现, 配置简单, 即使你不是web开发者, 也能简单搞定. </li>
</ul>
<p>使用非常简单</p>
<ul>
<li><code>color</code>: 线条颜色, 默认: ‘0,0,0’ ；三个数字分别为(R,G,B), 注意用,分割</li>
<li><code>opacity</code>: 线条透明度（0~1）, 默认: 0.5</li>
<li><code>count</code>: 线条的总数量, 默认: 150</li>
<li><code>zIndex</code>: 背景的z-index属性, css属性用于控制所在层的位置, 默认: -1</li>
</ul>
<p>eg :</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">color</span>=<span class="string">"255,132,0"</span> <span class="attr">opacity</span>=<span class="string">'0.6'</span> <span class="attr">zIndex</span>=<span class="string">"-2"</span> <span class="attr">count</span>=<span class="string">"99"</span> <span class="attr">src</span>=<span class="string">"//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>不足: CPU占用过高</p>
<h3 id="如何添加"><a href="#如何添加" class="headerlink" title="如何添加?"></a>如何添加?</h3><h4 id="修改代码"><a href="#修改代码" class="headerlink" title="修改代码"></a>修改代码</h4><p>打开<code>next/layout/_layout.swig</code>, 在<code>&lt;/body&gt;</code>之前添加如下代码:<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.canvas_nest %&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="修改主题配置文件"><a href="#修改主题配置文件" class="headerlink" title="修改主题配置文件"></a>修改主题配置文件</h4><p>打开<code>/next/_config.yml</code>, 添加以下代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># --------------------------------------------------------------</span><br><span class="line"># background settings</span><br><span class="line"># --------------------------------------------------------------</span><br><span class="line"># add canvas-nest effect</span><br><span class="line"># see detail from https://github.com/hustcc/canvas-nest.js</span><br><span class="line">canvas_nest: true</span><br></pre></td></tr></table></figure></p>
<p>至此, 大功告成, 运行hexo clean 和 hexo g hexo s之后就可以看到效果了</p>
<h2 id="鼠标点击爆炸特效"><a href="#鼠标点击爆炸特效" class="headerlink" title="鼠标点击爆炸特效"></a>鼠标点击爆炸特效</h2><p><img src="https://cdn.yangbingdong.com/img/build-hexo/hexo-next-click-boom.png" alt></p>
<p>在 <code>themes/next/source/js/src</code> 新建js文件 <code>fireworks.js</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateCoords</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    pointerX = (e.clientX || e.touches[<span class="number">0</span>].clientX) - canvasEl.getBoundingClientRect().left,</span><br><span class="line">    pointerY = e.clientY || e.touches[<span class="number">0</span>].clientY - canvasEl.getBoundingClientRect().top</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setParticuleDirection</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> t = anime.random(<span class="number">0</span>, <span class="number">360</span>) * <span class="built_in">Math</span>.PI / <span class="number">180</span>,</span><br><span class="line">    a = anime.random(<span class="number">50</span>, <span class="number">180</span>),</span><br><span class="line">    n = [ - <span class="number">1</span>, <span class="number">1</span>][anime.random(<span class="number">0</span>, <span class="number">1</span>)] * a;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        x: e.x + n * <span class="built_in">Math</span>.cos(t),</span><br><span class="line">        y: e.y + n * <span class="built_in">Math</span>.sin(t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createParticule</span>(<span class="params">e, t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> a.x = e,</span><br><span class="line">    a.y = t,</span><br><span class="line">    a.color = colors[anime.random(<span class="number">0</span>, colors.length - <span class="number">1</span>)],</span><br><span class="line">    a.radius = anime.random(<span class="number">16</span>, <span class="number">32</span>),</span><br><span class="line">    a.endPos = setParticuleDirection(a),</span><br><span class="line">    a.draw = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        ctx.beginPath(),</span><br><span class="line">        ctx.arc(a.x, a.y, a.radius, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI, !<span class="number">0</span>),</span><br><span class="line">        ctx.fillStyle = a.color,</span><br><span class="line">        ctx.fill()</span><br><span class="line">    &#125;,</span><br><span class="line">    a</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCircle</span>(<span class="params">e, t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> a.x = e,</span><br><span class="line">    a.y = t,</span><br><span class="line">    a.color = <span class="string">"#F00"</span>,</span><br><span class="line">    a.radius = <span class="number">0.1</span>,</span><br><span class="line">    a.alpha = <span class="number">0.5</span>,</span><br><span class="line">    a.lineWidth = <span class="number">6</span>,</span><br><span class="line">    a.draw = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        ctx.globalAlpha = a.alpha,</span><br><span class="line">        ctx.beginPath(),</span><br><span class="line">        ctx.arc(a.x, a.y, a.radius, <span class="number">0</span>, <span class="number">2</span> * <span class="built_in">Math</span>.PI, !<span class="number">0</span>),</span><br><span class="line">        ctx.lineWidth = a.lineWidth,</span><br><span class="line">        ctx.strokeStyle = a.color,</span><br><span class="line">        ctx.stroke(),</span><br><span class="line">        ctx.globalAlpha = <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    a</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderParticule</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> t = <span class="number">0</span>; t &lt; e.animatables.length; t++) &#123;</span><br><span class="line">        e.animatables[t].target.draw()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animateParticules</span>(<span class="params">e, t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> a = createCircle(e, t), n = [], i = <span class="number">0</span>; i &lt; numberOfParticules; i++) &#123;</span><br><span class="line">        n.push(createParticule(e, t))</span><br><span class="line">    &#125;</span><br><span class="line">    anime.timeline().add(&#123;</span><br><span class="line">        targets: n,</span><br><span class="line">        x: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e.endPos.x</span><br><span class="line">        &#125;,</span><br><span class="line">        y: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e.endPos.y</span><br><span class="line">        &#125;,</span><br><span class="line">        radius: <span class="number">0.1</span>,</span><br><span class="line">        duration: anime.random(<span class="number">1200</span>, <span class="number">1800</span>),</span><br><span class="line">        easing: <span class="string">"easeOutExpo"</span>,</span><br><span class="line">        update: renderParticule</span><br><span class="line">    &#125;).add(&#123;</span><br><span class="line">        targets: a,</span><br><span class="line">        radius: anime.random(<span class="number">80</span>, <span class="number">160</span>),</span><br><span class="line">        lineWidth: <span class="number">0</span>,</span><br><span class="line">        alpha: &#123;</span><br><span class="line">            value: <span class="number">0</span>,</span><br><span class="line">            easing: <span class="string">"linear"</span>,</span><br><span class="line">            duration: anime.random(<span class="number">600</span>, <span class="number">800</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        duration: anime.random(<span class="number">1200</span>, <span class="number">1800</span>),</span><br><span class="line">        easing: <span class="string">"easeOutExpo"</span>,</span><br><span class="line">        update: renderParticule,</span><br><span class="line">        offset: <span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">e, t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> n = <span class="keyword">this</span>,</span><br><span class="line">        i = <span class="built_in">arguments</span>;</span><br><span class="line">        clearTimeout(a),</span><br><span class="line">        a = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            e.apply(n, i)</span><br><span class="line">        &#125;,</span><br><span class="line">        t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> canvasEl = <span class="built_in">document</span>.querySelector(<span class="string">".fireworks"</span>);</span><br><span class="line"><span class="keyword">if</span> (canvasEl) &#123;</span><br><span class="line">    <span class="keyword">var</span> ctx = canvasEl.getContext(<span class="string">"2d"</span>),</span><br><span class="line">    numberOfParticules = <span class="number">30</span>,</span><br><span class="line">    pointerX = <span class="number">0</span>,</span><br><span class="line">    pointerY = <span class="number">0</span>,</span><br><span class="line">    tap = <span class="string">"mousedown"</span>,</span><br><span class="line">    colors = [<span class="string">"#FF1461"</span>, <span class="string">"#18FF92"</span>, <span class="string">"#5A87FF"</span>, <span class="string">"#FBF38C"</span>],</span><br><span class="line">    setCanvasSize = debounce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        canvasEl.width = <span class="number">2</span> * <span class="built_in">window</span>.innerWidth,</span><br><span class="line">        canvasEl.height = <span class="number">2</span> * <span class="built_in">window</span>.innerHeight,</span><br><span class="line">        canvasEl.style.width = <span class="built_in">window</span>.innerWidth + <span class="string">"px"</span>,</span><br><span class="line">        canvasEl.style.height = <span class="built_in">window</span>.innerHeight + <span class="string">"px"</span>,</span><br><span class="line">        canvasEl.getContext(<span class="string">"2d"</span>).scale(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">500</span>),</span><br><span class="line">    render = anime(&#123;</span><br><span class="line">        duration: <span class="number">1</span> / <span class="number">0</span>,</span><br><span class="line">        update: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, canvasEl.width, canvasEl.height)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(tap,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="string">"sidebar"</span> !== e.target.id &amp;&amp; <span class="string">"toggle-sidebar"</span> !== e.target.id &amp;&amp; <span class="string">"A"</span> !== e.target.nodeName &amp;&amp; <span class="string">"IMG"</span> !== e.target.nodeName &amp;&amp; (render.play(), updateCoords(e), animateParticules(pointerX, pointerY))</span><br><span class="line">    &#125;,</span><br><span class="line">    !<span class="number">1</span>),</span><br><span class="line">    setCanvasSize(),</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">"resize"</span>, setCanvasSize, !<span class="number">1</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>打开<code>themes/next/layout/_layout.swig</code>,在<code>&lt;/body&gt;</code>上面写下如下代码:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">class</span>=<span class="string">"fireworks"</span> <span class="attr">style</span>=<span class="string">"position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;"</span> &gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"//cdn.bootcss.com/animejs/2.2.0/anime.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/src/fireworks.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="添加音乐"><a href="#添加音乐" class="headerlink" title="添加音乐"></a>添加音乐</h2><p>去往<em><a href="http://music.163.com/" rel="external nofollow noopener noreferrer" target="_blank">网易云音乐</a></em>搜索喜欢的音乐, 点击生成外链播放器, 复制代码直接放到博文末尾即可, <code>height</code>设为0可隐藏播放器, 但仍然可以播放音乐, <code>auto</code>设成0可手动播放, 默认是1自动播放, 可把代码放到<code>themes/next/layout/_custom/sidebar.swig</code>文件里, 播放器会显示在站点预览中</p>
<h2 id="添加注脚"><a href="#添加注脚" class="headerlink" title="添加注脚"></a>添加注脚</h2><p>安装插件:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-reference --save</span><br></pre></td></tr></table></figure></p>
<p>用法如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this is a basic footnote[/^1] ##用的时候把/去掉</span><br></pre></td></tr></table></figure></p>
<p>在文章末尾添加:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[/^1]: basic footnote content ##用的时候把/去掉</span><br></pre></td></tr></table></figure></p>
<p>eg:this is a basic footnote<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="basic footnote content">[1]</span></a></sup></p>
<h2 id="自定义页面"><a href="#自定义页面" class="headerlink" title="自定义页面"></a>自定义页面</h2><p>执行<code>hexo new page &quot;guestbook&quot;</code>之后, 那怎么在博客中加进去呢？<br>找到<code>\next\_config.yml</code>下的<code>memu</code>, 把<code>guestbook</code>加进去:<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"> <span class="attr">home:</span> <span class="string">/</span></span><br><span class="line"> <span class="attr">categories:</span> <span class="string">/categories</span></span><br><span class="line"> <span class="comment">#about: /about</span></span><br><span class="line"> <span class="attr">archives:</span> <span class="string">/archives</span></span><br><span class="line"> <span class="attr">tags:</span> <span class="string">/tags</span></span><br><span class="line"> <span class="attr">guestbook:</span> <span class="string">/guestbook</span></span><br></pre></td></tr></table></figure></p>
<p>图标网站: <em><a href="http://fontawesome.io/icons/" rel="external nofollow noopener noreferrer" target="_blank">http://fontawesome.io/icons/</a></em></p>
<p>在<code>/themes/hexo-theme-next/languages/zh-Hans.yml</code>的目录下（这里默认你使用的是简体中文, 若是其他语言更改相应的<code>yml</code>就行）, 在<code>memu</code>下加一句即可:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">guestbook: 留言</span><br></pre></td></tr></table></figure></p>
<h2 id="添加字数统计和阅读时间"><a href="#添加字数统计和阅读时间" class="headerlink" title="添加字数统计和阅读时间"></a>添加字数统计和阅读时间</h2><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过以上安装后, 你可以在你的模板文件后者.md文件加入以下相关的标签实现本插件的功能<br>字数统计:WordCount<br>阅读时长预计:Min2Read<br>总字数统计: TotalCount</p>
</blockquote>
<h3 id="修改post-swig模板"><a href="#修改post-swig模板" class="headerlink" title="修改post.swig模板"></a>修改post.swig模板</h3><p>找到<code>themes\next\layout\_macro\post.swig</code>并打开插入以下代码:<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;# LeanCould PageView #&#125;</span><br><span class="line">         &#123;% if theme.leancloud_visitors.enable %&#125;</span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"&#123;&#123; url_for(post.path) &#125;&#125;"</span> <span class="attr">class</span>=<span class="string">"leancloud_visitors"</span> <span class="attr">data-flag-title</span>=<span class="string">"&#123;&#123; post.title &#125;&#125;"</span>&gt;</span></span><br><span class="line">		 <span class="symbol">&amp;nbsp;</span> | <span class="symbol">&amp;nbsp;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-icon"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-eye"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-text"</span>&gt;</span>&#123;&#123;__('post.visitors')&#125;&#125; <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"leancloud-visitors-count"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">         &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">	  </span><br><span class="line">#以下部分为: 字数统计、阅读时长插入代码</span><br><span class="line">         <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-time"</span>&gt;</span></span><br><span class="line">	   <span class="symbol">&amp;nbsp;</span> | <span class="symbol">&amp;nbsp;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-icon"</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-calendar-o"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-text"</span>&gt;</span>字数统计:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-count"</span>&gt;</span>&#123;&#123; wordcount(post.content) &#125;&#125;(字)<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">           </span><br><span class="line">         <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">	  </span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-time"</span>&gt;</span></span><br><span class="line">	   <span class="symbol">&amp;nbsp;</span> | <span class="symbol">&amp;nbsp;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-icon"</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-calendar-o"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-item-text"</span>&gt;</span>阅读时长:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-count"</span>&gt;</span>&#123;&#123; min2read(post.content) &#125;&#125;(分)<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">           </span><br><span class="line">         <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">#以上部分为: 字数统计、阅读时长插入代码</span><br></pre></td></tr></table></figure></p>
<h2 id="修改footer"><a href="#修改footer" class="headerlink" title="修改footer"></a>修改footer</h2><p>修改之后的样子大概是这样的:<br><img src="https://cdn.yangbingdong.com/img/build-hexo/result.png" alt></p>
<p>1、找到 <code>\themes\next\layout\partials\</code>下面的<code>footer.swig</code>文件, 打开会发现, 如下图的语句:<br><img src="https://cdn.yangbingdong.com/img/build-hexo/footer.png" alt></p>
<ul>
<li><p>第一个框 是下面侧栏的“日期❤ XXX”<br>如果想像我一样加东西, 一定要在双大括号外面写. 如: <code>xxx</code>,当然你要是想改彻底可以变量都删掉, 看个人意愿. </p>
</li>
<li><p>第二个, 是图一当中 “由Hexo驱动” 的Hexo链接, 先给删掉防止跳转, 如果想跳转当然也可以自己写地址, 至于中文一会处理. 注意删除的时候格式不能错, 只把<code>&lt;a&gt;...&lt;/a&gt;</code>标签这部分删除即可, 留着两个单引号’’,否则会出错哦. </p>
</li>
<li><p>第三个框也是最后一个了, 这个就是更改图一后半部分“主题-Next.XX”,这个比较爽直接将<a>..</a>都删掉, 同样中文“主题”一会处理, 删掉之后在上一行 ‘-’后面可以随意加上你想显示的东西, 不要显示敏感信息哟, 请自重. </p>
</li>
</ul>
<p>2、接下来, 处理剩余的中文信息. 找到这个地方<code>\themes\next\languages\</code> 下面的语言文件zh-Hans.yml（这里以中文为例, 有的习惯用英文的配置文件, 道理一样, 找对应位置即可）<br>打开之后, 如图:<br><img src="https://cdn.yangbingdong.com/img/build-hexo/languages.png" alt></p>
<h2 id="给博客添加吉祥物"><a href="#给博客添加吉祥物" class="headerlink" title="给博客添加吉祥物"></a>给博客添加吉祥物</h2><blockquote>
<p>详细信息: <strong><em><a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md</a></em></strong></p>
</blockquote>
<p>效果图: </p>
<p><img src="https://cdn.yangbingdong.com/img/build-hexo/hexo-helper-live2d.png" alt></p>
<p>安装依赖: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br><span class="line">npm install --save live2d-widget-model-wanko</span><br></pre></td></tr></table></figure>
<p><strong>站点配置</strong>添加: </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hexo-helper-live2d配置, 参考https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md</span></span><br><span class="line"><span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">scriptFrom:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">pluginRootPath:</span> <span class="string">live2dw/</span></span><br><span class="line">  <span class="attr">pluginJsPath:</span> <span class="string">lib/</span></span><br><span class="line">  <span class="attr">pluginModelPath:</span> <span class="string">assets/</span></span><br><span class="line">  <span class="attr">tagMode:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">debug:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">model:</span></span><br><span class="line">    <span class="attr">scale:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">use:</span> <span class="string">live2d-widget-model-wanko</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">    <span class="attr">superSample:</span> <span class="number">2</span> <span class="comment"># 超采样等级</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">100</span> </span><br><span class="line">    <span class="attr">height:</span> <span class="number">100</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">left</span> <span class="comment"># 位置</span></span><br><span class="line">  <span class="attr">mobile:</span></span><br><span class="line">    <span class="attr">show:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">react:</span></span><br><span class="line">    <span class="attr">opacityDefault:</span> <span class="number">0.9</span> <span class="comment"># 默认透明度</span></span><br><span class="line">    <span class="attr">opacityOnHover:</span> <span class="number">0.5</span> <span class="comment"># 鼠标移上透明度</span></span><br></pre></td></tr></table></figure>
<h2 id="侧栏加入已运行的时间"><a href="#侧栏加入已运行的时间" class="headerlink" title="侧栏加入已运行的时间"></a>侧栏加入已运行的时间</h2><p><code>themes/next/layout/_custom</code>中添加<code>sidebar.swig</code>文件: </p>
<figure class="highlight html"><figcaption><span>themes/next/layout/_custom</span><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html" rel="external nofollow noopener noreferrer" target="_blank">链接</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"days"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">show_date_time</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.setTimeout(<span class="string">"show_date_time()"</span>, <span class="number">1000</span>);</span></span><br><span class="line"><span class="javascript">        BirthDay=<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"01/10/2017 12:34:56"</span>);</span></span><br><span class="line"><span class="javascript">        today=<span class="keyword">new</span> <span class="built_in">Date</span>();</span></span><br><span class="line">        timeold=(today.getTime()-BirthDay.getTime());</span><br><span class="line">        sectimeold=timeold/1000</span><br><span class="line"><span class="javascript">        secondsold=<span class="built_in">Math</span>.floor(sectimeold);</span></span><br><span class="line">        msPerDay=24*60*60*1000</span><br><span class="line">        e_daysold=timeold/msPerDay</span><br><span class="line"><span class="javascript">        daysold=<span class="built_in">Math</span>.floor(e_daysold);</span></span><br><span class="line">        e_hrsold=(e_daysold-daysold)*24;</span><br><span class="line"><span class="javascript">        hrsold=setzero(<span class="built_in">Math</span>.floor(e_hrsold));</span></span><br><span class="line">        e_minsold=(e_hrsold-hrsold)*60;</span><br><span class="line"><span class="javascript">        minsold=setzero(<span class="built_in">Math</span>.floor((e_hrsold-hrsold)*<span class="number">60</span>));</span></span><br><span class="line"><span class="javascript">        seconds=setzero(<span class="built_in">Math</span>.floor((e_minsold-minsold)*<span class="number">60</span>));</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">'days'</span>).innerHTML=<span class="string">"已运行"</span>+daysold+<span class="string">"天"</span>+hrsold+<span class="string">"小时"</span>+minsold+<span class="string">"分"</span>+seconds+<span class="string">"秒"</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">setzero</span>(<span class="params">i</span>)</span>&#123;</span></span><br><span class="line">    if (i&lt;10)</span><br><span class="line"><span class="javascript">    &#123;i=<span class="string">"0"</span> + i&#125;;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> i;</span></span><br><span class="line">&#125;</span><br><span class="line">show_date_time();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在<code>themes/next/layout/_macro/sidebar.swig</code>中的<code>&lt;/section&gt;</code>之前添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% include &apos;../_custom/sidebar.swig&apos; %&#125;</span><br></pre></td></tr></table></figure>
<p>样式: </p>
<figure class="highlight diff"><figcaption><span>themes/next/source/css/_custom/custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line">// 自定义的侧栏时间样式</span><br><span class="line">#days &#123;</span><br><span class="line">    display: block;</span><br><span class="line">    color: #fffa74;</span><br><span class="line">    font-size: 14px;</span><br><span class="line">    margin-top: 15px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="更改标签云（tagcloud）的颜色"><a href="#更改标签云（tagcloud）的颜色" class="headerlink" title="更改标签云（tagcloud）的颜色"></a>更改标签云（tagcloud）的颜色</h2><p><code>themes/next/layout/page.swig</code>找到<code>tagcloud并替换</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; tagcloud(&#123;min_font: 13, max_font: 31, amount: 1000, color: true, start_color: &apos;#9733EE&apos;, end_color: &apos;#FF512F&apos;&#125;) &#125;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="设置动态title"><a href="#设置动态title" class="headerlink" title="设置动态title"></a>设置动态title</h2><p><code>themes/next/source/js/src</code>下创建<code>dytitle.js</code>: </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> OriginTitile = <span class="built_in">document</span>.title;</span><br><span class="line"><span class="keyword">var</span> titleTime;</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'visibilitychange'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.hidden) &#123;</span><br><span class="line">        $(<span class="string">'[rel="shortcut icon"]'</span>).attr(<span class="string">'href'</span>, <span class="string">"/TEP.png"</span>);</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">'w(ﾟДﾟ)w 出BUG啦！！！！'</span>;</span><br><span class="line">        clearTimeout(titleTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        $(<span class="string">'[rel="shortcut icon"]'</span>).attr(<span class="string">'href'</span>, <span class="string">"/favicon.png"</span>);</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">'♪(^∇^*)又好了. . . '</span> + OriginTitile;</span><br><span class="line">        titleTime = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">document</span>.title = OriginTitile;</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>修改<code>themes/next/layout/layout.swing</code>,在 <code>&lt;/body&gt;</code> 之前添加: :</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;script type="text/javascript" src="/js/src/dytitle.js"&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="修改文章底部的那个带-号的标签"><a href="#修改文章底部的那个带-号的标签" class="headerlink" title="修改文章底部的那个带#号的标签"></a>修改文章底部的那个带#号的标签</h2><p>修改模板<code>/themes/next/layout/_macro/post.swig</code>, 搜索 <code>rel=&quot;tag&quot;&gt;#</code>, 将 # 换成<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code></p>
<h1 id="元素微调自定义篇"><a href="#元素微调自定义篇" class="headerlink" title="元素微调自定义篇"></a>元素微调自定义篇</h1><p>那么如何把字体、页宽、按钮大小等等一些细节的东西调到自己喜欢的样式呢？<br>那就是通过浏览器元素定位, 调到自己喜欢的样式, 然后加到<code>themes/next/source/css/_custom/custom.styl</code>文件下面. </p>
<h2 id="定位元素"><a href="#定位元素" class="headerlink" title="定位元素"></a>定位元素</h2><p>用谷歌或者火狐浏览器打开博客页面, 按下F12进入调试<br>先点击定位按钮, 然后选择元素, 然后在定位出来的样式进行修改, 调到自己喜欢的样子, 就像这样↓<br><img src="https://cdn.yangbingdong.com/img/build-hexo/yemiantiaoshi.png" alt></p>
<h2 id="添加到样式文件"><a href="#添加到样式文件" class="headerlink" title="添加到样式文件"></a>添加到样式文件</h2><p>打开<code>themes/next/source/css/_custom/custom.styl</code>, 把调试好的样式加进去, 保存后<code>Ctrl+F5</code>就能看到效果了, 前提是在本地运行的, 下面列出博主的一些自定义样式:<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// Custom styles.</span><br><span class="line">// 页面头部背景</span><br><span class="line"><span class="selector-class">.header</span> &#123;  <span class="attribute">background</span>:<span class="built_in">url</span>(https://cdn.yangbingdong.com/img/header/header_background.jpg);&#125;</span><br><span class="line"></span><br><span class="line">// 子标题</span><br><span class="line"><span class="selector-class">.site-subtitle</span>&#123; <span class="attribute">font-size</span>: <span class="number">15px</span>; <span class="attribute">color</span>: white; &#125;</span><br><span class="line"></span><br><span class="line">// 标题</span><br><span class="line"><span class="selector-class">.site-title</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 标题背景</span><br><span class="line"><span class="selector-class">.brand</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 菜单栏</span><br><span class="line"><span class="selector-class">.menu</span> &#123;</span><br><span class="line">	<span class="attribute">margin-top</span>: <span class="number">20px</span>;</span><br><span class="line">	<span class="attribute">padding-left</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">text-align</span>: center;</span><br><span class="line">	<span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">240</span>, <span class="number">240</span>, <span class="number">240</span>, <span class="number">0.5</span>);</span><br><span class="line">	<span class="attribute">margin-left</span>: auto;</span><br><span class="line">	<span class="attribute">margin-right</span>: auto;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">530px</span>;</span><br><span class="line">	<span class="attribute">border-radius</span>: initial;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 菜单图表链接 以及 超链接样式</span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ff106c</span>;</span><br><span class="line">    <span class="attribute">border-bottom-color</span>: <span class="number">#ff106c</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 菜单字体大小</span><br><span class="line"><span class="selector-class">.menu</span> <span class="selector-class">.menu-item</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.menu</span> <span class="selector-class">.menu-item</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">border-bottom-color</span>: <span class="number">#ff106c</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 文章背景框框</span><br><span class="line"><span class="selector-class">.post</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">18px</span>;</span><br><span class="line">    <span class="attribute">-webkit-box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="built_in">rgba</span>(<span class="number">202</span>, <span class="number">203</span>, <span class="number">203</span>, <span class="number">0.8</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">// 站点描述</span><br><span class="line"><span class="selector-class">.site-description</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 头部inner</span><br><span class="line"><span class="selector-class">.header-inner</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">45px</span> <span class="number">0</span> <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">700px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 作者名</span><br><span class="line"><span class="selector-class">.site-author-name</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">'Comic Sans MS'</span>, sans-serif;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 文章之间的分割线</span><br><span class="line"><span class="selector-class">.posts-expand</span> <span class="selector-class">.post-eof</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">40px</span> auto <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">background</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 按钮样式</span><br><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ``代码块样式</span><br><span class="line"><span class="selector-tag">code</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#E6006B</span>;</span><br><span class="line">    <span class="attribute">background</span>: white;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 文章```代码块顶部样式</span><br><span class="line"><span class="selector-class">.highlight</span> <span class="selector-tag">figcaption</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0em</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0.5em</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#eee</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#e9e9e9</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.highlight</span> <span class="selector-tag">figcaption</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">80</span>, <span class="number">115</span>, <span class="number">184</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 文章标题动态效果 next/source/css/_common/components/post/post-title.styl中.posts-expand .post-title-link确保`position: relative;`属性存在, 如果需要标题呈现链接效果颜色, 将`color`元素去除即可</span><br><span class="line"><span class="selector-class">.posts-expand</span> <span class="selector-class">.post-title-link</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(<span class="number">90deg</span>, #a166ab <span class="number">0%</span>, #ef4e7b <span class="number">25%</span>, #f37055 <span class="number">50%</span>, #ef4e7b <span class="number">75%</span>, #a166ab <span class="number">100%</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 文章内标题样式（左边的竖线）</span><br><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, <span class="selector-tag">h6</span> &#123;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">4px</span> solid <span class="number">#657b83</span>;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">5px</span> solid <span class="number">#657b83</span>;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#444</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但并不是所有的样式都能调, 像页宽, 多说评论的样式在<code>custom.styl</code>文件是无效的. </p>
<h2 id="好玩的样式"><a href="#好玩的样式" class="headerlink" title="好玩的样式"></a>好玩的样式</h2><p>先在<code>themes/next/source/css/_custom/custom.styl</code>中添加以下样式:<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 下载样式</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-id">#download</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: inline-block;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line"><span class="attribute">background</span>: transparent;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#000</span>;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">2px</span>;</span><br><span class="line"><span class="attribute">transition</span>: all .<span class="number">5s</span> ease;</span><br><span class="line"><span class="attribute">font-weight</span>: bold;</span><br><span class="line">&amp;:hover &#123;</span><br><span class="line"><span class="selector-tag">background</span>: <span class="selector-id">#000</span>;</span><br><span class="line"><span class="selector-tag">color</span>: <span class="selector-id">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/ /颜色块-黄</span><br><span class="line"><span class="selector-tag">span</span><span class="selector-id">#inline-yellow</span> &#123;</span><br><span class="line"><span class="attribute">display</span>:inline;</span><br><span class="line"><span class="attribute">padding</span>:.<span class="number">2em</span> .<span class="number">6em</span> .<span class="number">3em</span>;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">80%</span>;</span><br><span class="line"><span class="attribute">font-weight</span>:bold;</span><br><span class="line"><span class="attribute">line-height</span>:<span class="number">1</span>;</span><br><span class="line"><span class="attribute">color</span>:<span class="number">#fff</span>;</span><br><span class="line"><span class="attribute">text-align</span>:center;</span><br><span class="line"><span class="attribute">white-space</span>:nowrap;</span><br><span class="line"><span class="attribute">vertical-align</span>:baseline;</span><br><span class="line"><span class="attribute">border-radius</span>:<span class="number">0</span>;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#f0ad4e</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 颜色块-绿</span><br><span class="line"><span class="selector-tag">span</span><span class="selector-id">#inline-green</span> &#123;</span><br><span class="line"><span class="attribute">display</span>:inline;</span><br><span class="line"><span class="attribute">padding</span>:.<span class="number">2em</span> .<span class="number">6em</span> .<span class="number">3em</span>;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">80%</span>;</span><br><span class="line"><span class="attribute">font-weight</span>:bold;</span><br><span class="line"><span class="attribute">line-height</span>:<span class="number">1</span>;</span><br><span class="line"><span class="attribute">color</span>:<span class="number">#fff</span>;</span><br><span class="line"><span class="attribute">text-align</span>:center;</span><br><span class="line"><span class="attribute">white-space</span>:nowrap;</span><br><span class="line"><span class="attribute">vertical-align</span>:baseline;</span><br><span class="line"><span class="attribute">border-radius</span>:<span class="number">0</span>;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#5cb85c</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 颜色块-蓝</span><br><span class="line"><span class="selector-tag">span</span><span class="selector-id">#inline-blue</span> &#123;</span><br><span class="line"><span class="attribute">display</span>:inline;</span><br><span class="line"><span class="attribute">padding</span>:.<span class="number">2em</span> .<span class="number">6em</span> .<span class="number">3em</span>;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">80%</span>;</span><br><span class="line"><span class="attribute">font-weight</span>:bold;</span><br><span class="line"><span class="attribute">line-height</span>:<span class="number">1</span>;</span><br><span class="line"><span class="attribute">color</span>:<span class="number">#fff</span>;</span><br><span class="line"><span class="attribute">text-align</span>:center;</span><br><span class="line"><span class="attribute">white-space</span>:nowrap;</span><br><span class="line"><span class="attribute">vertical-align</span>:baseline;</span><br><span class="line"><span class="attribute">border-radius</span>:<span class="number">0</span>;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#2780e3</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 颜色块-紫</span><br><span class="line"><span class="selector-tag">span</span><span class="selector-id">#inline-purple</span> &#123;</span><br><span class="line"><span class="attribute">display</span>:inline;</span><br><span class="line"><span class="attribute">padding</span>:.<span class="number">2em</span> .<span class="number">6em</span> .<span class="number">3em</span>;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">80%</span>;</span><br><span class="line"><span class="attribute">font-weight</span>:bold;</span><br><span class="line"><span class="attribute">line-height</span>:<span class="number">1</span>;</span><br><span class="line"><span class="attribute">color</span>:<span class="number">#fff</span>;</span><br><span class="line"><span class="attribute">text-align</span>:center;</span><br><span class="line"><span class="attribute">white-space</span>:nowrap;</span><br><span class="line"><span class="attribute">vertical-align</span>:baseline;</span><br><span class="line"><span class="attribute">border-radius</span>:<span class="number">0</span>;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#9954bb</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 左侧边框红色块级</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-id">#div-border-left-red</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: block;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line"><span class="attribute">border-left-width</span>: <span class="number">5px</span>;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line"><span class="attribute">border-left-color</span>: <span class="number">#df3e3e</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 左侧边框黄色块级</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-id">#div-border-left-yellow</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: block;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line"><span class="attribute">border-left-width</span>: <span class="number">5px</span>;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line"><span class="attribute">border-left-color</span>: <span class="number">#f0ad4e</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 左侧边框绿色块级</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-id">#div-border-left-green</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: block;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line"><span class="attribute">border-left-width</span>: <span class="number">5px</span>;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line"><span class="attribute">border-left-color</span>: <span class="number">#5cb85c</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 左侧边框蓝色块级</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-id">#div-border-left-blue</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: block;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line"><span class="attribute">border-left-width</span>: <span class="number">5px</span>;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line"><span class="attribute">border-left-color</span>: <span class="number">#2780e3</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 左侧边框紫色块级</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-id">#div-border-left-purple</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: block;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line"><span class="attribute">border-left-width</span>: <span class="number">5px</span>;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line"><span class="attribute">border-left-color</span>: <span class="number">#9954bb</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 右侧边框红色块级</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-id">#div-border-right-red</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: block;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line"><span class="attribute">border-right-width</span>: <span class="number">5px</span>;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line"><span class="attribute">border-right-color</span>: <span class="number">#df3e3e</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 右侧边框黄色块级</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-id">#div-border-right-yellow</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: block;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line"><span class="attribute">border-right-width</span>: <span class="number">5px</span>;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line"><span class="attribute">border-right-color</span>: <span class="number">#f0ad4e</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 右侧边框绿色块级</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-id">#div-border-right-green</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: block;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line"><span class="attribute">border-right-width</span>: <span class="number">5px</span>;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line"><span class="attribute">border-right-color</span>: <span class="number">#5cb85c</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 右侧边框蓝色块级</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-id">#div-border-right-blue</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: block;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line"><span class="attribute">border-right-width</span>: <span class="number">5px</span>;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line"><span class="attribute">border-right-color</span>: <span class="number">#2780e3</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 右侧边框紫色块级</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-id">#div-border-right-purple</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: block;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line"><span class="attribute">border-right-width</span>: <span class="number">5px</span>;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line"><span class="attribute">border-right-color</span>: <span class="number">#9954bb</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 上侧边框红色</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-id">#div-border-top-red</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: block;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line"><span class="attribute">border-top-width</span>: <span class="number">5px</span>;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line"><span class="attribute">border-top-color</span>: <span class="number">#df3e3e</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 上侧边框黄色</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-id">#div-border-top-yellow</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: block;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line"><span class="attribute">border-top-width</span>: <span class="number">5px</span>;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line"><span class="attribute">border-top-color</span>: <span class="number">#f0ad4e</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 上侧边框绿色</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-id">#div-border-top-green</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: block;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line"><span class="attribute">border-top-width</span>: <span class="number">5px</span>;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line"><span class="attribute">border-top-color</span>: <span class="number">#5cb85c</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 上侧边框蓝色</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-id">#div-border-top-blue</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: block;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line"><span class="attribute">border-top-width</span>: <span class="number">5px</span>;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line"><span class="attribute">border-top-color</span>: <span class="number">#2780e3</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 上侧边框紫色</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-id">#div-border-top-purple</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: block;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line"><span class="attribute">border-top-width</span>: <span class="number">5px</span>;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line"><span class="attribute">border-top-color</span>: <span class="number">#9954bb</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>用法如下</strong>: </p>
<h3 id="文字增加背景色块"><a href="#文字增加背景色块" class="headerlink" title="文字增加背景色块"></a>文字增加背景色块</h3><p><span id="inline-blue">站点配置文件</span> , <span id="inline-purple">主题配置文件</span><br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"inline-blue"</span>&gt;</span>站点配置文件<span class="tag">&lt;/<span class="name">span</span>&gt;</span>, </span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"inline-purple"</span>&gt;</span>主题配置文件<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="引用边框变色"><a href="#引用边框变色" class="headerlink" title="引用边框变色"></a>引用边框变色</h3><p></p><p id="div-border-left-red">如果没有安装成功, 那可能就是墙的原因. 建议下载 <code>Node.js</code> 直接安装. </p><p></p>
<p></p><p id="div-border-top-blue">关于更多基本操作和基础知识, 请查阅 <a href="https://hexo.io/zh-cn/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> 与 <a href="http://theme-next.iissnan.com/" rel="external nofollow noopener noreferrer" target="_blank">NexT</a> 官方文档.</p><br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"div-border-left-red"</span>&gt;</span>如果没有安装成功, 那可能就是墙的原因. 建议下载 `Node.js` 直接安装. <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"div-border-top-blue"</span>&gt;</span>关于更多基本操作和基础知识, 请查阅 [Hexo](https://hexo.io/zh-cn/) 与 [NexT](http://theme-next.iissnan.com/) 官方文档.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p>
<h3 id="在文档中增加图标"><a href="#在文档中增加图标" class="headerlink" title="在文档中增加图标"></a>在文档中增加图标</h3><ul>
<li><i class="fa fa-pencil"></i>支持Markdown<br><i>Hexo 支持 GitHub Flavored Markdown 的所有功能, 甚至可以整合 Octopress 的大多数插件. </i></li>
<li><i class="fa fa-cloud-upload"></i>一件部署<br><i>只需一条指令即可部署到Github Pages, 或其他网站</i></li>
<li><i class="fa fa-cog"></i>丰富的插件<br><i>Hexo 拥有强大的插件系统, 安装插件可以让 Hexo 支持 Jade, CoffeeScript. </i></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- &lt;i class=&quot;fa fa-pencil&quot;&gt;&lt;/i&gt;支持Markdown</span><br><span class="line">&lt;i&gt;Hexo 支持 GitHub Flavored Markdown 的所有功能, 甚至可以整合 Octopress 的大多数插件. &lt;/i&gt;</span><br><span class="line">- &lt;i class=&quot;fa fa-cloud-upload&quot;&gt;&lt;/i&gt;一件部署</span><br><span class="line">&lt;i&gt;只需一条指令即可部署到Github Pages, 或其他网站&lt;/i&gt;</span><br><span class="line">- &lt;i class=&quot;fa fa-cog&quot;&gt;&lt;/i&gt;丰富的插件</span><br><span class="line">&lt;i&gt;Hexo 拥有强大的插件系统, 安装插件可以让 Hexo 支持 Jade, CoffeeScript. &lt;/i&gt;</span><br></pre></td></tr></table></figure>
<p><i class="fa fa-github"></i><code>&lt;i class=&quot;fa fa-github&quot;&gt;&lt;/i&gt;</code><br><i class="fa fa-github fa-lg"></i><code>&lt;i class=&quot;fa fa-github fa-lg&quot;&gt;&lt;/i&gt;</code><br><i class="fa fa-github fa-2x"></i><code>&lt;i class=&quot;fa fa-github fa-2x&quot;&gt;&lt;/i&gt;</code></p>
<p>采用的是<strong><em><a href="http://fontawesome.io/examples/" rel="external nofollow noopener noreferrer" target="_blank">Font Awesome</a></em></strong>的图标. </p>
<h3 id="图形边框效果"><a href="#图形边框效果" class="headerlink" title="图形边框效果"></a>图形边框效果</h3><p><a id="download" href="https://git-scm.com/download/win" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-download"></i><span> Download Now</span><br></a><br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"download"</span> <span class="attr">href</span>=<span class="string">"https://git-scm.com/download/win"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-download"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span> Download Now<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这也是调用了<strong><em><a href="http://fontawesome.io/examples/" rel="external nofollow noopener noreferrer" target="_blank">Font Awesome</a></em></strong>的方法. </p>
<h2 id="代码高亮相关"><a href="#代码高亮相关" class="headerlink" title="代码高亮相关"></a>代码高亮相关</h2><p>先看一则代码</p>
<figure class="highlight diff"><figcaption><span>Hello World示例</span><a href="http://yangbingdong.com">这是链接</a></figcaption><table><tr><td class="code"><pre><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line"><span class="addition">+		System.out.println("Hello World!");</span></span><br><span class="line"><span class="deletion">-		System.out.println("Hello World!");</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>正确姿势, 代码片段开头: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[language] [title] [url] [link-text]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>[language]</code> 是代码语言的名称, 用来设置代码块颜色高亮, 非必须；</li>
<li><code>[title]</code> 是顶部左边的说明, 非必须；</li>
<li><code>[url]</code> 是顶部右边的超链接地址, 非必须；</li>
<li><code>[link text]</code> 如它的字面意思, 超链接的名称, 非必须. </li>
</ul>
<p>这 4 项应该是根据空格来分隔, 而不是<code>[]</code>, 故请不要加<code>[]</code>. 除非如果你想写后面两个, 但不想写前面两个, 那么就必须加<code>[]</code>了, 要这样写: <code>[] [] [url] [link text]</code>. </p>
<p>首先关于代码块颜色高亮, 高亮的模式可以在<strong>主题配置文件</strong>中设置: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Code Highlight theme</span><br><span class="line"># Available value:</span><br><span class="line">#    normal | night | night eighties | night blue | night bright</span><br><span class="line"># https://github.com/chriskempson/tomorrow-theme</span><br><span class="line"></span><br><span class="line">highlight_theme: normal</span><br></pre></td></tr></table></figure>
<p>要颜色正确高亮, 代码语言的名称肯定要写对, 各种支持语言的名称可以查看<a href="https://almostover.ru/2016-07/hexo-highlight-code-styles/" rel="external nofollow noopener noreferrer" target="_blank">这篇文章</a>. 也可以在站点配置文件<code>_config.yml</code>中设置自动高亮: </p>
<figure class="highlight diff"><figcaption><span>blog/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line"># 代码自动高亮</span><br><span class="line"><span class="deletion">-  auto_detect: false</span></span><br><span class="line"><span class="addition">+  auto_detect: true</span></span><br></pre></td></tr></table></figure>
<p>上边的diff是通过在<code>[language]</code>填写diff, 然后在相应代码前面加上<code>-</code>和<code>+</code></p>
<p>顶部的文字样式: </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 文章```代码块顶部样式</span><br><span class="line"><span class="selector-class">.highlight</span> <span class="selector-tag">figcaption</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0em</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0.5em</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#eee</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#e9e9e9</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.highlight</span> <span class="selector-tag">figcaption</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">80</span>, <span class="number">115</span>, <span class="number">184</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="站点加速篇"><a href="#站点加速篇" class="headerlink" title="站点加速篇"></a>站点加速篇</h1><h2 id="更改默认Google字体库"><a href="#更改默认Google字体库" class="headerlink" title="更改默认Google字体库"></a>更改默认Google字体库</h2><p>访问系统总是会耗费一大部分的时间在加载<code>google</code>字体库上, 而且经常加载不成功. </p>
<p>方法一: 用国内的CDN库来替代主题中的<code>google</code>字体库, 到<code>主题配置文件</code>中设置默认字体库:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">host: fonts.useso.com</span><br></pre></td></tr></table></figure></p>
<p>方法二: 关掉字体库的引用, 默认加载本地字体库, 到<code>主题配置文件</code>设置:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">font:</span><br><span class="line">  enable: false</span><br></pre></td></tr></table></figure></p>
<h2 id="使用云盘存放图片资源"><a href="#使用云盘存放图片资源" class="headerlink" title="使用云盘存放图片资源"></a>使用云盘存放图片资源</h2><p>由于Github的服务器在海外, 那么如果把图片也放到Github显然是不科学的, 而且Github的存储空间也有局限, 那么在这里博主推荐使用<em><a href="http://www.qiniu.com/" rel="external nofollow noopener noreferrer" target="_blank">七牛云储存</a></em><br>具体怎么做在之前的基础篇已经介绍过了, 详情请看→<em><a href="/2017/build-blog-hexo-base/#%E6%96%B9%E5%BC%8F%E4%B8%89">传送门</a></em></p>
<h2 id="压缩代码"><a href="#压缩代码" class="headerlink" title="压缩代码"></a>压缩代码</h2><p>安装插件:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-all-minifier --save</span><br></pre></td></tr></table></figure></p>
<p>之后执行<code>hexo g</code>就会自动压缩<br>但这有一个<strong>缺点</strong>, 就是本地运行也就是执行<code>hexo s</code>之后浏览器打开本地项目会很慢, 原因是每次点击一个链接它就会重新压缩一次, 所以建议本地调试的时候把项目根目录下的<code>package.json</code>中的<code>&quot;hexo-all-minifier&quot;: &quot;0.0.14&quot;</code>先删掉再调试,或者改成注释:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">    .</span><br><span class="line">	.</span><br><span class="line">	.</span><br><span class="line">    &quot;hexo-server&quot;: &quot;^0.2.0&quot;,</span><br><span class="line">    &quot;hexo-wordcount&quot;: &quot;^2.0.1&quot;,</span><br><span class="line">    &quot;this-is-compress-plugin&quot;: &#123;</span><br><span class="line">      &quot;hexo-all-minifier&quot;: &quot;0.0.14&quot;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>其实也没必要压缩代码, 牺牲了性能, 每次生成静态文件都太慢了, 得不偿失的感觉.</p>
<p><strong>高性能</strong>的压缩工具参考这里: <strong><em><a href="/2017/build-blog-hexo-base/#%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9">minify文件压缩</a></em></strong></p>
<h1 id="SEO-搜索引擎优化-篇"><a href="#SEO-搜索引擎优化-篇" class="headerlink" title="SEO(搜索引擎优化)篇"></a>SEO(搜索引擎优化)篇</h1><h2 id="网站验证"><a href="#网站验证" class="headerlink" title="网站验证"></a>网站验证</h2><p>以下是几个搜索引擎的提交入口: </p>
<ul>
<li><strong><em><a href="http://zhanzhang.baidu.com/linksubmit/url" rel="external nofollow noopener noreferrer" target="_blank">百度提交入口</a></em></strong></li>
<li><strong><em><a href="https://www.google.com/webmasters/tools/home?hl=zh-CN" rel="external nofollow noopener noreferrer" target="_blank">Google提交入口</a></em></strong></li>
<li><strong><em><a href="http://info.so.360.cn/site_submit.html" rel="external nofollow noopener noreferrer" target="_blank">360提交入口</a></em></strong></li>
</ul>
<p>以百度为例, 谷歌的太简单就不说了:<br>打开<em><a href="http://zhanzhang.baidu.com/linksubmit/url" rel="external nofollow noopener noreferrer" target="_blank">百度站长</a></em>验证网站<br><strong>方式一: 文件验证</strong></p>
<ul>
<li>登录百度站长选择添加网站, 使用方式为文件验证</li>
<li>将下载的文件放到<code>source</code>文件下</li>
<li>由于hexo自动会对html文件进行渲染, 所以在<code>站点配置文件</code>中找到<code>skip_render:</code></li>
<li>在后面添加文件名字, 如有多个用<code>[a.html,b.html]</code>, eg:<code>skip_render:[baidu_verify_tdOGHi8IQG.html, baidu_verify_vcJkI72f1e.html]</code></li>
<li><p>重新渲染文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后可以点击百度站长的验证按钮了</p>
</li>
</ul>
<p><strong>方式二: CNAME验证</strong></p>
<ol>
<li>去站长添加网站选择CNAME验证</li>
<li>把地址解析到zz.baidu.com</li>
<li>完成验证</li>
</ol>
<p>就像这样↓<br><img src="https://cdn.yangbingdong.com/img/build-hexo/DNSjiexi.png" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/build-hexo/baiduyanzheng.png" alt></p>
<h2 id="添加并提交sitemap"><a href="#添加并提交sitemap" class="headerlink" title="添加并提交sitemap"></a>添加并提交sitemap</h2><p>安装hexo的<code>sitemap</code>网站地图生成插件:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure></p>
<p>在<code>站点配置文件</code>中添加如下代码.<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hexo sitemap</span></span><br><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br></pre></td></tr></table></figure></p>
<p>配置成功后, 会生成<code>sitemap.xml</code>和<code>baidusitemap.xml</code>, 前者适合提交给<strong>谷歌搜素引擎</strong>, 后者适合提交<strong>百度搜索引擎</strong>.<br>百度sitemap提交如下↓<br><img src="https://cdn.yangbingdong.com/img/build-hexo/sitemap.png" alt></p>
<p>验证成功之后就可以开始推送了, 这里说一下, Google的收录真的快的不要不要的, 第二天就能搜得到, 百度就不想说了, 不知道要等到猴年马月<br><img src="https://cdn.yangbingdong.com/img/build-hexo/GoogleSearch.png" alt></p>
<h2 id="主动推送"><a href="#主动推送" class="headerlink" title="主动推送"></a>主动推送</h2><p>安装主动推送插件:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">﻿npm install hexo-baidu-url-submit --save</span><br></pre></td></tr></table></figure></p>
<p>在根目录下, 把以下内容配置到<code>站点配置文件</code>中:<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">baidu_url_submit:</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">3</span> <span class="comment">## 比如3, 代表提交最新的三个链接</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">www.henvyluk.com</span> <span class="comment">## 在百度站长平台中注册的域名</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">your_token</span> <span class="comment">## 请注意这是您的秘钥, 请不要发布在公众仓库里!</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidu_urls.txt</span> <span class="comment">## 文本文档的地址, 新链接会保存在此文本文档里</span></span><br></pre></td></tr></table></figure></p>
<p>至于上面提到的<code>your_token</code>可在百度站长如下位置找到↓<br><img src="https://cdn.yangbingdong.com/img/build-hexo/baidutoken.png" alt><br>其次, 记得查看<code>站点配置文件</code>中url的值, 必须包含是百度站长平台注册的域名（一般有www）, 比如:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url: http://www.ookamiantd.top</span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br></pre></td></tr></table></figure></p>
<p>接下来添加一个新的<code>deploy</code>的类型:<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">baidu_url_submitter</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">    <span class="attr">github:</span> <span class="string">git@github.com:masteranthoneyd/masteranthoneyd.github.io.git,master</span></span><br><span class="line">    <span class="attr">coding:</span> <span class="string">git@git.coding.net:ookamiantd/ookamiantd.git,master</span></span><br></pre></td></tr></table></figure></p>
<p>执行<code>hexo deploy</code>的时候, 新的连接就会被推送了. 这里讲一下原理: </p>
<ul>
<li>新链接的产生, <code>hexo generate</code>会产生一个文本文件, 里面包含最新的链接</li>
<li>新链接的提交, <code>hexo deploy</code>会从上述文件中读取链接, 提交至百度搜索引擎</li>
</ul>
<h2 id="自动推送"><a href="#自动推送" class="headerlink" title="自动推送"></a>自动推送</h2><p>把next<code>主题配置文件</code>中的<code>baidu_push</code>设置为<code>true</code>, 就可以了. </p>
<h2 id="添加蜘蛛协议"><a href="#添加蜘蛛协议" class="headerlink" title="添加蜘蛛协议"></a>添加蜘蛛协议</h2><p>在<code>/source/</code>目录下新建一个<code>robots.txt</code>文件, 添加下面的一段代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#hexo robots.txt</span><br><span class="line">User-agent: *</span><br><span class="line"></span><br><span class="line">Allow: /</span><br><span class="line">Allow: /archives/</span><br><span class="line"></span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /js/</span><br><span class="line">Disallow: /css/</span><br><span class="line">Disallow: /fonts/</span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /fancybox/</span><br><span class="line"></span><br><span class="line">Sitemap: http://blog.tangxiaozhu.com/search.xml</span><br><span class="line">Sitemap: http://blog.tangxiaozhu.com/sitemap.xml</span><br><span class="line">Sitemap: http://blog.tangxiaozhu.com/baidusitemap.xml</span><br></pre></td></tr></table></figure></p>
<p>然后到百度站长更新一下, 就像这样↓<br><img src="https://cdn.yangbingdong.com/img/build-hexo/robots.png" alt></p>
<h2 id="修改文章链接"><a href="#修改文章链接" class="headerlink" title="修改文章链接"></a>修改文章链接</h2><p>hexo默认的文章链接形式为<code>domain/year/month/day/postname</code>, 默认就是一个四级<code>url</code>, 并且可能造成<code>url</code>过长, 对搜索引擎是十分不友好的, 我们可以改成<code>domain/postname</code>的形式. 编辑<code>站点配置文件</code>文件, 修改其中的<code>permalink</code>字段为<code>permalink: :title.html</code>即可. </p>
<h2 id="更改首页标题格式为「关键词-网站名称-网站描述」"><a href="#更改首页标题格式为「关键词-网站名称-网站描述」" class="headerlink" title="更改首页标题格式为「关键词-网站名称 - 网站描述」"></a>更改首页标题格式为「关键词-网站名称 - 网站描述」</h2><p>打开<code>\themes\next\layout\index.swig</code>文件, 找到这行代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; &#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p>
<p>把它改成:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% block title %&#125;</span><br><span class="line"> &#123;&#123; theme.keywords &#125;&#125; - &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="自动给所有外部链接添加nofollow"><a href="#自动给所有外部链接添加nofollow" class="headerlink" title="自动给所有外部链接添加nofollow"></a>自动给所有外部链接添加nofollow</h2><p>安装<code>hexo-autonofollow</code>, 在站点的根目录下执行以下命令:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-autonofollow --save</span><br></pre></td></tr></table></figure></p>
<p>编辑<strong>站点配置文件</strong>, 新增以下内容到任意位置:<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">nofollow:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">exclude1.com</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">exclude2.com</span></span><br></pre></td></tr></table></figure></p>
<h1 id="多PC同步源码篇"><a href="#多PC同步源码篇" class="headerlink" title="多PC同步源码篇"></a>多PC同步源码篇</h1><p>1.准备工作: 公司电脑和家里电脑配置git ssh密钥连接</p>
<p>2.上传blog到git: 此项建议先在blog进度最新的PC上进行, 否则会有版本冲突, 解决也比较麻烦. 在PC上建立git ssh密钥连接和建立新库respo在此略过:    </p>
<ul>
<li>编辑<code>.gitignore</code>文件: <code>.gitignore</code>文件作用是声明不被git记录的文件, blog根目录下的<code>.gitignore</code>是hexo初始化是创建的, 可以直接编辑, 建议<code>.gitignore</code>文件包括以下内容:      </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.DS_Store      </span><br><span class="line">Thumbs.db      </span><br><span class="line">db.json      </span><br><span class="line">*.log      </span><br><span class="line">node_modules/      </span><br><span class="line">public/      </span><br><span class="line">.deploy*/</span><br></pre></td></tr></table></figure>
<p><code>public</code>内的文件可以根据<code>source</code>文件夹内容自动生成的, 不需要备份. 其他日志、压缩、数据库等文件也都是调试等使用, 也不需要备份. </p>
<p>初始化仓库:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init    </span><br><span class="line">git remote add origin &lt;server&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>server</code>是仓库的在线目录地址, 可以从git上直接复制过来, <code>origin</code>是本地分支, <code>remote add</code>会将本地仓库映射到托管服务器的仓库上. </p>
<p>添加本地文件到仓库并同步到git上:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add . #添加blog目录下所有文件, 注意有个&apos;.&apos;(.gitignore里面声明的文件不在此内)    </span><br><span class="line">git commit -m &quot;hexo source first add&quot; #添加更新说明    </span><br><span class="line">git push -u origin master  #推送更新到git上</span><br></pre></td></tr></table></figure></p>
<p>至此, git库上备份已完成. </p>
<p>3.将git的内容同步到另一台电脑: 假设之前将公司电脑中的blog源码内容备份到了git上, 现在家里电脑准备同步源码内容. <strong>注意</strong>, 在同步前也要事先建好hexo的环境, 不然同步后本地服务器运行时会出现无法运行错误. 在建好的环境的主目录运行以下命令:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init  #将目录添加到版本控制系统中    </span><br><span class="line">git remote add origin &lt;server&gt;  #同上    </span><br><span class="line">git fetch --all  #将git上所有文件拉取到本地    </span><br><span class="line">git reset --hard origin/master  #强制将本地内容指向刚刚同步git云端内容</span><br></pre></td></tr></table></figure></p>
<p><code>reset</code>对所拉取的文件不做任何处理, 此处不用<code>pull</code>是因为本地尚有许多文件, 使用<code>pull</code>会有一些<strong>版本冲突</strong>, 解决起来也麻烦, 而本地的文件都是初始化生成的文件, 较拉取的库里面的文件而言基本无用, 所以直接丢弃. </p>
<p>4.家里电脑生成完文章并部署到服务器上后, 此时需要将新的blog源码文件更新到git托管库上, 不然公司电脑上无法获取最新的文章. 在本地文件中运行以下命令: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add . #将所有更新的本地文件添加到版本控制系统中</span><br></pre></td></tr></table></figure>
<p>此时可以使用<code>git status</code>查看本地文件的状态. 然后对更改添加说明更推送到git托管库上: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &apos;更新信息说明&apos;  </span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
<p>至此, 家里电脑更新的备份完成. 在公司电脑上使用时, 只需先运行:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure></p>
<p>获取的源码即为最新文件</p>
<h1 id="插件总结篇"><a href="#插件总结篇" class="headerlink" title="插件总结篇"></a>插件总结篇</h1><h2 id="部署插件"><a href="#部署插件" class="headerlink" title="部署插件"></a>部署插件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<h2 id="rss"><a href="#rss" class="headerlink" title="rss"></a>rss</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure>
<h2 id="Algolia"><a href="#Algolia" class="headerlink" title="Algolia"></a>Algolia</h2><p>此处有两个版本</p>
<p><strong>第一</strong>（以<code>0.2.0</code>为例）: </p>
<p>在站点找到<code>package.json</code>, 把添加一行<code>&quot;hexo-algolia&quot;: &quot;^0.2.0&quot;</code>, 然后: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-algolia --save</span><br></pre></td></tr></table></figure>
<p>这个为旧版的algolia, 优点是全文索引, 缺点是字数太多会索引失败</p>
<p><strong>第二</strong>: 直接安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-algolia --save hexo algolia</span><br></pre></td></tr></table></figure>
<p>此处安装的应该是<code>1.0.0</code>之后的版本了, 优点是没有字数限制了（因为没有了全文索引）, 只会索引文章开头的部分字段. 但是需要在官网注册新key并且设置环境变量, 方法: <strong><em><a href="https://github.com/iissnan/theme-next-docs/issues/162" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/iissnan/theme-next-docs/issues/162</a></em></strong></p>
<h2 id="sitemap"><a href="#sitemap" class="headerlink" title="sitemap"></a>sitemap</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>
<h2 id="百度主动推送"><a href="#百度主动推送" class="headerlink" title="百度主动推送"></a>百度主动推送</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-baidu-url-submit --save</span><br></pre></td></tr></table></figure>
<h2 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-archive --save</span><br><span class="line">npm install hexo-generator-category --save</span><br><span class="line">npm install hexo-generator-tag --save</span><br></pre></td></tr></table></figure>
<p>站点配置文件:<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">index_generator:</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="attr">archive_generator:</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">10</span> <span class="comment">##归档页面默认20篇文章标题</span></span><br><span class="line">  <span class="attr">yearly:</span> <span class="literal">true</span>  <span class="comment">##生成年视图</span></span><br><span class="line">  <span class="attr">monthly:</span> <span class="literal">true</span> <span class="comment">##生成月视图</span></span><br><span class="line"></span><br><span class="line"><span class="attr">tag_generator:</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure></p>
<h2 id="压缩插件"><a href="#压缩插件" class="headerlink" title="压缩插件"></a>压缩插件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-all-minifier --save</span><br></pre></td></tr></table></figure>
<h2 id="七牛admin插件"><a href="#七牛admin插件" class="headerlink" title="七牛admin插件"></a>七牛admin插件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-admin-qiniu</span><br><span class="line">hexo server -d</span><br><span class="line">open http://localhost:4000/admin/</span><br></pre></td></tr></table></figure>
<p>站点配置文件:<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">admin:</span></span><br><span class="line">  <span class="attr">qiniuCfg:</span></span><br><span class="line">      <span class="attr">imageslim:</span> <span class="literal">true</span>  <span class="comment"># 启动图片瘦身, 仅华东区bucket可以使用</span></span><br><span class="line">      <span class="attr">AccessKey:</span> <span class="string">'your qiniu AK'</span></span><br><span class="line">      <span class="attr">SecretKey:</span> <span class="string">'your qiniu SK'</span></span><br><span class="line">      <span class="attr">BucketName:</span> <span class="string">'your BK Name'</span></span><br><span class="line">      <span class="attr">bucketHost:</span> <span class="string">'you BK Host'</span></span><br></pre></td></tr></table></figure></p>
<h2 id="注脚插件"><a href="#注脚插件" class="headerlink" title="注脚插件"></a>注脚插件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-reference --save</span><br></pre></td></tr></table></figure>
<h2 id="字数与阅读时间插件"><a href="#字数与阅读时间插件" class="headerlink" title="字数与阅读时间插件"></a>字数与阅读时间插件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure>
<h1 id="主题升级备份"><a href="#主题升级备份" class="headerlink" title="主题升级备份"></a>主题升级备份</h1><p>对于升级主题, 我们需要重新配置主题配置文件, 那么每次升级都要这么干吗？超麻烦！</p>
<p>NexT作者给我们的建议就是使用<strong><em><a href="https://hexo.io/docs/data-files.html" rel="external nofollow noopener noreferrer" target="_blank">Data Files</a></em></strong>, 具体详情请戳进 <strong><em><a href="https://github.com/iissnan/hexo-theme-next/issues/328" rel="external nofollow noopener noreferrer" target="_blank">Theme configurations using Hexo data files            #328</a></em></strong></p>
<h1 id="图片链接全局替换"><a href="#图片链接全局替换" class="headerlink" title="图片链接全局替换"></a>图片链接全局替换</h1><p>由于七牛的测试域名已回收, 无奈只能备案换成自己的域名. 本案后在七牛添加CDN, 确认可以访问后, 利用<code>sed</code>进行全局替换: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -i &quot;s/http:\/\/img.yangbingdong.com/https:\/\/cdn.yangbingdong.com/g&quot; ./*</span><br></pre></td></tr></table></figure>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>一路摸爬滚打下来也挺折腾的, 不过确实满满的成就感, 学到了很多<br>同时还要感谢很多很多的大神们的文章, 有一些都忘了收藏记录下来, 由衷地感谢</p>
<blockquote>
<p><strong>参考</strong><br><strong><em><a href="http://codepub.cn/2015/04/06/Github-Pages-personal-blog-from-Octopress-to-Hexo/" rel="external nofollow noopener noreferrer" target="_blank">http://codepub.cn/2015/04/06/Github-Pages-personal-blog-from-Octopress-to-Hexo/</a></em></strong><br><strong><em><a href="http://codepub.cn/2016/03/20/Hexo-blog-theme-switching-from-Jacman-to-NexT-Mist/" rel="external nofollow noopener noreferrer" target="_blank">http://codepub.cn/2016/03/20/Hexo-blog-theme-switching-from-Jacman-to-NexT-Mist/</a></em></strong><br><strong><em><a href="http://www.shellsec.com/news/34054.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.shellsec.com/news/34054.html</a></em></strong><br><strong><em><a href="https://www.0101tx.com/pages/hexonextsanf.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.0101tx.com/pages/hexonextsanf.html</a></em></strong><br><strong><em><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html" rel="external nofollow noopener noreferrer" target="_blank">https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html</a></em></strong><br><strong><em><a href="https://io-oi.me/tech/hexo-next-optimization.html" rel="external nofollow noopener noreferrer" target="_blank">https://io-oi.me/tech/hexo-next-optimization.html</a></em></strong></p>
</blockquote>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">basic footnote content<a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content><categories><category>Hexo</category></categories><tags><tag>Hexo</tag><tag>Node.js</tag><tag>Github</tag><tag>Coding</tag><tag>Git</tag></tags></entry><entry><title>基于Hexo+Github+Coding搭建个人博客——基础篇(从菜鸟到放弃)</title><url>/2017/build-blog-hexo-base/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/build-hexo/hexoGoverment.png" alt></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>搭建此博客的动机以及好处在此就不多谈了, 之前已经表达过, 详情请看<em><a href="/2017/hello-world/">Start My Blog Trip — Power By Hexo</a></em><br>记录一下搭建的基本过程以及遇到的一些问题, 仅供参考<br>= =废话不多说, 进入主题<br><a id="more"></a></p>
<ul>
<li><p>Hexo博客搭建的基础大致流程为:<br> 安装Node.js →安装Git → 安装Hexo → 安装主题 → 本地测试运行 → 注册给github与coding并创建pages仓库 → 部署</p>
</li>
<li><p>这是博主的系统环境与版本:<br>OS: Ubuntu16.04<br>Node.js: 6.2.0<br>Npm: 3.8.9<br>Hexo: 3.2.2<br>主题NexT: 5.1.0<br>Git: 2.7.4</p>
</li>
<li><p><strong>对于使用windows的童鞋, 可参考文章末尾处的参考链接, 步骤大同小异</strong></p>
</li>
<li>以下提到的<strong><font color="red">站点配置文件</font></strong>指的是博客文件根目录下的 <code>_config.yml</code>, <strong><font color="red">主题配置文件</font></strong>是主题文件夹下的 <code>_config.yml</code>, 童鞋们不要混淆了</li>
</ul>
<hr>
<h1 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h1><blockquote>
<p>Node.js的安装有很多种方式, <em><a href="https://hexo.io/zh-cn/docs/" rel="external nofollow noopener noreferrer" target="_blank">Hexo的官方文档</a></em> 建议是用<em><a href="https://github.com/creationix/nvm" rel="external nofollow noopener noreferrer" target="_blank">nvm</a></em> 安装, 但好多人都说不行, 所以找了另外两种方式安装<br><strong>windows</strong>的童鞋可参考<em><a href="http://www.runoob.com/nodejs/nodejs-install-setup.html" rel="external nofollow noopener noreferrer" target="_blank">安装Node.js</a></em></p>
</blockquote>
<h2 id="方法一-二进制包直接解压配置"><a href="#方法一-二进制包直接解压配置" class="headerlink" title="方法一: 二进制包直接解压配置"></a>方法一: 二进制包直接解压配置</h2><p>在node.js的<em><a href="https://nodejs.org/en/" rel="external nofollow noopener noreferrer" target="_blank">官网</a></em> 下载二进制包来安装的, 下载过后, 解压, 设置软链接, 要不然每次都执行命令都要加上路径, 好麻烦<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ln -s /home/ybd/Data/soft/application/node-v6.2.0-linux-x64/bin/node /usr/local/bin/node</span><br><span class="line"></span><br><span class="line">sudo ln -s /home/ybd/Data/soft/application/node-v6.2.0-linux-x64/bin/npm /usr/local/bin/npm</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>！源文件要写<strong><font color="red">绝对路径</font></strong>, 否则会报错: <strong>链接层数过多</strong>. 也可以直接将node可执行文件拷贝到 <code>/usr/local/bin</code> 目录下. </p>
<p>接下来就可以查看是否成功配置了<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure></p>
<h2 id="方法二-换源下载"><a href="#方法二-换源下载" class="headerlink" title="方法二: 换源下载"></a>方法二: 换源下载</h2><p>安装 6.x 版本:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -</span><br><span class="line">sudo apt-get install -y nodejs</span><br></pre></td></tr></table></figure></p>
<p>安装 8.x 版本:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -</span><br><span class="line">sudo apt-get install -y nodejs</span><br></pre></td></tr></table></figure></p>
<p>npm 更换淘宝镜像:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure></p>
<h2 id="方法三-源文件编译安装"><a href="#方法三-源文件编译安装" class="headerlink" title="方法三: 源文件编译安装"></a>方法三: 源文件编译安装</h2><p>在安装前, 首先需要配置安g++编译器<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br></pre></td></tr></table></figure></p>
<p>去<em><a href="https://nodejs.org/en/download/" rel="external nofollow noopener noreferrer" target="_blank">官网</a></em> 下载源代码, 选择最后一项, Source Code<br>解压到某一目录, 然后进入此目录,依次执行以下3条命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></p>
<p>执行以下命令, 检测是否已经装好node.js<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure></p>
<p>npm安装, 一条命令即可解决<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl http://npmjs.org/install.sh | sudo sh</span><br></pre></td></tr></table></figure></p>
<p><img src="https://cdn.yangbingdong.com/img/build-hexo/version.png" alt></p>
<p>博主安装Node.js遇到的问题就是多次安装了不同版本的Node.js, 有的是安装在用户变量上, 有的是系统变量, 所以每次用的时候都要切换到root用户, 就算赋权 <code>sudo chmod 777 file</code> 都没有用, 所以折腾了很久才把Node.js完全卸载, 再重新安装</p>
<h1 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h1><p><strong>Ubuntu</strong>系统下安装Git非常简单, 只需一条命令:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure></p>
<p><strong>windows</strong>下就直接到<em><a href="https://git-scm.com/download/win" rel="external nofollow noopener noreferrer" target="_blank">Git官网</a></em> 下载安装即可</p>
<p>然后终端执行 <code>git --version</code> 查看是否安装成功<br><img src="https://cdn.yangbingdong.com/img/build-hexo/git-version.png" alt></p>
<h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><blockquote>
<p>什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架. Hexo 使用 Markdown（或其他渲染引擎）解析文章, 在几秒内, 即可利用靓丽的主题生成静态网页. </p>
</blockquote>
<ul>
<li>所有以上必备的应用程序安装完成后, <strong>无论是在哪个操作系统</strong>, 之后的操作都一样</li>
</ul>
<p>安装Hexo的非常简单, 只要一条命令, 前提是安装好Node.js与Git<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p>
<ul>
<li>如果npm安装hexo失败, 则很有可能是<strong><font color="red">权限</font></strong>问题, 或者npm与node的版本不兼容（很少出现）</li>
</ul>
<p>如果顺利安装完成, 理论上Hexo已经安装完成, 但在<strong>Ubuntu</strong>系统中, 比较<strong>坑</strong>的地方就是 <code>hexo</code> 命令居然放在了Node.js安装目录的 <code>bin</code> 文件夹下, 不能快捷地在终端把命令敲出来, 所以还是老规矩, 软链接走起<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ln -s /home/ybd/data/application/node-v7.4.0-linux-x64/bin/hexo /usr/local/bin/hexo</span><br></pre></td></tr></table></figure></p>
<p>到此, Hexo的安装已基本完成, 可以先试一下<strong>Hello World</strong>. </p>
<h1 id="解决Hexo命令fs-SyncWriteStream问题"><a href="#解决Hexo命令fs-SyncWriteStream问题" class="headerlink" title="解决Hexo命令fs.SyncWriteStream问题"></a>解决Hexo命令fs.SyncWriteStream问题</h1><blockquote>
<p><code>nodejs</code>版本更新到<code>8.0</code>之后, 运行<code>hexo</code>相关命令总会出现这么一行鬼东西:<br><code>(node:538) [DEP0061] DeprecationWarning: fs.SyncWriteStream is deprecated.</code><br>虽然不怎么影响大局, 当对于强迫症来说是一个<strong>噩梦</strong>！</p>
</blockquote>
<p><code>nodejs</code>从<code>8.0</code>开始已经弃用了<code>fs.SyncWriteStream</code>方法, 但是某些插件里面还是用到这个方法. 查看Hexo项目也有这个一条<a href="https://github.com/hexojs/hexo/issues/2598" rel="external nofollow noopener noreferrer" target="_blank">issue</a>, 在<code>hexo</code>项目中其中有一个<code>hexo-fs</code>的插件调用了这个方法, 所以需要更新<code>hexo-fs</code>插件, 更新方法如下:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-fs --save</span><br></pre></td></tr></table></figure></p>
<p>当然还有一些插件: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git@0.3.1 --save</span><br><span class="line">npm install hexo-renderer-ejs@0.3.1 --save</span><br><span class="line">npm install hexo-server@0.2.2 --save</span><br></pre></td></tr></table></figure>
<p><strong>But</strong>, 问题木有得到解决啊！<br><code>hexo</code>命令有个<code>-debug</code>参数, 运行命令的时候加上这个参数, 可以定位问题: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ybd@15ffab36a16c:~/blog$ hexo clean --debug</span><br><span class="line">03:01:16.464 DEBUG Hexo version: 3.3.9</span><br><span class="line">03:01:16.467 DEBUG Working directory: ~/blog/</span><br><span class="line">03:01:16.539 DEBUG Config loaded: ~/blog/_config.yml</span><br><span class="line">03:01:16.613 DEBUG Plugin loaded: hexo-admin-qiniu</span><br><span class="line">(node:538) [DEP0061] DeprecationWarning: fs.SyncWriteStream is deprecated.</span><br><span class="line">03:01:16.655 DEBUG Plugin loaded: hexo-algolia</span><br><span class="line">03:01:16.657 DEBUG Plugin loaded: hexo-baidu-url-submit</span><br><span class="line">03:01:16.668 DEBUG Plugin loaded: hexo-deployer-git</span><br><span class="line">03:01:16.672 DEBUG Plugin loaded: hexo-fs</span><br><span class="line">03:01:16.674 DEBUG Plugin loaded: hexo-generator-archive</span><br><span class="line">03:01:16.677 DEBUG Plugin loaded: hexo-generator-baidu-sitemap</span><br><span class="line">03:01:16.678 DEBUG Plugin loaded: hexo-generator-category</span><br><span class="line">03:01:16.680 DEBUG Plugin loaded: hexo-generator-feed</span><br><span class="line">03:01:16.681 DEBUG Plugin loaded: hexo-generator-index</span><br><span class="line">03:01:16.682 DEBUG Plugin loaded: hexo-generator-tag</span><br><span class="line">03:01:16.826 DEBUG Plugin loaded: hexo-inject</span><br><span class="line">03:01:16.828 DEBUG Plugin loaded: hexo-renderer-ejs</span><br><span class="line">03:01:16.829 DEBUG Plugin loaded: hexo-generator-sitemap</span><br><span class="line">03:01:16.834 DEBUG Plugin loaded: hexo-renderer-marked</span><br><span class="line">03:01:16.836 DEBUG Plugin loaded: hexo-renderer-stylus</span><br><span class="line">03:01:16.881 DEBUG Plugin loaded: hexo-server</span><br><span class="line">03:01:16.912 DEBUG Plugin loaded: hexo-wordcount</span><br><span class="line">03:01:16.943 DEBUG Plugin loaded: hexo-reference</span><br><span class="line">03:01:16.946 DEBUG Script loaded: themes/next/scripts/merge-configs.js</span><br><span class="line">03:01:16.947 DEBUG Script loaded: themes/next/scripts/tags/button.js</span><br><span class="line">03:01:16.947 DEBUG Script loaded: themes/next/scripts/tags/center-quote.js</span><br><span class="line">03:01:16.947 DEBUG Script loaded: themes/next/scripts/tags/full-image.js</span><br><span class="line">03:01:16.947 DEBUG Script loaded: themes/next/scripts/tags/note.js</span><br><span class="line">03:01:16.948 DEBUG Script loaded: themes/next/scripts/tags/group-pictures.js</span><br><span class="line">03:01:16.949 DEBUG [hexo-inject] firing inject_ready</span><br><span class="line">03:01:16.951 INFO  Deleted database.</span><br><span class="line">03:01:16.956 DEBUG Database saved</span><br></pre></td></tr></table></figure>
<p>发现问题在<code>hexo-admin-qiniu</code>这个插件=.=</p>
<p>貌似也没怎么用这个插件, 那么就删掉吧:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmp uninstall hexo-admin-qiniu --save</span><br></pre></td></tr></table></figure></p>
<p>那个报错终于消失啦～～～</p>
<h1 id="本地启动Hello-World与Hexo简单使用"><a href="#本地启动Hello-World与Hexo简单使用" class="headerlink" title="本地启动Hello World与Hexo简单使用"></a>本地启动Hello World与Hexo简单使用</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>随便建一个文件夹, 名字随便取, 博主取其名为blog, <code>cd</code> 到文件夹里, 先安装必要的文件, 执行以下命令:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init  # hexo会在目标文件夹建立网站所需要的所有文件</span><br><span class="line">npm install  # 安装依赖包</span><br></pre></td></tr></table></figure></p>
<h2 id="本地启动"><a href="#本地启动" class="headerlink" title="本地启动"></a>本地启动</h2><p>有了必要的各种配置文件之后就可以在本地预览效果了<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g # 等同于hexo generate, 生成静态文件</span><br><span class="line">hexo s # 等同于hexo server, 在本地服务器运行</span><br></pre></td></tr></table></figure></p>
<p><img src="https://cdn.yangbingdong.com/img/build-hexo/buildCmd.png" alt><br>之后打开浏览器并输入IP地址 <code>http://localhost:4000/</code> 查看, 效果如下<br><img src="https://cdn.yangbingdong.com/img/build-hexo/helloWorld.png" alt></p>
<h2 id="新建文章与页面"><a href="#新建文章与页面" class="headerlink" title="新建文章与页面"></a>新建文章与页面</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;title&quot;  # 生成新文章: \source\_posts\title.md</span><br><span class="line">hexo new page &quot;title&quot;  # 生成新的页面, 后面可在主题配置文件中配置页面</span><br></pre></td></tr></table></figure>
<ul>
<li>生成文章或页面的模板放在博客文件夹根目录下的 <code>scaffolds/</code> 文件夹里面, 文章对应的是 <code>post.md</code> , 页面对应的是<code>page.md</code>, 草稿的是<code>draft.md</code></li>
</ul>
<h2 id="编辑文章"><a href="#编辑文章" class="headerlink" title="编辑文章"></a>编辑文章</h2><p>打开新建的文章<code>\source\_posts\postName.md</code>, 其中<code>postName</code>是<code>hexo new &quot;title&quot;</code>中的<code>title</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: Start My Blog Trip — Power By Hexo  # 文章页面上的显示名称, 可以任意修改, 不会出现在URL中</span><br><span class="line">date: 2017-01-10 23:49:28  # 文章生成时间, 一般不改</span><br><span class="line">categories: diary  # 文章分类目录, 多个分类使用[a,b,c]这种格式</span><br><span class="line">tags: [Hexo,diary]  # 文章标签</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">#这里开始使用markdown格式输入你的正文. </span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt; </span><br><span class="line">#more标签以下的内容要点击“阅读全文”才能看见</span><br></pre></td></tr></table></figure></p>
<h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p><strong>插入图片有三种方式</strong></p>
<h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>在博客根目录的 <code>source</code> 文件夹下新建一个 <code>img</code> 文件夹专门存放图片, 在博文中引用的<strong>图片路径</strong>为 <code>/img/图片名.后缀</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](图片路径)</span><br></pre></td></tr></table></figure>
<h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说, Hexo也提供了更组织化的方式来管理资源, 将<strong>站点配置文件</strong>中的 <code>post_asset_folder</code> 选项设为 <code>true</code> 来打开文章资源文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure>
<p>然后再博文中通过相对路径引用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img 图片文件名 %&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h3><p>使用<em><a href="http://www.qiniu.com/" rel="external nofollow noopener noreferrer" target="_blank">七牛云储存</a></em>, 因为Github跟Coding项目容量有限, 而且Github的主机在国外, 访问速度较慢, 把图片放在国内的图床上是个更好的选择, 免费用户实名审核之后, 新建空间, 专门用来放置博客上引用的资源, 进入空间后点击「内容管理」, 再点击「上传」<br><img src="https://cdn.yangbingdong.com/uploadImg.png" alt></p>
<p>上传完成之后点击关闭回到管理页面, 选中刚上传的图片, 最右边的操作点击复制链接即可<br><img src="https://cdn.yangbingdong.com/img/build-hexo/copyUrl.png" alt><br>然后在博文中通过地址引用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](图片地址如: https://cdn.yangbingdong.com/img/build-hexo/copyUrl.png)</span><br></pre></td></tr></table></figure></p>
<h2 id="简单的命令"><a href="#简单的命令" class="headerlink" title="简单的命令"></a>简单的命令</h2><p>总结一下简单的使用命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init [folder] # 初始化一个网站. 如果没有设置 folder , Hexo 默认在目前的文件夹建立网站</span><br><span class="line">hexo new [layout] &lt;title&gt; # 新建一篇文章. 如果没有设置 layout 的话, 默认使用 _config.yml 中的 default_layout 参数代替. 如果标题包含空格的话, 请使用引号括起来</span><br><span class="line">hexo version # 查看版本</span><br><span class="line">hexo clean # 清除缓存文件 (db.json) 和已生成的静态文件 (public)</span><br><span class="line">hexo g # 等于hexo generate # 生成静态文件</span><br><span class="line">hexo s # 等于hexo server # 本地预览</span><br><span class="line">hexo d # 等于hexo deploy # 部署, 可与hexo g合并为 hexo d -g</span><br></pre></td></tr></table></figure></p>
<h1 id="安装主题（以NexT为例）"><a href="#安装主题（以NexT为例）" class="headerlink" title="安装主题（以NexT为例）"></a>安装主题（以NexT为例）</h1><p>更多主题请看<strong><em><a href="https://www.zhihu.com/question/24422335" rel="external nofollow noopener noreferrer" target="_blank">知乎专栏</a></em></strong><br><img src="https://cdn.yangbingdong.com/img/build-hexo/scheme.png" alt></p>
<h2 id="复制主题"><a href="#复制主题" class="headerlink" title="复制主题"></a>复制主题</h2><p>Hexo 安装主题的方式非常简单, 只需要将主题文件拷贝至站点目录的 <code>themes</code> 目录下, 然后修改下配置文件即可<br>在这我们使用git克隆最新版<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd your-hexo-site</span><br><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p>
<h2 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h2><p>打开<strong>站点配置文件</strong>, 找到 theme 字段, 并将其值更改为 next<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure></p>
<p>然后 <code>hexo s</code> 即可预览主题效果</p>
<h2 id="更换主题外观"><a href="#更换主题外观" class="headerlink" title="更换主题外观"></a>更换主题外观</h2><p>NexT有三个外观, 博主用的是 <code>Muse</code>, 直接更改<strong>主题配置文件</strong>的 <code>scheme</code> 参数即可, 如果显示的是繁体中文, 那么<strong>站点配置文件</strong>中的 <code>language: zh-CN</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br></pre></td></tr></table></figure></p>
<p>在次执行 <code>hexo clean</code> 和 <code>heox s</code> 可预览效果<br><strong>大部分的设定都能在<em><a href="http://theme-next.iissnan.com/getting-started.html" rel="external nofollow noopener noreferrer" target="_blank">NexT的官方文档</a></em> 里面找到, 如侧栏、头像、打赏、评论等等, 在此就不多讲了, 照着文档走就行了, 接下只是个性定制的问题</strong></p>
<h1 id="其他主题推荐"><a href="#其他主题推荐" class="headerlink" title="其他主题推荐"></a>其他主题推荐</h1><p><strong><em><a href="https://xaoxuu.com/wiki/material-x/" rel="external nofollow noopener noreferrer" target="_blank">Material-X</a></em></strong></p>
<h1 id="注册Github和Coding并分别创建Pages"><a href="#注册Github和Coding并分别创建Pages" class="headerlink" title="注册Github和Coding并分别创建Pages"></a>注册Github和Coding并分别创建Pages</h1><p>在本地运行没有问题的话, 那么可以部署到外网去, 在此之前, 先得有服务器让你的项目可以托管, 那么Github Page与Coding Page就是个很好的东西, 它们可以让我们访问<strong>静态文件</strong>, 而Hexo生成的恰恰是静态文件<br>具体请查看 <em><a href="https://coding.net/help/doc/pages/index.html" rel="external nofollow noopener noreferrer" target="_blank">Coding Page</a></em> 、 <em><a href="https://pages.github.com/" rel="external nofollow noopener noreferrer" target="_blank">Github Page</a></em></p>
<p>那为什么要注册两个网站呢？因为Github是国外的服务器, 访问速度比较慢, 而Coding是国内的, 速度相对来说比较快, 在后面<strong>DNS解析</strong>的时候可以把国内的解析到Coding, 国外的解析到Github, 完美</p>
<h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><h3 id="注册Github帐号"><a href="#注册Github帐号" class="headerlink" title="注册Github帐号"></a>注册Github帐号</h3><p>进入<em><a href="https://github.com/" rel="external nofollow noopener noreferrer" target="_blank">Github</a></em> 首页进行注册, 用户名、邮箱和密码之后都需要用到, 自己记好, 不知道怎么注册的童鞋去问问度娘</p>
<h3 id="创建Repository-Github-Pages"><a href="#创建Repository-Github-Pages" class="headerlink" title="创建Repository(Github Pages)"></a>创建Repository(Github Pages)</h3><p>Repository相当于一个仓库, 用来放置你的代码文件. 首先, 登陆进入<em><a href="https://github.com/" rel="external nofollow noopener noreferrer" target="_blank">Github</a></em>, 选择首页中的 <code>New repository</code> 按钮<br><img src="https://cdn.yangbingdong.com/img/build-hexo/newRepo.png" alt><br>创建时, 只需要填写Repository name即可, 可以顺便创建README文件, 就是红色那个钩, 当然这个名字的格式必须为<code>{user_name}.github.io</code>, 其中<code>{user_name}</code><strong>必须</strong>与你的用户名一样, 这是github pages的<strong>特殊命名规范</strong>, 如下图请忽视红色警告, 那是因为博主已经有了一个pages项目<br><img src="https://cdn.yangbingdong.com/img/build-hexo/createRepo.png" alt></p>
<h2 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h2><h3 id="注册Coding帐号"><a href="#注册Coding帐号" class="headerlink" title="注册Coding帐号"></a>注册Coding帐号</h3><p>国内的网站, 绝大部分都是中文的, 注册什么的就不说了,进入<em><a href="https://coding.net" rel="external nofollow noopener noreferrer" target="_blank">Coding</a></em> 滚键盘就是了= =</p>
<h3 id="创建项目-Coding-Pages"><a href="#创建项目-Coding-Pages" class="headerlink" title="创建项目(Coding Pages)"></a>创建项目(Coding Pages)</h3><p>Coding Pages请看 <em><a href="https://coding.net/help/doc/pages/index.html" rel="external nofollow noopener noreferrer" target="_blank">Coding Pages</a></em><br>注册之后进入主页, 点击项目, 点击<strong>+</strong>, 项目名为你的用户名<br><img src="https://cdn.yangbingdong.com/img/build-hexo/createCoding.png" alt><br>查看Pages 服务是否开启: 点击项目 -&gt; 代码 -&gt; Pages 服务, 若没有开启则点开启<br><img src="https://cdn.yangbingdong.com/img/build-hexo/codingPage.png" alt></p>
<h1 id="配置SSH与Git"><a href="#配置SSH与Git" class="headerlink" title="配置SSH与Git"></a>配置SSH与Git</h1><p>那么我们有了两个免费的服务器之后, 就要绑定个人电脑与它们联系, 那就是<strong>SSH</strong>与<strong>Git</strong><br>绑定之后我们每次部署项目就不用输入帐号和密码</p>
<h2 id="生成SSH-Key"><a href="#生成SSH-Key" class="headerlink" title="生成SSH Key"></a>生成SSH Key</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C your_email@youremail.com</span><br></pre></td></tr></table></figure>
<p>后面的 <a href="mailto:`your_email@youremail.com" rel="external nofollow noopener noreferrer" target="_blank">`your_email@youremail.com</a><code>改为你的邮箱, 之后会要求确认路径和输入密码, 我们这使用默认的一路回车就行. 成功的话会在~/下生成</code>.ssh<code>文件夹, 进去, 打开</code>id_rsa.pub`, 复制里面的key, 粗暴点就是 Ctrl+a 然后 Ctrl+c</p>
<h2 id="添加SSH-Key"><a href="#添加SSH-Key" class="headerlink" title="添加SSH Key"></a>添加SSH Key</h2><p>首先是Github, 登录Github, 右上角 头像 -&gt; <code>Settings</code> —&gt; <code>SSH nd GPG keys</code> —&gt; <code>New SSH key</code> . 把公钥粘贴到key中, 填好title并点击 <code>Add SSH key</code><br><img src="https://cdn.yangbingdong.com/img/build-hexo/githubSSH.png" alt></p>
<p>至于Coding, 登录进入主页, 点击 <code>账户</code> —&gt; <code>SSH公钥</code> —&gt; 输入key再点击 <code>添加</code><br><img src="https://cdn.yangbingdong.com/img/build-hexo/codingSSH.png" alt></p>
<h2 id="验证成功与否"><a href="#验证成功与否" class="headerlink" title="验证成功与否"></a>验证成功与否</h2><p>验证github<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></p>
<p>如果是第一次的会提示是否continue, 输入<strong><font color="red">yes</font></strong>就会看到: You’ve successfully authenticated, but GitHub does not provide shell access . 这就表示已成功连上github!之前博主就是因为没有输入<strong>yes</strong>, 导致几次失败, 粗心地一路回车= =<br>验证coding<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@git.coding.net</span><br></pre></td></tr></table></figure></p>
<p>同上, 按<strong>yes</strong><br>接下来我们要做的就是把本地仓库传到github上去, 在此之前还需要设置username和email, 因为github每次commit都会记录他们<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name your name</span><br><span class="line">git config --global user.email your_email@youremail.com</span><br></pre></td></tr></table></figure></p>
<p>关于git可参考:<br><em><a href="http://blog.csdn.net/v123411739/article/details/44071059/" rel="external nofollow noopener noreferrer" target="_blank">史上最全github使用方法: github入门到精通</a></em><br><em><a href="/2017/note-of-learning-git/">Git学习笔记</a></em></p>
<h1 id="部署到Github与Coding"><a href="#部署到Github与Coding" class="headerlink" title="部署到Github与Coding"></a>部署到Github与Coding</h1><p>在此之前, 先安装<strong>Git部署插件</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>
<p>打<strong>开站点配置文件</strong>, 拉到底部, 修改部署配置:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:</span><br><span class="line">    github: git@github.com:masteranthoneyd/masteranthoneyd.github.io.git,master</span><br><span class="line">    coding: git@git.coding.net:ookamiantd/ookamiantd.git,master</span><br></pre></td></tr></table></figure></p>
<p>注意冒号后面是网站对应的用户名, 接着就是<strong>/</strong>, 然后再是你的项目名加上 <code>.git,master</code><br>保存后终端执行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></p>
<p>稍等片刻, 可能会由于环境、网络等原因, 部署的时间会有偏差, 有的人快有的慢<br><img src="https://cdn.yangbingdong.com/img/build-hexo/deploy.png" alt><br>部署完成后可在浏览器输入 <code>yourName.github.io</code> 或者 <code>yourName.coding.me</code> 都可以浏览到一个属于自己的博客了 ～</p>
<h1 id="绑定自定义域名开启Https"><a href="#绑定自定义域名开启Https" class="headerlink" title="绑定自定义域名开启Https"></a>绑定自定义域名开启Https</h1><ol>
<li>首先你需要一个域名, 这个就不说了, 可以去万网</li>
<li>分别对Coding以及Github解析</li>
</ol>
<h2 id="Coding-1"><a href="#Coding-1" class="headerlink" title="Coding"></a>Coding</h2><p>在代码中找到Pages服务: </p>
<p><img src="https://cdn.yangbingdong.com/img/build-hexo/coding-encrypt.png" alt></p>
<p>要注意的是需要<strong>按照提示添加CHAME记录</strong>, 比如博主的是<code>ookamiantd.coding.me</code>, 检验成功后才可绑定成功. </p>
<h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><ul>
<li>跟Coding一样, 需要添加CHAME记录, 记录值为对应的Pages域名, 比如博主的是<code>masteranthoneyd.github.io</code></li>
<li>除此之外还需要在网站根目录添加一个CHAME文件, 内容为你的自定义域名</li>
</ul>
<p><img src="https://cdn.yangbingdong.com/img/build-hexo/github-encccrypt.png" alt></p>
<p>效果图: </p>
<p><img src="https://cdn.yangbingdong.com/img/build-hexo/green-lock.png" alt></p>
<p>至此, 境内外的小绿锁都开启了. </p>
<p>当然, 如果站内有部分资源不是https方式（比如图片）, 锁就绿不起来了. </p>
<h1 id="文件压缩"><a href="#文件压缩" class="headerlink" title="文件压缩"></a>文件压缩</h1><p>压缩方式有挺多的, 如果是用 <strong><em><a href="http://theme-next.iissnan.com/getting-started.html" rel="external nofollow noopener noreferrer" target="_blank">NexT</a></em></strong> 主题, 可以使用 <code>hexo-all-minifier</code>, 但速度不太理想.</p>
<p>这里可以使用 Go 语言编写的 <strong><em><a href="https://github.com/tdewolff/minify/tree/master/cmd/minify" rel="external nofollow noopener noreferrer" target="_blank">minify</a></em></strong>, 性能挺高效果也还可以.</p>
<p>Ubuntu 下的 Golang 安装可以参考<strong><em><a href="https://yangbingdong.com/2017/ubuntu-dev-environment-to-build/#Golang">这里</a></em></strong>.</p>
<p>下载:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go get github.com/tdewolff/minify/cmd/minify</span><br></pre></td></tr></table></figure>
<p>之后 <code>minify</code> 命令会放在 <code>$GOPATH/bin</code> 下面</p>
<p>命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage: minify [options] [input]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -a, --all                              Minify all files, including hidden files and files in hidden directories</span><br><span class="line">      --css-decimals int                 Number of decimals to preserve in numbers, -1 is all (default -1)</span><br><span class="line">  -h, --help                             Show usage</span><br><span class="line">      --html-keep-conditional-comments   Preserve all IE conditional comments</span><br><span class="line">      --html-keep-default-attrvals       Preserve default attribute values</span><br><span class="line">      --html-keep-document-tags          Preserve html, head and body tags</span><br><span class="line">      --html-keep-end-tags               Preserve all end tags</span><br><span class="line">      --html-keep-whitespace             Preserve whitespace characters but still collapse multiple into one</span><br><span class="line">  -l, --list                             List all accepted filetypes</span><br><span class="line">      --match string                     Filename pattern matching using regular expressions</span><br><span class="line">      --mime string                      Mimetype (eg. text/css), optional for input filenames, has precedence over -type</span><br><span class="line">  -o, --output string                    Output file or directory (must have trailing slash), leave blank to use stdout</span><br><span class="line">  -r, --recursive                        Recursively minify directories</span><br><span class="line">      --svg-decimals int                 Number of decimals to preserve in numbers, -1 is all (default -1)</span><br><span class="line">      --type string                      Filetype (eg. css), optional for input filenames</span><br><span class="line">      --url string                       URL of file to enable URL minification</span><br><span class="line">  -v, --verbose                          Verbose</span><br><span class="line">      --version                          Version</span><br><span class="line">  -w, --watch                            Watch files and minify upon changes</span><br><span class="line">      --xml-keep-whitespace              Preserve whitespace characters but still collapse multiple into one</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">  Files or directories, leave blank to use stdin</span><br></pre></td></tr></table></figure>
<p>使用 <code>hexo g</code> 生成 <code>public</code> 文件后:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$GOPATH/bin/minify -r -a -o public public</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后用拙劣的语言总结一下博主搭建Hexo博客的体会, 六个字: 简洁但, 不简单.<br>再六个字, 正如NexT官方说的: 精于心, 简于形<br>= =貌似这个博客也不怎么简洁, 有点花俏, 装X嫌疑<br>人生在于折腾…</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><strong><em><a href="http://opiece.me/2015/04/09/hexo-guide/" rel="external nofollow noopener noreferrer" target="_blank">使用Hexo搭建个人博客(基于hexo3.0) </a></em></strong><br><strong><em><a href="http://codepub.cn/2015/04/06/Github-Pages-personal-blog-from-Octopress-to-Hexo/#" rel="external nofollow noopener noreferrer" target="_blank">Github Pages个人博客, 从Octopress转向Hexo</a></em></strong><br><strong><em><a href="http://lovenight.github.io/2015/11/10/Hexo-3-1-1-%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/" rel="external nofollow noopener noreferrer" target="_blank">Hexo 3.1.1 静态博客搭建指南</a></em></strong><br><strong><em><a href="https://hexo.io/zh-cn/" rel="external nofollow noopener noreferrer" target="_blank">Hexo官方文档</a></em></strong><br><strong><em><a href="http://theme-next.iissnan.com/getting-started.html" rel="external nofollow noopener noreferrer" target="_blank">NexT官方文档</a></em></strong></p>
<p>大部分热门的静态页面生成器都可在下面这个网页找到:<br><strong><em><a href="https://www.staticgen.com/" rel="external nofollow noopener noreferrer" target="_blank">https://www.staticgen.com/</a></em></strong></p>
</blockquote>
]]></content><categories><category>Hexo</category></categories><tags><tag>Hexo</tag><tag>Node.js</tag><tag>Github</tag><tag>Coding</tag><tag>Git</tag></tags></entry><entry><title>设计模式之创建型(Creational)</title><url>/2018/design-pattern-creational/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/design-pattern/design-pattern-creation.jpg" alt></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><blockquote>
<p>创建型模式(<code>Creational Pattern</code>)对类的实例化过程进行了抽象, 能够将软件模块中对象的创建和对象的使用分离. 为了使软件的结构更加清晰, 外界对于这些对象只需要知道它们共同的接口, 而不清楚其具体的实现细节, 使整个系统的设计更加符合单一职责原则. </p>
<p>创建型模式在创建什么(What), 由谁创建(Who), 何时创建(When)等方面都为软件设计者提供了尽可能大的灵活性. 创建型模式隐藏了类的实例的创建细节, 通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的. </p>
</blockquote>
<a id="more"></a>
<h1 id="Singleton-Pattern"><a href="#Singleton-Pattern" class="headerlink" title="Singleton Pattern"></a>Singleton Pattern</h1><blockquote>
<p>单例模式可以说简单, 也可以说不简单. . . 使用不当就是小学生了</p>
</blockquote>
<p><img src="https://cdn.yangbingdong.com/img/design-pattern-creational/singleton.png" alt></p>
<p>这么说吧, 一个城市只能有一个市长, 每当需要他的时候他总会出现, 并且每次都是同一个人. 总不能一个城市有两个市长吧？<br>那么单例模式就是保证一个类只有一个实例化对象, 并提供一个全局访问入口.<br>本质就是控制实例的数量. </p>
<h2 id="小学生式单例模式"><a href="#小学生式单例模式" class="headerlink" title="小学生式单例模式"></a>小学生式单例模式</h2><p>现在来看一个最原始的单例:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangbingdong.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ybd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 17-10-16</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 小学生式单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> SimpleSingleton instance;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">SimpleSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SimpleSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			instance = <span class="keyword">new</span> SimpleSingleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果是刚入门的程序猿这可以得到101分（多一份骄傲）<br>但若是已出来工作的写出这样的代码. . . 那是找群殴. . . </p>
<p>单例模式中注重的是<strong>单</strong>字, 上面代码有可能造成多个实例, 来一段多线程测试代码:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangbingdong.singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.Collections.synchronizedSet;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.concurrent.Executors.newCachedThreadPool;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ybd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 17-10-18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ExecutorService executorService = newCachedThreadPool();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(NUM);</span><br><span class="line">			CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(NUM);</span><br><span class="line">			Set&lt;String&gt; set = synchronizedSet(<span class="keyword">new</span> HashSet&lt;String&gt;());</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; i++) &#123;</span><br><span class="line">				executorService.execute(() -&gt; &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="comment">/* 阻塞并等待所有线程加载完毕再同时run */</span></span><br><span class="line">						cyclicBarrier.await();</span><br><span class="line">						SimpleSingleton singleton = SimpleSingleton.getInstance();</span><br><span class="line">						set.add(singleton.toString());</span><br><span class="line">					&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">						<span class="comment">/* 计数器用于阻塞主线程 */</span></span><br><span class="line">						countDownLatch.countDown();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* 阻塞主线程, 等待所有线程跑完再执行下面 */</span></span><br><span class="line">			countDownLatch.await();</span><br><span class="line">			System.out.println(<span class="string">"------并发情况下我们取到的实例------"</span>);</span><br><span class="line">			set.forEach(System.out::println);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			executorService.shutdown();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行结果: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">------并发情况下我们取到的实例------</span><br><span class="line">com.yangbingdong.singleton.SimpleSingleton@<span class="number">3</span>bf59e6d</span><br><span class="line">com.yangbingdong.singleton.SimpleSingleton@<span class="number">4e593</span>af6</span><br><span class="line">com.yangbingdong.singleton.SimpleSingleton@<span class="number">7</span>eac491e</span><br></pre></td></tr></table></figure>
<p>很明显的产生了<strong>多个实例</strong>, 三个线程同时通过了<code>instance == null</code>条件. </p>
<h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangbingdong.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ybd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 17-10-19</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 饿汉式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EagerSingleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> EagerSingleton instance = <span class="keyword">new</span> EagerSingleton();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">EagerSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EagerSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<strong>类加载</strong>保证了线程安全, <strong>空间换时间</strong>. </p>
<h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangbingdong.singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ybd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 17-10-19</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 懒汉式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">/* 可重入所保证线程安全 */</span></span><br><span class="line">			reentrantLock.lock();</span><br><span class="line">			<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">				instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> instance;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			reentrantLock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一次获取实例都需要同步, 性能极差, 不可取. </p>
<h2 id="双重检查加锁"><a href="#双重检查加锁" class="headerlink" title="双重检查加锁"></a>双重检查加锁</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangbingdong.singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ybd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 17-10-19.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 双重检查加锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckSingleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 1.5后加上 volatile 关键字使得double check变得有意义</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DoubleCheckSingleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">DoubleCheckSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">				reentrantLock.lock();</span><br><span class="line">				<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">					instance = <span class="keyword">new</span> DoubleCheckSingleton();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> instance;</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(reentrantLock.isHeldByCurrentThread())&#123;</span><br><span class="line">				reentrantLock.unlock();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>double check模式需要在给<code>instance</code>加上<code>volatile</code>关键字, 作用是当线程中的变量<strong>发生变化</strong>时, 会<strong>强制写回主存</strong>, <strong>其他线程</strong>发现主存的变量地址发生改变, 也会<strong>强制读取主存</strong>的变量. </p>
<p>如果不加<code>volatile</code>关键字, 则有可能出现这样的情况: </p>
<p>线程A、B同时进入并通过了第一个<code>if (instance == null)</code>, 然后A获取了锁, A把<code>instance</code>实例化并释放锁, B获取锁, 但此时B自己的内存里的<code>instance</code>还是空（因为没有强制读取主存并不知道<code>instance</code>已经被实例化了）, 所以又实例化了一个对象. . . </p>
<h2 id="Lazy-initialization-holder-class模式"><a href="#Lazy-initialization-holder-class模式" class="headerlink" title="Lazy initialization holder class模式"></a>Lazy initialization holder class模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangbingdong.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ybd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 17-10-19.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Lazy initialization holder class模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassSingleton</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">InnerClassSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> InnerClassSingleton singleton = <span class="keyword">new</span> InnerClassSingleton();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InnerClassSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> SingletonHolder.singleton;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在JVM进行类加载的时候会保证数据是同步的, 我们采用内部类实现: 在内部类里面去创建对象实例.<br>只要应用中不使用内部类 JVM 就不会去加载这个单例类, 也就不会创建单例对象, 从而实现<strong>延迟加载</strong>和<strong>线程安全</strong>. </p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangbingdong.singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ybd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 17-10-19.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 枚举就是一个单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  SingletonEnum implements Supplier&lt;String&gt; &#123;</span><br><span class="line">	SINGLETON &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"I'm singleton"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举天生就是一个单例, 并且是<strong>线程安全</strong>的, <strong>自由序列化</strong>的, 这意味着反序列化之后它还是原来的那个单例. </p>
<p>而其他的单例模式需要定义<code>readResolve()</code>方法, 反序列化的时候会调用此方法: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Object readResolve() &#123;</span><br><span class="line">        return instance;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Java标准库中的单例模式"><a href="#Java标准库中的单例模式" class="headerlink" title="Java标准库中的单例模式"></a>Java标准库中的单例模式</h2><p><code>java.lang.Runtime#getRuntime()</code>就是一个典型的代表.<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runtime</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Runtime currentRuntime = <span class="keyword">new</span> Runtime();</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title">getRuntime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> currentRuntime;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Runtime</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个<code>currentRuntime</code>就是在初始化就已经加载了的. </p>
<h1 id="Simple-Factory-Pattern"><a href="#Simple-Factory-Pattern" class="headerlink" title="Simple Factory Pattern"></a>Simple Factory Pattern</h1><p><img src="https://cdn.yangbingdong.com/img/design-pattern-creational/simple-factory.png" alt></p>
<p>简单工厂模式又被称为<strong>静态工厂方法模式</strong>, 由<strong>一个</strong>工厂类根据传入的参数, 动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例. </p>
<p>将“类实例化的操作”与“使用对象的操作”分开, 让使用者不用知道具体参数就可以实例化出所需要的“产品”类, 从而避免了在客户端代码中显式指定, 实现了<strong>解耦</strong>；<br>即使用者可直接消费产品而不需要知道其生产的细节</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>定义人类接口:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 是个人都会讲话</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现类（男人和女人）:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">implements</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"I'm man! \n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">implements</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"I'm woman! \n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>工厂类:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangbingdong.simplefactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.yangbingdong.simplefactory.HumanFactory.HumanEnum.MAN;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.yangbingdong.simplefactory.HumanFactory.HumanEnum.WOMAN;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ybd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 17-10-19.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HumanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">HumanFactory</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 工厂获取实例静态方法</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> humanEnum 根据传进来的枚举获取对应的实例</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 返回的实例</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Human <span class="title">getInstance</span><span class="params">(HumanEnum humanEnum)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (MAN.equals(humanEnum)) &#123;</span><br><span class="line">			System.out.println(<span class="string">"生产了男人"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Man();</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span> (WOMAN.equals(humanEnum)) &#123;</span><br><span class="line">			System.out.println(<span class="string">"生产了女人"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Woman();</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"什么都没有生产"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">enum</span> HumanEnum &#123;</span><br><span class="line">		MAN,WOMAN</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在来测试一下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangbingdong.simplefactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.yangbingdong.simplefactory.HumanFactory.HumanEnum.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ybd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 17-10-19.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactoryTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		invokeTalkIfNotNull(MAN);</span><br><span class="line"></span><br><span class="line">		invokeTalkIfNotNull(WOMAN);</span><br><span class="line"></span><br><span class="line">		invokeTalkIfNotNull(<span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeTalkIfNotNull</span><span class="params">(HumanFactory.HumanEnum man)</span> </span>&#123;</span><br><span class="line">		Optional.ofNullable(HumanFactory.getInstance(man)).ifPresent(Human::talk);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">生产了男人</span><br><span class="line">I<span class="string">'m man! </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">生产了女人</span></span><br><span class="line"><span class="string">I'</span>m woman! </span><br><span class="line"></span><br><span class="line">什么都没有生产</span><br></pre></td></tr></table></figure></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>将创建实例的工作与使用实例的工作分开, 使用者不必关心类对象如何创建, 只需要传入工厂需要的参数即可, 但也有<strong>弊端</strong>: 工厂类集中了所有实例（产品）的创建逻辑, 一旦这个工厂不能正常工作, 整个系统都会受到影响, 违背“开放 - 关闭原则”, 一旦添加新产品就不得不修改工厂类的逻辑, 这样就会造成工厂逻辑过于复杂, 对于系统维护和扩展不够友好. </p>
<h2 id="Java标准库中的简单工厂模式"><a href="#Java标准库中的简单工厂模式" class="headerlink" title="Java标准库中的简单工厂模式"></a>Java标准库中的简单工厂模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.util.Calendar - getInstance()</span><br><span class="line">java.util.Calendar - getInstance(TimeZone zone)</span><br><span class="line">java.util.Calendar - getInstance(Locale aLocale)</span><br><span class="line">java.util.Calendar - getInstance(TimeZone zone, Locale aLocale)</span><br><span class="line">java.text.NumberFormat - getInstance()</span><br><span class="line">java.text.NumberFormat - getInstance(Locale inLocale)</span><br></pre></td></tr></table></figure>
<h1 id="Factory-Method"><a href="#Factory-Method" class="headerlink" title="Factory Method"></a>Factory Method</h1><p><img src="https://cdn.yangbingdong.com/img/design-pattern-creational/factory-method.png" alt></p>
<p>工厂方法模式, 又称工厂模式、多态工厂模式和虚拟构造器模式, 通过定义工厂父类负责定义创建对象的公共接口, 而子类则负责生成具体的对象. 就是一个工厂生产一个专一产品. </p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>人类接口与实现类与上面的一样</p>
<p>主要是把工厂抽象成了接口, 具体的人类由具体的工厂实现类创建. </p>
<p>工厂接口定义统一的创建人类的借口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HumanFactory</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 定义抽象工厂方法</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Human <span class="title">createHuman</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个工厂实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ManFactory</span> <span class="keyword">implements</span> <span class="title">HumanFactory</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Human <span class="title">createHuman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"生产了男人"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Man();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WomanFactory</span> <span class="keyword">implements</span> <span class="title">HumanFactory</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Human <span class="title">createHuman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"生产了女人"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Woman();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangbingdong.factorymethod;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ybd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 17-10-25.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryMethodTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      HumanFactory humanFactory = <span class="keyword">new</span> ManFactory();</span><br><span class="line">      humanFactory.createHuman().talk();</span><br><span class="line"></span><br><span class="line">      humanFactory = <span class="keyword">new</span> WomanFactory();</span><br><span class="line">      humanFactory.createHuman().talk();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">生产了男人</span><br><span class="line">I<span class="string">'m man! </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">生产了女人</span></span><br><span class="line"><span class="string">I'</span>m woman!</span><br></pre></td></tr></table></figure>
<h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><p>工厂方法模式把具体产品的创建推迟到工厂类的子类（具体工厂）中, 此时工厂类不再负责所有产品的创建, 而只是给出具体工厂必须实现的接口, 这样工厂方法模式在添加新产品的时候就不修改工厂类逻辑而是添加新的工厂子类, 符合<strong>开放封闭原则</strong>, 克服了简单工厂模式中缺点. 工厂模式可以说是简单工厂模式的进一步抽象和拓展, 在保留了简单工厂的封装优点的同时, 让扩展变得简单, 让继承变得可行, 增加了多态性的体现. </p>
<p>同时<strong>缺点</strong>也很明显, 多一个产品就多一个工厂, 开销变大了, 不适用与创建多种产品. </p>
<h2 id="Java中的工厂方法"><a href="#Java中的工厂方法" class="headerlink" title="Java中的工厂方法"></a>Java中的工厂方法</h2><p>查找了一下, 数据库链接驱动就是一个典型的工厂方法模式, Java定义链接数据库以及其他操作的接口, 数据库厂商必须实现这些接口, 比如Mysql、Oracle. </p>
<h1 id="Abstract-Factory"><a href="#Abstract-Factory" class="headerlink" title="Abstract Factory"></a>Abstract Factory</h1><p><img src="https://cdn.yangbingdong.com/img/design-pattern-creational/abstract-factory.png" alt></p>
<p>抽象工厂模式为创建一组对象提供了一种解决方案. 与工厂方法模式相比, 抽象工厂模式中的具体工厂不只是创建一种产品, 它负责创建一族产品. 比如AMD工厂负责生产AMD全家桶, Intel工厂负责生产Intel全家桶. </p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p>首先定义CPU接口以及实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CPU</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AMDCPU</span> <span class="keyword">implements</span> <span class="title">CPU</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntelCPU</span> <span class="keyword">implements</span> <span class="title">CPU</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主板接口以及实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MainBoard</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AMDMainBoard</span> <span class="keyword">implements</span> <span class="title">MainBoard</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntelMainBoard</span> <span class="keyword">implements</span> <span class="title">MainBoard</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义抽象工厂与实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">	<span class="function">CPU <span class="title">createCPU</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">MainBoard <span class="title">createMainBoard</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AMDFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> CPU <span class="title">createCPU</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"生产了AMD的CPU"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> AMDCPU();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> MainBoard <span class="title">createMainBoard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"生产了AMD的主板"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> AMDMainBoard();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntelFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> CPU <span class="title">createCPU</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"生产了Intel的CPU"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> IntelCPU();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> MainBoard <span class="title">createMainBoard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"生产了Intel的主板"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> IntelMainBoard();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		AbstractFactory abstractFactory = <span class="keyword">new</span> AMDFactory();</span><br><span class="line">		abstractFactory.createCPU();</span><br><span class="line">		abstractFactory.createMainBoard();</span><br><span class="line"></span><br><span class="line">		abstractFactory = <span class="keyword">new</span> IntelFactory();</span><br><span class="line">		abstractFactory.createCPU();</span><br><span class="line">		abstractFactory.createMainBoard();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">生产了AMD的CPU</span><br><span class="line">生产了AMD的主板</span><br><span class="line">生产了Intel的CPU</span><br><span class="line">生产了Intel的主板</span><br></pre></td></tr></table></figure>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>优点</strong>: </p>
<p><strong>分离接口和实现</strong>: 客户端使用抽象工厂来创建需要的对象, 而客户端根本就不知道具体的实现是谁, 客户端只是面向产品的接口编程而已. 也就是说, 客户端从具体的产品实现中解耦. </p>
<p><strong>使切换产品族变得容易</strong>: 因为一个具体的工厂实现代表的是一个产品族, 比如上面例子的从Intel系列到AMD系列只需要切换一下具体工厂. </p>
<p><strong>缺点</strong>: </p>
<p><strong>不太容易扩展新的产品</strong>: 如果需要给整个产品族添加一个新的产品, 那么就需要修改抽象工厂, 这样就会导致修改所有的工厂实现类</p>
<h2 id="Java标准类库中的抽象工厂模式"><a href="#Java标准类库中的抽象工厂模式" class="headerlink" title="Java标准类库中的抽象工厂模式"></a>Java标准类库中的抽象工厂模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;<span class="comment">//一种产品</span></span><br><span class="line"></span><br><span class="line">    Object[] toArray();</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; T[] toArray(T[] a);</span><br><span class="line"></span><br><span class="line">    <span class="function">ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span></span>;<span class="comment">//另外一种产品</span></span><br><span class="line"></span><br><span class="line">    <span class="function">ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Builder"><a href="#Builder" class="headerlink" title="Builder"></a>Builder</h1><p>将一个<strong>复杂</strong>对象的<strong>构建</strong>与它的表示<strong>分离</strong>, 使得同样的构建过程可以创建不同的表示. </p>
<p>使用<strong><em><a href="https://projectlombok.org" rel="external nofollow noopener noreferrer" target="_blank">Lombok</a></em></strong>中的<code>@Builder</code>可以很简单地实现Builder模式, <code>@Accessors(chain = true)</code>也可以实现类似的模式. </p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Summoner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> String innate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Summoner</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = builder.name;</span><br><span class="line">        <span class="keyword">this</span>.type = builder.type;</span><br><span class="line">        <span class="keyword">this</span>.innate = builder.innate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> String type;</span><br><span class="line">        <span class="keyword">private</span> String innate;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Builder <span class="title">name</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Builder <span class="title">type</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.type = type;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Builder <span class="title">innate</span><span class="params">(String innate)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.innate = innate;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Summoner <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Summoner(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuilderDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Summoner monkey = <span class="keyword">new</span> Summoner.Builder().name(<span class="string">"齐天大圣 - 孙悟空"</span>).type(<span class="string">"上单 - AD"</span>).innate(<span class="string">"基石天赋 - 战争雷霆"</span>).build();</span><br><span class="line">        System.out.println(monkey.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点: </p>
<ul>
<li>封装性很好: 使用建造者模式可以有效的封装变化, 在使用建造者模式的场景中, 一般产品类和建造者类是比较稳定的, 因此, 将主要的业务逻辑封装在导演类中对整体而言可以取得比较好的稳定性. </li>
<li>扩展性很好: 建造者模式很容易进行扩展. 如果有新的需求, 通过实现一个新的建造者类就可以完成, 基本上不用修改之前已经测试通过的代码, 因此也就不会对原有功能引入风险. </li>
<li>可以有效控制细节风险: 由于具体的建造者是独立的, 因此可以对建造者过程逐步细化, 而不对其他的模块产生任何影响. </li>
</ul>
<p>缺点: </p>
<ul>
<li>建造者模式所创建的产品一般具有较多的共同点, 其组成部分相似, 如果产品之间的差异性很大, 则不适合使用建造者模式, 因此其使用范围受到一定的限制. </li>
<li>如果产品的内部变化复杂, 可能会导致需要定义很多具体建造者类来实现这种变化, 导致系统变得很庞大. </li>
</ul>
<h2 id="Java类库中的建造者模式"><a href="#Java类库中的建造者模式" class="headerlink" title="Java类库中的建造者模式"></a>Java类库中的建造者模式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder strBuilder= <span class="keyword">new</span> StringBuilder();</span><br><span class="line">strBuilder.append(<span class="string">"one"</span>);</span><br><span class="line">strBuilder.append(<span class="string">"two"</span>);</span><br><span class="line">strBuilder.append(<span class="string">"three"</span>);</span><br><span class="line">String str= strBuilder.toString();</span><br></pre></td></tr></table></figure>
<h1 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h1><p>原型模式是<code>23GOF</code>模式的一种, 其特点就是通过<strong>克隆/拷贝</strong>的方式来, 节约创建成本和资源, 被拷贝`的对象模型就称之为<strong>原型</strong>. </p>
<p>JAVA中对原型模式提供了良好的支持, 我们只需要实现<code>Cloneable</code>接口即可, 它的目的就是将对象标记为可被复制. </p>
<p>一般的应用场景是, 对象的创建非常复杂, 可以使用原型模式快捷的创建对象；或在运行过程中不知道对象的具体类型, 可使用原型模式创建一个相同类型的对象, 或者在运行过程中动态的获取到一个对象的状态. </p>
<h2 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点: </p>
<ul>
<li>由于clone方法是由虚拟机直接复制内存块执行, 所以在速度上比使用new的方式创建对象要快. </li>
<li>可以基于原型, 快速的创建一个对象, 而无需知道创建的细节. </li>
<li>可以在运行时动态的获取对象的类型以及状态, 从而创建一个对象. </li>
</ul>
<p>缺点: </p>
<ul>
<li>需要实现 <code>Cloneable</code>接口, <code>clone</code>位于内部, 不易扩展, 容易违背<code>开闭原则</code>(程序扩展,不应该修改原有代码). </li>
<li>默认的 <code>clone</code> 只是浅克隆, 深度克隆需要额外编码比如: 统一实现<code>Cloneable</code>接口, 或者<strong>序列化</strong>方式. </li>
</ul>
<p>代码就不贴了, 实际开发中估计用不到, 但有一句话说得很对: 存在即合理. </p>
<p>原型模式一般伴随这工厂模式, 代码可参考: <strong><em><a href="https://github.com/masteranthoneyd/design-pattern-java/tree/master/creational/src/com/yangbingdong/prototype" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/masteranthoneyd/design-pattern-java/tree/master/creational/src/com/yangbingdong/prototype</a></em></strong></p>
]]></content><categories><category>Programming</category><category>Java</category><category>Design Pattern</category></categories><tags><tag>Java</tag><tag>Design Pattern</tag></tags></entry><entry><title>设计模式原则与UML类图</title><url>/2017/design-pattern-uml-and-six-principle/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/design-pattern-uml-and-six-principle/designpatterns.png" alt></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><blockquote>
<p><em><a href="https://www.google.co.jp/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwjyks2QifnWAhVJKo8KHegiD20QFggnMAA&amp;url=https%3A%2F%2Fzh.wikipedia.org%2Fzh-hans%2F%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F&amp;usg=AOvVaw0z1ZKodwif8lD1sp_vC9C_" rel="external nofollow noopener noreferrer" target="_blank">设计模式</a></em>, 总的来说, 就是前人踩过无数的坑总结出来的软件设计经验. 在学习设计模式之前, 有必要了解它的一些<strong>规则</strong>以及<strong>建模</strong>.<br><em><a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80" rel="external nofollow noopener noreferrer" target="_blank">UML</a></em>(Unified Modeling Language)又称<strong>统一建模语言</strong>或<strong>标准建模语言</strong>, 是始于1997年一个OMG(Object Management Group)标准, 它是一个支持模型化和软件系统开发的图形化语言, 为软件开发的所有阶段提供模型化和可视化支持, 包括由需求分析到规格, 到构造和配置. </p>
</blockquote>
<a id="more"></a>
<h1 id="Design-Pattern"><a href="#Design-Pattern" class="headerlink" title="Design Pattern"></a>Design Pattern</h1><p>在<a href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E9%AB%94%E5%B7%A5%E7%A8%8B" rel="external nofollow noopener noreferrer" target="_blank">软件工程</a>中, <strong>设计模式</strong>（design pattern）是对<a href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E4%BB%B6%E8%A8%AD%E8%A8%88" rel="external nofollow noopener noreferrer" target="_blank">软件设计</a>中普遍存在（反复出现）的各种问题, 所提出的解决方案. 这个术语是由<a href="https://zh.wikipedia.org/wiki/%E5%9F%83%E9%87%8C%E5%B8%8C%C2%B7%E4%BC%BD%E7%91%AA" rel="external nofollow noopener noreferrer" target="_blank">埃里希·伽玛</a>（Erich Gamma）等人在1990年代从<a href="https://zh.wikipedia.org/wiki/%E5%BB%BA%E7%AD%91%E8%AE%BE%E8%AE%A1" rel="external nofollow noopener noreferrer" target="_blank">建筑设计</a>领域引入到<a href="https://zh.wikipedia.org/wiki/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8" rel="external nofollow noopener noreferrer" target="_blank">计算机科学</a>的. </p>
<p>设计模式并不直接用来完成<a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BC%8F%E7%A2%BC" rel="external nofollow noopener noreferrer" target="_blank">代码</a>的编写, 而是描述在各种不同情况下, 要怎么解决问题的一种方案. <a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1" rel="external nofollow noopener noreferrer" target="_blank">面向对象</a>设计模式通常以<a href="https://zh.wikipedia.org/wiki/%E9%A1%9E%E5%88%A5" rel="external nofollow noopener noreferrer" target="_blank">类别</a>或<a href="https://zh.wikipedia.org/wiki/%E7%89%A9%E4%BB%B6_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8" rel="external nofollow noopener noreferrer" target="_blank">对象</a>)来描述其中的关系和相互作用, 但不涉及用来完成应用程序的特定类别或对象. 设计模式能使不稳定依赖于相对稳定、具体依赖于相对抽象, 避免会引起麻烦的紧耦合, 以增强软件设计面对并适应变化的能力.   ——来自维基百科</p>
<h2 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则."></a>六大原则.</h2><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>单一职责原则（<code>Single Responsibility Principle</code>,SRP）: 就一个类而言, 应该仅有一个引起它变化的原因. 即一个类应该<strong>只负责一个功能领域中的相应职责</strong>. </p>
<p>单一职责原则是实现<strong>高内聚</strong>、<strong>低耦合</strong>的指导方针, 它是最简单但又最难运用的原则, 需要设计人员发现类的<strong>不同职责</strong>并将其<strong>分离</strong>, 而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验. </p>
<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>开闭原则（<code>Open-Closed Principle</code>,OCP）: 是指软件实体（类、模块、函数等等）应该<strong>可以扩展</strong>, 但是<strong>不可修改</strong>. 即软件实体应该尽量在不修改原有代码的情况下进行扩展. </p>
<p>为了满足开闭原则, 需要对系统进行<strong>抽象化</strong>设计, <strong>抽象化是开闭原则的关键</strong>. </p>
<h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>里氏替换原则（<code>Liskov Substitution Principle</code>,LSP）: 所有引用父类的地方必须<strong>能够透明的使用子类的对象</strong>. 即子类型必须能够替换掉它们的父类型. </p>
<p>里氏替换原则告诉我们, 在软件中将一个基类对象替换成它的子类对象, 程序将不会产生任何错误和异常, <strong>反过来则不成立</strong>, 如果一个软件实体使用的是一个子类对象的话, 那么它不一定能够使用基类对象. 因此在程序中尽量使用基类类型来对对象进行定义, 而在运行时再确定其子类类型, 用子类对象来替换父类对象. 同时, 里氏代换原则是实现开闭原则的重要方式之一. </p>
<h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><p>依赖倒置原则（<code>Dependency Inversion Principle</code>,DIP）: 抽象不应该依赖细节, 细节应该依赖于抽象. 即应该<strong>针对接口编程</strong>, 而不是针对实现编程. </p>
<p>在大多数情况下, 我们会同时使用开闭原则、里氏代换原则和依赖倒转原则, 开闭原则是目标, 里氏代换原则是基础, 依赖倒转原则是手段. </p>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>接口隔离原则（<code>Interface Segregation Principle</code>,ISP）: 使用专门的接口, 而不使用单一的总接口, 即客户端不应该依赖那些它不需要的接口. </p>
<p>根据接口隔离原则, 当一个接口太大时, 我们需要将它分割成一些更细小的接口, 使用该接口的客户端仅需知道与之相关的方法即可. 每一个接口应该承担一种相对独立的角色, 不干不该干的事, 该干的事都要干. </p>
<h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p>迪米特法则（<code>Law of Demeter</code>,LoD）: 一个软件实体应当尽可能少地与其它实体发生相互作用. </p>
<p>迪米特法则又称为<strong>最少知识原则</strong>（<code>LeastKnowledge Principle</code>,LIP）.<br>如果一个系统符合迪米特法则, 那么当其中某一个模块发生修改时, 就会尽量少地影响其他模块, 扩展会相对容易, 这是对软件实体之间通信的限制, 迪米特法则要求限制软件实体之间通信的宽度和深度. 迪米特法则可降低系统的耦合度, 使类与类之间保持松散的耦合关系. </p>
<h2 id="三大类型"><a href="#三大类型" class="headerlink" title="三大类型"></a>三大类型</h2><h3 id="创建型-Creational"><a href="#创建型-Creational" class="headerlink" title="创建型(Creational)"></a><a href="/2018/design-pattern-creational">创建型(Creational)</a></h3><ul>
<li><p><strong>单例模式</strong>(<code>Singleton</code>): 保证一个类仅有一个实例, 并提供一个访问它的全局访问点. </p>
</li>
<li><p><strong>工厂方法</strong>(<code>Factory Method</code>): 定义一个创建对象的接口, 让其子类自己决定实例化哪一个工厂类, 工厂模式使其创建过程延迟到子类进行. </p>
</li>
<li><p><strong>抽象工厂</strong>(<code>Abstract Factory</code>): 提供一个创建一系列相关或相互依赖对象的接口, 而无需指定它们具体的类. </p>
</li>
<li><p><strong>建造者模式</strong>(<code>Builder</code>): 将一个复杂对象的构建与它的表示分离, 使得同样的构建过程可以创建不同的表示. </p>
</li>
<li><p><strong>原型模式</strong>(<code>Prototype</code>): 用原型实例指定创建对象的种类, 并且通过拷贝这些原型来创建新的对象. </p>
</li>
</ul>
<h3 id="结构型-Structural"><a href="#结构型-Structural" class="headerlink" title="结构型(Structural)"></a>结构型(Structural)</h3><ul>
<li><p><strong>适配器模式</strong>(<code>Adapter</code>): 适配器模式把一个类的接口变换成客户端所期待的另一种接口, 从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作. </p>
</li>
<li><p><strong>装饰模式</strong>(<code>Decrator</code>): 装饰模式是在不必改变原类文件和使用继承的情况下, 动态的扩展一个对象的功能. 它是通过创建一个包装对象, 也就是装饰来包裹真实的对象. </p>
</li>
<li><p><strong>代理模式(</strong><code>Proxy</code>): 为其他对象提供一种代理以控制对这个对象的访问 ；</p>
</li>
<li><p><strong>外观模式</strong>(<code>Facade</code>): 为子系统中的一组接口提供一个一致的界面, 外观模式定义了一个高层接口, 这个接口使得这一子系统更加容易使用. </p>
</li>
<li><p><strong>桥接模式</strong>(<code>Bridge</code>): 将抽象部分与实现部分分离, 使它们都可以独立的变化. </p>
</li>
<li><p><strong>组合模式</strong>(<code>Composite</code>): 允许你将对象组合成树形结构来表现”整体-部分”层次结构. 组合能让客户以一致的方法处理个别对象以及组合对象. </p>
</li>
<li><p><strong>享元模式</strong>(<code>Flyweight</code>): 运用共享技术有效地支持大量细粒度的对象. </p>
</li>
</ul>
<h3 id="行为型-Behavioral"><a href="#行为型-Behavioral" class="headerlink" title="行为型(Behavioral)"></a>行为型(Behavioral)</h3><ul>
<li><p><strong>策略模式</strong>(<code>Strategy</code>): 定义一组算法, 将每个算法都封装起来, 并且使他们之间可以互换. </p>
</li>
<li><p><strong>模板方法</strong>(<code>Template Method</code>): 一个操作中算法的框架, 而将一些步骤延迟到子类中, 使得子类可以不改变算法的结构即可重定义该算法中的某些特定步骤. </p>
</li>
<li><p><strong>观察者模式</strong>(<code>Observer</code>): 定义对象间的一种一对多的依赖关系, 当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并被自动更新. </p>
</li>
<li><p><strong>迭代器模式</strong>(<code>Iterator</code>): 提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示；</p>
</li>
<li><p><strong>职责链模式</strong>(<code>Chain of Responsibility</code>): 避免请求发送者与接收者耦合在一起, 让多个对象都有可能接收请求, 将这些对象连接成一条链, 并且沿着这条链传递请求, 直到有对象处理它为止. </p>
</li>
<li><p><strong>命令模式</strong>(<code>Command</code>): 将一个请求封装为一个对象, 从而使你可以用不同的请求对客户进行参数化, 对请求排队和记录请求日志, 以及支持可撤销的操作；</p>
</li>
<li><p><strong>备忘录模式</strong>(<code>Memento</code>): 在不破坏封装性的前提下, 捕获一个对象的内部状态, 并在该对象之外保存这个状态. 这样就可以将该对象恢复到原先保存的状态. </p>
</li>
<li><p><strong>状态模式</strong>(<code>State</code>): 允许对象在内部状态改变时改变它的行为, 对象看起来好像修改了它的类. </p>
</li>
<li><p><strong>访问者模式</strong>(<code>Visitor</code>): 表示一个作用于其对象结构中的各元素的操作, 它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作. </p>
</li>
<li><p><strong>中介者模式</strong>(<code>Mediator</code>): 用一个中介对象来封装一系列的对象交互, 中介者使各对象不需要显示地相互引用. 从而使其耦合松散, 而且可以独立地改变它们之间的交互. </p>
</li>
<li><p><strong>解释器模式</strong>(<code>Interpreter</code>): 给定一个语言, 定义它的文法表示, 并定义一个解释器, 这个解释器使用该标识来解释语言中的句子. </p>
</li>
</ul>
<h2 id="四大阶段"><a href="#四大阶段" class="headerlink" title="四大阶段"></a>四大阶段</h2><p>　　1、没学之前, 什么是设计模式, 老听别人说设计模式, 感觉好高大上, 那它到底是什么鬼. 这时我们设计的代码复用性很差、难以维护. </p>
<p>　　2、学了几个模式后, 感觉很简单, 于是到处想着要用自己学过的模式, 这样就会造成滥用. 最后感觉还不如不用. </p>
<p>　　3、学完全部模式时, 感觉很多模式太相似了, 无法很清晰的知道各模式之间的区别、联系, 这时一脸懵逼, 脑子一团乱麻. 在使用时, 分不清要使用那种模式. </p>
<p>　　4、模式已熟记于心, 已忘其形, 深知其意, 达到无剑胜有剑的境界, 恭喜你, 万剑归宗已练成！！！</p>
<h1 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h1><p>UML中有九种建模的图标, 即:<br><strong>用例图</strong>、<strong>类图</strong>、<strong>对象图</strong>、<strong>顺序图</strong>、<strong>协作图</strong>、<strong>状态图</strong>、<strong>活动图</strong>、<strong>组件图</strong>、<strong>配置图</strong></p>
<h2 id="Class-Diagram"><a href="#Class-Diagram" class="headerlink" title="Class Diagram"></a>Class Diagram</h2><p>在这主要学习一下<strong>类图 Class diagram </strong>.<br>通过显示出系统的类以及这些类之间的关系来表示系统. 类图是静态的———它们显示出什么可以产生影响但不会告诉你什么时候产生影响. </p>
<p>UML类的符号是一个被划分成三块的方框: 类名, 属性, 和操作. 抽象类的名字, 是斜体的. 类之间的关系是连接线. </p>
<h2 id="类与类的关系"><a href="#类与类的关系" class="headerlink" title="类与类的关系"></a>类与类的关系</h2><ul>
<li><strong>泛化</strong>: 可以简单的理解为继承关系；</li>
<li><strong>实现</strong>: 一般是接口和实现类之间的关系；</li>
<li><strong>关联</strong>: 一种拥有关系, 比如老师类中有学生列表, 那么老师类和学生类就是拥有关系；</li>
<li><strong>聚合</strong>: 整体与部分的关系, 但是整体和部分是可以分离而独立存在的, 如汽车类和轮胎类；</li>
<li><strong>组合</strong>: 整体与部分的关系, 但是二者不可分离, 分离了就没有意义了, 例如, 公司类和部门类, 没有公司就没有部门；</li>
<li><strong>依赖</strong>: 一种使用关系, 例如创建 A 类必须要有 B 类. </li>
</ul>
<p><img src="https://cdn.yangbingdong.com/img/design-pattern-uml-and-six-principle/uml-relation.png" alt></p>
<p>这是一个类图的记忆方法: <strong><em><a href="https://mp.weixin.qq.com/s/yfp5ejzm4kHW44kU876SYQ" rel="external nofollow noopener noreferrer" target="_blank">https://mp.weixin.qq.com/s/yfp5ejzm4kHW44kU876SYQ</a></em></strong></p>
<h2 id="StarUML"><a href="#StarUML" class="headerlink" title="StarUML"></a>StarUML</h2><p><em><a href="http://staruml.io/" rel="external nofollow noopener noreferrer" target="_blank">StarUML</a></em>…就是一个画UML的很炫酷的工具=.=</p>
<h3 id="显示interface"><a href="#显示interface" class="headerlink" title="显示interface"></a>显示interface</h3><p>在staruml中, interface默认是以一个圆圈显示的(尴尬了)…, 但好在可以设置成想要的样子. </p>
<ol>
<li>添加一个圆圈（interface）之后, 右键或选择菜单栏中的Format</li>
<li>选择Stereotype Display -&gt; Label, 这样矩形就显示出来了</li>
<li>同样是Format, 然后把Suppress Operations取消掉, 这样操作就可以显示出来了</li>
</ol>
<p><img src="https://cdn.yangbingdong.com/img/learning-uml-and-using-staruml/interface-01.png" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/learning-uml-and-using-staruml/interface-02.png" alt></p>
<h2 id="Gliffy"><a href="#Gliffy" class="headerlink" title="Gliffy"></a>Gliffy</h2><p><em><a href="https://www.gliffy.com/" rel="external nofollow noopener noreferrer" target="_blank">Gliffy</a></em>是一个<em><a href="https://go.gliffy.com/go/html5/launch" rel="external nofollow noopener noreferrer" target="_blank">在线</a></em>绘图工具, 支持Chrome插件, 非常强大. </p>
<p><img src="https://cdn.yangbingdong.com/img/design-pattern-uml-and-six-principle/gliffy.png" alt></p>
]]></content><categories><category>Programming</category><category>Java</category><category>Design Pattern</category></categories><tags><tag>Java</tag><tag>Design Pattern</tag></tags></entry><entry><title>分布式锁的几种实现方式</title><url>/2018/distribution-lock/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/distribute-lock/distribute-lock-banner.png" alt></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><blockquote>
<p>在现代互联网, 通常都是伴随着分布式、高并发等, 在某些业务中例如下订单扣减库存, 如果不对库存资源做临界处理, 在并发量大的时候会出现库存不准确的情况. 在单个服务的情况下可以通过Java自带的一些锁对临界资源进行处理, 例如<code>synchronized</code>、<code>Reentrantlock</code>, 甚至是通过无锁技术（比如<code>RangeBuffer</code>）都可以实现同一个JVM内的锁. But, 在<strong>能够弹性伸缩的分布式环境</strong>下, Java内置的锁显然不能够满足需求, 需要借助外部进程实现分布式锁. </p>
</blockquote>
<a id="more"></a>
<h1 id="几种实现方式"><a href="#几种实现方式" class="headerlink" title="几种实现方式"></a>几种实现方式</h1><p>分布式环境下, 数据一致性问题一直是一个比较重要的话题, 而又不同于单进程的情况. 分布式与单机情况下最大的不同在于其不是多线程而是多进程. 多线程由于可以共享堆内存, 因此可以简单的采取内存作为标记存储位置. 而进程之间甚至可能都不在同一台物理机上, 因此需要将标记存储在一个所有进程都能看到的地方. </p>
<p>常见的是秒杀场景, 订单服务部署了多个实例. 如秒杀商品有4个, 第一个用户购买3个, 第二个用户购买2个, 理想状态下第一个用户能购买成功, 第二个用户提示购买失败, 反之亦可. 而实际可能出现的情况是, 两个用户都得到库存为4, 第一个用户买到了3个, 更新库存之前, 第二个用户下了2个商品的订单, 更新库存为2, 导致出错. </p>
<p>在上面的场景中, 商品的库存是共享变量, 面对高并发情形, 需要保证对资源的访问互斥. 在单机环境中, Java中其实提供了很多并发处理相关的API, 但是这些API在分布式场景中就无能为力了. 也就是说单纯的Java API并不能提供分布式锁的能力. 分布式系统中, 由于分布式系统的分布性, 即多线程和多进程并且分布在不同机器中, <code>synchronized</code>和<code>lock</code>这两种锁将<strong>失去原有锁的效果</strong>, 需要我们自己实现分布式锁. </p>
<p>常见的锁方案如下: </p>
<ul>
<li>基于数据库实现分布式锁（基本用来玩的）</li>
<li>基于缓存, 实现分布式锁, 如<code>Redis</code>（业界常用方式）</li>
<li>基于<code>Zookeeper</code>实现分布式锁（性能低）</li>
</ul>
<p>下面我们简单介绍下这几种锁的实现. </p>
<h2 id="基于数据库"><a href="#基于数据库" class="headerlink" title="基于数据库"></a>基于数据库</h2><blockquote>
<p>虽然这种方式基本上<strong>不会被用于生产环境</strong></p>
</blockquote>
<p>基于数据库的锁实现也有两种方式, 一是基于数据库表, 另一种是基于数据库排他锁. </p>
<h3 id="基于数据库表的增删"><a href="#基于数据库表的增删" class="headerlink" title="基于数据库表的增删"></a>基于数据库表的增删</h3><p>基于数据库表增删是最简单的方式, 首先创建一张锁的表主要包含下列字段: 方法名, 时间戳等字段. </p>
<p>具体使用的方法, 当需要锁住某个方法时, 往该表中插入一条相关的记录. 这边需要注意, 方法名是有唯一性约束的, 如果有多个请求同时提交到数据库的话, 数据库会保证只有一个操作可以成功, 那么我们就可以认为操作成功的那个线程获得了该方法的锁, 可以执行方法体内容. </p>
<p>执行完毕, 需要<code>delete</code>该记录. </p>
<p>当然, 这边只是简单介绍一下. 对于上述方案可以进行优化, 如应用主从数据库, 数据之间双向同步. 一旦挂掉快速切换到备库上；做一个定时任务, 每隔一定时间把数据库中的超时数据清理一遍；使用<code>while</code>循环, 直到<code>insert</code>成功再返回成功, 虽然并不推荐这样做；还可以记录当前获得锁的机器的主机信息和线程信息, 那么下次再获取锁的时候先查询数据库, 如果当前机器的主机信息和线程信息在数据库可以查到的话, 直接把锁分配给他就可以了, 实现<strong>可重入锁</strong>. </p>
<blockquote>
<ul>
<li><strong>可重入锁</strong>: 可以再次进入方法A, 就是说在释放锁前此线程可以再次进入方法A（方法A递归）. </li>
<li><strong>不可重入锁（自旋锁）</strong>: 不可以再次进入方法A, 也就是说获得锁进入方法A是此线程在释放锁钱唯一的一次进入方法A. </li>
</ul>
</blockquote>
<h3 id="基于数据库排他锁"><a href="#基于数据库排他锁" class="headerlink" title="基于数据库排他锁"></a>基于数据库排他锁</h3><p>我们还可以通过数据库的排他锁来实现分布式锁. 基于MySql的InnoDB引擎, 可以使用以下方法来实现加锁操作: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void lock()&#123;</span><br><span class="line">    connection.setAutoCommit(false)</span><br><span class="line">    int count = 0;</span><br><span class="line">    while(count &lt; 4)&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            select * from lock where lock_name=xxx for update;</span><br><span class="line">            if(结果不为空)&#123;</span><br><span class="line">                //代表获取到锁</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        //为空或者抛异常的话都表示没有获取到锁</span><br><span class="line">        sleep(1000);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    throw new LockException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在查询语句后面增加<code>for update</code>, 数据库会在查询过程中给数据库表增加排他锁. 当某条记录被加上排他锁之后, 其他线程无法再在该行记录上增加排他锁. 其他没有获取到锁的就会阻塞在上述<code>select</code>语句上, 可能的结果有2种, 在超时之前获取到了锁, 在超时之前仍未获取到锁. </p>
<p>获得排它锁的线程即可获得分布式锁, 当获取到锁之后, 可以执行方法的业务逻辑, 执行完方法之后, 释放锁<code>connection.commit()</code>. </p>
<p>存在的问题主要是性能不高和sql超时的异常. </p>
<h3 id="基于数据库锁的优缺点"><a href="#基于数据库锁的优缺点" class="headerlink" title="基于数据库锁的优缺点"></a>基于数据库锁的优缺点</h3><p>上面两种方式都是依赖数据库的一张表, 一种是通过表中的记录的存在情况确定当前是否有锁存在, 另外一种是通过数据库的排他锁来实现分布式锁. </p>
<ul>
<li>优点是直接借助数据库, 简单容易理解. </li>
<li>缺点是操作数据库需要一定的开销, 性能问题需要考虑. </li>
</ul>
<h2 id="基于Zookeeper"><a href="#基于Zookeeper" class="headerlink" title="基于Zookeeper"></a>基于Zookeeper</h2><p>基于Zookeeper<strong>临时有序节点</strong>可以实现的分布式锁. 每个客户端对某个方法加锁时, 在Zookeeper上的与该方法对应的指定节点的目录下, 生成一个唯一的瞬时有序节点. 判断是否获取锁的方式很简单, 只需要判断有序节点中序号最小的一个. 当释放锁的时候, 只需将这个瞬时节点删除即可. 同时, 其可以避免服务宕机导致的锁无法释放, 而产生的死锁问题. </p>
<p>提供的第三方库有<a href="https://curator.apache.org/" rel="external nofollow noopener noreferrer" target="_blank">curator</a>, 具体使用读者可以自行去看一下. Curator提供的<code>InterProcessMutex</code>是分布式锁的实现. <code>acquire</code>方法获取锁, release方法释放锁. 另外, 锁释放、阻塞锁、可重入锁等问题都可以有有效解决. 讲下阻塞锁的实现, 客户端可以通过在ZK中创建顺序节点, 并且在节点上绑定监听器, 一旦节点有变化, Zookeeper会通知客户端, 客户端可以检查自己创建的节点是不是当前所有节点中序号最小的, 如果是就获取到锁, 便可以执行业务逻辑. </p>
<p>根据Zookeeper的这些特性, 我们来看看如何利用这些特性来实现分布式锁: </p>
<ul>
<li>创建一个锁目录<code>lock</code></li>
<li>线程A获取锁会在<code>lock</code>目录下, 创建临时顺序节点</li>
<li>获取锁目录下所有的子节点, 然后获取比自己小的兄弟节点, 如果不存在, 则说明当前线程顺序号最小, 获得锁</li>
<li>线程B创建临时节点并获取所有兄弟节点, 判断自己不是最小节点, <strong>设置监听(<code>watcher</code>)比自己次小的节点</strong></li>
<li>线程A处理完, 删除自己的节点, 线程B监听到变更事件, 判断自己是最小的节点, 获得锁</li>
</ul>
<p>最后, Zookeeper实现的分布式锁其实存在一个缺点, 那就是<strong>性能上可能并没有缓存服务那么高</strong>. 因为每次在创建锁和释放锁的过程中, 都要动态创建、销毁瞬时节点来实现锁功能. ZK中创建和删除节点只能通过Leader服务器来执行, 然后将数据同不到所有的Follower机器上. 并发问题, 可能存在网络抖动, 客户端和ZK集群的session连接断了, zk集群以为客户端挂了, 就会删除临时节点, 这时候其他客户端就可以获取到分布式锁了. </p>
<p>下面是简单例子: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CuratorTest &#123;</span><br><span class="line">	private static String address = &quot;127.0.0.1:2181&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);</span><br><span class="line">		CuratorFramework client = CuratorFrameworkFactory.newClient(address, retryPolicy);</span><br><span class="line">		client.start();</span><br><span class="line">		//创建分布式锁, 锁空间的根节点路径为/curator/lock</span><br><span class="line">		InterProcessMutex mutex = new InterProcessMutex(client, &quot;/curator/lock&quot;);</span><br><span class="line">		ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5);</span><br><span class="line">		CompletionService&lt;Object&gt; completionService = new ExecutorCompletionService&lt;&gt;(fixedThreadPool);</span><br><span class="line">		for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">			completionService.submit(() -&gt; &#123;</span><br><span class="line">				boolean flag = false;</span><br><span class="line">				try &#123;</span><br><span class="line">					//尝试获取锁, 最多等待5秒</span><br><span class="line">					flag = mutex.acquire(5, TimeUnit.SECONDS);</span><br><span class="line">					Thread currentThread = Thread.currentThread();</span><br><span class="line">					if (flag) &#123;</span><br><span class="line">						System.out.println(&quot;线程&quot; + currentThread.getId() + &quot;获取锁成功&quot;);</span><br><span class="line">					&#125; else &#123;</span><br><span class="line">						System.out.println(&quot;线程&quot; + currentThread.getId() + &quot;获取锁失败&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">					//模拟业务逻辑, 延时4秒</span><br><span class="line">					Thread.sleep(4000);</span><br><span class="line">				&#125; catch (Exception e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125; finally &#123;</span><br><span class="line">					if (flag) &#123;</span><br><span class="line">						try &#123;</span><br><span class="line">							mutex.release();</span><br><span class="line">						&#125; catch (Exception e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				return null;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		// 等待线程跑完</span><br><span class="line">		int count = 0;</span><br><span class="line">		while (count &lt; 5) &#123;</span><br><span class="line">			if (completionService.poll() != null) &#123;</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;=========  Complete!&quot;);</span><br><span class="line">		client.close();</span><br><span class="line">		fixedThreadPool.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基于缓存"><a href="#基于缓存" class="headerlink" title="基于缓存"></a>基于缓存</h2><p>相对于基于数据库实现分布式锁的方案来说, 基于缓存来实现在性能方面会表现的更好一点, 存取速度快很多. 而且很多缓存是可以集群部署的, 可以解决单点问题. 基于缓存的锁有好几种, 如Memcached、Redis, 下面主要讲解基于Redis的分布式实现. </p>
<h1 id="基于Redis的分布式锁实现"><a href="#基于Redis的分布式锁实现" class="headerlink" title="基于Redis的分布式锁实现"></a>基于Redis的分布式锁实现</h1><blockquote>
<p>首先, 为了确保分布式锁可用, 我们至少要确保锁的实现同时满足以下四个条件: </p>
<ol>
<li><strong>互斥性. </strong>在任意时刻, 只有一个客户端能持有锁. </li>
<li><strong>不会发生死锁. </strong>即使有一个客户端在持有锁的期间崩溃而没有主动解锁, 也能保证后续其他客户端能加锁. </li>
<li><strong>具有容错性. </strong>只要大部分的Redis节点正常运行, 客户端就可以加锁和解锁. </li>
<li><strong>解铃还须系铃人. </strong>加锁和解锁必须是同一个客户端, 客户端自己不能把别人加的锁给解了. </li>
</ol>
</blockquote>
<h2 id="基于Spring-Data-Redis"><a href="#基于Spring-Data-Redis" class="headerlink" title="基于Spring Data Redis"></a>基于Spring Data Redis</h2><p>下面是正确的实现姿势. （使用Spring Data Redis）</p>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="加锁姿势"><a href="#加锁姿势" class="headerlink" title="加锁姿势"></a>加锁姿势</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">private Boolean setNxEx(String key, String value) &#123;</span><br><span class="line">	return stringRedisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt; &#123;</span><br><span class="line">		StringRedisConnection stringRedisConn = (StringRedisConnection) connection;</span><br><span class="line">		return stringRedisConn.set(key, value, Expiration.from(1L, TimeUnit.MINUTES), SET_IF_ABSENT);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行上面的<code>setNxEx()</code>方法就只会导致两种结果: </p>
<ol>
<li>当前没有锁（key不存在）, 那么就进行加锁操作, 并对锁设置个有效期, 同时value表示加锁的客户端. </li>
<li>已有锁存在, 不做任何操作. </li>
</ol>
<p>网上有许多教程在加锁的步骤都<strong>不是原子性</strong>的, 有些是先加锁, 成功后再设置过期时间；有些将过期时间设置为value, 获取锁失败会判断value是否小于当前时间, 是则删除在设置新的值. 这些方法由于不是原子性, 在极端情况（比如多线程, 或者代码执行到某一行就宕机了等等）必然会导致锁失效或死锁等情况…</p>
<p>在上面<code>stringRedisConn.set(...)</code>方法中, 确保了上锁与设置过期时间的原子性. </p>
<h3 id="解锁姿势"><a href="#解锁姿势" class="headerlink" title="解锁姿势"></a>解锁姿势</h3><p>配置类: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public RedisScript&lt;Boolean&gt; releaseLockScript(DLockConfigProperty dLockConfigProperty) &#123;</span><br><span class="line">	DefaultRedisScript&lt;Boolean&gt; redisScript = new DefaultRedisScript&lt;&gt;();</span><br><span class="line">	String scriptLocation = &quot;scripts/release_lock.lua&quot;;</span><br><span class="line">	redisScript.setScriptSource(new ResourceScriptSource(new ClassPathResource(scriptLocation)));</span><br><span class="line">	redisScript.setResultType(Boolean.class);</span><br><span class="line">	return redisScript;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Lua脚本: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if redis.call(&apos;GET&apos;, KEYS[1]) == ARGV[1] then</span><br><span class="line">    return 1 == redis.call(&apos;DEL&apos;, KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return false</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>核心代码: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Resource</span><br><span class="line">private StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">@Resource</span><br><span class="line">private RedisScript&lt;Boolean&gt; script;</span><br><span class="line"></span><br><span class="line">public void release(String key, String value) &#123;</span><br><span class="line">    stringRedisTemplate.execute(script, singletonList(key), value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了配置, 解锁就一行代码搞定, 虽然简洁, 里面也是有很多学问滴. . . </p>
<p>为什么要用Lua脚本？确保原子性, 如何保证, 请看官网对<code>eval</code>命令的相关解释. 上面脚本表达的意思很简单, 对比传进来的value是否相等, 是则删除锁. value可使用UUID作为当前线程的标识符, <strong>只有但前线程才能解锁</strong>. </p>
<p>网上的错误姿势一般都是执行完业务代码直接删除锁, 这样会导致删除了其他线程获的锁. </p>
<p>上面实现的分布式锁是不支持可重入的, 需要额外的编码, 业界当然早就开源了类似的框架, 比如下面介绍的Redisson. </p>
<h2 id="基于Redisson"><a href="#基于Redisson" class="headerlink" title="基于Redisson"></a>基于Redisson</h2><blockquote>
<p><strong><em><a href="https://github.com/redisson/redisson" rel="external nofollow noopener noreferrer" target="_blank">Redisson</a></em></strong> 是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）. 它不仅提供了一系列的分布式的Java常用对象, 还提供了许多分布式服务. 其中包括(<code>BitSet</code>, <code>Set</code>, <code>Multimap</code>, <code>SortedSet</code>, <code>Map</code>, <code>List</code>, <code>Queue</code>, <code>BlockingQueue</code>, <code>Deque</code>, <code>BlockingDeque</code>, <code>Semaphore</code>, <code>Lock</code>, <code>AtomicLong</code>, <code>CountDownLatch</code>, <code>Publish / Subscribe</code>, <code>Bloom filter</code>, <code>Remote service</code>, <code>Spring cache</code>, <code>Executor service</code>, <code>Live Object service</code>, <code>Scheduler service</code>) Redisson提供了使用Redis的最简单和最便捷的方法. Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern）, 从而让使用者能够将精力更集中地放在处理业务逻辑上. </p>
</blockquote>
<p>Redisson提供的众多功能中有一项就是可重入锁（Reentrant Lock）, 具体用法可参考 <strong><em><a href="https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8" rel="external nofollow noopener noreferrer" target="_blank">文档</a></em></strong> </p>
<h3 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;netty-transport-native-epoll&lt;/artifactId&gt;</span><br><span class="line">    &lt;classifier&gt;linux-x86_64&lt;/classifier&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.7.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">@Slf4j</span><br><span class="line">public class RedissonDLock implements DLock &#123;</span><br><span class="line"></span><br><span class="line">	private final Long waitTime;</span><br><span class="line">	private final Long leaseTime;</span><br><span class="line">	private final TimeUnit timeUnit;</span><br><span class="line">	private final RedissonClient redisson;</span><br><span class="line"></span><br><span class="line">	public RedissonDLock(DLockConfigProperty property) &#123;</span><br><span class="line">		// 设置一些基本属性</span><br><span class="line">		this.waitTime = property.getWaitTime();</span><br><span class="line">		this.leaseTime = property.getLeaseTime();</span><br><span class="line">		this.timeUnit = property.getTimeUnit();</span><br><span class="line"></span><br><span class="line">		Config config = new Config();</span><br><span class="line">		SingleServerConfig singleServerConfig = config.useSingleServer();</span><br><span class="line">		singleServerConfig.setAddress(&quot;redis://&quot; + property.getHost() + &quot;:&quot; + property.getPort());</span><br><span class="line">		if (property.getPassword() != null &amp;&amp; property.getPassword().trim().length() &gt; 0) &#123;</span><br><span class="line">			singleServerConfig.setPassword(property.getPassword());</span><br><span class="line">		&#125;</span><br><span class="line">		try &#123;</span><br><span class="line">			Class.forName(&quot;io.netty.channel.epoll.Epoll&quot;);</span><br><span class="line">			// 如果是Linux系统可采用Epoll算法, 需要引入 netty-transport-native-epoll</span><br><span class="line">			if (Epoll.isAvailable()) &#123;</span><br><span class="line">				config.setTransportMode(TransportMode.EPOLL);</span><br><span class="line">				log.info(&quot;Starting with optional epoll library&quot;);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				log.info(&quot;Starting without optional epoll library&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		redisson = Redisson.create(config);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void tryLockAndAction(LockKeyGenerator lockKeyGenerator, AfterAcquireAction acquireAction) &#123;</span><br><span class="line">		tryLockAndAction(lockKeyGenerator, acquireAction, waitTime, leaseTime, timeUnit);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void tryLockAndAction(LockKeyGenerator lockKeyGenerator, AfterAcquireAction acquireAction, Long waitTime, Long leaseTime, TimeUnit timeUnit) &#123;</span><br><span class="line">		tryLockAndAction(lockKeyGenerator, acquireAction, DEFAULT_FAIL_ACQUIRE_ACTION, waitTime, leaseTime, timeUnit);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void tryLockAndAction(LockKeyGenerator lockKeyGenerator, AfterAcquireAction acquireAction, FailAcquireAction failAcquireAction, Long waitTime, Long leaseTime, TimeUnit timeUnit) &#123;</span><br><span class="line">		try (LockHolder holder = new LockHolder(redisson.getLock(lockKeyGenerator.getLockKey()))) &#123;</span><br><span class="line">			boolean acquire = holder.getLock().tryLock(waitTime, leaseTime, timeUnit);</span><br><span class="line">			if (acquire) &#123;</span><br><span class="line">				acquireAction.doAction();</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				failAcquireAction.doOnFail();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			throw new RuntimeException(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public &lt;T&gt; T tryLockAndExecuteCommand(LockKeyGenerator lockKeyGenerator, AfterAcquireCommand&lt;T&gt; command, FailAcquireAction failAcquireAction, Long waitTime, Long leaseTime, TimeUnit timeUnit) throws Throwable &#123;</span><br><span class="line">		try (LockHolder holder = new LockHolder(redisson.getLock(lockKeyGenerator.getLockKey()))) &#123;</span><br><span class="line">			boolean acquire = holder.getLock().tryLock(waitTime, leaseTime, timeUnit);</span><br><span class="line">			if (acquire) &#123;</span><br><span class="line">				return command.executeCommand();</span><br><span class="line">			&#125;</span><br><span class="line">			failAcquireAction.doOnFail();</span><br><span class="line">		&#125;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Data</span><br><span class="line">	@Accessors(chain = true)</span><br><span class="line">	@AllArgsConstructor</span><br><span class="line">	private static class LockHolder implements AutoCloseable &#123;</span><br><span class="line">		private RLock lock;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public void close() &#123;</span><br><span class="line">			lock.unlockAsync();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>一般服务器都是Linux系统, 引入<code>io.netty.channel.epoll.Epoll</code>采用Epoll方式有助于提升性能</li>
<li>使用<code>try-with-resource</code>方式提高代码优雅性…</li>
</ul>
<h3 id="注解驱动"><a href="#注解驱动" class="headerlink" title="注解驱动"></a>注解驱动</h3><p>Lock注解: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">public @interface Lock &#123;</span><br><span class="line"></span><br><span class="line">	String namespace() default &quot;default&quot;;</span><br><span class="line"></span><br><span class="line">	String key();</span><br><span class="line"></span><br><span class="line">	Class&lt;?&gt; prefixClass();</span><br><span class="line"></span><br><span class="line">	String separator() default &quot;:&quot;;</span><br><span class="line"></span><br><span class="line">	long waitTime() default 2L;</span><br><span class="line"></span><br><span class="line">	long leaseTime() default 5L;</span><br><span class="line"></span><br><span class="line">	TimeUnit timeUnit() default TimeUnit.SECONDS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>切面类: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">@Order(1)</span><br><span class="line">public class DLockAspect &#123;</span><br><span class="line">	@Resource</span><br><span class="line">	private DLock dLock;</span><br><span class="line"></span><br><span class="line">	@Value(&quot;$&#123;spring.application.name&#125;&quot;)</span><br><span class="line">	private String namespace;</span><br><span class="line"></span><br><span class="line">	@Around(value = &quot;@annotation(lock)&quot;)</span><br><span class="line">	public Object doAround(ProceedingJoinPoint pjp, Lock lock) throws Throwable &#123;</span><br><span class="line">		Method method = ((MethodSignature) pjp.getSignature()).getMethod();</span><br><span class="line"></span><br><span class="line">		Object[] args = pjp.getArgs();</span><br><span class="line">		String keySpEL = lock.key();</span><br><span class="line">		String resourceKey = parseSpel(method, args, keySpEL, String.class);</span><br><span class="line"></span><br><span class="line">		String finalKey = buildFinalKey(lock, resourceKey);</span><br><span class="line">		return dLock.tryLockAndExecuteCommand(() -&gt; finalKey, () -&gt; pjp.proceed(pjp.getArgs()), DEFAULT_FAIL_ACQUIRE_ACTION,</span><br><span class="line">				lock.waitTime(), lock.leaseTime(), lock.timeUnit());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private String buildFinalKey(Lock lock, String key) &#123;</span><br><span class="line">		return namespace == null || namespace.length() == 0 ? lock.namespace() : namespace +</span><br><span class="line">				lock.separator() +</span><br><span class="line">				lock.prefixClass().getSimpleName() +</span><br><span class="line">				lock.separator() +</span><br><span class="line">				key;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用了 <strong><em><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#expressions" rel="external nofollow noopener noreferrer" target="_blank">SpEL</a></em></strong> 解析锁的Key: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final class SpelHelper &#123;</span><br><span class="line">	private static final ExpressionParser PARSER = new SpelExpressionParser();</span><br><span class="line">	private static final LocalVariableTableParameterNameDiscoverer DISCOVERER = new LocalVariableTableParameterNameDiscoverer();</span><br><span class="line"></span><br><span class="line">	public static &lt;T&gt; T parseSpel(Method method, Object[] args, String spel, Class&lt;T&gt; clazz) &#123;</span><br><span class="line">		String[] parameterNames = DISCOVERER.getParameterNames(method);</span><br><span class="line">		requireNonNull(parameterNames);</span><br><span class="line">		EvaluationContext context = buildSpelContext(parameterNames, args);</span><br><span class="line">		Expression expression = PARSER.parseExpression(spel);</span><br><span class="line">		return expression.getValue(context, clazz);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static EvaluationContext buildSpelContext(String[] parameterNames, Object[] args) &#123;</span><br><span class="line">		EvaluationContext context = new StandardEvaluationContext();</span><br><span class="line">		for (int len = 0; len &lt; parameterNames.length; len++) &#123;</span><br><span class="line">			context.setVariable(parameterNames[len], args[len]);</span><br><span class="line">		&#125;</span><br><span class="line">		context.setVariable(&quot;args&quot;, args);</span><br><span class="line">		return context;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// @Lock(prefixClass = TestService.class, key = &quot;#id&quot;)</span><br><span class="line">@Lock(prefixClass = TestService.class, key = &quot;#args[0]&quot;)</span><br><span class="line">public void lockTest(Long id) &#123;</span><br><span class="line">	doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果锁被早被别的线程使用, 一般我们使用线程Sleep的方式等待锁释放, 但Redisson的底层采用了更优雅的等待策略, 通过发布订阅通知其他线程, 所以性能也会有所提高. </p>
</blockquote>
<h1 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h1><blockquote>
<p>Redisson官方文档: <strong><em><a href="https://github.com/redisson/redisson/wiki/%E7%9B%AE%E5%BD%95" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/redisson/redisson/wiki/%E7%9B%AE%E5%BD%95</a></em></strong></p>
<p>示例代码: <strong><em><a href="https://github.com/masteranthoneyd/starter/tree/master/dlock" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/masteranthoneyd/starter/tree/master/dlock</a></em></strong></p>
</blockquote>
]]></content><categories><category>Programming</category><category>Java</category></categories><tags><tag>Java</tag><tag>Redis</tag><tag>Zookeeper</tag><tag>Spring Boot</tag><tag>Spring</tag></tags></entry><entry><title>极致的追求, 高性能并发框架 Disruptor</title><url>/2018/disruptor-learning/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/disruptor-learning/Models.png" alt></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><blockquote>
<p><a href="https://lmax-exchange.github.io/disruptor/" rel="external nofollow noopener noreferrer" target="_blank">Disruptor</a>是英国外汇交易公司LMAX开发的一个高性能队列, 研发的初衷是<strong>解决内存队列的延迟问题</strong>（在性能测试中发现竟然与I/O操作处于同样的数量级）. 基于Disruptor开发的系统单线程能支撑<strong>每秒600万订单</strong>, 2010年在QCon演讲后, 获得了业界关注. 2011年, 企业应用软件专家Martin Fowler专门撰写长文介绍. 同年它还获得了Oracle官方的Duke大奖. 目前, 包括<strong>Apache Storm</strong>、<strong>Camel</strong>、<strong>Log4j2</strong>、<strong>Reactor</strong>在内的很多知名项目都应用或参考了Disruptor以获取高性能. </p>
<p>其实Disruptor与其说是一个框架, 不如说是一种设计思路, 这个设计思路对于存在“并发、缓冲区、生产者—消费者模型、事务处理”这些元素的程序来说, Disruptor提出了一种大幅提升性能（TPS）的方案. </p>
<p>听说小米也是用这个东东把亚马逊搞挂了: <a href="http://bbs.xiaomi.cn/t-13417592" rel="external nofollow noopener noreferrer" target="_blank">http://bbs.xiaomi.cn/t-13417592</a></p>
</blockquote>
<a id="more"></a>
<h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><p>在理解<a href="https://github.com/LMAX-Exchange/disruptor" rel="external nofollow noopener noreferrer" target="_blank">Disruptor</a>之前, 我们需要看一下它的核心概念</p>
<ul>
<li><a href="https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/RingBuffer.java" rel="external nofollow noopener noreferrer" target="_blank"><strong>Ring Buffer</strong></a>: Ring Buffer通常被认为是Disruptor的主要方面, 然而从3.0开始, Ring Buffer只负责存储和更新通过Disruptor的数据（Events）. 而且对于一些高级用例可以完全由用户替换. </li>
<li><a href="https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/Sequence.java" rel="external nofollow noopener noreferrer" target="_blank"><strong>Sequence</strong></a>: Disruptor使用序列作为一种手段来确定特定组件的位置. 每个消费者（EventProcessor）都像Disruptor本身一样维护一个Sequence. 大部分并发代码依赖于这些Sequence值的移动, 因此Sequence支持AtomicLong的许多当前特性. 事实上, 与2版本之间唯一真正的区别是序列包含额外的功能, 以防止序列和其他值之间的错误共享. </li>
<li><a href="https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/Sequencer.java" rel="external nofollow noopener noreferrer" target="_blank"><strong>Sequencer</strong></a>: Sequencer是Disruptor的真正核心. 这个接口的2个实现（单生产者, 多生产者）实现了所有的并发算法, 用于在生产者和消费者之间快速正确地传递数据. </li>
<li><a href="https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/SequenceBarrier.java" rel="external nofollow noopener noreferrer" target="_blank"><strong>Sequence Barrier</strong></a>: 序列屏障由序列发生器产生, 并包含对序列发生器的主要发布序列和任何相关消费者的序列的引用. 它包含确定消费者是否有任何事件可供处理的逻辑. </li>
<li><a href="https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/WaitStrategy.java" rel="external nofollow noopener noreferrer" target="_blank"><strong>Wait Strategy</strong></a>: 等待策略决定了消费者如何等待事件被生产者置于Disruptor中. </li>
<li><strong>Event</strong>: 从生产者到消费者的数据单位. 事件没有特定的代码表示, 因为它完全由用户定义. </li>
<li><a href="https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/EventProcessor.java" rel="external nofollow noopener noreferrer" target="_blank"><strong>EventProcessor</strong></a>: 用于处理来自Disruptor的事件的主事件循环, 并拥有消费者序列的所有权. 有一个称为BatchEventProcessor的表示, 它包含一个有效的事件循环实现, 并将回调到EventHandler接口的已用提供的实现上. </li>
<li><a href="https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/EventHandler.java" rel="external nofollow noopener noreferrer" target="_blank"><strong>EventHandler</strong></a>: 由用户实现的界面, 代表Disruptor的使用者. </li>
<li><strong>Producer</strong>: 这是调用Disruptor排入事件的用户代码. 这个概念在代码中也没有表示. </li>
</ul>
<h1 id="Java内置队列"><a href="#Java内置队列" class="headerlink" title="Java内置队列"></a>Java内置队列</h1><blockquote>
<p>以下内容来自美团点评技术团队博文</p>
</blockquote>
<p>Java的内置队列如下表所示. </p>
<table>
<thead>
<tr>
<th>队列</th>
<th>有界性</th>
<th>锁</th>
<th>数据结构</th>
</tr>
</thead>
<tbody>
<tr>
<td>ArrayBlockingQueue</td>
<td>bounded</td>
<td>加锁</td>
<td>arraylist</td>
</tr>
<tr>
<td>LinkedBlockingQueue</td>
<td>optionally-bounded</td>
<td>加锁</td>
<td>linkedlist</td>
</tr>
<tr>
<td>ConcurrentLinkedQueue</td>
<td>unbounded</td>
<td>无锁</td>
<td>linkedlist</td>
</tr>
<tr>
<td>LinkedTransferQueue</td>
<td>unbounded</td>
<td>无锁</td>
<td>linkedlist</td>
</tr>
<tr>
<td>PriorityBlockingQueue</td>
<td>unbounded</td>
<td>加锁</td>
<td>heap</td>
</tr>
<tr>
<td>DelayQueue</td>
<td>unbounded</td>
<td>加锁</td>
<td>heap</td>
</tr>
</tbody>
</table>
<p>队列的底层一般分成三种: 数组、链表和堆. 其中, 堆一般情况下是为了实现带有优先级特性的队列, 暂且不考虑. </p>
<p>我们就从数组和链表两种数据结构来看, 基于数组线程安全的队列, 比较典型的是<code>ArrayBlockingQueue</code>, 它主要通过加锁的方式来保证线程安全；基于链表的线程安全队列分成<code>LinkedBlockingQueue</code>和<code>ConcurrentLinkedQueue</code>两大类, 前者也通过锁的方式来实现线程安全, 而后者以及上面表格中的<code>LinkedTransferQueue</code>都是通过原子变量<code>compare and swap</code>（以下简称“<strong>CAS</strong>”）这种不加锁的方式来实现的. </p>
<p>通过不加锁的方式实现的队列都是<strong>无界</strong>的（无法保证队列的长度在确定的范围内）；而加锁的方式, 可以实现有界队列. 在稳定性要求特别高的系统中, 为了防止生产者速度过快, 导致内存溢出, 只能选择有界队列；同时, 为了减少Java的垃圾回收对系统性能的影响, 会尽量选择<code>array/heap</code>格式的数据结构. 这样筛选下来, 符合条件的队列就只有<code>ArrayBlockingQueue</code>. </p>
<h1 id="ArrayBlockingQueue的问题"><a href="#ArrayBlockingQueue的问题" class="headerlink" title="ArrayBlockingQueue的问题"></a>ArrayBlockingQueue的问题</h1><p><code>ArrayBlockingQueue</code>在实际使用过程中, 会因为加锁和伪共享等出现严重的性能问题, 我们下面来分析一下. </p>
<h2 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h2><p>现实编程过程中, 加锁通常会严重地影响性能. 线程会因为竞争不到锁而被挂起, 等锁被释放的时候, 线程又会被恢复, 这个过程中存在着很大的开销, 并且通常会有较长时间的中断, 因为当一个线程正在等待锁时, 它不能做任何其他事情. 如果一个线程在持有锁的情况下被延迟执行, 例如发生了缺页错误、调度延迟或者其它类似情况, 那么所有需要这个锁的线程都无法执行下去. 如果被阻塞线程的优先级较高, 而持有锁的线程优先级较低, 就会发生优先级反转. </p>
<p>Disruptor论文中讲述了一个实验: </p>
<ul>
<li>这个测试程序调用了一个函数, 该函数会对一个64位的计数器循环自增5亿次. </li>
<li>机器环境: 2.4G 6核</li>
<li>运算: 64位的计数器累加5亿次</li>
</ul>
<table>
<thead>
<tr>
<th>Method</th>
<th>Time (ms)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Single thread</td>
<td>300</td>
</tr>
<tr>
<td>Single thread with CAS</td>
<td>5,700</td>
</tr>
<tr>
<td>Single thread with lock</td>
<td>10,000</td>
</tr>
<tr>
<td>Single thread with volatile write</td>
<td>4,700</td>
</tr>
<tr>
<td>Two threads with CAS</td>
<td>30,000</td>
</tr>
<tr>
<td>Two threads with lock</td>
<td>224,000</td>
</tr>
</tbody>
</table>
<p>CAS操作比单线程无锁慢了1个数量级；有锁且多线程并发的情况下, 速度比单线程无锁慢3个数量级. 可见无锁速度最快. </p>
<p>单线程情况下, 不加锁的性能 &gt; CAS操作的性能 &gt; 加锁的性能. </p>
<p>在多线程情况下, 为了保证线程安全, 必须使用CAS或锁, 这种情况下, CAS的性能超过锁的性能, 前者大约是后者的8倍. </p>
<p><strong>综上可知, 加锁的性能是最差的. </strong></p>
<h3 id="关于锁和CAS"><a href="#关于锁和CAS" class="headerlink" title="关于锁和CAS"></a>关于锁和CAS</h3><p>保证线程安全一般分成两种方式: 锁和原子变量. </p>
<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p><img src="https://cdn.yangbingdong.com/img/disruptor-learning/lock.png" alt="img"></p>
<p>采取加锁的方式, 默认线程会冲突, 访问数据时, 先加上锁再访问, 访问之后再解锁. 通过锁界定一个临界区, 同时只有一个线程进入. 如上图所示, <code>Thread2</code>访问<code>Entry</code>的时候, 加了锁, <code>Thread1</code>就不能再执行访问<code>Entry</code>的代码, 从而保证线程安全. </p>
<p>下面是<code>ArrayBlockingQueue</code>通过加锁的方式实现的<code>offer</code>方法, 保证线程安全. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == items.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            insert(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h4><p>原子变量能够保证原子性的操作, 意思是某个任务在执行过程中, 要么全部成功, 要么全部失败回滚, 恢复到执行之前的初态, 不存在初态和成功之间的中间状态. 例如CAS操作, <strong>要么比较并交换成功</strong>, <strong>要么比较并交换失败</strong>. 由CPU保证原子性. </p>
<p>通过原子变量可以实现线程安全. 执行某个任务的时候, 先假定不会有冲突, 若不发生冲突, 则直接执行成功；当发生冲突的时候, 则执行失败, 回滚再重新操作, 直到不发生冲突. </p>
<p><img src="https://cdn.yangbingdong.com/img/disruptor-learning/cas.png" alt="img"></p>
<p>如图所示, <code>Thread1</code>和<code>Thread2</code>都要把<code>Entry</code>加1. 若不加锁, 也不使用CAS, 有可能<code>Thread1</code>取到了<code>myValue=1</code>, <code>Thread2</code>也取到了<code>myValue=1</code>, 然后相加, <code>Entry</code>中的<code>value</code>值为2. 这与预期不相符, 我们预期的是<code>Entry</code>的值经过两次相加后等于3. </p>
<p>CAS会先把<code>Entry</code>现在的<code>value</code>跟线程当初读出的值相比较, 若相同, 则赋值；若不相同, 则赋值执行失败. 一般会通过<code>while/for</code>循环来重新执行, <strong>直到赋值成功</strong>. </p>
<p>代码示例是<code>AtomicInteger</code>的<code>getAndAdd</code>方法. CAS是CPU的一个指令, 由CPU保证原子性. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically adds the given value to the current value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> delta the value to add</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = get();</span><br><span class="line">        <span class="keyword">int</span> next = current + delta;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically sets the value to the given updated value</span></span><br><span class="line"><span class="comment"> * if the current value &#123;<span class="doctag">@code</span> ==&#125; the expected value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if successful. False return indicates that</span></span><br><span class="line"><span class="comment"> * the actual value was not equal to the expected value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在高度竞争的情况下, 锁的性能将超过原子变量的性能, 但是更真实的竞争情况下, 原子变量的性能将超过锁的性能. 同时原子变量不会有死锁等活跃性问题. </p>
<h2 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h2><h3 id="什么是共享"><a href="#什么是共享" class="headerlink" title="什么是共享"></a>什么是共享</h3><p>下图是计算的基本结构. L1、L2、L3分别表示一级缓存、二级缓存、三级缓存, 越靠近CPU的缓存, 速度越快, 容量也越小. 所以L1缓存很小但很快, 并且紧靠着在使用它的CPU内核；L2大一些, 也慢一些, 并且仍然只能被一个单独的CPU核使用；L3更大、更慢, 并且被单个插槽上的所有CPU核共享；最后是主存, 由全部插槽上的所有CPU核共享. </p>
<p><img src="https://cdn.yangbingdong.com/img/disruptor-learning/computer.png" alt="img"></p>
<p>当CPU执行运算的时候, 它先去L1查找所需的数据、再去L2、然后是L3, 如果最后这些缓存中都没有, 所需的数据就要去主内存拿. 走得越远, 运算耗费的时间就越长. 所以如果你在做一些很频繁的事, 你要尽量确保数据在L1缓存中. </p>
<p>另外, 线程之间共享一份数据的时候, 需要一个线程把数据写回主存, 而另一个线程访问主存中相应的数据. </p>
<p>下面是从CPU访问不同层级数据的时间概念:</p>
<table>
<thead>
<tr>
<th>从CPU到</th>
<th>大约需要的CPU周期</th>
<th>大约需要的时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>主存</td>
<td></td>
<td>约60-80ns</td>
</tr>
<tr>
<td>QPI 总线传输(between sockets, not drawn)</td>
<td></td>
<td>约20ns</td>
</tr>
<tr>
<td>L3 cache</td>
<td>约40-45 cycles</td>
<td>约15ns</td>
</tr>
<tr>
<td>L2 cache</td>
<td>约10 cycles</td>
<td>约3ns</td>
</tr>
<tr>
<td>L1 cache</td>
<td>约3-4 cycles</td>
<td>约1ns</td>
</tr>
<tr>
<td>寄存器</td>
<td>1 cycle</td>
</tr>
</tbody>
</table>
<p>可见CPU读取主存中的数据会比从L1中读取慢了近2个数量级. </p>
<h3 id="缓存行"><a href="#缓存行" class="headerlink" title="缓存行"></a>缓存行</h3><p>Cache是由很多个cache line组成的. 每个cache line通常是64字节, 并且它有效地引用主内存中的一块儿地址. 一个Java的<code>long</code>类型变量是8字节, 因此在一个缓存行中可以存8个<code>long</code>类型的变量. </p>
<p>CPU每次从主存中拉取数据时, 会把相邻的数据也存入同一个cache line. </p>
<p>在访问一个long数组的时候, 如果数组中的一个值被加载到缓存中, 它会自动加载另外7个. 因此你能非常快的遍历这个数组. 事实上, 你可以非常快速的遍历在连续内存块中分配的任意数据结构. </p>
<p>下面的例子是测试利用cache line的特性和不利用cache line的特性的效果对比. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheLineEffect</span> </span>&#123;</span><br><span class="line">    <span class="comment">//考虑一般缓存行大小是64字节, 一个 long 类型占8字节</span></span><br><span class="line">    <span class="keyword">static</span>  <span class="keyword">long</span>[][] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">1024</span> * <span class="number">1024</span>][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span> * <span class="number">1024</span>; i++) &#123;</span><br><span class="line">            arr[i] = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">8</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">                arr[i][j] = <span class="number">0L</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">long</span> marked = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span> * <span class="number">1024</span>; i+=<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>; j&lt; <span class="number">8</span>;j++)&#123;</span><br><span class="line">                sum = arr[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Loop times:"</span> + (System.currentTimeMillis() - marked) + <span class="string">"ms"</span>);</span><br><span class="line"></span><br><span class="line">        marked = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i+=<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>; j&lt; <span class="number">1024</span> * <span class="number">1024</span>;j++)&#123;</span><br><span class="line">                sum = arr[j][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Loop times:"</span> + (System.currentTimeMillis() - marked) + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在2G Hz、2核、8G内存的运行环境中测试, 速度差一倍. </p>
<p>结果:<br>Loop times:30ms<br>Loop times:65ms</p>
<h3 id="什么是伪共享"><a href="#什么是伪共享" class="headerlink" title="什么是伪共享"></a>什么是伪共享</h3><p><code>ArrayBlockingQueue</code>有三个成员变量: </p>
<ul>
<li><code>takeIndex</code>: 需要被取走的元素下标</li>
<li><code>putIndex</code>: 可被元素插入的位置的下标</li>
<li><code>count</code>: 队列中元素的数量</li>
</ul>
<p>这三个变量很容易放到一个缓存行中, 但是之间修改没有太多的关联. 所以每次修改, 都会使之前缓存的数据失效, 从而不能完全达到共享的效果. </p>
<p><img src="https://cdn.yangbingdong.com/img/disruptor-learning/falseSharing.png" alt="img"></p>
<p>如上图所示, 当生产者线程<code>put</code>一个元素到<code>ArrayBlockingQueue</code>时, <code>putIndex</code>会修改, 从而导致消费者线程的缓存中的缓存行无效, 需要从主存中重新读取. </p>
<p>这种无法充分使用缓存行特性的现象, 称为伪共享. </p>
<p>对于伪共享, 一般的解决方案是, 增大数组元素的间隔使得由不同线程存取的元素位于不同的缓存行上, 以空间换时间. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FalseSharing</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> ITERATIONS = <span class="number">500L</span> * <span class="number">1000L</span> * <span class="number">100L</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> arrayIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> ValuePadding[] longs;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">FalseSharing</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> arrayIndex)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.arrayIndex = arrayIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                System.gc();</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">                runTest(i);</span><br><span class="line">                System.out.println(<span class="string">"Thread num "</span>+i+<span class="string">" duration = "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runTest</span><span class="params">(<span class="keyword">int</span> NUM_THREADS)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            Thread[] threads = <span class="keyword">new</span> Thread[NUM_THREADS];</span><br><span class="line">            longs = <span class="keyword">new</span> ValuePadding[NUM_THREADS];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; longs.length; i++) &#123;</span><br><span class="line">                longs[i] = <span class="keyword">new</span> ValuePadding();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">                threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> FalseSharing(i));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Thread t : threads) &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> i = ITERATIONS + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">0</span> != --i) &#123;</span><br><span class="line">                longs[arrayIndex].value = <span class="number">0L</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ValuePadding</span> </span>&#123;</span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">long</span> p9, p10, p11, p12, p13, p14;</span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">long</span> p15;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueNoPadding</span> </span>&#123;</span><br><span class="line">            <span class="comment">// protected long p1, p2, p3, p4, p5, p6, p7;</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">            <span class="comment">// protected long p9, p10, p11, p12, p13, p14, p15;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在2G Hz, 2核, 8G内存, jdk 1.7.0_45 的运行环境下, 使用了共享机制比没有使用共享机制, 速度快了4倍左右. </p>
<p>结果:<br>Thread num 1 duration = 447<br>Thread num 2 duration = 463<br>Thread num 3 duration = 454<br>Thread num 4 duration = 464<br>Thread num 5 duration = 561<br>Thread num 6 duration = 606<br>Thread num 7 duration = 684<br>Thread num 8 duration = 870<br>Thread num 9 duration = 823</p>
<p>把代码中ValuePadding都替换为ValueNoPadding后的结果:<br>Thread num 1 duration = 446<br>Thread num 2 duration = 2549<br>Thread num 3 duration = 2898<br>Thread num 4 duration = 3931<br>Thread num 5 duration = 4716<br>Thread num 6 duration = 5424<br>Thread num 7 duration = 4868<br>Thread num 8 duration = 4595<br>Thread num 9 duration = 4540</p>
<p>备注: 在jdk1.8中, 有专门的注解<code>@Contended</code>来避免伪共享, 更优雅地解决问题. </p>
<h1 id="Disruptor的设计方案"><a href="#Disruptor的设计方案" class="headerlink" title="Disruptor的设计方案"></a>Disruptor的设计方案</h1><p>Disruptor通过以下设计来解决队列速度慢的问题: </p>
<ul>
<li>环形数组结构</li>
</ul>
<p>为了避免垃圾回收, 采用数组而非链表. 同时, 数组对处理器的缓存机制更加友好. </p>
<ul>
<li>元素位置定位</li>
</ul>
<p>数组长度<code>2^n</code>, 通过位运算, 加快定位的速度. 下标采取递增的形式. 不用担心<code>index</code>溢出的问题. <code>index</code>是<code>long</code>类型, 即使100万QPS的处理速度, 也需要30万年才能用完. </p>
<ul>
<li>无锁设计</li>
</ul>
<p>每个生产者或者消费者线程, 会先<strong>申请</strong>可以操作的元素在数组中的位置, 申请到之后, 直接在该位置写入或者读取数据. </p>
<p>下面忽略数组的环形结构, 介绍一下如何实现无锁设计. 整个过程通过原子变量CAS, 保证操作的线程安全. </p>
<h2 id="一个生产者"><a href="#一个生产者" class="headerlink" title="一个生产者"></a>一个生产者</h2><h3 id="写数据"><a href="#写数据" class="headerlink" title="写数据"></a>写数据</h3><p>生产者单线程写数据的流程比较简单: </p>
<ol>
<li>申请写入m个元素；</li>
<li>若是有m个元素可以写入, 则返回<strong>最大的序列号</strong>. 这儿主要判断是否会覆盖未读的元素；</li>
<li>若是返回的正确, 则生产者开始写入元素. </li>
</ol>
<p><img src="https://cdn.yangbingdong.com/img/disruptor-learning/singleWriter.png" alt="img"><br>图5 单个生产者生产过程示意图</p>
<h2 id="多个生产者"><a href="#多个生产者" class="headerlink" title="多个生产者"></a>多个生产者</h2><p>多个生产者的情况下, 会遇到“如何防止多个线程重复写同一个元素”的问题. Disruptor的解决方法是, <strong>每个线程获取不同的一段数组空间进行操作</strong>. 这个通过CAS很容易达到. 只需要在分配元素的时候, 通过CAS判断一下这段空间是否已经分配出去即可. </p>
<p>但是会遇到一个<strong>新问题</strong>: 如何防止读取的时候, 读到还未写的元素. Disruptor在多个生产者的情况下, 引入了一个与<code>Ring Buffer</code>大小相同的<code>buffer</code>: <code>available Buffer</code>. 当某个位置写入成功的时候, 便把<code>availble Buffer</code>相应的位置置位, 标记为写入成功. 读取的时候, 会遍历<code>available Buffer</code>, 来判断元素是否已经就绪. </p>
<p>下面分读数据和写数据两种情况介绍. </p>
<h3 id="读数据"><a href="#读数据" class="headerlink" title="读数据"></a>读数据</h3><p>生产者多线程写入的情况会复杂很多: </p>
<ol>
<li>申请读取到序号n；</li>
<li>若<code>writer cursor</code> &gt;= n, 这时仍然无法确定连续可读的最大下标. 从<code>reader cursor</code>开始读取<code>available Buffer</code>, 一直查到第一个不可用的元素, 然后返回最大连续可读元素的位置；</li>
<li>消费者读取元素. </li>
</ol>
<p>如下图所示, 读线程读到下标为2的元素, 三个线程<code>Writer1</code>/<code>Writer2</code>/<code>Writer3</code>正在向<code>RingBuffer</code>相应位置写数据, 写线程被分配到的最大元素下标是11. </p>
<p>读线程申请读取到下标从3到11的元素, 判断<code>writer cursor&gt;=11</code>. 然后开始读取<code>availableBuffer</code>, 从3开始, 往后读取, 发现下标为7的元素没有生产成功, 于是<code>WaitFor(11)</code>返回6. </p>
<p>然后, 消费者读取下标从3到6共计4个元素. </p>
<p><img src="https://cdn.yangbingdong.com/img/disruptor-learning/multWriterReader.png" alt="img"></p>
<h3 id="写数据-1"><a href="#写数据-1" class="headerlink" title="写数据"></a>写数据</h3><p>多个生产者写入的时候: </p>
<ol>
<li>申请写入m个元素；</li>
<li>若是有m个元素可以写入, 则返回最大的序列号. 每个生产者会被分配一段独享的空间；</li>
<li>生产者写入元素, 写入元素的同时设置<code>available Buffer</code>里面相应的位置, 以标记自己哪些位置是已经写入成功的. </li>
</ol>
<p>如下图所示, <code>Writer1</code>和<code>Writer2</code>两个线程写入数组, 都申请可写的数组空间. <code>Writer1</code>被分配了下标3到下表5的空间, <code>Writer2</code>被分配了下标6到下标9的空间. </p>
<p><code>Writer1</code>写入下标3位置的元素, 同时把<code>available Buffer</code>相应位置置位, 标记已经写入成功, 往后移一位, 开始写下标4位置的元素. <code>Writer2</code>同样的方式. 最终都写入完成. </p>
<p><img src="https://cdn.yangbingdong.com/img/disruptor-learning/multWriterWrite.png" alt="img"></p>
<p>防止不同生产者对同一段空间写入的代码, 如下所示: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">tryNext</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="keyword">throws</span> InsufficientCapacityException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"n must be &gt; 0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> current;</span><br><span class="line">    <span class="keyword">long</span> next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        current = cursor.get();</span><br><span class="line">        next = current + n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!hasAvailableCapacity(gatingSequences, n, current))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> InsufficientCapacityException.INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!cursor.compareAndSet(current, next));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>do</code>/<code>while</code>循环的条件<code>cursor.compareAndSet(current, next)</code>, 来判断每次申请的空间是否已经被其他生产者占据. 假如已经被占据, 该函数会返回失败, While循环重新执行, 申请写入空间. </p>
<p>消费者的流程与生产者非常类似, 这儿就不多描述了. Disruptor通过精巧的无锁设计实现了在高并发情形下的高性能. </p>
<h1 id="等待策略"><a href="#等待策略" class="headerlink" title="等待策略"></a>等待策略</h1><h2 id="生产者的等待策略"><a href="#生产者的等待策略" class="headerlink" title="生产者的等待策略"></a>生产者的等待策略</h2><p>暂时只有休眠1ns. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LockSupport.parkNanos(1);</span><br></pre></td></tr></table></figure>
<h2 id="消费者的等待策略"><a href="#消费者的等待策略" class="headerlink" title="消费者的等待策略"></a>消费者的等待策略</h2><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>BlockingWaitStrategy</code></td>
<td>默认等待策略. 和<code>BlockingQueue</code>的实现很类似, 通过使用锁和条件（<code>Condition</code>）进行线程阻塞的方式, 等待生产者唤醒(线程同步和唤醒). 此策略对于线程切换来说, 最节约CPU资源, 但在高并发场景下性能有限</td>
<td>CPU资源紧缺, 吞吐量和延迟并不重要的场景</td>
</tr>
<tr>
<td><code>BusySpinWaitStrategy</code></td>
<td>死循环策略. 消费者线程会尽最大可能监控缓冲区的变化, 会占用所有CPU资源,线程一直自旋等待, 比较耗CPU</td>
<td>通过不断重试, 减少切换线程导致的系统调用, 而降低延迟. 推荐在线程绑定到固定的CPU的场景下使用</td>
</tr>
<tr>
<td><code>LiteBlockingWaitStrategy</code></td>
<td>通过线程阻塞的方式, 等待生产者唤醒, 比<code>BlockingWaitStrategy</code>要轻, 某些情况下可以减少阻塞的次数</td>
<td></td>
</tr>
<tr>
<td><code>PhasedBackoffWaitStrategy</code></td>
<td>根据指定的时间段参数和指定的等待策略决定采用哪种等待策略</td>
<td>CPU资源紧缺, 吞吐量和延迟并不重要的场景</td>
</tr>
<tr>
<td><code>SleepingWaitStrategy</code></td>
<td>CPU友好型策略. 会在循环中不断等待数据. 可通过参数设置,首先进行自旋等待, 若不成功, 则使用<code>Thread.yield()</code>让出CPU, 并使用<code>LockSupport.parkNanos(1)</code>进行线程睡眠, 通过线程调度器重新调度；或一直自旋等待, 所以, 此策略数据处理数据可能会有较高的延迟, 适合用于对延迟不敏感的场景, 优点是对生产者线程影响小, 典型应用场景是异步日志</td>
<td>性能和CPU资源之间有很好的折中. 延迟不均匀</td>
</tr>
<tr>
<td><code>TimeoutBlockingWaitStrategy</code></td>
<td>通过参数设置阻塞时间, 如果超时则抛出异常</td>
<td>CPU资源紧缺, 吞吐量和延迟并不重要的场景</td>
</tr>
<tr>
<td><code>YieldingWaitStrategy</code></td>
<td>低延时策略. 消费者线程会不断循环监控<code>RingBuffer</code>的变化, 在循环内部使用<code>Thread.yield()</code>让出CPU给其他线程, 通过线程调度器重新调度</td>
<td>性能和CPU资源之间有很好的折中. 延迟比较均匀</td>
</tr>
</tbody>
</table>
<h1 id="核心对象"><a href="#核心对象" class="headerlink" title="核心对象"></a>核心对象</h1><ol>
<li><code>RingBuffer</code>: 环形的一个数据结构, 对象初始化时, 会使用事件<code>Event</code>进行填充. <code>Buffer</code>的大小<strong>必须是2的幂次方</strong>, 方便移位操作. </li>
<li><code>Event</code>: 无指定具体接口, 用户自己实现, 可以携带任何业务数据. </li>
<li><code>EventFactory</code>: 产生事件<code>Event</code>的工厂, 由用户自己实现. </li>
<li><code>EventTranslator</code>: 事件发布的回调接口, 由用户实现, 负责将业务参数设置到事件中. </li>
<li><code>Sequencer</code>: 序列产生器, 也是协调生产者和消费者及实现高并发的核心. 有<code>MultiProducerSequencer</code> 和 <code>SingleProducerSequencer</code>两个实现类. </li>
<li><code>SequenceBarrier</code>: 拥有<code>RingBuffer</code>的发布事件<code>Sequence</code>引用和消费者依赖的<code>Sequence</code>引用. 决定消费者消费可消费的<code>Sequence</code>. </li>
<li><code>EventHandler</code>: 事件的处理者, 由用户自己实现. </li>
<li><code>EventProcessor</code>: 事件的处理器, 单独在一个线程中运行. </li>
<li><code>WorkHandler</code>: 事件的处理者, 由用户自己实现. </li>
<li><code>WorkProcessor</code>: 事件的处理器, 单独在一个线程中运行. </li>
<li><code>WorkerPool</code>: 一组<code>WorkProcessor</code>的处理. </li>
<li><code>WaitStrategy</code>: 在消费者比生产者快时, 消费者处理器的等待策略. </li>
</ol>
<h1 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h1><p>按照官方的指南, 一般套路如下: </p>
<ol>
<li>自定义事件类: 例如 <code>LongEvent</code> </li>
<li>实现<code>EventFactory&lt;T&gt;</code>: 例如<code>LongEventFactory implements EventFactory&lt;LongEvent&gt;</code></li>
<li>实现<code>EventHandler&lt;T&gt;</code>（消费者）: 例如<code>LongEventHandler implements EventHandler&lt;LongEvent&gt;</code></li>
<li>实现<code>EventTranslatorOneArg&lt;T, E&gt;</code>作为生产者, 将业务转换为事件: 例如<code>LongEventTranslatorOneArg implements EventTranslatorOneArg&lt;LongEvent, ByteBuffer&gt;</code></li>
<li>提供线程池或线程工厂</li>
<li>定义buffer大小, 它<strong>必须是2的幂</strong>, 否则会在初始化时抛出异常. 因为重点在于使用逻辑二进制运算符有着更好的性能；(例如:mod运算)</li>
<li>构建<code>Disruptor&lt;T&gt;</code></li>
<li>启动<code>disruptor</code>, <code>disruptor.start()</code></li>
<li>发布事件, 驱动自行流转</li>
</ol>
<h2 id="基础事件生产与消费"><a href="#基础事件生产与消费" class="headerlink" title="基础事件生产与消费"></a>基础事件生产与消费</h2><h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangbingdong.springbootdisruptor.basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ybd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 18-1-31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@contact</span> yangbingdong@1994.gmail</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEvent</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定义事件工厂"><a href="#定义事件工厂" class="headerlink" title="定义事件工厂"></a>定义事件工厂</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangbingdong.springbootdisruptor.basic;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.EventFactory;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ybd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 18-1-31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@contact</span> yangbingdong@1994.gmail</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEventFactory</span> <span class="keyword">implements</span> <span class="title">EventFactory</span>&lt;<span class="title">LongEvent</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> LongEvent <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		log.info(<span class="string">"logEventFactory create LongEvent..."</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> LongEvent();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定义消费者"><a href="#定义消费者" class="headerlink" title="定义消费者"></a>定义消费者</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangbingdong.springbootdisruptor.basic;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.EventHandler;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ybd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 18-1-31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@contact</span> yangbingdong@1994.gmail</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEventHandler</span> <span class="keyword">implements</span> <span class="title">EventHandler</span>&lt;<span class="title">LongEvent</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(LongEvent event, <span class="keyword">long</span> sequence, <span class="keyword">boolean</span> endOfBatch)</span> </span>&#123;</span><br><span class="line">		log.info(<span class="string">"handle event: "</span> + event);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定义生产者"><a href="#定义生产者" class="headerlink" title="定义生产者"></a>定义生产者</h2><h3 id="3-0版本之前"><a href="#3-0版本之前" class="headerlink" title="3.0版本之前"></a>3.0版本之前</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangbingdong.springbootdisruptor.basic;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.RingBuffer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ybd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 18-1-31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@contact</span> yangbingdong@1994.gmail</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEventProducer</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> RingBuffer&lt;LongEvent&gt; ringBuffer;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LongEventProducer</span><span class="params">(RingBuffer&lt;LongEvent&gt; ringBuffer)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.ringBuffer = ringBuffer;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onData</span><span class="params">(ByteBuffer bb)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Grab the next sequence</span></span><br><span class="line">		<span class="keyword">long</span> sequence = ringBuffer.next();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Get the entry in the Disruptor</span></span><br><span class="line">			LongEvent event = ringBuffer.get(sequence);</span><br><span class="line">			<span class="comment">// for the sequence</span></span><br><span class="line">			<span class="comment">// Fill with data</span></span><br><span class="line">			event.setValue(bb.getLong(<span class="number">0</span>));</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			ringBuffer.publish(sequence);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-0版本之后使用Translators"><a href="#3-0版本之后使用Translators" class="headerlink" title="3.0版本之后使用Translators"></a>3.0版本之后使用Translators</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangbingdong.springbootdisruptor.basic;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.EventTranslatorOneArg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ybd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 18-1-31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@contact</span> yangbingdong@1994.gmail</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongEventProducerWithTranslator</span> <span class="keyword">implements</span> <span class="title">EventTranslatorOneArg</span>&lt;<span class="title">LongEvent</span>, <span class="title">ByteBuffer</span>&gt;</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">translateTo</span><span class="params">(LongEvent event, <span class="keyword">long</span> sequence, ByteBuffer bb)</span> </span>&#123;</span><br><span class="line">		event.setValue(bb.getLong(<span class="number">0</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试实例"><a href="#测试实例" class="headerlink" title="测试实例"></a>测试实例</h2><h3 id="单生产者-单消费者"><a href="#单生产者-单消费者" class="headerlink" title="单生产者, 单消费者"></a>单生产者, 单消费者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singleProducerLongEventDefaultTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	<span class="comment">// Executor that will be used to construct new threads for consumers</span></span><br><span class="line">	Executor executor = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The factory for the event</span></span><br><span class="line">	LongEventFactory factory = <span class="keyword">new</span> LongEventFactory();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Specify the size of the ring buffer, must be power of 2.</span></span><br><span class="line">	<span class="keyword">int</span> bufferSize = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Construct the Disruptor</span></span><br><span class="line">	Disruptor&lt;LongEvent&gt; disruptor = <span class="keyword">new</span> Disruptor&lt;&gt;(factory, bufferSize, executor, ProducerType.SINGLE, <span class="keyword">new</span> BlockingWaitStrategy());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Connect the handler</span></span><br><span class="line">	disruptor.handleEventsWith(<span class="keyword">new</span> LongEventHandler());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start the Disruptor, starts all threads running</span></span><br><span class="line">	disruptor.start();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get the ring buffer from the Disruptor to be used for publishing.</span></span><br><span class="line">	RingBuffer&lt;LongEvent&gt; ringBuffer = disruptor.getRingBuffer();</span><br><span class="line"></span><br><span class="line">	LongEventProducer producer = <span class="keyword">new</span> LongEventProducer(ringBuffer);</span><br><span class="line"></span><br><span class="line">	ByteBuffer bb = ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">long</span> l = <span class="number">0</span>; l &lt; <span class="number">100</span>; l++) &#123;</span><br><span class="line">		bb.putLong(<span class="number">0</span>, l);</span><br><span class="line">		producer.onData(bb);</span><br><span class="line">		Thread.sleep(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新版的Disruptor不建议我们使用<code>Executor</code>, 而使用<code>ThreadFactory</code>代替: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singleProducerLongEventUseThreadFactoryTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	ThreadFactory threadFactory = <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger index = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Thread(<span class="keyword">null</span>, r, <span class="string">"disruptor-thread-"</span> + index.getAndIncrement());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	LongEventFactory factory = <span class="keyword">new</span> LongEventFactory();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> bufferSize = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	Disruptor&lt;LongEvent&gt; disruptor = <span class="keyword">new</span> Disruptor&lt;&gt;(factory, bufferSize, threadFactory, ProducerType.SINGLE, <span class="keyword">new</span> BlockingWaitStrategy());</span><br><span class="line"></span><br><span class="line">	disruptor.handleEventsWith(<span class="keyword">new</span> LongEventHandler());</span><br><span class="line"></span><br><span class="line">	disruptor.start();</span><br><span class="line"></span><br><span class="line">	RingBuffer&lt;LongEvent&gt; ringBuffer = disruptor.getRingBuffer();</span><br><span class="line"></span><br><span class="line">	LongEventProducer producer = <span class="keyword">new</span> LongEventProducer(ringBuffer);</span><br><span class="line"></span><br><span class="line">	ByteBuffer bb = ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">long</span> l = <span class="number">0</span>; l &lt; <span class="number">100</span>; l++) &#123;</span><br><span class="line">		bb.putLong(<span class="number">0</span>, l);</span><br><span class="line">		producer.onData(bb);</span><br><span class="line">		Thread.sleep(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新版Disruptor使用Translators: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singleProducerLongEventUseTranslatorsTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	ThreadFactory threadFactory = <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger index = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Thread(<span class="keyword">null</span>, r, <span class="string">"disruptor-thread-"</span> + index.getAndIncrement());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	LongEventFactory factory = <span class="keyword">new</span> LongEventFactory();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> bufferSize = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	Disruptor&lt;LongEvent&gt; disruptor = <span class="keyword">new</span> Disruptor&lt;&gt;(factory, bufferSize, threadFactory, ProducerType.SINGLE, <span class="keyword">new</span> BlockingWaitStrategy());</span><br><span class="line"></span><br><span class="line">	disruptor.handleEventsWith(<span class="keyword">new</span> LongEventHandler());</span><br><span class="line"></span><br><span class="line">	disruptor.start();</span><br><span class="line"></span><br><span class="line">	RingBuffer&lt;LongEvent&gt; ringBuffer = disruptor.getRingBuffer();</span><br><span class="line"></span><br><span class="line">	LongEventProducerWithTranslator longEventProducerWithTranslator = <span class="keyword">new</span> LongEventProducerWithTranslator();</span><br><span class="line"></span><br><span class="line">	ByteBuffer bb = ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">long</span> l = <span class="number">0</span>; l &lt; <span class="number">100</span>; l++) &#123;</span><br><span class="line">		bb.putLong(<span class="number">0</span>, l);</span><br><span class="line">		ringBuffer.publishEvent(longEventProducerWithTranslator, bb);</span><br><span class="line">		Thread.sleep(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.yangbingdong.com/img/disruptor-learning/simple-test01.jpg" alt></p>
<p>java8版: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singleProducerLongEventJava8Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> bufferSize = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	Disruptor&lt;LongEvent&gt; disruptor = <span class="keyword">new</span> Disruptor&lt;&gt;(LongEvent::<span class="keyword">new</span>, bufferSize, (ThreadFactory) Thread::<span class="keyword">new</span>, ProducerType.SINGLE, <span class="keyword">new</span> BlockingWaitStrategy());</span><br><span class="line"></span><br><span class="line">	disruptor.handleEventsWith((event, sequence, endOfBatch) -&gt; log.info(<span class="string">"handle event: "</span> + event));</span><br><span class="line"></span><br><span class="line">	disruptor.start();</span><br><span class="line"></span><br><span class="line">	RingBuffer&lt;LongEvent&gt; ringBuffer = disruptor.getRingBuffer();</span><br><span class="line"></span><br><span class="line">	ByteBuffer bb = ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line">	LongStream.range(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">			  .forEach(tryLongConsumer(l -&gt; &#123;</span><br><span class="line">				  bb.putLong(<span class="number">0</span>, l);</span><br><span class="line">				  ringBuffer.publishEvent((event, sequence, buffer) -&gt; event.setValue(buffer.getLong(<span class="number">0</span>)), bb);</span><br><span class="line">				  Thread.sleep(<span class="number">10</span>);</span><br><span class="line">			  &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.yangbingdong.com/img/disruptor-learning/simple-test02.jpg" alt></p>
<h3 id="多生产者-单消费者"><a href="#多生产者-单消费者" class="headerlink" title="多生产者, 单消费者"></a>多生产者, 单消费者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiProducerOneCustomerTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> bufferSize = <span class="number">1</span> &lt;&lt; <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">	Disruptor&lt;LongEvent&gt; disruptor = <span class="keyword">new</span> Disruptor&lt;&gt;(LongEvent::<span class="keyword">new</span>, bufferSize, Executors.defaultThreadFactory(), ProducerType.MULTI, <span class="keyword">new</span> SleepingWaitStrategy());</span><br><span class="line"></span><br><span class="line">	disruptor.handleEventsWith((event, sequence, endOfBatch) -&gt; &#123;</span><br><span class="line">		log.info(<span class="string">"handle event: &#123;&#125;, sequence: &#123;&#125;, endOfBatch: &#123;&#125;"</span>, event, sequence, endOfBatch);</span><br><span class="line">		countDownLatch.countDown();</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	LongEventProducerWithTranslator longEventProducerWithTranslator = <span class="keyword">new</span> LongEventProducerWithTranslator();</span><br><span class="line"></span><br><span class="line">	disruptor.start();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">new</span> Thread(() -&gt; produce(disruptor, longEventProducerWithTranslator, <span class="number">0</span>, <span class="number">10</span>)).start();</span><br><span class="line">	<span class="keyword">new</span> Thread(() -&gt; produce(disruptor, longEventProducerWithTranslator, <span class="number">10</span>, <span class="number">20</span>)).start();</span><br><span class="line">	<span class="keyword">new</span> Thread(() -&gt; produce(disruptor, longEventProducerWithTranslator, <span class="number">20</span>, <span class="number">30</span>)).start();</span><br><span class="line"></span><br><span class="line">	countDownLatch.await();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(Disruptor&lt;LongEvent&gt; disruptor, LongEventProducerWithTranslator longEventProducerWithTranslator, <span class="keyword">int</span> i, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		RingBuffer&lt;LongEvent&gt; ringBuffer = disruptor.getRingBuffer();</span><br><span class="line"></span><br><span class="line">		ByteBuffer bb = ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">long</span> l = i; l &lt; i2; l++) &#123;</span><br><span class="line">			bb.putLong(<span class="number">0</span>, l);</span><br><span class="line">			ringBuffer.publishEvent(longEventProducerWithTranslator, bb);</span><br><span class="line">			TimeUnit.MILLISECONDS.sleep(<span class="number">20</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一个及以上生产者-多个消费者"><a href="#一个及以上生产者-多个消费者" class="headerlink" title="一个及以上生产者, 多个消费者"></a>一个及以上生产者, 多个消费者</h3><p><img src="https://cdn.yangbingdong.com/img/disruptor-learning/dsl1.png" alt></p>
<p>先处理完c1和c2才处理c3: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiCustomerOneProducerTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> bufferSize = <span class="number">1</span> &lt;&lt; <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">	Disruptor&lt;LongEvent&gt; disruptor = <span class="keyword">new</span> Disruptor&lt;&gt;(LongEvent::<span class="keyword">new</span>, bufferSize, Executors.defaultThreadFactory(), ProducerType.MULTI, <span class="keyword">new</span> YieldingWaitStrategy());</span><br><span class="line"></span><br><span class="line">	LongEventHandler c1 = <span class="keyword">new</span> LongEventHandler();</span><br><span class="line">	LongEventHandler2 c2 = <span class="keyword">new</span> LongEventHandler2();</span><br><span class="line">	LongEventHandler3 c3 = <span class="keyword">new</span> LongEventHandler3();</span><br><span class="line"></span><br><span class="line">	disruptor.handleEventsWith(c1, c2).then(c3);</span><br><span class="line"></span><br><span class="line">	LongEventProducerWithTranslator longEventProducerWithTranslator = <span class="keyword">new</span> LongEventProducerWithTranslator();</span><br><span class="line"></span><br><span class="line">	disruptor.start();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">new</span> Thread(() -&gt; produce(disruptor, longEventProducerWithTranslator, <span class="number">0</span>, <span class="number">100</span>)).start();</span><br><span class="line"></span><br><span class="line">	TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.yangbingdong.com/img/disruptor-learning/multi-test1.jpg" alt></p>
<p>从上图结果可以看出来c1和c2的顺序是不确定的, c3总是在最后. </p>
<p><img src="https://cdn.yangbingdong.com/img/disruptor-learning/dsl2.png" alt></p>
<p>如图, 消费者1b消费时, 必须保证消费者1a已经完成对该消息的消费；消费者2b消费时, 必须保证消费者2a已经完成对该消息的消费；消费者c3消费时, 必须保证消费者1b和2b已经完成对该消息的消费. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiCustomerOneProducerTest2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> bufferSize = <span class="number">1</span> &lt;&lt; <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">	Disruptor&lt;LongEvent&gt; disruptor = <span class="keyword">new</span> Disruptor&lt;&gt;(LongEvent::<span class="keyword">new</span>, bufferSize, Executors.defaultThreadFactory(), ProducerType.SINGLE, <span class="keyword">new</span> LiteBlockingWaitStrategy());</span><br><span class="line"></span><br><span class="line">	LongEventHandler c1a = <span class="keyword">new</span> LongEventHandler();</span><br><span class="line">	LongEventHandler2 c2a = <span class="keyword">new</span> LongEventHandler2();</span><br><span class="line">	LongEventHandler3 c1b = <span class="keyword">new</span> LongEventHandler3();</span><br><span class="line">	LongEventHandler4 c2b = <span class="keyword">new</span> LongEventHandler4();</span><br><span class="line"></span><br><span class="line">	disruptor.handleEventsWith(c1a, c2a);</span><br><span class="line">	disruptor.after(c1a).then(c1b);</span><br><span class="line">	disruptor.after(c2a).then(c2b);</span><br><span class="line">	disruptor.after(c1b, c2b).then((EventHandler&lt;LongEvent&gt;) (event, sequence, endOfBatch) -&gt; System.out.println(<span class="string">"last costumer \n"</span>));</span><br><span class="line"></span><br><span class="line">	LongEventProducerWithTranslator longEventProducerWithTranslator = <span class="keyword">new</span> LongEventProducerWithTranslator();</span><br><span class="line"></span><br><span class="line">	disruptor.start();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">new</span> Thread(() -&gt; produce(disruptor, longEventProducerWithTranslator, <span class="number">0</span>, <span class="number">30</span>)).start();</span><br><span class="line"></span><br><span class="line">	TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.yangbingdong.com/img/disruptor-learning/multi-test2.jpg" alt></p>
<p>再来一个复杂点的: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiCustomerOneProducerTest3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> bufferSize = <span class="number">1</span> &lt;&lt; <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">	Disruptor&lt;LongEvent&gt; disruptor = <span class="keyword">new</span> Disruptor&lt;&gt;(LongEvent::<span class="keyword">new</span>, bufferSize, Executors.defaultThreadFactory(), ProducerType.SINGLE, <span class="keyword">new</span> LiteBlockingWaitStrategy());</span><br><span class="line"></span><br><span class="line">	EventHandler a = (EventHandler&lt;LongEvent&gt;) (event, sequence, endOfBatch) -&gt; System.out.println(<span class="string">"process a... event: "</span> + event);</span><br><span class="line">	EventHandler b = (EventHandler&lt;LongEvent&gt;) (event, sequence, endOfBatch) -&gt; System.out.println(<span class="string">"process b... event: "</span> + event);</span><br><span class="line">	EventHandler c = (EventHandler&lt;LongEvent&gt;) (event, sequence, endOfBatch) -&gt; System.out.println(<span class="string">"process c... event: "</span> + event);</span><br><span class="line">	EventHandler d = (EventHandler&lt;LongEvent&gt;) (event, sequence, endOfBatch) -&gt; System.out.println(<span class="string">"process d... event: "</span> + event);</span><br><span class="line">	EventHandler e = (EventHandler&lt;LongEvent&gt;) (event, sequence, endOfBatch) -&gt; System.out.println(<span class="string">"process e... a,b,c has completed, event: "</span> + event + <span class="string">"\n"</span>);</span><br><span class="line">	EventHandler f = (EventHandler&lt;LongEvent&gt;) (event, sequence, endOfBatch) -&gt; System.out.println(<span class="string">"process f... d has completed, event: "</span> + event + <span class="string">"\n"</span>);</span><br><span class="line">	EventHandler g = (EventHandler&lt;LongEvent&gt;) (event, sequence, endOfBatch) -&gt; System.out.println(<span class="string">"process g... e,f has completed, event: "</span> + event + <span class="string">"\n\n"</span>);</span><br><span class="line"></span><br><span class="line">	disruptor.handleEventsWith(a, b, c, d);</span><br><span class="line">	disruptor.after(a, b, c).then(e);</span><br><span class="line">	disruptor.after(d).then(f);</span><br><span class="line">	disruptor.after(e, f).then(g);</span><br><span class="line"></span><br><span class="line">	LongEventProducerWithTranslator longEventProducerWithTranslator = <span class="keyword">new</span> LongEventProducerWithTranslator();</span><br><span class="line"></span><br><span class="line">	disruptor.start();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">new</span> Thread(() -&gt; produce(disruptor, longEventProducerWithTranslator, <span class="number">0</span>, <span class="number">2</span>)).start();</span><br><span class="line"></span><br><span class="line">	TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.yangbingdong.com/img/disruptor-learning/multi-test3.jpg" alt></p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>Disruptor默认会把异常包装成<code>RuntimeException</code>并抛出去, 导致线程挂掉或阻塞, 我们需要自定义异常处理器: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">disruptor.setDefaultExceptionHandler(<span class="keyword">new</span> ExceptionHandler&lt;LongEvent&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleEventException</span><span class="params">(Throwable ex, <span class="keyword">long</span> sequence, LongEvent event)</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"捕捉异常: "</span> + ex.getMessage());</span><br><span class="line">				System.out.println(<span class="string">"处理异常逻辑..."</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleOnStartException</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"handleOnStartException"</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleOnShutdownException</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"handleOnShutdownException"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="从RingBuffer中移除对象"><a href="#从RingBuffer中移除对象" class="headerlink" title="从RingBuffer中移除对象"></a>从RingBuffer中移除对象</h1><blockquote>
<p>来自官方翻译: 当通过Disruptor传递数据时, 对象可能比预期寿命更长. 为避免发生这种情况, 可能需要在处理事件后清除事件. 如果你有一个单一的事件处理程序清除在同一个处理程序中的值是足够的. 如果你有一连串的事件处理程序, 那么你可能需要一个特定的处理程序放置在链的末尾来处理对象. </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectEvent</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    T val;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        val = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClearingEventHandler</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">EventHandler</span>&lt;<span class="title">ObjectEvent</span>&lt;<span class="title">T</span>&gt;&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(ObjectEvent&lt;T&gt; event, <span class="keyword">long</span> sequence, <span class="keyword">boolean</span> endOfBatch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Failing to call clear here will result in the </span></span><br><span class="line">        <span class="comment">// object associated with the event to live until</span></span><br><span class="line">        <span class="comment">// it is overwritten once the ring buffer has wrapped</span></span><br><span class="line">        <span class="comment">// around to the beginning.</span></span><br><span class="line">        event.clear(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Disruptor&lt;ObjectEvent&lt;String&gt;&gt; disruptor = <span class="keyword">new</span> Disruptor&lt;&gt;(</span><br><span class="line">        () -&gt; ObjectEvent&lt;String&gt;(), bufferSize, executor);</span><br><span class="line"></span><br><span class="line">    disruptor</span><br><span class="line">        .handleEventsWith(<span class="keyword">new</span> ProcessingEventHandler())</span><br><span class="line">        .then(<span class="keyword">new</span> ClearingObjectHandler());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="消费者分片"><a href="#消费者分片" class="headerlink" title="消费者分片"></a>消费者分片</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">implements</span> <span class="title">EventHandler</span>&lt;<span class="title">ValueEvent</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> ordinal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> numberOfConsumers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> ordinal, <span class="keyword">final</span> <span class="keyword">long</span> numberOfConsumers)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ordinal = ordinal;</span><br><span class="line">        <span class="keyword">this</span>.numberOfConsumers = numberOfConsumers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(<span class="keyword">final</span> ValueEvent entry, <span class="keyword">final</span> <span class="keyword">long</span> sequence, <span class="keyword">final</span> <span class="keyword">boolean</span> onEndOfBatch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((sequence % numberOfConsumers) == ordinal)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Process the event</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>disruptor.handleEventsWithWorkerPool(...)</code>也可以实现这种类似消费者组的功能. </p>
<p>或者更简单地实现<code>WorkHandler</code>也可以:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisruptorInnerShardingHandler</span>&lt;<span class="title">S</span>&gt; <span class="keyword">implements</span> <span class="title">WorkHandler</span>&lt;<span class="title">DisruptorEvent</span>&lt;<span class="title">S</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Map&lt;Class, DisruptorEventSourceHandler&lt;S&gt;&gt; handlerMap;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DisruptorInnerShardingHandler</span><span class="params">(Map&lt;Class, DisruptorEventSourceHandler&lt;S&gt;&gt; handlerMap)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.handlerMap = handlerMap;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(DisruptorEvent&lt;S&gt; event)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Class sourceClass = event.getSourceClass();</span><br><span class="line">			DisruptorEventSourceHandler&lt;S&gt; sourceHandler = handlerMap.get(sourceClass);</span><br><span class="line">			notNull(sourceHandler, <span class="string">"Source handler not found: "</span> + sourceClass);</span><br><span class="line">			sourceHandler.handlerSource(event.getSource());</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			event.clean();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="避免伪缓存"><a href="#避免伪缓存" class="headerlink" title="避免伪缓存"></a>避免伪缓存</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FalseSharing</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        testPointer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testPointer</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Pointer pointer = <span class="keyword">new</span> Pointer();</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">                pointer.x++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">                pointer.y++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println(System.currentTimeMillis() - start);</span><br><span class="line">        System.out.println(pointer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pointer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> x;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中x跟y会加载到同一个缓存行, 运行时间为 <strong>3581ms</strong>.</p>
<p>下面通过填充内存解决伪缓存:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pointer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> x;</span><br><span class="line">    <span class="keyword">long</span> p1, p2, p3, p4, p5;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为缓存行为64个字节, 可以填充5个long类型的字段(Java对象头16个字节), 运行时间为 <strong>586ms</strong>.</p>
<p>或者使用Java8提供的 <a href="mailto:`@sun.misc.Contended" rel="external nofollow noopener noreferrer" target="_blank">`@sun.misc.Contended</a>` 注解:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pointer</span> </span>&#123;</span><br><span class="line">    MyLong x = <span class="keyword">new</span> MyLong();</span><br><span class="line">    MyLong y = <span class="keyword">new</span> MyLong();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Contended</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLong</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意: 需要在启动参数中加上 <code>-XX:-RestrictContended</code> 才能生效.</strong></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>代码: <a href="https://github.com/masteranthoneyd/spring-boot-learning/tree/master/spring-boot-disruptor" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/masteranthoneyd/spring-boot-learning/tree/master/spring-boot-disruptor</a></p>
<p>来自某大神的点评:<br>“当对性能的追求达到这样的程度, 以致对现代硬件构成的理解变得越来越重要. ”这句话恰当地形容了Disruptor/LMAX在对性能方面的追求和失败. 咦, 失败？为什么会这么说呢？Disruptor当然是一个优秀的框架, 我说的失败指的是在开发它的过程中, LMAX曽试图提高并发程序效率, 优化、使用锁或借助其他模型, 但是这些尝试最终失败了——然后他们构建了Disruptor. 再提问: 一个Java程序员在尝试提高他的程序性能的时候, 需要了解很多硬件知识吗？我想很多人都会回答“不需要”, 构建Disruptor的过程中, 最初开发人员对这个问题的回答可能也是“不需要”, 但是尝试失败后他们决定另辟蹊径. 总的看下Disruptor的设计: 锁到CAS、缓冲行填充、避免GC等, 我感觉这些设计都在刻意“迁就”或者“依赖”硬件设计, 这些设计更像是一种“(ugly)hack”（毫无疑问, Disruptor还是目前最优秀的方案之一）. </p>
</blockquote>
<p>Disruptor可以说是工程级别的项目, 通过各种高级的优化达到了性能的极致: </p>
<ul>
<li>可选锁无关<code>lock-free</code>, 没有竞争所以非常快</li>
<li>所有访问者都记录自己的序号的实现方式, 允许多个生产者与多个消费者共享相同的数据结构</li>
<li>在每个对象中都能跟踪序列号, 没有为伪共享和非预期的竞争</li>
<li>增加缓存行补齐, 提升<code>cache</code>缓存命中率</li>
<li>环形数组中的元素不会被删除</li>
</ul>
]]></content><categories><category>Programming</category><category>Java</category></categories><tags><tag>Java</tag><tag>Disruptor</tag></tags></entry><entry><title>Docker入坑笔记</title><url>/2017/docker-learning/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/docker/docker.png" alt></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><blockquote>
<p>Docker是什么？下面是官方的一段说明:<br><strong><em><a href="https://www.docker.com/what-docker" rel="external nofollow noopener noreferrer" target="_blank">Docker is the world’s leading software containerization platform.</a></em></strong><br>恩, 很<code>niubility</code>, 引领世界软件容器化的平台…<br>本篇主要记录Docker的基础学习（安装、简单使用）</p>
</blockquote>
<a id="more"></a>
<h1 id="Containerization-VS-Virtualization"><a href="#Containerization-VS-Virtualization" class="headerlink" title="Containerization VS Virtualization"></a>Containerization VS Virtualization</h1><p>了解Docker之前, 我们有必要了解一下容器化<br><img src="https://cdn.yangbingdong.com/img/docker/compare-container-and-docker2.jpg" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/docker/compare-container-and-docker.jpg" alt></p>
<p><strong>容器相当于轻量级的虚拟机, 但隔离性不如虚拟机</strong>. </p>
<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p><strong>核心理念</strong>: Build, Ship, and Run Any App, Anywhere</p>
<p>(Java的核心理念: Write once, run anywhere)</p>
<p><img src="https://cdn.yangbingdong.com/img/docker/container-history.jpg" alt></p>
<p><strong>Docker是<code>GO</code>语言编写的容器化的一种实现</strong>, 是一个<strong>分布式</strong>应用<strong>构建</strong>、<strong>迁移</strong>和<strong>运行</strong>的开放平台, 它允许开发或运维人员将应用和运行应用所<strong>依赖的文件打包到一个标准化的单元</strong>（容器）中运行. 其他的容器实现有<strong>OpenVZ</strong>, <strong>Pouch</strong>(<code>Ali</code>出品)等. </p>
<p><strong>服务器</strong>好比运输码头: 拥有场地和各种设备（服务器硬件资源）</p>
<p><strong>服务器容器化</strong>好比作码头上的仓库: 拥有独立的空间堆放各种货物或集装箱</p>
<p>(仓库之间完全独立, 独立的应用系统和操作系统）</p>
<p><strong>实现的核心技术</strong>: lcx、cgroup、namespaces…（Linux内核级别隔离技术）</p>
<p><strong>注意点</strong>: 不能乱玩…遵循<strong>单一职责</strong>, <strong>无状态</strong>. </p>
<h1 id="Docker实现DevOps的优势"><a href="#Docker实现DevOps的优势" class="headerlink" title="Docker实现DevOps的优势"></a>Docker实现DevOps的优势</h1><p><strong>优势一</strong>:</p>
<p>开发、测试和生产环境的<strong>统一化</strong>和<strong>标准化</strong>. 镜像作为标准的交付件, 可在开发、测试和生产环境上以容器来运行, 最终实现三套环境上的应用以及运行所<strong>依赖内容的完全一致</strong>. </p>
<p><strong>优势二</strong>:</p>
<p><strong>解决底层基础环境的异构问题</strong>. 基础环境的多元化造成了从Dev到Ops过程中的阻力, 而使用Docker Engine可无视基础环境的类型. 不同的物理设备, 不同的虚拟化类型, 不同云计算平台, 只要是运行了Docker Engine的环境, 最终的应用都会以容器为基础来提供服务. </p>
<p><strong>优势三</strong>:</p>
<p>易于<strong>构建</strong>、<strong>迁移</strong>和<strong>部署</strong>. Dockerfile实现镜像构建的标准化和可复用, 镜像本身的分层机制也提高了镜像构建的效率. 使用Registry可以将构建好的镜像迁移到任意环境, 而且环境的部署仅需要将静态只读的镜像转换为动态可运行的容器即可. </p>
<p><strong>优势四</strong>:</p>
<p><strong>轻量</strong>和<strong>高效</strong>. 和需要封装操作系统的虚拟机相比, 容器仅需要封装应用和应用需要的依赖文件, 实现轻量的应用运行环境, 且拥有比虚拟机更高的硬件资源利用率. </p>
<p><strong>优势五</strong>:</p>
<p>工具链的标准化和快速部署. 将实现DevOps所需的多种工具或软件进行Docker化后, 可在任意环境实现一条或多条工具链的快速部署. </p>
<p>适合<strong>敏捷开发</strong>、<strong>持续交付</strong></p>
<h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><p>以下是Docker的三个基本概念. </p>
<h2 id="Image-镜像"><a href="#Image-镜像" class="headerlink" title="Image(镜像)"></a>Image(镜像)</h2><p>官方而言, Docker 镜像是一个<strong>特殊的文件系统</strong>, 除了提供容器运行时所需的程序、库、资源、配置等文件外, 还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）. 镜像不包含任何动态数据, 其内容在构建之后也不会被改变.<br>对博主而言, 它相当于就是个<code>Java Class</code>(类)=.=</p>
<p>但它的存储结构类似<code>Git</code>, 一层一层地网上盖, <strong>删除一个文件并不会真的删除</strong>, 只是在那个文件上面做了一个标记为已删除. 在最终容器运行的时候, 虽然不会看到这个文件, 但是实际上该文件会<strong>一直跟随镜像</strong>. 因此, 在构建镜像的时候, 需要额外小心, <strong>每一层尽量只包含该层需要添加的东西</strong>, 任何额外的东西应该在该层构建结束前清理掉. </p>
<h2 id="Container-容器"><a href="#Container-容器" class="headerlink" title="Container(容器)"></a>Container(容器)</h2><p><img src="https://cdn.yangbingdong.com/img/docker/docker-component.jpg" alt></p>
<p>通俗来说, 如果镜像是类, 那么容器就是这个类的实例了, 镜像是静态的定义, 容器是镜像运行时的实体. 容器可以被创建、启动、停止、删除、暂停等. </p>
<p>容器也有其特性, 例如存储, 不指定数据卷(<code>Volume</code>)的话, 容器消亡数据也就跟着没了…<br>跟多特性请自行百度~</p>
<h2 id="Repository-仓库"><a href="#Repository-仓库" class="headerlink" title="Repository(仓库)"></a>Repository(仓库)</h2><p>仓库没啥好说的了, 以 <code>Ubuntu</code> 镜像 为例, <code>ubuntu</code> 是仓库的名字, 其内包含有不同的版本标签, 如, <code>14.04</code>, <code>16.04</code>. 我们可以通过 <code>ubuntu:14.04</code>, 或者 <code>ubuntu:16.04</code> 来具体指定所需哪个版本的镜像. 如果忽略了标签, 比如 <code>ubuntu</code>, 那将视为 <code>ubuntu:latest</code></p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>这里以Ubuntu为例（当然是因为博主用的是Ubuntu= =）, 版本的话Docker目前支持的Ubuntu版本最低为12.04LTS,但从稳定性上考虑,推荐使用14.04LTS或更高的版本. </p>
<h2 id="使用脚本自动安装"><a href="#使用脚本自动安装" class="headerlink" title="使用脚本自动安装"></a>使用脚本自动安装</h2><p>在测试或开发环境中 Docker 官方为了简化安装流程, 提供了一套便捷的安装脚本, Ubuntu 系统上可以使用这套脚本安装:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh --mirror Aliyun</span><br></pre></td></tr></table></figure></p>
<p>执行这个命令后, 脚本就会自动的将一切准备工作做好, 并且把 Docker 安装在系统中</p>
<h2 id="使用-APT-镜像源-安装"><a href="#使用-APT-镜像源-安装" class="headerlink" title="使用 APT 镜像源 安装"></a>使用 APT 镜像源 安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure>
<p>鉴于国内网络问题, 强烈建议使用国内源</p>
<h3 id="国内源"><a href="#国内源" class="headerlink" title="国内源"></a>国内源</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line">sudo add-apt-repository \</span><br><span class="line">    &quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \</span><br><span class="line">    $(lsb_release -cs) \</span><br><span class="line">    stable&quot;</span><br></pre></td></tr></table></figure>
<p>以上命令会添加 稳定 版本的 Docker CE APT 镜像源, 如果需要最新版本的 Docker CE 请将 <code>stable</code> 改为 <code>edge</code> 或者 <code>test</code> . 从 Docker 17.06 开始, <code>edge</code> <code>test</code> 版本的 APT 镜像源也会包含稳定版本的 Docker</p>
<h3 id="官方源"><a href="#官方源" class="headerlink" title="官方源"></a>官方源</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line">sudo add-apt-repository \</span><br><span class="line">   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span><br><span class="line">   $(lsb_release -cs) \</span><br><span class="line">   stable&quot;</span><br></pre></td></tr></table></figure>
<h3 id="安装-Docker-CE"><a href="#安装-Docker-CE" class="headerlink" title="安装 Docker CE"></a>安装 Docker CE</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure>
<h2 id="启动-Docker-CE"><a href="#启动-Docker-CE" class="headerlink" title="启动 Docker CE"></a>启动 Docker CE</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable docker</span><br><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>
<h2 id="建立-docker-用户组"><a href="#建立-docker-用户组" class="headerlink" title="建立 docker 用户组"></a>建立 docker 用户组</h2><p>默认情况下, <code>docker</code> 命令会使用 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket" rel="external nofollow noopener noreferrer" target="_blank">Unix socket</a> 与 Docker 引擎通讯. 而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket. 出于安全考虑, 一般 Linux 系统上不会直接使用 <code>root</code> 用户. 因此, 更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组.<br>建立 <code>docker</code> 组(貌似执行了自动安装脚本会自动建一个docker的用户组):<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo groupadd docker</span><br></pre></td></tr></table></figure></p>
<p>将当前用户加入 <code>docker</code> 组:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure></p>
<p>加入<code>docker</code> 组之后要<strong>重启才能生效</strong>哦…</p>
<h2 id="Mirror-Acceleration"><a href="#Mirror-Acceleration" class="headerlink" title="Mirror Acceleration"></a>Mirror Acceleration</h2><p>没有代理的话国内访问<a href="https://hub.docker.com/" rel="external nofollow noopener noreferrer" target="_blank">Docker Hub</a>的速度实在感人, 但Docker官方和国内很多云服务商都提供了加速器服务: </p>
<ul>
<li><a href="https://docs.docker.com/registry/recipes/mirror/#use-case-the-china-registry-mirror" rel="external nofollow noopener noreferrer" target="_blank">Docker 官方提供的中国registry mirror</a></li>
<li><a href="https://cr.console.aliyun.com/#/accelerator" rel="external nofollow noopener noreferrer" target="_blank">阿里云加速器</a></li>
<li><a href="https://www.daocloud.io/mirror#accelerator-doc" rel="external nofollow noopener noreferrer" target="_blank">DaoCloud 加速器</a></li>
<li><a href="http://docs.alauda.cn/feature/accelerator.html" rel="external nofollow noopener noreferrer" target="_blank">灵雀云加速器</a></li>
</ul>
<p>如阿里, 注册并申请后会得到加速域名如<code>https://vioqnt8w.mirror.aliyuncs.com</code>, 然后正如官方说的一样, 通过修改<code>daemon</code>配置文件<code>/etc/docker/daemon.json</code>来使用加速器:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&apos;EOF&apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://vioqnt8w.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure></p>
<p>查看生效: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker info|grep &quot;Registry Mirrors&quot; -A 1</span><br></pre></td></tr></table></figure>
<p>输出如下: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Registry Mirrors:</span><br><span class="line"> https://vioqnt8w.mirror.aliyuncs.com/</span><br></pre></td></tr></table></figure>
<h1 id="镜像的相关操作"><a href="#镜像的相关操作" class="headerlink" title="镜像的相关操作"></a>镜像的相关操作</h1><h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><p><a href="https://hub.docker.com/explore/" rel="external nofollow noopener noreferrer" target="_blank"><strong>Docker Hub</strong></a> 上有大量的高质量的镜像可以用, 我们可以通过以下的方式获取镜像:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry地址]&lt;仓库名&gt;:&lt;标签&gt;</span><br></pre></td></tr></table></figure></p>
<p>选项可以通过<code>docker pull --help</code>查看.<br>eg, 从Docker Hub下载<code>REPOSITORY</code>为<code>java</code>的所有镜像:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull -a java</span><br></pre></td></tr></table></figure></p>
<h2 id="列出"><a href="#列出" class="headerlink" title="列出"></a>列出</h2><p>使用<code>docker images [OPTIONS] [REPOSITORY[:TAG]]</code>列出已下载的镜像<br><img src="https://cdn.yangbingdong.com/img/docker/docker-images.png" alt><br>列表包含了仓库名、标签、镜像 ID、创建时间以及所占用的空间</p>
<p>OPTIONS说明:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-a :列出本地所有的镜像（含中间映像层, 默认情况下, 过滤掉中间映像层）；</span><br><span class="line">--digests :显示镜像的摘要信息；</span><br><span class="line">-f :显示满足条件的镜像；</span><br><span class="line">--format :指定返回值的模板文件；</span><br><span class="line">--no-trunc :显示完整的镜像信息；</span><br><span class="line">-q :只显示镜像ID.</span><br></pre></td></tr></table></figure></p>
<p>eg:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 看到在 mongo:3.2 之后建立的镜像,想查看某个位置之前的镜像也可以, 只需要把 since 换成 before 即可</span><br><span class="line">docker images -f since=mongo:3.2</span><br></pre></td></tr></table></figure></p>
<h3 id="虚悬镜像-dangling-image"><a href="#虚悬镜像-dangling-image" class="headerlink" title="虚悬镜像(dangling image)"></a>虚悬镜像(dangling image)</h3><p>举个例子: 原来为 <code>mongo:3.2</code>, 随着官方镜像维护, 发布了新版本后, 重新 <code>docker pull mongo:3.2</code> 时, <code>mongo:3.2</code> 这个镜像名被转移到了新下载的镜像身上, 而旧的镜像上的这个名称则被取消, 从而成为了 <code>&lt;none&gt;</code>. 除了 <code>docker pull</code> 可能导致这种情况, <code>docker build</code> 也同样可以导致这种现象. 由于新旧镜像同名, 旧镜像名称被取消, 从而出现仓库名、标签均为 <code>&lt;none&gt;</code> 的镜像. 这类无标签镜像也被称为 <strong>虚悬镜像(dangling image)</strong> , 可以用下面的命令专门显示这类镜像:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images -f dangling=true</span><br></pre></td></tr></table></figure></p>
<p>一般来说, 虚悬镜像已经失去了存在的价值, 是可以随意删除的, 可以用下面的命令删除:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rmi $(docker images -q -f dangling=<span class="literal">true</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h2><p>从容器创建一个新的镜像:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure></p>
<p>OPTIONS说明:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-a :提交的镜像作者；</span><br><span class="line">-c :使用Dockerfile指令来创建镜像；</span><br><span class="line">-m :提交时的说明文字；</span><br><span class="line">-p :在commit时, 将容器暂停.</span><br></pre></td></tr></table></figure></p>
<p>eg:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker commit -a &quot;ybd&quot; -m &quot;my apache&quot; a404c6c174a2  mymysql:v1</span><br></pre></td></tr></table></figure></p>
<p>当我们修改了镜像文件提交时候, 可以使用<code>docker diff [OPTIONS] CONTAINER</code>查看修改了什么东西.<br>一般地, 不推荐使用<code>commit</code>来构建镜像, 之前也提过, 镜像是特殊的文件系统, 改了东西之后原来的基础之上叠加, 使之变得<strong>越来越臃肿</strong>. 此外, 使用 <code>docker commit</code> 意味着所有对镜像的操作都是黑箱操作, 生成的镜像也被称为<strong>黑箱镜像</strong>, 换句话说, 就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像, 别人根本无从得知. 一般我们会使用<code>Dockerfile</code>定制镜像. </p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除镜像可以使用:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure></p>
<p>OPTIONS说明:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-f :强制删除；</span><br><span class="line">--no-prune :不移除该镜像的过程镜像, 默认移除；</span><br></pre></td></tr></table></figure></p>
<p>一般会组合使用: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi $(docker images -q -f dangling=true)</span><br><span class="line"></span><br><span class="line">docker rmi $(docker images -q redis)</span><br><span class="line"></span><br><span class="line">docker rmi $(docker images -q -f before=mongo:3.2)</span><br></pre></td></tr></table></figure>
<h2 id="查看元数据"><a href="#查看元数据" class="headerlink" title="查看元数据"></a>查看元数据</h2><p>docker inspect : 获取容器/镜像的元数据. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker inspect [OPTIONS] CONTAINER|IMAGE [CONTAINER|IMAGE...]</span><br></pre></td></tr></table></figure>
<p>OPTIONS说明: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-f :指定返回值的模板文件. </span><br><span class="line">-s :显示总的文件大小. </span><br><span class="line">--type :为指定类型返回JSON.</span><br></pre></td></tr></table></figure>
<p><strong>实例</strong></p>
<p>获取镜像mysql:5.6的元信息. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~: docker inspect mysql:5.6</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: &quot;sha256:2c0964ec182ae9a045f866bbc2553087f6e42bfc16074a74fb820af235f070ec&quot;,</span><br><span class="line">        &quot;RepoTags&quot;: [</span><br><span class="line">            &quot;mysql:5.6&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;RepoDigests&quot;: [],</span><br><span class="line">        &quot;Parent&quot;: &quot;&quot;,</span><br><span class="line">        &quot;Comment&quot;: &quot;&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2016-05-24T04:01:41.168371815Z&quot;,</span><br><span class="line">        &quot;Container&quot;: &quot;e0924bc460ff97787f34610115e9363e6363b30b8efa406e28eb495ab199ca54&quot;,</span><br><span class="line">        &quot;ContainerConfig&quot;: &#123;</span><br><span class="line">            &quot;Hostname&quot;: &quot;b0cf605c7757&quot;,</span><br><span class="line">            &quot;Domainname&quot;: &quot;&quot;,</span><br><span class="line">            &quot;User&quot;: &quot;&quot;,</span><br><span class="line">            &quot;AttachStdin&quot;: false,</span><br><span class="line">            &quot;AttachStdout&quot;: false,</span><br><span class="line">            &quot;AttachStderr&quot;: false,</span><br><span class="line">            &quot;ExposedPorts&quot;: &#123;</span><br><span class="line">                &quot;3306/tcp&quot;: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>获取正在运行的容器mymysql的 IP. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~: docker inspect -f &apos;&apos; mymysql</span><br><span class="line">172.17.0.3</span><br></pre></td></tr></table></figure>
<p>查看容器内部IP: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker inspect --format=&apos;&#123;\&#123;.NetworkSettings.IPAddress&#125;&#125;&apos; CONTAINER</span><br><span class="line">（注: 由于代码块解析的问题, 上面NetworkSettings前面的 \ 去掉）</span><br></pre></td></tr></table></figure>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>docker tag: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker tag IMAGE/CONTAINER TAG</span><br></pre></td></tr></table></figure>
<p>ex: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将同一IMAGE_ID的所有tag, 合并为一个新的</span><br><span class="line"># docker tag 195eb2565349 ybd/ubuntu:rm_test</span><br><span class="line">新建一个tag, 保留旧的那条记录</span><br><span class="line"># docker tag Registry/Repos:Tag New_Registry/New_Repos:New_Tag</span><br></pre></td></tr></table></figure>
<h2 id="保存镜像到归档文件"><a href="#保存镜像到归档文件" class="headerlink" title="保存镜像到归档文件"></a>保存镜像到归档文件</h2><p>docker save : 将指定镜像保存成 tar 归档文件. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker save [OPTIONS] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure>
<p>OPTIONS说明: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-o :输出到的文件.</span><br></pre></td></tr></table></figure>
<p><strong>实例</strong></p>
<p>将镜像runoob/ubuntu:v3 生成my_ubuntu_v3.tar文档</p>
<p>runoob@runoob:~$ docker save -o my_ubuntu_v3.tar runoob/ubuntu:v3</p>
<h2 id="导入镜像"><a href="#导入镜像" class="headerlink" title="导入镜像"></a>导入镜像</h2><h3 id="Import"><a href="#Import" class="headerlink" title="Import"></a>Import</h3><p>docker import : 从归档文件中创建镜像. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure>
<p>OPTIONS说明: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-c :应用docker 指令创建镜像；</span><br><span class="line"></span><br><span class="line">-m :提交时的说明文字；</span><br></pre></td></tr></table></figure>
<p>例如: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker import  ubuntu.tar ybd/ubuntu:v1</span><br></pre></td></tr></table></figure>
<h3 id="Load"><a href="#Load" class="headerlink" title="Load"></a>Load</h3><p>Usage:    docker load [OPTIONS]</p>
<p>Load an image from a tar archive or STDIN</p>
<p>Options:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-i, --input string   Read from tar archive file, instead of STDIN</span><br><span class="line"></span><br><span class="line">-q, --quiet          Suppress the load output</span><br></pre></td></tr></table></figure>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol>
<li>首先, docker import可以重新指定镜像的名字, docker load不可以</li>
<li>其次, 我们发现导出后的版本会比原来的版本稍微小一些. 那是因为导出后, 会丢失历史和元数据. 执行下面的命令就知道了:<br>显示镜像的所有层(layer)<br><code>docker images --tree</code><br>执行命令, 显示下面的内容. 正你看到的, 导出后再导入(exported-imported)的镜像会丢失所有的历史, 而保存后再加载（saveed-loaded）的镜像没有丢失<strong>历史和层(layer)</strong>. 这意味着使用导出后再导入的方式, 你将无法回滚到之前的层(layer), 同时, 使用保存后再加载的方式持久化整个镜像, 就可以做到<strong>层回滚</strong>（可以执行docker tag 来回滚之前的层）. </li>
</ol>
<h1 id="容器的相关操作"><a href="#容器的相关操作" class="headerlink" title="容器的相关操作"></a>容器的相关操作</h1><h2 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h2><p>docker run : 创建一个新的容器并运行一个命令 docker create : 创建一个新的容器但不启动它<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line">docker create [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure></p>
<p>docker run OPTIONS说明:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-a stdin: 指定标准输入输出内容类型, 可选 STDIN/STDOUT/STDERR 三项；</span><br><span class="line"></span><br><span class="line">-d: 后台运行容器, 并返回容器ID；</span><br><span class="line"></span><br><span class="line">-i: 以交互模式运行容器, 通常与 -t 同时使用；</span><br><span class="line"></span><br><span class="line">-t: 为容器重新分配一个伪输入终端, 通常与 -i 同时使用；</span><br><span class="line"></span><br><span class="line">-v: 挂载数据卷</span><br><span class="line"></span><br><span class="line">--name=&quot;nginx-lb&quot;: 为容器指定一个名称；</span><br><span class="line"></span><br><span class="line">--restart=always: docker启动容器也跟着启动</span><br><span class="line"></span><br><span class="line">--dns 8.8.8.8: 指定容器使用的DNS服务器, 默认和宿主一致；</span><br><span class="line"></span><br><span class="line">--dns-search example.com: 指定容器DNS搜索域名, 默认和宿主一致；</span><br><span class="line"></span><br><span class="line">-h &quot;mars&quot;: 指定容器的hostname；</span><br><span class="line"></span><br><span class="line">-e username=&quot;ritchie&quot;: 设置环境变量；</span><br><span class="line"></span><br><span class="line">--env-file=[]: 从指定文件读入环境变量；</span><br><span class="line"></span><br><span class="line">--cpuset=&quot;0-2&quot; or --cpuset=&quot;0,1,2&quot;: 绑定容器到指定CPU运行；</span><br><span class="line"></span><br><span class="line">-m :设置容器使用内存最大值；</span><br><span class="line"></span><br><span class="line">--net=&quot;bridge&quot;: 指定容器的网络连接类型, 支持 bridge/host/none/container: 四种类型；</span><br><span class="line"></span><br><span class="line">--link=[]: 添加链接到另一个容器；</span><br><span class="line"></span><br><span class="line">--expose=[]: 开放一个端口或一组端口；  &lt;b&gt;实例&lt;/b&gt;</span><br></pre></td></tr></table></figure></p>
<p>例如, 启动一个 bash 终端, 允许用户进行交互:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -t -i ubuntu:14.04 /bin/bash</span><br></pre></td></tr></table></figure></p>
<p>当利用 <code>docker run</code> 来创建容器时, Docker 在后台运行的标准操作包括: </p>
<ul>
<li>检查本地是否存在指定的镜像, 不存在就从公有仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统, 并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<p>启动一个es并指明healthcheck相关策略: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --rm -d \</span><br><span class="line">    --name=elasticsearch \</span><br><span class="line">    --health-cmd=&quot;curl --silent --fail localhost:9200/_cluster/health || exit 1&quot; \</span><br><span class="line">    --health-interval=5s \</span><br><span class="line">    --health-retries=12 \</span><br><span class="line">    --health-timeout=2s \</span><br><span class="line">    elasticsearch:5.5</span><br></pre></td></tr></table></figure>
<h2 id="暂停"><a href="#暂停" class="headerlink" title="暂停"></a>暂停</h2><p>docker pause :暂停容器中所有的进程. </p>
<p>docker unpause :恢复容器中所有的进程. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pause [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line">docker unpause [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>
<p><strong>实例</strong></p>
<p>暂停数据库容器db01提供服务. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pause db01</span><br></pre></td></tr></table></figure>
<p>恢复数据库容器db01提供服务. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker unpause db01</span><br></pre></td></tr></table></figure>
<h2 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h2><p>docker stop :停止一个运行中的容器:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stop [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure></p>
<h2 id="杀掉容器"><a href="#杀掉容器" class="headerlink" title="杀掉容器"></a>杀掉容器</h2><p>docker kill :杀掉一个运行中的容器. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker kill [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>
<p>OPTIONS说明: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-s :向容器发送一个信号</span><br></pre></td></tr></table></figure>
<p><strong>实例</strong></p>
<p>杀掉运行中的容器mynginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker kill -s KILL mynginx</span><br></pre></td></tr></table></figure>
<h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>使用docker exec :<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</span><br></pre></td></tr></table></figure></p>
<p>OPTIONS说明:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-d :分离模式: 在后台运行</span><br><span class="line"></span><br><span class="line">-i :即使没有附加也保持STDIN 打开</span><br><span class="line"></span><br><span class="line">-t :分配一个伪终端</span><br></pre></td></tr></table></figure></p>
<p>例如进入ubuntu容器交互式模式:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it ubuntu /bin/sh</span><br></pre></td></tr></table></figure></p>
<p>或者使用docker attach: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker attach --sig-proxy=false CONTAINER</span><br></pre></td></tr></table></figure>
<p><code>attach</code>是可以带上<code>--sig-proxy=false</code>来确保<code>CTRL-D</code>或<code>CTRL-C</code>不会关闭容器. </p>
<h2 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h2><p><strong>导出容器快照</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker export [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure></p>
<p>例如:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker export 7691a814370e &gt; ubuntu.tar</span><br></pre></td></tr></table></figure></p>
<h2 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rm [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>
<p>OPTIONS说明:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-f :通过SIGKILL信号强制删除一个运行中的容器</span><br><span class="line"></span><br><span class="line">-l :移除容器间的网络连接, 而非容器本身</span><br><span class="line"></span><br><span class="line">-v :-v 删除与容器关联的卷</span><br></pre></td></tr></table></figure></p>
<p>删除所有容器:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rm $(docker ps -a -q)</span><br></pre></td></tr></table></figure></p>
<p>但这并不会删除运行中的容器</p>
<h2 id="列出容器"><a href="#列出容器" class="headerlink" title="列出容器"></a>列出容器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps [OPTIONS]</span><br></pre></td></tr></table></figure>
<p>OPTIONS说明:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-a :显示所有的容器, 包括未运行的. </span><br><span class="line"></span><br><span class="line">-f, --filter :根据条件过滤显示的内容. </span><br><span class="line"></span><br><span class="line">--format :指定返回值的模板文件. </span><br><span class="line"></span><br><span class="line">-l :显示最近创建的容器. </span><br><span class="line"></span><br><span class="line">-n :列出最近创建的n个容器. </span><br><span class="line"></span><br><span class="line">--no-trunc :不截断输出. </span><br><span class="line"></span><br><span class="line">-q :静默模式, 只显示容器编号. </span><br><span class="line"></span><br><span class="line">-s :显示总的文件大小.</span><br></pre></td></tr></table></figure></p>
<p>例如列出最近创建的5个容器信息:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps -n 5</span><br></pre></td></tr></table></figure></p>
<p>列出所有创建的容器ID:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps -a -q</span><br></pre></td></tr></table></figure></p>
<p>下面是docker官方的filter参数: </p>
<table>
<thead>
<tr>
<th style="text-align:center">Filter</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>id</code></td>
<td style="text-align:left">Container’s ID</td>
</tr>
<tr>
<td style="text-align:center"><code>name</code></td>
<td style="text-align:left">Container’s name</td>
</tr>
<tr>
<td style="text-align:center"><code>label</code></td>
<td style="text-align:left">An arbitrary string representing either a key or a key-value pair. Expressed as <code>&lt;key&gt;</code> or <code>&lt;key&gt;=&lt;value&gt;</code></td>
</tr>
<tr>
<td style="text-align:center"><code>exited</code></td>
<td style="text-align:left">An integer representing the container’s exit code. Only useful with <code>--all</code>.</td>
</tr>
<tr>
<td style="text-align:center"><code>status</code></td>
<td style="text-align:left">One of <code>created</code>, <code>restarting</code>, <code>running</code>, <code>removing</code>, <code>paused</code>, <code>exited</code>, or <code>dead</code></td>
</tr>
<tr>
<td style="text-align:center"><code>ancestor</code></td>
<td style="text-align:left">Filters containers which share a given image as an ancestor. Expressed as <code>&lt;image-name&gt;[:&lt;tag&gt;]</code>, <code>&lt;image id&gt;</code>, or <code>&lt;image@digest&gt;</code></td>
</tr>
<tr>
<td style="text-align:center"><code>before</code> or <code>since</code></td>
<td style="text-align:left">Filters containers created before or after a given container ID or name</td>
</tr>
<tr>
<td style="text-align:center"><code>volume</code></td>
<td style="text-align:left">Filters running containers which have mounted a given volume or bind mount.</td>
</tr>
<tr>
<td style="text-align:center"><code>network</code></td>
<td style="text-align:left">Filters running containers connected to a given network.</td>
</tr>
<tr>
<td style="text-align:center"><code>publish</code> or <code>expose</code></td>
<td style="text-align:left">Filters containers which publish or expose a given port. Expressed as <code>&lt;port&gt;[/&lt;proto&gt;]</code> or <code>&lt;startport-endport&gt;/[&lt;proto&gt;]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>health</code></td>
<td style="text-align:left">Filters containers based on their healthcheck status. One of <code>starting</code>, <code>healthy</code>, <code>unhealthy</code> or <code>none</code>.</td>
</tr>
<tr>
<td style="text-align:center"><code>isolation</code></td>
<td style="text-align:left">Windows daemon only. One of <code>default</code>, <code>process</code>, or <code>hyperv</code>.</td>
</tr>
<tr>
<td style="text-align:center"><code>is-task</code></td>
<td style="text-align:left">Filters containers that are a “task” for a service. Boolean option (<code>true</code> or <code>false</code>)</td>
</tr>
</tbody>
</table>
<p>ex 列出所有状态为退出的容器: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps -q --filter status=exited</span><br></pre></td></tr></table></figure>
<h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker logs [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure>
<p>OPTIONS说明: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-f : 跟踪日志输出</span><br><span class="line"></span><br><span class="line">--since :显示某个开始时间的所有日志</span><br><span class="line"></span><br><span class="line">-t : 显示时间戳</span><br><span class="line"></span><br><span class="line">--tail :仅列出最新N条容器日志</span><br></pre></td></tr></table></figure>
<h2 id="数据拷贝"><a href="#数据拷贝" class="headerlink" title="数据拷贝"></a>数据拷贝</h2><p>docker cp :用于容器与主机之间的数据拷贝. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-</span><br><span class="line"></span><br><span class="line">docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH</span><br></pre></td></tr></table></figure>
<p>OPTIONS说明: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-L :保持源目标中的链接</span><br></pre></td></tr></table></figure>
<p><strong>实例</strong></p>
<p>将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker cp /www/runoob 96f7f14e99ab:/www/</span><br></pre></td></tr></table></figure>
<p>将主机/www/runoob目录拷贝到容器96f7f14e99ab中, 目录重命名为www. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker cp /www/runoob 96f7f14e99ab:/www</span><br></pre></td></tr></table></figure>
<p>将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker cp  96f7f14e99ab:/www /tmp/</span><br></pre></td></tr></table></figure>
<h1 id="Volume的相关操作"><a href="#Volume的相关操作" class="headerlink" title="Volume的相关操作"></a>Volume的相关操作</h1><p>Usage:    docker volume COMMAND</p>
<table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://docs.docker.com/engine/reference/commandline/volume_create/" rel="external nofollow noopener noreferrer" target="_blank">docker volume create</a></td>
<td>Create a volume</td>
</tr>
<tr>
<td><a href="https://docs.docker.com/engine/reference/commandline/volume_inspect/" rel="external nofollow noopener noreferrer" target="_blank">docker volume inspect</a></td>
<td>Display detailed information on one or more volumes</td>
</tr>
<tr>
<td><a href="https://docs.docker.com/engine/reference/commandline/volume_ls/" rel="external nofollow noopener noreferrer" target="_blank">docker volume ls</a></td>
<td>List volumes</td>
</tr>
<tr>
<td><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/" rel="external nofollow noopener noreferrer" target="_blank">docker volume prune</a></td>
<td>Remove all unused volumes</td>
</tr>
<tr>
<td><a href="https://docs.docker.com/engine/reference/commandline/volume_rm/" rel="external nofollow noopener noreferrer" target="_blank">docker volume rm</a></td>
<td>Remove one or more volumes</td>
</tr>
</tbody>
</table>
<p>ex 删除所有悬浮的volume: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker volume rm $(docker volume ls -q -f dangling=true)</span><br></pre></td></tr></table></figure>
<h2 id="选择-v-还是-–mount-参数"><a href="#选择-v-还是-–mount-参数" class="headerlink" title="选择 -v 还是 -–mount 参数"></a>选择 -v 还是 -–mount 参数</h2><p>Docker 新用户应该选择 <code>--mount</code> 参数, 经验丰富的 Docker 使用者对 <code>-v</code> 或者 <code>--volume</code> 已经很熟悉了, 但是推荐使用 <code>--mount</code> 参数. </p>
<p>使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录到容器中去. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run -d -P \</span><br><span class="line">--name web \</span><br><span class="line">--mount type=bind,source=/src/webapp,target=/opt/webapp \</span><br><span class="line">training/webapp \</span><br><span class="line">python app.py</span><br></pre></td></tr></table></figure>
<p>上面的命令加载主机的 <code>/src/webapp</code> 目录到容器的 <code>/opt/webapp</code>目录. 这个功能在进行测试的时候十分方便, 比如用户可以放置一些程序到本地目录中, 来查看容器是否正常工作. 本地目录的路径必须是<strong>绝对路径</strong>, 以前使用 <code>-v</code> 参数时<strong>如果本地目录不存在</strong> Docker 会<strong>自动为你创建</strong>一个文件夹, 现在使用 <code>--mount</code> 参数时如果本地目录不存在, Docker 会<strong>报错</strong>. </p>
<p>Docker 挂载主机目录的默认权限是 <code>读写</code>, 用户也可以通过增加 <code>readonly</code> 指定为 <code>只读</code>. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -P \</span><br><span class="line">--name web \</span><br><span class="line">--mount type=bind,source=/src/webapp,target=/opt/webapp,readonly \</span><br><span class="line">training/webapp \</span><br><span class="line">python app.py</span><br></pre></td></tr></table></figure>
<h1 id="Network的相关操作"><a href="#Network的相关操作" class="headerlink" title="Network的相关操作"></a>Network的相关操作</h1><p>基本命令: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker network create</span><br><span class="line">docker network connect</span><br><span class="line">docker network ls</span><br><span class="line">docker network rm</span><br><span class="line">docker network disconnect</span><br><span class="line">docker network inspect</span><br></pre></td></tr></table></figure>
<p>下面先创建一个新的 Docker 网络. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker network create -d bridge my-net</span><br></pre></td></tr></table></figure>
<p><code>-d</code> 参数指定 Docker 网络类型, 有 <code>bridge</code> <code>overlay</code>. 其中 <code>overlay</code> 网络类型用于 Swarm mode</p>
<p>容器链接网络: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it --rm --name busybox1 --network my-net busybox sh</span><br></pre></td></tr></table></figure>
<p>创建一个Swarm mode网络: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker network create \</span><br><span class="line">--driver overlay \</span><br><span class="line">--opt encrypted \</span><br><span class="line">--attachable \</span><br><span class="line">--subnet 10.0.9.0/24 \</span><br><span class="line">--gateway 10.0.9.99 \</span><br><span class="line">my-network</span><br></pre></td></tr></table></figure>
<h1 id="Dockerfile-详解"><a href="#Dockerfile-详解" class="headerlink" title="Dockerfile 详解"></a>Dockerfile 详解</h1><p><img src="https://cdn.yangbingdong.com/img/note-of-dockerfile/dockerfile.jpg" alt></p>
<blockquote>
<p>制作一个镜像可以使用<code>docker commit</code>和定制Dockerfile, 但推荐的是写Dockerfile. </p>
<p>因为<code>docker commit</code>是一个<strong>暗箱操作</strong>, 除了制作镜像的人知道执行过什么命令、怎么生成的镜像, 别人根本无从得知, 而且会加入一些没用的操作导致镜像<strong>臃肿</strong>. </p>
</blockquote>
<h2 id="Build-Images"><a href="#Build-Images" class="headerlink" title="Build Images"></a>Build Images</h2><p>首先在当前空目录创建一个Dockerfile:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM ubuntu:latest</span><br><span class="line"></span><br><span class="line">ENV BLOG_PATH /root/blog</span><br><span class="line">ENV NODE_VERSION 6</span><br><span class="line"></span><br><span class="line">MAINTAINER yangbingdong &lt;yangbingdong1994@gmail.com&gt;</span><br><span class="line"></span><br><span class="line">RUN \</span><br><span class="line">    apt-get update -y &amp;&amp; \</span><br><span class="line">    apt-get install -y git curl libpng-dev &amp;&amp; \</span><br><span class="line">    curl -sL https://deb.nodesource.com/setup_$NODE_VERSION.x | bash - &amp;&amp; \</span><br><span class="line">    apt-get install -y nodejs &amp;&amp; \</span><br><span class="line">    apt-get clean &amp;&amp; \</span><br><span class="line">    apt-get autoclean &amp;&amp; \</span><br><span class="line">    rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/* &amp;&amp; \</span><br><span class="line">    npm install -g hexo-cli</span><br><span class="line"></span><br><span class="line">WORKDIR $BLOG_PATH</span><br><span class="line"></span><br><span class="line">VOLUME [&quot;$BLOG_PATH&quot;, &quot;/root/.ssh&quot;]</span><br><span class="line"></span><br><span class="line">EXPOSE 4000</span><br><span class="line"></span><br><span class="line">CMD [&apos;/bin/bash&apos;]</span><br></pre></td></tr></table></figure></p>
<p>然后在当前目录打开终端:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t &lt;repo-name&gt;/&lt;image-name&gt;:&lt;tag&gt; .</span><br></pre></td></tr></table></figure></p>
<p>其中<code>&lt;repo-name&gt;</code>表示仓库名, 与远程仓库（如docker hub）名字要一致, <code>&lt;tag&gt;</code>表示标签, 不给默认<code>latest</code>, 都是<strong>可选项</strong>, 例如可以写成这样:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t &lt;image-name&gt; .</span><br></pre></td></tr></table></figure></p>
<p><img src="https://cdn.yangbingdong.com/img/note-of-dockerfile/docker-build.png" alt></p>
<p>看到<code>Successfully built</code>就表示构建成功了</p>
<p>注意<code>docker build</code> 命令最后有一个 <code>.</code>表示构建的<strong>上下文</strong>, 镜像构建需要把上下文的东西上传到Docker引擎去构建. </p>
<h2 id="Dockerfile-指令"><a href="#Dockerfile-指令" class="headerlink" title="Dockerfile 指令"></a>Dockerfile 指令</h2><h3 id="From-指定基础镜像"><a href="#From-指定基础镜像" class="headerlink" title="From 指定基础镜像"></a>From 指定基础镜像</h3><p>所谓定制镜像, 那一定是以一个镜像为基础, 在其上进行定制. 而 <code>FROM</code> 就是指定<strong>基础镜像</strong>, 因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令, 并且必须是第一条指令. </p>
<p>在 <a href="https://hub.docker.com/explore/" rel="external nofollow noopener noreferrer" target="_blank">Docker Hub</a>上有非常多的高质量的官方镜像, 有可以直接拿来使用的服务类的镜像, 如 <a href="https://hub.docker.com/_/nginx/" rel="external nofollow noopener noreferrer" target="_blank"><code>nginx</code></a>、<a href="https://hub.docker.com/_/redis/" rel="external nofollow noopener noreferrer" target="_blank"><code>redis</code></a>、<a href="https://hub.docker.com/_/mongo/" rel="external nofollow noopener noreferrer" target="_blank"><code>mongo</code></a>、<a href="https://hub.docker.com/_/mysql/" rel="external nofollow noopener noreferrer" target="_blank"><code>mysql</code></a>、<a href="https://hub.docker.com/_/httpd/" rel="external nofollow noopener noreferrer" target="_blank"><code>httpd</code></a>、<a href="https://hub.docker.com/_/php/" rel="external nofollow noopener noreferrer" target="_blank"><code>php</code></a>、<a href="https://hub.docker.com/_/tomcat/" rel="external nofollow noopener noreferrer" target="_blank"><code>tomcat</code></a> 等； 也有一些方便开发、构建、运行各种语言应用的镜像, 如 <a href="https://hub.docker.com/_/node/" rel="external nofollow noopener noreferrer" target="_blank"><code>node</code></a>、<a href="https://hub.docker.com/_/openjdk/" rel="external nofollow noopener noreferrer" target="_blank"><code>openjdk</code></a>、<a href="https://hub.docker.com/_/python/" rel="external nofollow noopener noreferrer" target="_blank"><code>python</code></a>、<a href="https://hub.docker.com/_/ruby/" rel="external nofollow noopener noreferrer" target="_blank"><code>ruby</code></a>、<a href="https://hub.docker.com/_/golang/" rel="external nofollow noopener noreferrer" target="_blank"><code>golang</code></a> 等. 可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制. 如果没有找到对应服务的镜像, 官方镜像中还提供了一些更为基础的操作系统镜像, 如 <a href="https://hub.docker.com/_/ubuntu/" rel="external nofollow noopener noreferrer" target="_blank"><code>ubuntu</code></a>、<a href="https://hub.docker.com/_/debian/" rel="external nofollow noopener noreferrer" target="_blank"><code>debian</code></a>、<a href="https://hub.docker.com/_/centos/" rel="external nofollow noopener noreferrer" target="_blank"><code>centos</code></a>、<a href="https://hub.docker.com/_/fedora/" rel="external nofollow noopener noreferrer" target="_blank"><code>fedora</code></a>、<a href="https://hub.docker.com/_/alpine/" rel="external nofollow noopener noreferrer" target="_blank"><code>alpine</code></a> 等, 这些操作系统的软件库为我们提供了更广阔的扩展空间. </p>
<p>除了选择现有镜像为基础镜像外, Docker 还存在一个特殊的镜像, 名为 <code>scratch</code>. 这个镜像是虚拟的概念, 并不实际存在, 它表示一个空白的镜像. </p>
<h3 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h3><p><code>RUN</code> 指令是用来执行命令行命令的. 由于命令行的强大能力, <code>RUN</code> 指令在定制镜像时是最常用的指令之一. 其格式有两种: </p>
<ul>
<li><p><em>shell</em> 格式: <code>RUN &lt;命令&gt;</code>, 就像直接在命令行中输入的命令一样. 刚才写的 Dockrfile 中的 <code>RUN</code> 指令就是这种格式. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RUN echo &apos;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure>
</li>
<li><p><em>exec</em> 格式: <code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>, 这更像是函数调用中的格式. </p>
</li>
</ul>
<p><strong>注意</strong>: </p>
<ul>
<li>RUN命令尽量精简, 也就是像上面一样一个RUN（使用<code>$$ \</code>）, 如果分开写很多个RUN会导致镜像铺了很多层从而臃肿. </li>
<li>RUN最后记住清理掉没用的垃圾, 很多人初学 Docker 制作出了很臃肿的镜像的原因之一, 就是忘记了每一层构建的最后一定要清理掉无关文件. </li>
</ul>
<h3 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h3><p>格式: </p>
<ul>
<li><code>COPY &lt;源路径&gt;... &lt;目标路径&gt;</code></li>
<li><code>COPY [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li>
</ul>
<p>和 <code>RUN</code> 指令一样, 也有两种格式, 一种类似于命令行, 一种类似于函数调用. </p>
<p><code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置. 比如:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPY package.json /usr/src/app/</span><br></pre></td></tr></table></figure></p>
<h3 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h3><p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致. 但是在 <code>COPY</code> 基础上增加了一些功能. </p>
<p>比如 <code>&lt;源路径&gt;</code> 可以是一个 <code>URL</code>, 这种情况下, Docker 引擎会试图去下载这个链接的文件放到 <code>&lt;目标路径&gt;</code> 去. 下载后的文件权限自动设置为 <code>600</code>, 如果这并不是想要的权限, 那么还需要增加额外的一层 <code>RUN</code>进行权限调整, 另外, 如果下载的是个压缩包, 需要解压缩, 也一样还需要额外的一层 <code>RUN</code> 指令进行解压缩. 所以不如直接使用 <code>RUN</code> 指令, 然后使用 <code>wget</code> 或者 <code>curl</code> 工具下载, 处理权限、解压缩、然后清理无用文件更合理. 因此, 这个功能其实并不实用, 而且不推荐使用. </p>
<p>如果 <code>&lt;源路径&gt;</code> 为一个 <code>tar</code> 压缩文件的话, 压缩格式为 <code>gzip</code>, <code>bzip2</code> 以及 <code>xz</code> 的情况下, <code>ADD</code> 指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径&gt;</code> 去. </p>
<p>在某些情况下, 这个自动解压缩的功能非常有用, 比如官方镜像 <code>ubuntu</code> 中: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line">ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>但在某些情况下, 如果我们真的是希望复制个压缩文件进去, 而不解压缩, 这时就不可以使用 <code>ADD</code> 命令了. </p>
<p>在 Docker 官方的最佳实践文档中要求, 尽可能的使用 <code>COPY</code>, 因为 <code>COPY</code> 的语义很明确, 就是复制文件而已, 而 <code>ADD</code> 则包含了更复杂的功能, 其行为也不一定很清晰. 最适合使用 <code>ADD</code> 的场合, 就是所提及的需要自动解压缩的场合. </p>
<p>另外需要注意的是, <code>ADD</code> 指令会令镜像构建缓存失效, 从而可能会令镜像构建变得比较缓慢. </p>
<p>因此在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候, 可以遵循这样的原则, 所有的文件复制均使用 <code>COPY</code> 指令, 仅在需要自动解压缩的场合使用 <code>ADD</code>. </p>
<h3 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h3><p><code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的. </p>
<p><code>CMD</code> 指令的格式和 <code>RUN</code> 相似, 也是两种格式: </p>
<ul>
<li><code>shell</code> 格式: <code>CMD &lt;命令&gt;</code></li>
<li><code>exec</code> 格式: <code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li>
<li>参数列表格式: <code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>. 在指定了 <code>ENTRYPOINT</code> 指令后, 用 <code>CMD</code> 指定具体的参数. </li>
</ul>
<p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令, 比如, <code>ubuntu</code> 镜像默认的 <code>CMD</code> 是 <code>/bin/bash</code>, 如果我们直接 <code>docker run -it ubuntu</code> 的话, 会直接进入 <code>bash</code>. 我们也可以在运行时指定运行别的命令, 如 <code>docker run -it ubuntu cat /etc/os-release</code>. 这就是用 <code>cat /etc/os-release</code> 命令替换了默认的 <code>/bin/bash</code> 命令了, 输出了系统版本信息. </p>
<p>在指令格式上, 一般推荐使用 <code>exec</code> 格式, 这类格式在解析时会被解析为 JSON 数组, 因此一定要使用双引号 <code>&quot;</code>, 而不要使用单引号. </p>
<p>如果使用 <code>shell</code> 格式的话, 实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行. 比如:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CMD echo $HOME</span><br></pre></td></tr></table></figure></p>
<p>在实际执行中, 会将其变更为:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ]</span><br></pre></td></tr></table></figure></p>
<p>所以如果使用<code>shell</code>格式会导致容器<strong>莫名退出</strong>, 因为实际上执行的事<code>sh</code>命令, 而<code>sh</code>命令执行完时候容器也就没有存在的意义. </p>
<h3 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h3><p><code>ENTRYPOINT</code> 的格式和 <code>RUN</code> 指令格式一样, 分为 <code>exec</code> 格式和 <code>shell</code> 格式. </p>
<p><code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样, 都是在指定容器启动程序及参数. <code>ENTRYPOINT</code> 在运行时也可以替代, 不过比 <code>CMD</code> 要略显繁琐, 需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定. </p>
<p>当指定了 <code>ENTRYPOINT</code> 后, <code>CMD</code> 的含义就发生了改变, 不再是直接的运行其命令, 而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令, 换句话说实际执行时, 将变为: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</span><br></pre></td></tr></table></figure>
<p>这个指令非常有用, 例如可以把命令后面的参数传进来或启动容器前准备一些环境然后执行启动命令（通过脚本<code>exec &quot;$@&quot;</code>）. </p>
<h3 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h3><p>格式有两种: </p>
<ul>
<li><code>ENV &lt;key&gt; &lt;value&gt;</code></li>
<li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li>
</ul>
<p>这个指令很简单, 就是设置环境变量而已, 无论是后面的其它指令, 如 <code>RUN</code>, 还是运行时的应用, 都可以直接使用这里定义的环境变量. </p>
<p>ex: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENV NODE_VERSION 6</span><br><span class="line">...</span><br><span class="line">RUN curl -sL https://deb.nodesource.com/setup_$NODE_VERSION.x | bash - &amp;&amp; \</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h3><p>格式: <code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p>
<p>构建参数和 <code>ENV</code> 的效果一样, 都是设置环境变量. 所不同的是, <code>ARG</code> 所设置的构建环境的环境变量, 在将来容器运行时是不会存在这些环境变量的. 但是不要因此就使用 <code>ARG</code> 保存密码之类的信息, 因为 <code>docker history</code> 还是可以看到所有值的. </p>
<p><code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称, 以及定义其默认值. 该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖. </p>
<p>在 1.13 之前的版本, 要求 <code>--build-arg</code> 中的参数名, 必须在 <code>Dockerfile</code> 中用 <code>ARG</code> 定义过了, 换句话说, 就是 <code>--build-arg</code> 指定的参数, 必须在 <code>Dockerfile</code> 中使用了. 如果对应参数没有被使用, 则会报错退出构建. 从 1.13 开始, 这种严格的限制被放开, 不再报错退出, 而是显示警告信息, 并继续构建. 这对于使用 CI 系统, 用同样的构建流程构建不同的 <code>Dockerfile</code> 的时候比较有帮助, 避免构建命令必须根据每个 Dockerfile 的内容修改. </p>
<h3 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h3><p>格式为: </p>
<ul>
<li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li>
<li><code>VOLUME &lt;路径&gt;</code></li>
</ul>
<p>之前我们说过, 容器运行时应该尽量保持容器存储层不发生写操作, 对于数据库类需要保存动态数据的应用, 其数据库文件应该保存于卷(volume)中, 后面的章节我们会进一步介绍 Docker 卷的概念. 为了防止运行时用户忘记将动态文件所保存目录挂载为卷, 在 <code>Dockerfile</code> 中, 我们可以事先指定某些目录挂载为匿名卷, 这样在运行时如果用户不指定挂载, 其应用也可以正常运行, 不会向容器存储层写入大量数据.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VOLUME /data</span><br></pre></td></tr></table></figure></p>
<p>这里的 <code>/data</code> 目录就会在运行时自动挂载为匿名卷, 任何向 <code>/data</code> 中写入的信息都不会记录进容器存储层, 从而保证了容器存储层的无状态化. 当然, 运行时可以覆盖这个挂载设置. 比如:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -v mydata:/data xxxx</span><br></pre></td></tr></table></figure></p>
<p>在这行命令中, 就使用了 <code>mydata</code> 这个命名卷挂载到了 <code>/data</code> 这个位置, 替代了 <code>Dockerfile</code> 中定义的匿名卷的挂载配置. </p>
<h3 id="EXPOSE-声明端口"><a href="#EXPOSE-声明端口" class="headerlink" title="EXPOSE 声明端口"></a>EXPOSE 声明端口</h3><p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>.<br><code>EXPOSE</code> 指令是声明运行时容器提供服务端口, 这只是一个声明, 在运行时并不会因为这个声明应用就会开启这个端口的服务. 在 Dockerfile 中写入这样的声明有两个好处, 一个是帮助镜像使用者理解这个镜像服务的守护端口, 以方便配置映射；另一个用处则是在运行时使用随机端口映射时, 也就是 <code>docker run -P</code>时, 会自动随机映射 <code>EXPOSE</code> 的端口. </p>
<p>此外, 在早期 Docker 版本中还有一个特殊的用处. 以前所有容器都运行于默认桥接网络中, 因此所有容器互相之间都可以直接访问, 这样存在一定的安全性问题. 于是有了一个 Docker 引擎参数 <code>--icc=false</code>, 当指定该参数后, 容器间将默认无法互访, 除非互相间使用了 <code>--links</code> 参数的容器才可以互通, 并且只有镜像中 <code>EXPOSE</code> 所声明的端口才可以被访问. 这个 <code>--icc=false</code> 的用法, 在引入了 <code>docker network</code>后已经基本不用了, 通过自定义网络可以很轻松的实现容器间的互联与隔离. </p>
<p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来. <code>-p</code>, 是映射宿主端口和容器端口, 换句话说, 就是将容器的对应端口服务公开给外界访问, 而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已, 并不会自动在宿主进行端口映射. </p>
<h3 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h3><p>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code>.<br>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录）, 以后各层的当前目录就被改为指定的目录, 如该目录不存在, <code>WORKDIR</code> 会帮你建立目录. </p>
<p>之前提到一些初学者常犯的错误是把 <code>Dockerfile</code> 等同于 Shell 脚本来书写, 这种错误的理解还可能会导致出现下面这样的错误:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RUN cd /app</span><br><span class="line">RUN echo &quot;hello&quot; &gt; world.txt</span><br></pre></td></tr></table></figure></p>
<p>如果将这个 Dockerfile 进行构建镜像运行后, 会发现找不到 <code>/app/world.txt</code> 文件, 或者其内容不是 <code>hello</code>. 原因其实很简单, 在 Shell 中, 连续两行是同一个进程执行环境, 因此前一个命令修改的内存状态, 会直接影响后一个命令；而在 Dockerfile 中, 这两行 <code>RUN</code> 命令的执行环境根本不同, 是两个完全不同的容器. 这就是对 Dokerfile 构建分层存储的概念不了解所导致的错误. </p>
<p>之前说过每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更. 第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更, 一个内存上的变化而已, 其结果不会造成任何文件变更. 而到第二层的时候, 启动的是一个全新的容器, 跟第一层的容器更完全没关系, 自然不可能继承前一层构建过程中的内存变化. </p>
<p>因此如果需要改变以后各层的工作目录的位置, 那么应该使用 <code>WORKDIR</code> 指令. </p>
<h3 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a>USER 指定当前用户</h3><p>格式: <code>USER &lt;用户名&gt;</code></p>
<p><code>USER</code> 指令和 <code>WORKDIR</code> 相似, 都是改变环境状态并影响以后的层. <code>WORKDIR</code> 是改变工作目录, <code>USER</code>则是改变之后层的执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份. </p>
<p>当然, 和 <code>WORKDIR</code> 一样, <code>USER</code> 只是帮助你切换到指定用户而已, 这个用户必须是事先建立好的, 否则无法切换. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis</span><br><span class="line">USER redis</span><br><span class="line">RUN [ &quot;redis-server&quot; ]</span><br></pre></td></tr></table></figure>
<h3 id="HEALTHCHECK-健康检查"><a href="#HEALTHCHECK-健康检查" class="headerlink" title="HEALTHCHECK 健康检查"></a>HEALTHCHECK 健康检查</h3><p>格式: </p>
<ul>
<li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>: 设置检查容器健康状况的命令</li>
<li><code>HEALTHCHECK NONE</code>: 如果基础镜像有健康检查指令, 使用这行可以屏蔽掉其健康检查指令</li>
</ul>
<p><code>HEALTHCHECK</code> 支持下列选项: </p>
<ul>
<li><code>--interval=&lt;间隔&gt;</code>: 两次健康检查的间隔, 默认为 30 秒；</li>
<li><code>--timeout=&lt;间隔&gt;</code>: 健康检查命令运行超时时间, 如果超过这个时间, 本次健康检查就被视为失败, 默认 30 秒；</li>
<li><code>--retries=&lt;次数&gt;</code>: 当连续失败指定次数后, 则将容器状态视为 <code>unhealthy</code>, 默认 3 次. </li>
<li><code>--start-period=&lt;间隔&gt;</code>: 应用的启动的初始化时间, 在启动过程中的健康检查失效不会计入, 默认 0 秒； (从17.05)引入</li>
</ul>
<p>在 <code>HEALTHCHECK [选项] CMD</code> 后面的命令, 格式和 <code>ENTRYPOINT</code> 一样, 分为 <code>shell</code> 格式, 和 <code>exec</code> 格式. 命令的返回值决定了该次健康检查的成功与否: </p>
<ul>
<li><code>0</code>: 成功；</li>
<li><code>1</code>: 失败；</li>
<li><code>2</code>: 保留值, 不要使用</li>
</ul>
<p>容器启动之后, 初始状态会为 <code>starting</code> (启动中). Docker Engine会等待 <code>interval</code> 时间, 开始执行健康检查命令, 并周期性执行. 如果单次检查返回值非0或者运行需要比指定 <code>timeout</code> 时间还长, 则本次检查被认为失败. 如果健康检查连续失败超过了 <code>retries</code> 重试次数, 状态就会变为 <code>unhealthy</code> (不健康). </p>
<p>注: </p>
<ul>
<li>一旦有一次健康检查成功, Docker会将容器置回 <code>healthy</code> (健康)状态</li>
<li>当容器的健康状态发生变化时, Docker Engine会发出一个 <code>health_status</code> 事件. </li>
</ul>
<p>假设我们有个镜像是个最简单的 Web 服务, 我们希望增加健康检查来判断其 Web 服务是否在正常工作, 我们可以用 <code>curl</code>来帮助判断, 其 <code>Dockerfile</code> 的 <code>HEALTHCHECK</code> 可以这么写: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM elasticsearch:5.5</span><br><span class="line"></span><br><span class="line">HEALTHCHECK --interval=5s --timeout=2s --retries=12 \</span><br><span class="line">  CMD curl --silent --fail localhost:9200/_cluster/health || exit 1</span><br></pre></td></tr></table></figure>
<h2 id="ENTRYPOINT与CMD使用区别"><a href="#ENTRYPOINT与CMD使用区别" class="headerlink" title="ENTRYPOINT与CMD使用区别"></a>ENTRYPOINT与CMD使用区别</h2><table>
<thead>
<tr>
<th></th>
<th>No ENTRYPOINT</th>
<th>ENTRYPOINT entry arg0</th>
<th>ENTRYPOINT [“entry”, “arg0”]</th>
</tr>
</thead>
<tbody>
<tr>
<td>No CMD</td>
<td>error, not allowed</td>
<td>/bin/sh -c entry arg0</td>
<td>entry arg0</td>
</tr>
<tr>
<td>CMD [“cmd”, “arg1”]</td>
<td>cmd arg1</td>
<td>/bin/sh -c entry arg0</td>
<td>entry arg0 cmd arg1</td>
</tr>
<tr>
<td>CMD cmd arg1</td>
<td>/bin/sh -c cmd arg1</td>
<td>/bin/sh -c entry arg0</td>
<td>entry arg0 /bin/sh -c cmd arg1</td>
</tr>
</tbody>
</table>
<p>上表源于官方文档中的<a href="https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact" rel="external nofollow noopener noreferrer" target="_blank">Understand how CMD and ENTRYPOINT interact</a>, 有所简化. </p>
<ol>
<li>ENTRYPOINT和CMD至少要有一个. </li>
<li>使用<code>ENTRYPOINT entry arg0</code>形式, 与CMD将没有任何配合. 因此, 除非特定需求, 否则不推荐这种使用方式. </li>
<li>右下角<code>entry arg0 /bin/sh -c cmd arg1</code>这种形式, 几乎没有什么使用场景, 反而是常见错误, 应该尽量避免. </li>
</ol>
<p>本质上, 其实可以理解为ENTRYPOINT是真正的Docker可执行入口, 而CMD则是可选参数. 之所以在很多情况下直接写CMD也能生效, 是因为ENTRYPOINT就相当于是指定Shell, 而CMD则是指定Shell中执行的命令. 注意, 只是『相当于』. </p>
<h3 id="注意PID"><a href="#注意PID" class="headerlink" title="注意PID"></a>注意PID</h3><p>原则上, 一个Docker容器里应该只有一个进程, 其PID为1. Docker外部的操作, 比如<code>docker stop</code>, 就是向这个进程<strong>发送信号</strong>. <strong>如果那个唯一的前台进程PID不为1, 那么就会收不到信号, 只能在超时（默认约10秒）后被kill</strong>. </p>
<p>在Dockerfile中使用<code>ENTRYPOINT entry arg0</code>这种形式时, <code>entry</code>的位置总是应该使用<code>exec</code>, 后面再接其它内容. 比如, <code>ENTRYPOINT exec top</code>, 这可以确保<code>top</code>命令是PID为1的进程. 否则, <code>ENTRYPOINT top</code>的形式, PID为1的进程就是<code>/bin/sh -c top</code>, 而<code>top</code>则被挤到了另外一个进程. </p>
<h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><ul>
<li>Dockerfile里也需要注意<strong>权限问题</strong>（nodejs7版本以上不能正常安装hexo, 需要创建用户并制定权限去安装）</li>
<li>在docker容器里如果是root用户对挂载的文件进行了操作, 那么实际上挂载文件的<strong>权限也变成了root的</strong></li>
<li>使用attach进入容器, 退出的时候容器也跟着退出了. . . 囧</li>
<li>每一个RUN是一个<strong>新的shell</strong></li>
<li><code>su -</code>之前在启动脚本加了<code>-</code>, 导致<strong>环境变量以及工作目录都变了</strong></li>
</ul>
<h2 id="Hexo-Dockerfile"><a href="#Hexo-Dockerfile" class="headerlink" title="Hexo Dockerfile"></a>Hexo Dockerfile</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line"></span><br><span class="line">MAINTAINER yangbingdong &lt;yangbingdong1994@gmail.com&gt;</span><br><span class="line"></span><br><span class="line">USER root</span><br><span class="line"></span><br><span class="line">ENV NODE_VERSION 8.9.4</span><br><span class="line">ENV NODE_DIR /opt/nodejs</span><br><span class="line">ENV HOXO_DIR /root/hexo</span><br><span class="line"></span><br><span class="line">RUN apt-get update &amp;&amp; \</span><br><span class="line">	apt-get install -y git curl &amp;&amp; \</span><br><span class="line">	mkdir $&#123;NODE_DIR&#125; &amp;&amp; \</span><br><span class="line">	curl -L https://nodejs.org/dist/v$&#123;NODE_VERSION&#125;/node-v$&#123;NODE_VERSION&#125;-linux-x64.tar.gz | tar xvzf - -C $&#123;NODE_DIR&#125; --strip-components=1 </span><br><span class="line">     </span><br><span class="line">ENV PATH $PATH:$&#123;NODE_DIR&#125;/bin</span><br><span class="line"></span><br><span class="line">RUN npm install -g hexo-cli</span><br><span class="line"></span><br><span class="line">ENV PATH $PATH:$&#123;NODE_DIR&#125;/bin</span><br><span class="line"></span><br><span class="line">RUN cd /root &amp;&amp; \</span><br><span class="line">	hexo init hexo &amp;&amp; \</span><br><span class="line">	cd hexo &amp;&amp; \</span><br><span class="line">	git clone https://github.com/iissnan/hexo-theme-next themes/next &amp;&amp; \</span><br><span class="line">	npm install &amp;&amp; \</span><br><span class="line">	apt-get clean &amp;&amp; \</span><br><span class="line">	apt-get autoremove -y &amp;&amp; \</span><br><span class="line">	rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*</span><br><span class="line"></span><br><span class="line">VOLUME [&quot;/root/hexo/source/_posts&quot;] </span><br><span class="line"></span><br><span class="line">WORKDIR /root/hexo</span><br><span class="line"></span><br><span class="line">COPY docker-entrypoint.sh /docker-entrypoint.sh</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;/docker-entrypoint.sh&quot;]</span><br></pre></td></tr></table></figure>
<p><code>docker-entrypoint.sh</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">set -e</span><br><span class="line">hexo clean &amp;&amp; hexo server</span><br><span class="line">exec &quot;$@&quot;</span><br></pre></td></tr></table></figure>
<h1 id="修改Docker默认镜像-容器存放位置"><a href="#修改Docker默认镜像-容器存放位置" class="headerlink" title="修改Docker默认镜像, 容器存放位置"></a>修改Docker默认镜像, 容器存放位置</h1><h2 id="方法一、软链接"><a href="#方法一、软链接" class="headerlink" title="方法一、软链接"></a>方法一、软链接</h2><p>默认情况下Docker的存放位置为: <code>/var/lib/docker</code><br>可以通过下面命令查看具体位置: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker info | grep &quot;Docker Root Dir&quot;</span><br></pre></td></tr></table></figure>
<p>解决这个问题, 最直接的方法当然是挂载分区到这个目录, 但是我的数据盘还有其他东西, 这肯定不好管理, 所以采用修改镜像和容器的存放路径的方式达到目的. </p>
<p>这个方法里将通过软连接来实现. </p>
<p>首先停掉Docker服务: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br><span class="line">或者</span><br><span class="line">service docker stop</span><br></pre></td></tr></table></figure>
<p>然后移动整个<code>/var/lib/docker</code>目录到目的路径: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv /var/lib/docker /root/data/docker</span><br><span class="line">ln -s /root/data/docker /var/lib/docker</span><br></pre></td></tr></table></figure>
<p>这时候启动Docker时发现存储目录依旧是<code>/var/lib/docker</code>, 但是实际上是存储在数据盘的, 你可以在数据盘上看到容量变化. </p>
<h2 id="方法二、修改镜像和容器的存放路径"><a href="#方法二、修改镜像和容器的存放路径" class="headerlink" title="方法二、修改镜像和容器的存放路径"></a>方法二、修改镜像和容器的存放路径</h2><p>指定镜像和容器存放路径的参数是<code>--graph=/var/lib/docker</code>, 我们只需要修改配置文件指定启动参数即可. </p>
<p>Docker 的配置文件可以设置大部分的后台进程参数, 在各个操作系统中的存放位置不一致, 在 Ubuntu 中的位置是: <code>/etc/default/docker</code>, 在 CentOS 中的位置是: <code>/etc/sysconfig/docker</code>. </p>
<p>如果是 CentOS 则添加下面这行: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OPTIONS=--graph=&quot;/root/data/docker&quot; --selinux-enabled -H fd://</span><br></pre></td></tr></table></figure>
<p>如果是 Ubuntu 则添加下面这行（因为 Ubuntu 默认没开启 selinux）: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OPTIONS=--graph=&quot;/root/data/docker&quot; -H fd://</span><br><span class="line"># 或者</span><br><span class="line">DOCKER_OPTS=&quot;-g /root/data/docker&quot;</span><br></pre></td></tr></table></figure>
<p>最后重新启动, Docker 的路径就改成 <code>/root/data/docker</code> 了. </p>
<h1 id="定期清理容器日志"><a href="#定期清理容器日志" class="headerlink" title="定期清理容器日志"></a>定期清理容器日志</h1><blockquote>
<p>参考: <a href="https://zhuanlan.zhihu.com/p/29051214" rel="external nofollow noopener noreferrer" target="_blank"><em>https://zhuanlan.zhihu.com/p/29051214</em></a></p>
</blockquote>
<h2 id="通过logrotate服务实现日志定期清理和回卷"><a href="#通过logrotate服务实现日志定期清理和回卷" class="headerlink" title="通过logrotate服务实现日志定期清理和回卷"></a>通过logrotate服务实现日志定期清理和回卷</h2><p>logrotate是个十分有用的工具, 它可以自动对日志进行截断（或轮循）、压缩以及删除旧的日志文件. 例如, 你可以设置logrotate, 让/var/log/foo日志文件每30天轮循, 并删除超过6个月的日志. 配置完后, logrotate的运作完全自动化, 不必进行任何进一步的人为干预. </p>
<p><strong><a href="https://github.com/blacklabelops/logrotate" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/blacklabelops/logrotate</a></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --restart=always \</span><br><span class="line">  --name=logrotate \</span><br><span class="line">  -v /var/lib/docker/containers:/var/lib/docker/containers \</span><br><span class="line">  -v /var/log/docker:/var/log/docker \</span><br><span class="line">  -e &quot;LOGS_DIRECTORIES=/var/lib/docker/containers /var/log/docker&quot; \</span><br><span class="line">  -e &quot;LOGROTATE_INTERVAL=daily&quot; \</span><br><span class="line">  blacklabelops/logrotate</span><br></pre></td></tr></table></figure>
<h2 id="通过修改dockerd参数进行回卷和清理"><a href="#通过修改dockerd参数进行回卷和清理" class="headerlink" title="通过修改dockerd参数进行回卷和清理"></a>通过修改dockerd参数进行回卷和清理</h2><p>在<code>/etc/docker/daemon.json</code>中添加<code>log-driver</code>以及<code>log-opts</code>参数: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://vioqnt8w.mirror.aliyuncs.com&quot;],</span><br><span class="line">  &quot;insecure-registries&quot;: [&quot;192.168.6.113:8888&quot;],</span><br><span class="line">  &quot;log-driver&quot;:&quot;json-file&quot;,</span><br><span class="line">  &quot;log-opts&quot;:&#123;</span><br><span class="line">    &quot;max-size&quot; :&quot;10m&quot;,&quot;max-file&quot;:&quot;3&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数说明: 设置单个容器日志超过10M则进行回卷, 回卷的副本数超过3个就进行清理. </p>
<p>重启docker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload &amp;&amp; sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<h1 id="数据卷备份与恢复"><a href="#数据卷备份与恢复" class="headerlink" title="数据卷备份与恢复"></a>数据卷备份与恢复</h1><h2 id="数据卷备份"><a href="#数据卷备份" class="headerlink" title="数据卷备份"></a>数据卷备份</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --rm \</span><br><span class="line">  --volumes-from &lt;ContainerName&gt; \</span><br><span class="line">  -v $(pwd):/backup \</span><br><span class="line">  busybox \</span><br><span class="line">  tar cvf /backup/backup.tar /data</span><br></pre></td></tr></table></figure>
<ul>
<li><code>--rm</code>: 执行完命令之后移除容器</li>
<li><code>--volumes-from &lt;Container&gt;</code>: 连接要备份数据的容器</li>
<li><code>-v $(pwd):/backup</code>: 挂载当前路径到容器 busybox 容器, 数据将会备份到此路径</li>
<li><code>busybox</code>: 非常小的镜像</li>
<li><code>tar cvf /backup/backup.tar /data</code>: 将 /data 路径下的文件打包到 backup.tar</li>
</ul>
<h2 id="数据卷恢复"><a href="#数据卷恢复" class="headerlink" title="数据卷恢复"></a>数据卷恢复</h2><p><strong>1、新建容器</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -v /data --name &lt;ContainerName&gt; &lt;Image&gt;</span><br></pre></td></tr></table></figure>
<p><strong>2、恢复数据</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --rm \</span><br><span class="line">  --volumes-from &lt;ContainerName&gt; \</span><br><span class="line">  -v $(pwd):/backup \</span><br><span class="line">  busybox \</span><br><span class="line">  tar xvf /backup/backup.tar</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意: 其中的路径 /data 仅为示例, 具体需要备份的文件路径请结合自身需求. </p>
</blockquote>
<h1 id="使用Github自动构建Docker"><a href="#使用Github自动构建Docker" class="headerlink" title="使用Github自动构建Docker"></a>使用Github自动构建Docker</h1><p><img src="https://cdn.yangbingdong.com/ima/docker-automated-built/github-docker.jpg" alt></p>
<blockquote>
<p>一开始玩Docker总是用别人的镜像确实很爽<del>歪歪</del>…<br>But, 如果要定制个性化的Image那就必须要自己写Dockerfile了, 但是每一次修改完Dockerfile, 都要经过几个步骤:<br>Built -&gt; Push -&gt; Delete invalid images<br>对于程序猿而言做重复的事情是很恐怖的, 所以博主选择Github自动构建Docker Image~</p>
</blockquote>
<h2 id="创建用于自动构建的仓库"><a href="#创建用于自动构建的仓库" class="headerlink" title="创建用于自动构建的仓库"></a>创建用于自动构建的仓库</h2><p>在Github上面创建一个项目并把Dockerfile以及上下文需要用到的文件放到里面. </p>
<h2 id="链接仓库服务"><a href="#链接仓库服务" class="headerlink" title="链接仓库服务"></a>链接仓库服务</h2><p>首先需要绑定一个仓库服务（Github）: </p>
<p>1、登录<code>Docker Hub</code>；<br>2、选择 <code>Profile</code> &gt; <code>Settings</code> &gt; <code>Linked Accounts &amp; Services</code>；<br>3、选择需要连接的仓库服务（目前只支持<code>Github</code>和<code>BitBucket</code>）；<br>4、这时候需要授权, 点击授权就可以了.<br><img src="https://cdn.yangbingdong.com/ima/docker-automated-built/add-repo-service.png" alt></p>
<h2 id="创建一个自动构建"><a href="#创建一个自动构建" class="headerlink" title="创建一个自动构建"></a>创建一个自动构建</h2><p>自动构建需要创建对应的仓库类型<br>自动构建仓库也可以使用<code>docker push</code>把已有的镜像上传上去<br>1、选择<code>Create</code> &gt; <code>Create Automated Build</code>；<br>2、选择<code>Github</code>；<br>3、接下来会列出<code>User/Organizations</code>的所有项目, 从中选择你需要的构建的项目（包含Dockerfile）；<br>4、可以选择<code>Click here to customize</code>自定义路径；<br>5、最后点击创建就可以了.<br><img src="https://cdn.yangbingdong.com/ima/docker-automated-built/create-automated.png" alt><br><img src="https://cdn.yangbingdong.com/ima/docker-automated-built/creating.png" alt></p>
<h2 id="集成到Github"><a href="#集成到Github" class="headerlink" title="集成到Github"></a>集成到Github</h2><p>用过<code>Github</code>自动构建当然需要<code>Github</code>的支持啦, 这里只需要在Github里面点两下就配置完成, 很方便:<br><img src="https://cdn.yangbingdong.com/ima/docker-automated-built/add-integrations.png" alt><br>在<code>Add Service</code>里面找到<code>Docker</code>并添加</p>
<p><img src="https://cdn.yangbingdong.com/ima/docker-automated-built/github-docker-server.png" alt></p>
<h2 id="构建设置"><a href="#构建设置" class="headerlink" title="构建设置"></a>构建设置</h2><h3 id="勾选自动构建"><a href="#勾选自动构建" class="headerlink" title="勾选自动构建"></a>勾选自动构建</h3><p>系统会默认帮我们勾上自动构建选项:<br><img src="https://cdn.yangbingdong.com/ima/docker-automated-built/aotumated-setting.png" alt><br>这时候, 当我们的Dockerfile有变动会自动触发构建:<br><img src="https://cdn.yangbingdong.com/ima/docker-automated-built/building.png" alt><br>还在构建过程中我们可以点击Cancel取消构建过程. </p>
<h3 id="添加新的构建"><a href="#添加新的构建" class="headerlink" title="添加新的构建"></a>添加新的构建</h3><p>Docker hub默认选择master分支作为latest版本, 我们可以根据自己的标签或分支构建不同的版本:<br><img src="https://cdn.yangbingdong.com/ima/docker-automated-built/add-build.png" alt></p>
<p>（点击箭头位置会出现例子）<br>这样, 当我们创建一个标签如1.0.2并push上去的时候会自动触发构建～</p>
<p><code>Git</code>标签相关请看: <strong><em><a href="/2017/note-of-learning-git/#标签管理">Git标签管理</a></em></strong></p>
<h3 id="远程触发构建"><a href="#远程触发构建" class="headerlink" title="远程触发构建"></a>远程触发构建</h3><p>当然我们也可以远程触发构建, 同样在Build Setting页面:<br><img src="https://cdn.yangbingdong.com/ima/docker-automated-built/remote-trigger.png" alt><br>然后例子已经说的很清楚了</p>
<p>参考: <strong><em><a href="https://docs.docker.com/docker-hub/builds/" rel="external nofollow noopener noreferrer" target="_blank">https://docs.docker.com/docker-hub/builds/</a></em></strong></p>
<h1 id="使用代理构建镜像"><a href="#使用代理构建镜像" class="headerlink" title="使用代理构建镜像"></a>使用代理构建镜像</h1><p>有时候, 我们构建镜像需要在镜像内安装一些软件, 因为构建时采用的是<code>bridge</code>模式, 对于一些资源比较稀缺或需要<strong>科学上网</strong>才能安装的软件慢得简直无法忍受. 对此, 我们可以在构建时设置<strong>构建参数</strong>（<code>--build-arg</code>）从而达到代理安装的目的. 或者也可以用官方的Docker Hub自动构建, 或者将Dockerfile上传到VPS进行构建=.=…但感觉没必要. </p>
<p>例如像下面<code>Dockerfile</code>: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM XXXXXX</span><br><span class="line">MAINTAINER ybd &lt;yangbingdong1994@gmail.com&gt; </span><br><span class="line">ARG HTTP_PROXY</span><br><span class="line">ENV http_proxy=$&#123;HTTP_PROXY&#125; https_proxy=$&#123;HTTP_PROXY&#125;</span><br><span class="line">RUN apk update &amp;&amp; \</span><br><span class="line">    apk add --no-cache &amp;&amp; \</span><br><span class="line">    apk add curl bash tree tzdata .....</span><br><span class="line">ENV http_proxy=</span><br><span class="line">ENV https_proxy=</span><br></pre></td></tr></table></figure>
<p>然后构建: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build --build-arg HTTP_PROXY=192.168.6.113:8118 -t yangbingdong/oraclejdk8 .</span><br></pre></td></tr></table></figure>
<p><code>192.168.6.113:8118</code>是从Sock5转换过来的http代理</p>
<p><strong>注意: 镜像内软件安装完成时候需要将代理置空, 所以上面示例最后两行后面的值是空的, 否则接下来容器内发生的网络访问都会走代理…</strong></p>
<h1 id="开启远程API"><a href="#开启远程API" class="headerlink" title="开启远程API"></a>开启远程API</h1><p><strong>注意: 这是一个危险动作, 仅测试使用, 生产慎用！</strong></p>
<p>某些应用可能需要使用Docker的远程API调用, 例如Portainer. </p>
<h2 id="方式一-修改配置文件"><a href="#方式一-修改配置文件" class="headerlink" title="方式一, 修改配置文件"></a>方式一, 修改配置文件</h2><p>打开<code>/lib/systemd/system/docker.service</code>, 将<code>ExecStart=/usr/bin/docker daemon -H fd://</code>修改为<code>ExecStart=/usr/bin/docker daemon -H fd:// -H tcp://0.0.0.0:2375</code>. </p>
<p>其中<code>2375</code>是就是远程调用端口. </p>
<p>然后重启Dcoker: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload &amp;&amp; sudo service docker restart</span><br></pre></td></tr></table></figure>
<h2 id="方式二-添加代理"><a href="#方式二-添加代理" class="headerlink" title="方式二, 添加代理"></a>方式二, 添加代理</h2><p>这种方式比较优雅点, 不需要重启Docker或更改配置文件: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -ti -d -p 2375:2375 \</span><br><span class="line">--restart=always \</span><br><span class="line">--hostname=$HOSTNAME \</span><br><span class="line">--name shipyard-proxy \</span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">-e PORT=2375 \</span><br><span class="line">shipyard/docker-proxy</span><br></pre></td></tr></table></figure>
<h1 id="Self-Usage-Docker-Or-Compose"><a href="#Self-Usage-Docker-Or-Compose" class="headerlink" title="Self Usage Docker Or Compose"></a>Self Usage Docker Or Compose</h1><blockquote>
<p>更多请看: <strong><em><a href="https://github.com/masteranthoneyd/docker-compose-related" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/masteranthoneyd/docker-compose-related</a></em></strong></p>
</blockquote>
<h2 id="Visualizer"><a href="#Visualizer" class="headerlink" title="Visualizer"></a><em><a href="https://hub.docker.com/r/dockersamples/visualizer/" rel="external nofollow noopener noreferrer" target="_blank">Visualizer</a></em></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">--name=viz \</span><br><span class="line">--publish=8088:8080/tcp \</span><br><span class="line">--constraint=node.role==manager \</span><br><span class="line">--mount=type=bind,src=/var/run/docker.sock,dst=/var/run/docker.sock \</span><br><span class="line">dockersamples/visualizer</span><br></pre></td></tr></table></figure>
<h2 id="Nexus3"><a href="#Nexus3" class="headerlink" title="Nexus3"></a><em><a href="https://hub.docker.com/r/sonatype/nexus3/" rel="external nofollow noopener noreferrer" target="_blank">Nexus3</a></em></h2><p><strong>创建Volume</strong> : </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker volume create --name nexus-data</span><br></pre></td></tr></table></figure>
<p><strong>运行实例</strong>: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NEXUS_PORT=8090 &amp;&amp; \</span><br><span class="line">NEXUS_VERSION=3.6.2 &amp;&amp; \</span><br><span class="line">docker run --restart=always \</span><br><span class="line">-d \</span><br><span class="line">-p $&#123;NEXUS_PORT&#125;:8081 \</span><br><span class="line">--name nexus \</span><br><span class="line">-v nexus-data:/nexus-data \</span><br><span class="line">sonatype/nexus3:$&#123;NEXUS_VERSION&#125;</span><br></pre></td></tr></table></figure>
<p>查看启动日志: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker logs nexus</span><br></pre></td></tr></table></figure>
<p><strong>备份</strong>: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BAK_CONTAINER=ubuntu:latest &amp;&amp; \</span><br><span class="line">VOLUME=nexus-data &amp;&amp; \</span><br><span class="line">BAK_PATH=$&#123;PWD&#125; &amp;&amp; \</span><br><span class="line">BAK_ARCHIVE_NAME=nexus-data &amp;&amp; \</span><br><span class="line">docker run --rm \</span><br><span class="line">-v $&#123;BAK_PATH&#125;:/backup \</span><br><span class="line">-v $&#123;VOLUME&#125;:/backup-data \</span><br><span class="line">$&#123;BAK_CONTAINER&#125; \</span><br><span class="line">tar zcvf /backup/$&#123;BAK_ARCHIVE_NAME&#125;.tar.gz /backup-data</span><br></pre></td></tr></table></figure>
<p><strong>还原</strong>: </p>
<p>先要创建还原的Volume: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker volume create --name nexus-data1</span><br></pre></td></tr></table></figure>
<p>然后: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BAK_CONTAINER=ubuntu:latest &amp;&amp; \</span><br><span class="line">RESTORE_VOLUME=nexus-data1 &amp;&amp; \</span><br><span class="line">BAK_PATH=$&#123;PWD&#125; &amp;&amp; \</span><br><span class="line">BAK_ARCHIVE_NAME=nexus-data &amp;&amp; \</span><br><span class="line">docker volume create --name $&#123;RESTORE_VOLUME&#125; &amp;&amp; \</span><br><span class="line">docker run --rm \</span><br><span class="line">-v $&#123;RESTORE_VOLUME&#125;:/restore \</span><br><span class="line">-v $&#123;BAK_PATH&#125;:/backup \</span><br><span class="line">ubuntu:latest \</span><br><span class="line">tar zxvf /backup/$&#123;BAK_ARCHIVE_NAME&#125;.tar.gz -C /restore --strip-components=1</span><br></pre></td></tr></table></figure>
<h2 id="Ngrok（服务端）"><a href="#Ngrok（服务端）" class="headerlink" title="Ngrok（服务端）"></a><em><a href="https://hub.docker.com/r/hteen/ngrok/" rel="external nofollow noopener noreferrer" target="_blank">Ngrok（服务端）</a></em></h2><p><strong>运行实例</strong>: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NGROK_DATA=/root/docker/ngrok/data &amp;&amp; \</span><br><span class="line">NGROK_PORT=9000 &amp;&amp; \</span><br><span class="line">docker run -idt --name ngrok-server \</span><br><span class="line">-p $&#123;NGROK_PORT&#125;:80 -p 4432:443 -p 4443:4443 \</span><br><span class="line">-v $&#123;NGROK_DATA&#125;:/myfiles \</span><br><span class="line">-e DOMAIN=&apos;ngrok.yangbingdong.com&apos; hteen/ngrok /bin/sh /server.sh</span><br></pre></td></tr></table></figure>
<blockquote>
<p>详情: <a href="http://yangbingdong.com/2017/self-hosted-build-ngrok-server/#Docker搭建Ngrok"><strong><em>Docker搭建Ngrok</em></strong></a></p>
</blockquote>
<h2 id="ShowDoc"><a href="#ShowDoc" class="headerlink" title="ShowDoc"></a><em><a href="https://github.com/star7th/showdoc" rel="external nofollow noopener noreferrer" target="_blank">ShowDoc</a></em></h2><p>功能: API与数据字典管理</p>
<p>docker-compose.yml:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &apos;3.4&apos;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  showdoc:</span><br><span class="line">    image: yangbingdong/showdoc:1.0</span><br><span class="line">    volumes:</span><br><span class="line">      - /home/ybd/data/docker/showdoc/data:/var/www/html</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;4999:80&quot;</span><br><span class="line">    restart: always</span><br></pre></td></tr></table></figure>
<p>其中要把 <em><a href="https://github.com/star7th/showdoc" rel="external nofollow noopener noreferrer" target="_blank">ShowDoc</a></em> 整个项目根目录所有文件拷贝到 data 里面, 确保里面文件可执行 <code>chmod -R 777 data</code></p>
<p>访问 <code>localhost:4999/install</code> 进行设置后把data里面的 <code>install</code> 目录删除防止再次安装. </p>
<h1 id="Last"><a href="#Last" class="headerlink" title="Last"></a>Last</h1><p><img src="https://cdn.yangbingdong.com/img/docker/cmd_logic.png" alt></p>
<blockquote>
<p>参考:<br><strong><em><a href="https://yeasy.gitbooks.io/docker_practice/content/" rel="external nofollow noopener noreferrer" target="_blank">Docker — 从入门到实践</a></em></strong><br><strong><em><a href="https://kamisec.github.io/2017/06/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/" rel="external nofollow noopener noreferrer" target="_blank">Docker命令大全</a></em></strong><br><strong><em><a href="https://docs.docker.com/engine/reference/commandline/cli/" rel="external nofollow noopener noreferrer" target="_blank">Docker命令官方文档</a></em></strong></p>
</blockquote>
]]></content><categories><category>Docker</category></categories><tags><tag>Docker</tag></tags></entry><entry><title>Start My Blog Trip — Power By Hexo</title><url>/2017/hello-world/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/hello-world/start-trip.png" alt><br><blockquote class="blockquote-center"><p>Life is a generic method like [ public <t> Life doSomething(T t){} ],T is the part of life that requires you to play in a period of time,and the method will return a life you expect if you to be T.<br>                                    —— <strong><em>沃·兹基硕德</em></strong></t></p>
</blockquote><br>为什么要写博客？除了可以将自己在工作学习中的一些知识及经验记录下来. 不断积累知识, 不断总结经验以外, 更重要的是 <em><a href="http://www.15yan.com/topic/chuang-zuo-de-mi-mi/i0sBdlKnryf/?f=wx" rel="external nofollow noopener noreferrer" target="_blank">为了保持逼格, 不要停止写作</a></em> . 虽然高中的语文<strong>从来</strong>都没有及格过, 作文也写得挺烂, 但我会尽力得用我拙劣的语言把每一篇博客都写好…</p>
<a id="more"></a>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="50%" height="86" src="//music.163.com/outchain/player?type=2&id=26075648&auto=0&height=66"></iframe>

<p><strong>引用一下别人的话</strong></p>
<blockquote>
<p>喜欢写Blog的人, 会经历三个阶段<br>第一阶段, 刚接触Blog, 觉得很新鲜, 试着选择一个免费空间来写.<br>第二阶段, 发现免费空间限制太多, 就自己购买域名和空间, 搭建独立博客.<br>第三阶段, 觉得独立博客的管理太麻烦, 最好在保留控制权的前提下, 让别人来管, 自己只负责写文章. </p>
</blockquote>
<hr>
<p>之前学习的时候, 看别人的一些文章、博客跟着造轮子, 然而过几天就不记得了又要到搜索引擎翻一番看一看, 觉得很麻烦（因为博主比较懒= =）. 然后决定自己注册一个博客论坛整理一下知识点, 之后发现大神们都有自己的搭建博客, 都很不错, 于是乎跟着造轮子, 几天折腾, 总算把这个博客搭建完成并且做了一些优化. 语文不好, 废话也不多说了, 我个人搭建Hexo博客的过程-&gt;<em><a href="/2017/build-blog-hexo-base/">传送门</a></em>.<br>最后, 请允许我分享一篇很好的文章: <em><a href="https://zhuanlan.zhihu.com/p/19743861?columnSlug=cnfeat" rel="external nofollow noopener noreferrer" target="_blank">《为什么你要写博客？》</a></em></p>
<p><center><h2><a href="https://zhuanlan.zhihu.com/p/19743861?columnSlug=cnfeat" rel="external nofollow noopener noreferrer" target="_blank">为什么你要写博客？</a></h2></center></p>
<h3 id="一个选择"><a href="#一个选择" class="headerlink" title="一个选择"></a>一个选择</h3><p>我知道现在可能说这话有点不合时宜, 毕竟博客时代都已经过去了, 再号召大家用过就好像时的东西是不是有点逆流而上？</p>
<p>我曾经也问过自己这个问题, 但是我觉得, 博客时代过去跟我们要开博客是没有多大关系的, 就好像你的读书时代已经过去你就不再读书一样. </p>
<p>判断一件事情值不值得去做有一个方法: 在一张白纸的左边写不值得做的原因, 然后在右边写值得做的原因, 写完一比较, 一权衡, 自然能够得出结果. </p>
<p>大家都成年人了, 你会觉得这样思考分析总结的过程才是正确的思考的方法吧？</p>
<p>所以, 我在这里列出要写（独立）博客的原因, 供大家去选择, 然后填在你白纸的右边. </p>
<p>注意, 我不是给你一个建议, 而是提供一个选择, 这个选择蕴藏着我也不知道的可能. </p>
<h3 id="博客的内容"><a href="#博客的内容" class="headerlink" title="博客的内容"></a>博客的内容</h3><p>写博客不难, 你可以当作是生活的记录, 但是这样的记录没有任何的意义. 写要对得住写本身, 写出来的东西应该是思考的结果. 我认为, 如果你要开一个博客, 博客的内容应该是这样的: </p>
<ul>
<li>1、 不是生活杂记、不是流水账、不是牢骚、不是抱怨、不是心情琐记……；</li>
<li>2、 有目的地写, 要务实, 追求质量；</li>
<li>3、 承认真实的自己, 不要吹嘘, 不要装逼, 无需讨好读者；</li>
<li>4、 记录自己学习、思考、总结的过程；</li>
<li>5、 分享你的故事、所得、感想、经验；</li>
<li>6、你对钱怎么看, 你认为赚到多少钱是足够的？如果你明天一早醒来, 已经有足够的钱, 你将会如何继续安排自己的生活？</li>
<li>7、对你来说, 什么是理想的性生活？什么是理想的性道德, 在你的性道德观中, 什么样的性生活是禁忌的, 需要避免的, 什么样的性生活是美好的, 需要得到鼓励和发展的？</li>
<li>8、你的择友标准是什么？什么样的人你会愿意交往, 什么样的人你会拒绝和他交往？</li>
<li>9、你对死亡怎么看？你希望自己活到多少岁, 你准备怎么度过从现在到死亡的这段时间？如果你要立遗嘱, 这份遗嘱会怎么写？</li>
</ul>
<p>以上的这九个问题摘自《很少人能顺畅回答这9个问题——心理治疗刚开始医生常常会先问你的 》by 李孟潮. </p>
<p>这些问题的答案你可以选择不发, 但是我强烈地建议写下来, 只有在写的时候你才可以慎重地思考这些问题, 而不会回避跳过或者留下空白, 这是接受自己的第一步. </p>
<h3 id="提供持续学习的动力"><a href="#提供持续学习的动力" class="headerlink" title="提供持续学习的动力"></a>提供持续学习的动力</h3><p>例如, 我为自己设限每天写一千字, 信息的不断输出给我带来恐惧, 我害怕有一天我写无可写, 于是我不停地阅读, 通过个人的知识管理促使自己不断学习, 提高核心竞争力. </p>
<p>详细的知识管理可以看我的这篇文章: 《个人知识管理的方法》, 回复「知识」可见</p>
<h3 id="积累更多的知识"><a href="#积累更多的知识" class="headerlink" title="积累更多的知识"></a>积累更多的知识</h3><p>写并不是单纯的写. </p>
<p>例如你写着写着, 你突然忘记了一个概念, 于是上网找, 找回来这个概念的时候, 你重温这个概念, 可能还会顺便看了一下这个概念的其他东西. </p>
<p>例如你需要获取第一手的资料, 寻找信息来源本身就是一个知识积累的过程, 同时, 你慢慢就学会了鉴别知识: 什么是没有用的心灵鸡汤, 什么是不值得关注的吐槽名人, 还有, 在这个过程中, 你还养成你的心智. </p>
<h3 id="提高将事情讲清楚的能力"><a href="#提高将事情讲清楚的能力" class="headerlink" title="提高将事情讲清楚的能力"></a>提高将事情讲清楚的能力</h3><p>很多东西你以为懂了, 但当你在写下来的时候, 你就觉得无从下手了. </p>
<blockquote>
<p>如果一件事情你不能讲清楚, 十有八九你还没有完全理解. </p>
</blockquote>
<p>将事情写下来, 慢慢就可以提高你的逻辑思维能力, 分析能力, 写会迫使你在你脑中搭建一个有条理的框架. 例如我写这篇文章一样, 我就将值得写博客的原因一点一点地罗列出来, 事情就更加清晰, 你也可以更好的思考问题. </p>
<h3 id="分享带来的连锁反应"><a href="#分享带来的连锁反应" class="headerlink" title="分享带来的连锁反应"></a>分享带来的连锁反应</h3><blockquote>
<p>“通过分享, 你获得了直接而快速的回报, 你最终或许会发现你已将版权和“保留所有权利”抛诸脑后. 新的经济学准则是: 参与你作品的人越多, 回报越高. 在分享主义里, 如果你愿意你可以保留所有权, 但是我乐于分享. ” by 毛向辉 《分享主义: 一场思维革命》</p>
</blockquote>
<p>互联网精神其中最重要的就是分享主义, 基于分享主义, 你可以享受到社会化及互联网给你带来的种种便利和好处, 你分享了一个知识, 你就成为了互联网中的一个点, 这个点的大小由你自己来决定, 互联网的大潮会将你的这个点推送到它所能触及的每个角落, 让需要的人得到, 同时, 你的这个点也会继续扩大, 连接到整个网络, 这个点有可能连接成一张网, 而你就是这张网的中心. </p>
<h3 id="帮你找到志同道合的人"><a href="#帮你找到志同道合的人" class="headerlink" title="帮你找到志同道合的人"></a>帮你找到志同道合的人</h3><p>在微博, 在朋友圈, 你可能找不到跟你志同道合的人, 而在博客, 你可以通过看他的几篇文章就迅速地理解认同这个人, 即使你没有见过这个人, 但你也可以通过这种关联来相互学习. </p>
<p>如果你在一个领域有相当的了解, 你将这些内容发在网络上, 网络上跟你志趣相投的人也会被你吸引过来, 根据吸引力法则, 你是怎样的人你就被怎么样的人吸引, 这就是博客所能赋予你的魅力. </p>
<blockquote>
<p>即使博客没有被他人关注, 我们依然可以找到同好, 你可以自己将博文转载到其他站点, 人们会通过搜索引擎找到你, 有邮件、微博等工具, 我们不乏与他人交流的途径. by Gabriel Weinberg《Why I blog》</p>
</blockquote>
<h3 id="记录成长"><a href="#记录成长" class="headerlink" title="记录成长"></a>记录成长</h3><p>隔一段时间, 你再回头看你写的博客, 你会发现自己正在通过这样的方式在不断的成长, 这种成长在自己眼里是一种财富, 在别人眼里是一张地图, 你得到了收获, 不断修正自己的错误, 别人得到了指引, 避免走弯路. </p>
<p>更多的情况是当你回望自己的时候你会发现自己是一个傻逼, so what, that is what I am！</p>
<h3 id="培养持续做一件事情的能力"><a href="#培养持续做一件事情的能力" class="headerlink" title="培养持续做一件事情的能力"></a>培养持续做一件事情的能力</h3><p>开始是坚持, 后来是习惯, 接着喜欢. 以后当有人对你说, 「你写那么多有用的东西, 你真的很厉害啊！」你可以笑而不语, 也可以大声说道: 「你妹, 你不知道我开始的时候多么痛苦！」</p>
<p>让你长久地去跑步, 你可能做不到；让你每个月看一本书, 你也可能做不到；但让你持续地写一个博客, 你可以做得到. </p>
<p>你不相信？你不试试你怎么知道？</p>
<p>默默地持续做一件事是一种难得的能力, 也是一种难得的品质. </p>
<h3 id="讨论反思"><a href="#讨论反思" class="headerlink" title="讨论反思"></a>讨论反思</h3><p>每人都会有思维的盲点, 就好像这篇文章一样, 可能你觉得我可能说得不对, 你可以反驳我, 我欢迎这种讨论, 因为讨论的过程中会产生各种的思维的碰撞, 这种碰撞会让你反思, 也会激发出你新的灵感, 这种讨论反思给自己的带来巨大的受益. </p>
<p>互联网给你的反馈就是让你承受更多, 接受更多, 成为一个更好的人. </p>
<h3 id="搜寻到你意想不到东西"><a href="#搜寻到你意想不到东西" class="headerlink" title="搜寻到你意想不到东西"></a>搜寻到你意想不到东西</h3><p>世界不止是你的家, 你的公司, 你的朋友圈, 你应该去发现一个更大的世界, 通过写博客, 你会知道世界上还有很多人像你一样在写博客, 这些人和知识正在世界的某个角落在等着你. </p>
<p>例如, 在写这篇文章的过程中, 我才知道了Gabriel Weinberg, 我才要将阳志平的博客重读一遍. 写的过程会让你有很多新的发现, 这些新的发现都值得你去再写下来, 总结分享出去. </p>
<h3 id="一个人在做一件属于自己的事"><a href="#一个人在做一件属于自己的事" class="headerlink" title="一个人在做一件属于自己的事"></a>一个人在做一件属于自己的事</h3><p>很多你认为自己很牛逼的事情都是自己一个人做出来. </p>
<p>别人在刷微博, 你在看书, 别人在看穿越剧, 你在学英文, 别人在去唱K, 你在写个人总结. 吃饭也要找同伴, 出游要找同伴, 看电影要找同伴, 你上一次一个人在做一件属于自己的事是在什么时候？</p>
<blockquote>
<p>如果你想要清晰地思考, 就必须远离人群. 但是走得越远, 你的处境就会越困难, 收到的阻力也会越大. 因为你没有迎合社会习俗, 而是一步步地与它背道而驰. 如果自己就是潮水的一部分 , 怎么能看见潮流的方向呢？你只能永远保持质疑, 问自己, 什么话是我不能说的？为什么？——Paul Graham《不能说的话》</p>
</blockquote>
<h3 id="互联网的身份识别"><a href="#互联网的身份识别" class="headerlink" title="互联网的身份识别"></a>互联网的身份识别</h3><blockquote>
<p>一个长期的价值博客是一份很好的简历. 这里的“简历”并非是狭义上的求职简历, 毕竟现在还没有到价值博客的时代, 很多人写博客都是到处转载或者干脆碎碎念, 正因此面试官未必拿个人博客当成了解一个人的更可靠窗口. </p>
</blockquote>
<blockquote>
<p>这里的“简历”是指一个让别人了解自己的窗口, 虽然我们未必做得到像罗永浩、Keso这样的博客, 个人的影响力已经足以支撑出一份事业（牛博和5gme）, 但至少你会因此而结识更多的人, 你的博客价值越高, 你结识的人就越牛, 跟牛人交流又会让你的眼界得到极大的开阔, 打开一扇又一扇你原本不知道的门, 于是你就变得更牛… 这是一个良性循环. by 刘未鹏</p>
</blockquote>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>你可能想不到在白纸的左边（不值得写博客的原因）写什么了, 想不到写个「博客时代已经过去」或者「我没有时间」也可以, 但与此同时, 你也可以用那些时间去思考一下「怎么做到长期写一个价值博客」. </p>
<p>如果你不想思考, 也可以回复「价值」看看别人的建议. </p>
]]></content><categories><category>Essay</category></categories><tags><tag>Hexo</tag></tags></entry><entry><title>Docker可视化与管理工具</title><url>/2018/docker-visual-management-and-orchestrate-tools/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/docker-visual-management-and-orchestrate-tools/docker-managerment.png" alt></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><blockquote>
<p>在学习了Docker的基本操作之后, 接下来就是Docker的管理部分了, 这包括Docker的可视化管理以及集群管理. </p>
<p>此篇主要记录Docker私有库的搭建, Docker编排工具的介绍以及使用, 可视化管理工具的介绍以及搭建…</p>
</blockquote>
<a id="more"></a>
<h1 id="Docker-Registry-amp-Mirror"><a href="#Docker-Registry-amp-Mirror" class="headerlink" title="Docker Registry &amp; Mirror"></a>Docker Registry &amp; Mirror</h1><h2 id="Harbor"><a href="#Harbor" class="headerlink" title="Harbor"></a>Harbor</h2><blockquote>
<p>官方文档: <strong><em><a href="https://goharbor.io/docs/" rel="external nofollow noopener noreferrer" target="_blank">https://goharbor.io/docs/</a></em></strong></p>
</blockquote>
<p><img src="https://cdn.yangbingdong.com/img/docker-visual-management-and-orchestrate-tools/harbor-arch.png" alt></p>
<p>Harbor是一个用于存储和分发Docker镜像的企业级Registry服务器, 通过添加一些企业必需的功能特性, 例如安全、标识和管理等, 扩展了开源Docker Distribution. 作为一个企业级私有Registry服务器, Harbor提供了更好的性能和安全. 提升用户使用Registry构建和运行环境传输镜像的效率. Harbor支持安装在多个Registry节点的镜像资源复制, 镜像全部保存在私有Registry中, 确保数据和知识产权在公司内部网络中管控. 另外, Harbor也提供了高级的安全特性, 诸如用户管理, 访问控制和活动审计等. </p>
<ul>
<li><strong>基于角色的访问控制</strong> - 用户与Docker镜像仓库通过“项目”进行组织管理, 一个用户可以对多个镜像仓库在同一命名空间（project）里有不同的权限. </li>
<li><strong>镜像复制</strong> - 镜像可以在多个Registry实例中复制（同步）. 尤其适合于负载均衡, 高可用, 混合云和多云的场景. </li>
<li><strong>图形化用户界面</strong> - 用户可以通过浏览器来浏览, 检索当前Docker镜像仓库, 管理项目和命名空间. </li>
<li><strong>AD/LDAP 支持</strong> - Harbor可以集成企业内部已有的AD/LDAP, 用于鉴权认证管理. </li>
<li><strong>审计管理</strong> - 所有针对镜像仓库的操作都可以被记录追溯, 用于审计管理. </li>
<li><strong>国际化</strong> - 已拥有英文、中文、德文、日文和俄文的本地化版本. 更多的语言将会添加进来. </li>
<li><strong>RESTful API</strong> - RESTful API 提供给管理员对于Harbor更多的操控, 使得与其它管理软件集成变得更容易. </li>
<li><p><strong>部署简单</strong> - 提供在线和离线两种安装工具, 也可以安装到vSphere平台(OVA方式)虚拟设备. </p>
</li>
<li><p>集成clair进行镜像安全漏洞扫描等等</p>
</li>
</ul>
<h3 id="Download"><a href="#Download" class="headerlink" title="Download"></a>Download</h3><p><a href="https://github.com/goharbor/harbor/releases" rel="external nofollow noopener noreferrer" target="_blank"><strong><em>Release页面</em></strong></a> 下载离线安装包（或在线也可以, 不过安装的时候很慢）</p>
<h3 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h3><p>解压缩之后, 目录下会生成<code>harbor.yml</code>文件, 该文件就是Harbor的配置文件, 这里只展示一部分, 后续会根据这个配置来生成 <code>docker-compose.yml</code>: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 不能配置 localhost 或 127.0.0.1, 只能配置内网ip或者域名</span><br><span class="line">hostname: 172.16.8.196</span><br><span class="line"></span><br><span class="line"># 默认端口是80</span><br><span class="line">http:</span><br><span class="line">  port: 8080</span><br><span class="line"></span><br><span class="line"># 登录密码, 账号为 admin</span><br><span class="line">harbor_admin_password: Harbor12345</span><br><span class="line"></span><br><span class="line"># 数据存放目录</span><br><span class="line">data_volume: /root/docker/harbor/data</span><br><span class="line"></span><br><span class="line"># 日志配置</span><br><span class="line">log:</span><br><span class="line">  level: info</span><br><span class="line">  local:</span><br><span class="line">    rotate_count: 5</span><br><span class="line">    rotate_size: 20M</span><br><span class="line">    location: /root/docker/harbor/data/log/harbor  # 这个要写最对路径</span><br><span class="line">    </span><br><span class="line">_version: 1.9.0</span><br></pre></td></tr></table></figure>
<h3 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h3><p>运行安装脚本: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./install.sh</span><br></pre></td></tr></table></figure>
<p>集成clair漏洞扫描: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./install.sh --with-clair</span><br></pre></td></tr></table></figure>
<p>脚本会自动解压镜像文件并运行docker-compose</p>
<p><img src="https://cdn.yangbingdong.com/img/docker-visual-management-and-orchestrate-tools/harbor-install.png" alt></p>
<p>或者运行<code>prepare</code>文件再手动运行docker-compose</p>
<p>启动之后浏览器打开刚才修改的hostname</p>
<p><img src="https://cdn.yangbingdong.com/img/docker-visual-management-and-orchestrate-toolsharbor-homepage.png" alt></p>
<p><strong>帐号密码默认是</strong> <code>admin/Harbor12345</code>, 可在配置文件<code>harbor.yml</code>中修改</p>
<p><strong>修改配置文件之后</strong>需要重新生成一些内置配置: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./prepare</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<h3 id="登录被refuse"><a href="#登录被refuse" class="headerlink" title="登录被refuse"></a>登录被refuse</h3><p>多次docker login被refuse</p>
<p><img src="https://cdn.yangbingdong.com/img/docker-visual-management-and-orchestrate-tools/refuse.png" alt></p>
<p>这是因为 Docker 默认<strong>不允许非 <code>HTTPS</code> 方式推送镜像</strong>. 我们可以通过 Docker 配置来<strong>取消这个限制</strong>, 或者配置能够通过 <code>HTTPS</code> 访问的私有仓库. </p>
<p>如果是<code>systemd</code> 的系统例如<code>Ubuntu16.04+</code>、<code>Debian 8+</code>、<code>centos 7</code>, 可以在<code>/etc/docker/daemon.json</code> 中写入如下内容: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://xxxxx.mirror.aliyuncs.com&quot;],</span><br><span class="line">  &quot;insecure-registries&quot;: [&quot;192.168.1.102:8888&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后重新加载Docker: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl reload docker</span><br></pre></td></tr></table></figure>
<h3 id="Login-and-Push"><a href="#Login-and-Push" class="headerlink" title="Login and Push"></a>Login and Push</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker login 192.168.1.102:8888 -u admin -p Harbor12345</span><br><span class="line"></span><br><span class="line">docker tag ubuntu:latest 192.168.1.102/library/ubuntu:latest</span><br><span class="line">docker push 192.168.1.102/library/ubuntu:latest</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.yangbingdong.com/img/docker-visual-management-and-orchestrate-tools/harbor-push.png" alt></p>
<p><strong>注意</strong>: 使用<code>docker stack deploy</code>时, 如果是私有镜像, 需要终端登录后加上<code>--with-registry-auth</code>选项. </p>
<h3 id="删除Harbor"><a href="#删除Harbor" class="headerlink" title="删除Harbor"></a>删除Harbor</h3><p><strong>删除harbor, 但保留数据</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose down -v</span><br></pre></td></tr></table></figure>
<p><strong>删除harbor数据</strong>（对应<code>docker-compose.yml</code>里面的数据卷）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -r /data/database</span><br><span class="line">rm -r /data/registry</span><br></pre></td></tr></table></figure>
<p><strong>删除镜像</strong></p>
<p>UI界面操作删除镜像, 只是删除元数据, 并未删除真实数据, 还需要调用registry的garbage-collect进行清理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose stop</span><br><span class="line"></span><br><span class="line">docker run -it --name gc --rm --volumes-from registry vmware/registry:2.6.2-photon garbage-collect --dry-run /etc/registry/config.yml #只是打印过程, 并不删除</span><br><span class="line"></span><br><span class="line">docker run -it --name gc --rm --volumes-from registry vmware/registry:2.6.2-photon garbage-collect  /etc/registry/config.yml</span><br><span class="line"></span><br><span class="line">docker-compose start</span><br></pre></td></tr></table></figure>
<p>注意: 配置文件<code>config.yml</code>挂载在<code>/etc/registry/</code>下.</p>
<h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><h4 id="python版本"><a href="#python版本" class="headerlink" title="python版本"></a>python版本</h4><p>在Ubuntu18.04中的python是3+版本的, 需要装回2.7版本, 不然会有不明异常. . . : </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install python2.7 python-minimal -y</span><br></pre></td></tr></table></figure>
<h4 id="Fail-to-generate-key-file"><a href="#Fail-to-generate-key-file" class="headerlink" title="Fail to generate key file"></a>Fail to generate key file</h4><p>这个貌似是openssl的问题, 解决方案是将<code>prepare</code>中的<code>empty_subj = &quot;/C=/ST=/L=/O=/CN=/&quot;</code>改为<code>empty_subj = &quot;/&quot;</code></p>
<h2 id="Registry-Mirror"><a href="#Registry-Mirror" class="headerlink" title="Registry Mirror"></a>Registry Mirror</h2><p><strong>registry mirror原理</strong></p>
<p>Docker Hub的镜像数据分为两部分: index数据和registry数据. 前者保存了镜像的一些元数据信息, 数据量很小；后者保存了镜像的实际数据, 数据量比较大. 平时我们使用docker pull命令拉取一个镜像时的过程是: 先去index获取镜像的一些元数据, 然后再去registry获取镜像数据. </p>
<p>所谓registry mirror就是搭建一个registry, 然后将docker hub的registry数据缓存到自己本地的registry. 整个过程是: 当我们使用docker pull去拉镜像的时候, 会先从我们本地的registry mirror去获取镜像数据, 如果不存在, registry mirror会先从docker hub的registry拉取数据进行缓存, 再传给我们. 而且整个过程是流式的, registry mirror并不会等全部缓存完再给我们传, 而且边缓存边给客户端传. </p>
<p>对于缓存, 我们都知道一致性非常重要. registry mirror与docker官方保持一致的方法是: registry mirror只是缓存了docker hub的registry数据, 并不缓存index数据. 所以我们pull镜像的时候会先连docker hub的index获取镜像的元数据, 如果我们registry mirror里面有该镜像的缓存, 且数据与从index处获取到的元数据一致, 则从registry mirror拉取；如果我们的registry mirror有该镜像的缓存, 但数据与index处获取的元数据不一致, 或者根本就没有该镜像的缓存, 则先从docker hub的registry缓存或者更新数据. </p>
<p>1、拉取镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull registry:latest</span><br></pre></td></tr></table></figure>
<p>2、获取registry的默认配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it --rm --entrypoint cat registry:latest  /etc/docker/registry/config.yml &gt; config.yml</span><br></pre></td></tr></table></figure>
<p>内容可能如下: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: 0.1</span><br><span class="line">log:</span><br><span class="line">  fields:</span><br><span class="line">    service: registry</span><br><span class="line">storage:</span><br><span class="line">  cache:</span><br><span class="line">    blobdescriptor: inmemory</span><br><span class="line">  filesystem:</span><br><span class="line">    rootdirectory: /var/lib/registry</span><br><span class="line">http:</span><br><span class="line">  addr: :5000</span><br><span class="line">  headers:</span><br><span class="line">    X-Content-Type-Options: [nosniff]</span><br><span class="line">health:</span><br><span class="line">  storagedriver:</span><br><span class="line">    enabled: true</span><br><span class="line">    interval: 10s</span><br><span class="line">    threshold: 3</span><br></pre></td></tr></table></figure>
<p>我们在最后面加上如下配置: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxy:</span><br><span class="line">  remoteurl: https://registry-1.docker.io</span><br><span class="line">  username: [username]</span><br><span class="line">  password: [password]</span><br></pre></td></tr></table></figure>
<p><code>username</code>和<code>password</code>是可选的, 如果配置了的话, 那registry mirror除了可以缓存所有的公共镜像外, 也可以访问这个用户所有的私有镜像. </p>
<p>启动registry容器: </p>
<p>Bash</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run  --restart=always -p 5000:5000 --name v2-mirror -v /data:/var/lib/registry -v  $PWD/config.yml:/etc/registry/config.yml registry:latest /etc/registry/config.yml</span><br></pre></td></tr></table></figure>
<p>当然我们也可以使用docker-compose启动: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &apos;3&apos;</span><br><span class="line">services:</span><br><span class="line">  registry:</span><br><span class="line">    image: library/registry:latest</span><br><span class="line">    container_name: registry-mirror</span><br><span class="line">    restart: always</span><br><span class="line">    volumes:</span><br><span class="line">      - /data:/var/lib/registry</span><br><span class="line">      - ./config.yml:/etc/registry/config.yml</span><br><span class="line">    ports:</span><br><span class="line">      - 5000:5000</span><br><span class="line">    command:</span><br><span class="line">      [&quot;serve&quot;, &quot;/etc/registry/config.yml&quot;]</span><br></pre></td></tr></table></figure>
<p>curl验证一下服务是否启动OK: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ybd @ ybd-PC in ~ [17:30:14] </span><br><span class="line">$ curl -I http://192.168.6.113:5000</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Date: Fri, 05 Jan 2018 09:30:27 GMT</span><br><span class="line">Content-Type: text/plain; charset=utf-8</span><br></pre></td></tr></table></figure>
<p>最后修改<code>/etc/docker/daemon.json</code>或<code>/etc/default/docker</code>中的<code>registry-mirrors</code>即可</p>
<h1 id="Cluster-and-Orchestrate-Tools"><a href="#Cluster-and-Orchestrate-Tools" class="headerlink" title="Cluster and Orchestrate Tools"></a>Cluster and Orchestrate Tools</h1><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><p><img src="https://cdn.yangbingdong.com/img/docker-visual-management-and-orchestrate-tools/docker-compose-logo.png" alt></p>
<blockquote>
<p>官方文档: <a href="https://docs.docker.com/compose/" rel="external nofollow noopener noreferrer" target="_blank"><strong><em>https://docs.docker.com/compose/</em></strong></a></p>
<p>release: <a href="https://github.com/docker/compose/releases" rel="external nofollow noopener noreferrer" target="_blank"><strong><em>https://github.com/docker/compose/releases</em></strong></a></p>
</blockquote>
<p>Compose是定义和运行多容器Docker应用程序的工具, 使用Compose, 您可以使用YAML文件来配置应用程序的服务, 然后, 使用单个命令创建并启动配置中的所有服务. </p>
<p>Dockerfile 可以让用户管理一个单独的应用容器. 使用Docker Compose, 不再需要使用shell脚本来启动容器. 在配置文件中, 所有的容器通过services来定义, 然后使用<code>docker-compose</code>脚本来启动, 停止和重启应用, 和应用中的服务以及所有依赖服务的容器</p>
<h3 id="Install-1"><a href="#Install-1" class="headerlink" title="Install"></a>Install</h3><p>最新安装请看官方文档: <strong><em><a href="https://docs.docker.com/compose/install/#install-compose" rel="external nofollow noopener noreferrer" target="_blank">https://docs.docker.com/compose/install/#install-compose</a></em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>
<p>变为可执行命令: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>
<p>检查安装成功: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure>
<p>卸载: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rm /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>
<h3 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h3><p>基本命令: </p>
<p><code>-p</code> 指定项目名称</p>
<p><code>build</code> 构建项目中的服务容器 –force-rm 删除构建过程中的临时容器</p>
<p><code>--no-cache</code> 构建过程中不使用 cache</p>
<p><code>--pull</code> 始终通过 pull 来获取更新版本的镜像</p>
<p><code>docker-compose kill</code> 强制停止服务容器</p>
<p><code>docker-compose logs</code> 查看容器的输出 调试必备</p>
<p><code>docker-compose pause</code> 暂停一个服务容器</p>
<p><code>docker-compose unpause</code> 恢复暂停</p>
<p><code>docker-compose port</code> 打印某个容器端口所映射的公共端口</p>
<p><code>docker-compose ps</code> 列出项目中目前的所有容器 -q 只打印容器 id</p>
<p><code>docker-compose pull</code> 拉取服务依赖的镜像</p>
<p><code>docker-compose restart -t</code> 指定重启前停止容器的超时默认10秒</p>
<p><code>docker-compose rm</code> 删除所有停止状态的容器先执行 stop</p>
<p><code>docker-compose run</code> 指定服务上执行一个命令</p>
<p><code>docker-compose start</code> 启动已经存在的服务容器</p>
<p><code>docker-compose stop</code> 停止已经存在的服务容器</p>
<p><code>docker-compose up</code> 自动构建、创建服务、启动服务, 关联一系列, 运行在前台, ctrl c 就都停止运行. 如果容器已经存在, 将会尝试停止容器, 重新创建. 如果不希望重新创建, 可以 <code>--no-recreate</code> 就只启动处于停止状态的容器, 如果只想重新部署某个服务, 可以使用</p>
<p><code>docker-compose up --no-deps -d</code> , 不影响其所依赖的服务</p>
<p><code>docker-compose up -d</code> 后台启动运行, 生产环境必备</p>
<p><code>docker-compose down</code> 停止并删除容器</p>
<h3 id="Zsh命令补全"><a href="#Zsh命令补全" class="headerlink" title="Zsh命令补全"></a>Zsh命令补全</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/.zsh/completion</span><br><span class="line">curl -L https://raw.githubusercontent.com/docker/compose/$(docker-compose version --short)/contrib/completion/zsh/_docker-compose &gt; ~/.zsh/completion/_docker-compose</span><br></pre></td></tr></table></figure>
<p>在<code>.zshrc</code>添加: </p>
<p><strong>注意</strong>: (如果是<code>oh-my-zsh</code>, 在<code>$ZSH/oh-my-zsh.sh</code>中添加)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fpath=(~/.zsh/completion $fpath)</span><br></pre></td></tr></table></figure>
<p>执行: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">autoload -Uz compinit &amp;&amp; compinit -i</span><br></pre></td></tr></table></figure>
<p>重载: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exec $SHELL -l</span><br></pre></td></tr></table></figure>
<h3 id="Compose-文件指令"><a href="#Compose-文件指令" class="headerlink" title="Compose 文件指令"></a>Compose 文件指令</h3><blockquote>
<p>最新参看文档: <strong><em><a href="https://docs.docker.com/compose/compose-file/" rel="external nofollow noopener noreferrer" target="_blank">https://docs.docker.com/compose/compose-file/</a></em></strong></p>
</blockquote>
<p>默认的模板文件名称为 <code>docker-compose.yml</code>, 格式为 YAML 格式. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  webapp:</span><br><span class="line">    image: examples/web</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:80&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/data&quot;</span><br></pre></td></tr></table></figure>
<p>注意每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 Dockerfile）等来自动构建生成镜像. </p>
<p>如果使用 <code>build</code> 指令, 在 <code>Dockerfile</code> 中设置的选项(例如: <code>CMD</code>, <code>EXPOSE</code>, <code>VOLUME</code>, <code>ENV</code> 等) 将会自动被获取, 无需在 <code>docker-compose.yml</code> 中再次设置. 下面分别介绍各个指令的用法. </p>
<h4 id="build"><a href="#build" class="headerlink" title="build"></a><code>build</code></h4><p>指定 <code>Dockerfile</code> 所在文件夹的路径（可以是绝对路径, 或者相对 docker-compose.yml 文件的路径）. <code>Compose</code> 将会利用它自动构建这个镜像, 然后使用这个镜像. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &apos;3&apos;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  webapp:</span><br><span class="line">    build: ./dir</span><br></pre></td></tr></table></figure>
<p>你也可以使用 <code>context</code> 指令指定 <code>Dockerfile</code> 所在文件夹的路径. </p>
<p>使用 <code>dockerfile</code> 指令指定 <code>Dockerfile</code> 文件名. </p>
<p>使用 <code>arg</code> 指令指定构建镜像时的变量. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &apos;3&apos;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  webapp:</span><br><span class="line">    build:</span><br><span class="line">      context: ./dir</span><br><span class="line">      dockerfile: Dockerfile-alternate</span><br><span class="line">      args:</span><br><span class="line">        buildno: 1</span><br></pre></td></tr></table></figure>
<p>使用 <code>cache_from</code> 指定构建镜像的缓存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">build:</span><br><span class="line">  context: .</span><br><span class="line">  cache_from:</span><br><span class="line">    - alpine:latest</span><br><span class="line">    - corp/web_app:3.14</span><br></pre></td></tr></table></figure>
<h4 id="cap-add-cap-drop"><a href="#cap-add-cap-drop" class="headerlink" title="cap_add, cap_drop"></a><code>cap_add, cap_drop</code></h4><p>指定容器的内核能力（capacity）分配. </p>
<p>例如, 让容器拥有所有能力可以指定为: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cap_add:</span><br><span class="line">  - ALL</span><br></pre></td></tr></table></figure>
<p>去掉 NET_ADMIN 能力可以指定为: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cap_drop:</span><br><span class="line">  - NET_ADMIN</span><br></pre></td></tr></table></figure>
<h4 id="command"><a href="#command" class="headerlink" title="command"></a><code>command</code></h4><p>覆盖容器启动后默认执行的命令. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">command: echo &quot;hello world&quot;</span><br></pre></td></tr></table></figure>
<h4 id="configs"><a href="#configs" class="headerlink" title="configs"></a><code>configs</code></h4><p>仅用于 <code>Swarm mode</code>, 详细内容请查看下面Swarm模式介绍</p>
<h4 id="cgroup-parent"><a href="#cgroup-parent" class="headerlink" title="cgroup_parent"></a><code>cgroup_parent</code></h4><p>指定父 <code>cgroup</code> 组, 意味着将继承该组的资源限制. </p>
<p>例如, 创建了一个 cgroup 组名称为 <code>cgroups_1</code>. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cgroup_parent: cgroups_1</span><br></pre></td></tr></table></figure>
<h4 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a><code>container_name</code></h4><p>指定容器名称. 默认将会使用 <code>项目名称_服务名称_序号</code> 这样的格式. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">container_name: docker-web-container</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意: 指定容器名称后, 该服务将<strong>无法进行扩展</strong>（<strong>scale</strong>）, 因为 Docker 不允许多个容器具有相同的名称. </p>
</blockquote>
<h4 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a><code>deploy</code></h4><p>仅用于 <code>Swarm mode</code>, 这是 V3 才能使用的语法, 通过<code>docker-compose up</code>方式启动会忽略这部分. </p>
<p>语法规则: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  replicas: 6</span><br><span class="line">  update_config:</span><br><span class="line">    parallelism: 2</span><br><span class="line">    delay: 10s</span><br><span class="line">  restart_policy:</span><br><span class="line">    condition: on-failure</span><br></pre></td></tr></table></figure>
<h5 id="mode"><a href="#mode" class="headerlink" title="mode"></a><code>mode</code></h5><p>首先 deploy 提供了一个模式选项, 它的值有 <code>global</code> 和 <code>replicated</code> 两个, 默认是 <code>replicated</code> 模式. </p>
<p>这两个模式的区别是: </p>
<ul>
<li><code>global</code>: 每个集群每个服务实例启动一个容器, 就像以前启动 Service 时一样. </li>
<li><code>replicated</code>: 用户可以指定集群中实例的副本数量. </li>
</ul>
<p>以前这个功能是无法在 Compose 中直接实现的, 以前需要用户先使用 <code>docker-compose bundle</code> 命令将 docker-compose.yml 转换为 .dab 文件, 然后才能拿到集群部署, 而且很多功能用不了. </p>
<p>但是随着这次更新把 stack 加进来了, deploy 也就水到渠成加进了 Compose 功能中. </p>
<h5 id="replicas"><a href="#replicas" class="headerlink" title="replicas"></a><code>replicas</code></h5><p>上面说到可以指定副本数量, 其中 replicas 就是用于指定副本数量的选项. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  replicas: 6</span><br></pre></td></tr></table></figure>
<p>部署服务栈: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stack deploy --compose-file docker-compose.yml</span><br></pre></td></tr></table></figure>
<h5 id="placement"><a href="#placement" class="headerlink" title="placement"></a><code>placement</code></h5><p>这是 Docker 1.12 版本时就引入的概念, 允许用户限制服务容器, 下面是官方的说明: </p>
<table>
<thead>
<tr>
<th>node attribute</th>
<th>matches</th>
<th>example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>node.id</code></td>
<td>Node ID</td>
<td><code>node.id==2ivku8v2gvtg4</code></td>
</tr>
<tr>
<td><code>node.hostname</code></td>
<td>Node hostname</td>
<td><code>node.hostname!=node-2</code></td>
</tr>
<tr>
<td><code>node.role</code></td>
<td>Node role</td>
<td><code>node.role==manager</code></td>
</tr>
<tr>
<td><code>node.labels</code></td>
<td>user defined node labels</td>
<td><code>node.labels.security==high</code></td>
</tr>
<tr>
<td><code>engine.labels</code></td>
<td>Docker Engine’s labels</td>
<td><code>engine.labels.operatingsystem==ubuntu 14.04</code></td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &apos;3&apos;</span><br><span class="line">services:</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints:</span><br><span class="line">          - node.role == manager</span><br><span class="line">          - engine.labels.operatingsystem == ubuntu 14.04</span><br><span class="line">        preferences:</span><br><span class="line">          - spread: node.labels.zone</span><br></pre></td></tr></table></figure>
<h5 id="update-config"><a href="#update-config" class="headerlink" title="update_config"></a><code>update_config</code></h5><p>早在上一个版本中, Swarm 就提供了一个升级回滚的功能. 当服务升级出现故障时, 超过重试次数则停止升级的功能, 这也很方便, 避免让错误的应用替代现有正常服务. </p>
<p>这个选项用于告诉 Compose 使用怎样的方式升级, 以及升级失败后怎样回滚原来的服务. </p>
<ul>
<li><code>parallelism</code>: 服务中多个容器同时更新. </li>
<li><code>delay</code>: 设置每组容器更新之间的延迟时间. </li>
<li><code>failure_action</code>: 设置更新失败时的动作, 可选值有 continue 与 pause (默认是: pause). </li>
<li><code>monitor</code>: 每次任务更新失败后监视故障的持续时间 (ns|us|ms|s|m|h) (默认: 0s). </li>
<li><code>max_failure_ratio</code>: 更新期间容忍的故障率. </li>
</ul>
<h5 id="resources"><a href="#resources" class="headerlink" title="resources"></a><code>resources</code></h5><p>看例子: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">resources:</span><br><span class="line">  limits:</span><br><span class="line">    cpus: &apos;0.001&apos;</span><br><span class="line">    memory: 50M</span><br><span class="line">  reservations:</span><br><span class="line">    cpus: &apos;0.0001&apos;</span><br><span class="line">    memory: 20M</span><br></pre></td></tr></table></figure>
<p>知道干啥用了吧, 这是一个新的语法选项, 替代了之前的类似 <code>cpu_shares</code>, <code>cpu_quota</code>, <code>cpuset</code>, <code>mem_limit</code>, <code>memswap_limit</code> 这种选项. 统一起来好看点. </p>
<h5 id="restart-policy"><a href="#restart-policy" class="headerlink" title="restart_policy"></a><code>restart_policy</code></h5><p>设置如何重启容器, 毕竟有时候容器会意外退出. </p>
<ul>
<li><code>condition</code>: 设置重启策略的条件, 可选值有 none, on-failure 和 any (默认: any). </li>
<li><code>delay</code>: 在重新启动尝试之间等待多长时间, 指定为持续时间（默认值: 0）. </li>
<li><code>max_attempts</code>: 设置最大的重启尝试次数, 默认是永不放弃, 哈哈, 感受到一股运维的绝望. </li>
<li><code>window</code>: 在决定重新启动是否成功之前要等待多长时间, 默认是立刻判断, 有些容器启动时间比较长, 指定一个“窗口期”非常重要. </li>
</ul>
<h4 id="devices"><a href="#devices" class="headerlink" title="devices"></a><code>devices</code></h4><p>指定设备映射关系. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">devices:</span><br><span class="line">  - &quot;/dev/ttyUSB1:/dev/ttyUSB0&quot;</span><br></pre></td></tr></table></figure>
<h4 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a><code>depends_on</code></h4><p>解决容器的依赖、<strong>启动先后的问题</strong>. 以下例子中会先启动 <code>redis</code> <code>db</code> 再启动 <code>web</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &apos;3&apos;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">      - redis</span><br><span class="line"></span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意: <code>web</code> 服务不会等待 <code>redis</code> <code>db</code> 「完全启动」之后才启动. </p>
</blockquote>
<h4 id="dns"><a href="#dns" class="headerlink" title="dns"></a><code>dns</code></h4><p>自定义 <code>DNS</code> 服务器. 可以是一个值, 也可以是一个列表. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dns: 8.8.8.8</span><br><span class="line"></span><br><span class="line">dns:</span><br><span class="line">  - 8.8.8.8</span><br><span class="line">  - 114.114.114.114</span><br></pre></td></tr></table></figure>
<h4 id="dns-search"><a href="#dns-search" class="headerlink" title="dns_search"></a><code>dns_search</code></h4><p>配置 <code>DNS</code> 搜索域. 可以是一个值, 也可以是一个列表. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dns_search: example.com</span><br><span class="line"></span><br><span class="line">dns_search:</span><br><span class="line">  - domain1.example.com</span><br><span class="line">  - domain2.example.com</span><br></pre></td></tr></table></figure>
<h4 id="tmpfs"><a href="#tmpfs" class="headerlink" title="tmpfs"></a><code>tmpfs</code></h4><p>挂载一个 tmpfs 文件系统到容器. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tmpfs: /run</span><br><span class="line">tmpfs:</span><br><span class="line">  - /run</span><br><span class="line">  - /tmp</span><br></pre></td></tr></table></figure>
<h4 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a><code>env_file</code></h4><p>从文件中获取环境变量, 可以为单独的文件路径或列表, 默认读当前目录<code>.env</code>. </p>
<p>如果通过 <code>docker-compose -f FILE</code> 方式来指定 Compose 模板文件, 则 <code>env_file</code> 中变量的路径会<strong>基于模板文件路径</strong>. </p>
<p>如果有变量名称与 <code>environment</code> 指令冲突, 则按照惯例, <strong>以后者为准</strong>. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">env_file: .env</span><br><span class="line"></span><br><span class="line">env_file:</span><br><span class="line">  - ./common.env</span><br><span class="line">  - ./apps/web.env</span><br><span class="line">  - /opt/secrets.env</span><br></pre></td></tr></table></figure>
<p>环境变量文件中每一行必须符合格式, 支持 <code>#</code> 开头的注释行. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># common.env: Set development environment</span><br><span class="line">PROG_ENV=development</span><br></pre></td></tr></table></figure>
<h4 id="environment"><a href="#environment" class="headerlink" title="environment"></a><code>environment</code></h4><p>设置环境变量. 你可以使用数组或字典两种格式. </p>
<p><strong>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值</strong>, <strong>可以用来防止泄露不必要的数据</strong>. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">environment:</span><br><span class="line">  RACK_ENV: development</span><br><span class="line">  SESSION_SECRET:</span><br><span class="line"></span><br><span class="line">environment:</span><br><span class="line">  - RACK_ENV=development</span><br><span class="line">  - SESSION_SECRET</span><br></pre></td></tr></table></figure>
<p>如果变量名称或者值中用到 <code>true|false, yes|no</code> 等表达 <a href="http://yaml.org/type/bool.html" rel="external nofollow noopener noreferrer" target="_blank">布尔</a> 含义的词汇, <strong>最好放到引号里</strong>, 避免 YAML 自动解析某些内容为对应的布尔语义. 这些特定词汇, 包括</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF</span><br></pre></td></tr></table></figure>
<h4 id="expose"><a href="#expose" class="headerlink" title="expose"></a><code>expose</code></h4><p>暴露端口, 但不映射到宿主机, 只被连接的服务访问. </p>
<p>仅可以指定内部端口为参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expose:</span><br><span class="line"> - &quot;3000&quot;</span><br><span class="line"> - &quot;8000&quot;</span><br></pre></td></tr></table></figure>
<h4 id="external-links"><a href="#external-links" class="headerlink" title="external_links"></a><code>external_links</code></h4><blockquote>
<p>注意: 不建议使用该指令. </p>
</blockquote>
<p>链接到 <code>docker-compose.yml</code> 外部的容器, 甚至并非 <code>Compose</code> 管理的外部容器. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">external_links:</span><br><span class="line"> - redis_1</span><br><span class="line"> - project_db_1:mysql</span><br><span class="line"> - project_db_1:postgresql</span><br></pre></td></tr></table></figure>
<h4 id="extra-hosts"><a href="#extra-hosts" class="headerlink" title="extra_hosts"></a><code>extra_hosts</code></h4><p>类似 Docker 中的 <code>--add-host</code> 参数, 指定额外的 host 名称映射信息. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extra_hosts:</span><br><span class="line"> - &quot;googledns:8.8.8.8&quot;</span><br><span class="line"> - &quot;dockerhub:52.1.157.61&quot;</span><br></pre></td></tr></table></figure>
<p>会在启动后的服务容器中 <code>/etc/hosts</code> 文件中添加如下两条条目. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8.8.8.8 googledns</span><br><span class="line">52.1.157.61 dockerhub</span><br></pre></td></tr></table></figure>
<h4 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a><code>healthcheck</code></h4><p>通过命令检查容器是否健康运行. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">healthcheck:</span><br><span class="line">  test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;]</span><br><span class="line">  interval: 1m30s</span><br><span class="line">  timeout: 10s</span><br><span class="line">  retries: 3</span><br></pre></td></tr></table></figure>
<h4 id="image"><a href="#image" class="headerlink" title="image"></a><code>image</code></h4><p>指定为镜像名称或镜像 ID. 如果镜像在本地不存在, <code>Compose</code> 将会尝试拉去这个镜像. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">image: ubuntu</span><br><span class="line">image: orchardup/postgresql</span><br><span class="line">image: a4bc65fd</span><br></pre></td></tr></table></figure>
<h4 id="labels"><a href="#labels" class="headerlink" title="labels"></a><code>labels</code></h4><p>为容器添加 Docker 元数据（metadata）信息. 例如可以为容器添加辅助说明信息. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">labels:</span><br><span class="line">  com.startupteam.description: &quot;webapp for a startup team&quot;</span><br><span class="line">  com.startupteam.department: &quot;devops department&quot;</span><br><span class="line">  com.startupteam.release: &quot;rc3 for v1.0&quot;</span><br></pre></td></tr></table></figure>
<h4 id="links"><a href="#links" class="headerlink" title="links"></a><code>links</code></h4><blockquote>
<p>注意: 不推荐使用该指令. </p>
</blockquote>
<h4 id="logging"><a href="#logging" class="headerlink" title="logging"></a><code>logging</code></h4><p>配置日志选项. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logging:</span><br><span class="line">  driver: syslog</span><br><span class="line">  options:</span><br><span class="line">    syslog-address: &quot;tcp://192.168.0.42:123&quot;</span><br></pre></td></tr></table></figure>
<p>目前支持三种日志驱动类型. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">driver: &quot;json-file&quot;</span><br><span class="line">driver: &quot;syslog&quot;</span><br><span class="line">driver: &quot;none&quot;</span><br></pre></td></tr></table></figure>
<p><code>options</code> 配置日志驱动的相关参数. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">options:</span><br><span class="line">  max-size: &quot;200k&quot;</span><br><span class="line">  max-file: &quot;10&quot;</span><br></pre></td></tr></table></figure>
<p>更多详情: <a href="https://docs.docker.com/engine/admin/logging/overview/" rel="external nofollow noopener noreferrer" target="_blank">https://docs.docker.com/engine/admin/logging/overview/</a></p>
<h4 id="network-mode"><a href="#network-mode" class="headerlink" title="network_mode"></a><code>network_mode</code></h4><p>设置网络模式. 使用和 <code>docker run</code> 的 <code>--network</code> 参数一样的值. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">network_mode: &quot;bridge&quot;</span><br><span class="line">network_mode: &quot;host&quot;</span><br><span class="line">network_mode: &quot;none&quot;</span><br><span class="line">network_mode: &quot;service:[service name]&quot;</span><br><span class="line">network_mode: &quot;container:[container name/id]&quot;</span><br></pre></td></tr></table></figure>
<h4 id="networks"><a href="#networks" class="headerlink" title="networks"></a><code>networks</code></h4><p>配置容器连接的网络. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  some-service:</span><br><span class="line">    networks:</span><br><span class="line">     - some-network</span><br><span class="line">     - other-network</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  some-network:</span><br><span class="line">  other-network:</span><br></pre></td></tr></table></figure>
<p>Docker 网络类型, 有 <code>bridge</code> <code>overlay</code>, 默认为<code>bridge</code>. 其中 <code>overlay</code> 网络类型用于 <code>Swarm mode</code></p>
<h4 id="pid"><a href="#pid" class="headerlink" title="pid"></a><code>pid</code></h4><p>跟主机系统共享进程命名空间. 打开该选项的容器之间, 以及容器和宿主机系统之间可以通过进程 ID 来相互访问和操作. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pid: &quot;host&quot;</span><br></pre></td></tr></table></figure>
<h4 id="ports"><a href="#ports" class="headerlink" title="ports"></a><code>ports</code></h4><p>暴露端口信息. </p>
<p>使用宿主端口: 容器端口 <code>(HOST:CONTAINER)</code> 格式, 或者仅仅指定容器的端口（宿主将会随机选择端口）都可以. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ports:</span><br><span class="line"> - &quot;3000&quot;</span><br><span class="line"> - &quot;8000:8000&quot;</span><br><span class="line"> - &quot;49100:22&quot;</span><br><span class="line"> - &quot;127.0.0.1:8001:8001&quot;</span><br></pre></td></tr></table></figure>
<p><em>注意: 当使用 HOST:CONTAINER 格式来映射端口时, 如果你使用的容器端口小于 60 并且没放到引号里, 可能会得到错误结果, 因为 YAML 会自动解析 xx:yy 这种数字格式为 60 进制. 为避免出现这种问题, 建议数字串都采用引号包括起来的字符串格式. </em></p>
<h4 id="secrets"><a href="#secrets" class="headerlink" title="secrets"></a><code>secrets</code></h4><p>存储敏感数据, 例如 <code>mysql</code> 服务密码. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">mysql:</span><br><span class="line">  image: mysql</span><br><span class="line">  environment:</span><br><span class="line">    MYSQL_ROOT_PASSWORD_FILE: /run/secrets/db_root_password</span><br><span class="line">  secrets:</span><br><span class="line">    - db_root_password</span><br><span class="line">    - my_other_secret</span><br><span class="line"></span><br><span class="line">secrets:</span><br><span class="line">  my_secret:</span><br><span class="line">    file: ./my_secret.txt</span><br><span class="line">  my_other_secret:</span><br><span class="line">    external: true</span><br></pre></td></tr></table></figure>
<h4 id="security-opt"><a href="#security-opt" class="headerlink" title="security_opt"></a><code>security_opt</code></h4><p>指定容器模板标签（label）机制的默认属性（用户、角色、类型、级别等）. 例如配置标签的用户名和角色名. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">security_opt:</span><br><span class="line">    - label:user:USER</span><br><span class="line">    - label:role:ROLE</span><br></pre></td></tr></table></figure>
<h4 id="stop-signal"><a href="#stop-signal" class="headerlink" title="stop_signal"></a><code>stop_signal</code></h4><p>设置另一个信号来停止容器. 在默认情况下使用的是 SIGTERM 停止容器. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stop_signal: SIGUSR1</span><br></pre></td></tr></table></figure>
<h4 id="sysctls"><a href="#sysctls" class="headerlink" title="sysctls"></a><code>sysctls</code></h4><p>配置容器内核参数. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sysctls:</span><br><span class="line">  net.core.somaxconn: 1024</span><br><span class="line">  net.ipv4.tcp_syncookies: 0</span><br><span class="line"></span><br><span class="line">sysctls:</span><br><span class="line">  - net.core.somaxconn=1024</span><br><span class="line">  - net.ipv4.tcp_syncookies=0</span><br></pre></td></tr></table></figure>
<h4 id="ulimits"><a href="#ulimits" class="headerlink" title="ulimits"></a><code>ulimits</code></h4><p>指定容器的 ulimits 限制值. </p>
<p>例如, 指定最大进程数为 65535, 指定文件句柄数为 20000（软限制, 应用可以随时修改, 不能超过硬限制） 和 40000（系统硬限制, 只能 root 用户提高）. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ulimits:</span><br><span class="line">  nproc: 65535</span><br><span class="line">  nofile:</span><br><span class="line">    soft: 20000</span><br><span class="line">    hard: 40000</span><br></pre></td></tr></table></figure>
<h4 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a><code>volumes</code></h4><p>数据卷所挂载路径设置. 可以设置宿主机路径 （<code>HOST:CONTAINER</code>） 或加上访问模式 （<code>HOST:CONTAINER:ro</code>）. </p>
<p>该指令中路径支持相对路径. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">volumes:</span><br><span class="line"> - /var/lib/mysql</span><br><span class="line"> - cache/:/tmp/cache</span><br><span class="line"> - ~/configs:/etc/configs/:ro</span><br></pre></td></tr></table></figure>
<h4 id="其它指令"><a href="#其它指令" class="headerlink" title="其它指令"></a>其它指令</h4><p>此外, 还有包括 <code>domainname, entrypoint, hostname, ipc, mac_address, privileged, read_only, shm_size, restart, stdin_open, tty, user, working_dir</code> 等指令, 基本跟 <code>docker run</code> 中对应参数的功能一致. </p>
<p>指定服务容器启动后执行的入口文件. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">entrypoint: /code/entrypoint.sh</span><br></pre></td></tr></table></figure>
<p>指定容器中运行应用的用户名. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user: nginx</span><br></pre></td></tr></table></figure>
<p>指定容器中工作目录. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">working_dir: /code</span><br></pre></td></tr></table></figure>
<p>指定容器中搜索域名、主机名、mac 地址等. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">domainname: your_website.com</span><br><span class="line">hostname: test</span><br><span class="line">mac_address: 08-00-27-00-0C-0A</span><br></pre></td></tr></table></figure>
<p>允许容器中运行一些特权命令. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">privileged: true</span><br></pre></td></tr></table></figure>
<p>指定容器退出后的重启策略为始终重启. 该命令对保持服务始终运行十分有效, 在生产环境中推荐配置为 <code>always</code> 或者 <code>unless-stopped</code>. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">restart: always</span><br></pre></td></tr></table></figure>
<p>以只读模式挂载容器的 root 文件系统, 意味着不能对容器内容进行修改. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">read_only: true</span><br></pre></td></tr></table></figure>
<p>打开标准输入, 可以接受外部输入. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stdin_open: true</span><br></pre></td></tr></table></figure>
<p>模拟一个伪终端. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tty: true</span><br></pre></td></tr></table></figure>
<h4 id="读取变量"><a href="#读取变量" class="headerlink" title="读取变量"></a>读取变量</h4><p>Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 <code>.env</code> 文件中的变量. </p>
<p>例如, 下面的 Compose 文件将从运行它的环境中读取变量 <code>${MONGO_VERSION}</code> 的值, 并写入执行的指令中. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">db:</span><br><span class="line">  image: &quot;mongo:$&#123;MONGO_VERSION&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>如果执行 <code>MONGO_VERSION=3.2 docker-compose up</code> 则会启动一个 <code>mongo:3.2</code> 镜像的容器；如果执行 <code>MONGO_VERSION=2.8 docker-compose up</code> 则会启动一个 <code>mongo:2.8</code> 镜像的容器. </p>
<p>若当前目录存在 <code>.env</code> 文件, 执行 <code>docker-compose</code> 命令时将从该文件中读取变量. </p>
<p>在当前目录新建 <code>.env</code> 文件并写入以下内容. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 支持 # 号注释</span><br><span class="line">MONGO_VERSION=3.6</span><br></pre></td></tr></table></figure>
<p>执行 <code>docker-compose up</code> 则会启动一个 <code>mongo:3.6</code> 镜像的容器. </p>
<p><strong>官方例子</strong>: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  redis:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;6379&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - frontend</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 2</span><br><span class="line">      update_config:</span><br><span class="line">        parallelism: 2</span><br><span class="line">        delay: 10s</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">  db:</span><br><span class="line">    image: postgres:9.4</span><br><span class="line">    volumes:</span><br><span class="line">      - db-data:/var/lib/postgresql/data</span><br><span class="line">    networks:</span><br><span class="line">      - backend</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line">  vote:</span><br><span class="line">    image: dockersamples/examplevotingapp_vote:before</span><br><span class="line">    ports:</span><br><span class="line">      - 5000:80</span><br><span class="line">    networks:</span><br><span class="line">      - frontend</span><br><span class="line">    depends_on:</span><br><span class="line">      - redis</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 2</span><br><span class="line">      update_config:</span><br><span class="line">        parallelism: 2</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">  result:</span><br><span class="line">    image: dockersamples/examplevotingapp_result:before</span><br><span class="line">    ports:</span><br><span class="line">      - 5001:80</span><br><span class="line">    networks:</span><br><span class="line">      - backend</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 1</span><br><span class="line">      update_config:</span><br><span class="line">        parallelism: 2</span><br><span class="line">        delay: 10s</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line"></span><br><span class="line">  worker:</span><br><span class="line">    image: dockersamples/examplevotingapp_worker</span><br><span class="line">    networks:</span><br><span class="line">      - frontend</span><br><span class="line">      - backend</span><br><span class="line">    deploy:</span><br><span class="line">      mode: replicated</span><br><span class="line">      replicas: 1</span><br><span class="line">      labels: [APP=VOTING]</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">        delay: 10s</span><br><span class="line">        max_attempts: 3</span><br><span class="line">        window: 120s</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line"></span><br><span class="line">  visualizer:</span><br><span class="line">    image: dockersamples/visualizer:stable</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:8080&quot;</span><br><span class="line">    stop_grace_period: 1m30s</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/var/run/docker.sock:/var/run/docker.sock&quot;</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  frontend:</span><br><span class="line">  backend:</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  db-data:</span><br></pre></td></tr></table></figure>
<h3 id="理解多compose文件组合"><a href="#理解多compose文件组合" class="headerlink" title="理解多compose文件组合"></a>理解多compose文件组合</h3><p>默认, <code>compose</code>会读取两个文件, 一个<code>docker-compose.yml</code>和一个可选的<code>docker-compose.override.yml</code>文件. 通常, <code>docker-compose.yml</code>文件包含你的基本配置, 而<code>docker-compose.override.yml</code>, 顾名思义, 就是包含的现有服务配置的覆盖内容, 或完全新的配置. </p>
<p>如果一个服务在这两个文件中都有定义, 那么<code>compose</code>将使用<a href="https://docs.docker.com/compose/extends/#adding-and-overriding-configuration" rel="external nofollow noopener noreferrer" target="_blank">添加和覆盖配置</a>中所描述的规则来合并服务</p>
<p>要使用多个<code>override</code>文件或不同名称的<code>override</code>文件, 可以使用<code>-f</code>选项来指定文件列表. <code>compose</code><strong>根据在命令行指定的顺序来合并它们</strong>. </p>
<p>当使用多个配置文件时, 必须确保文件中所有的路径都是<strong>相对于</strong><code>base compose</code>文件的(<code>-f</code> 指定的第一个<code>compose</code>文件). 这样要求是因为<code>override</code>文件不需要一个有效的<code>compose</code>文件. <code>override</code>文件可以只包含配置中的一小片段. 跟踪一个服务的片段是相对于那个路径的, 这是很困难的事, 所以一定要保持路径容易理解, 所以路径必须定义为相对于base文件的路径. </p>
<p><strong>例如</strong>, 定义两个配置文件: </p>
<p><strong>docker-compose.yml</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">web:</span><br><span class="line">  image: example/my_web_app:latest</span><br><span class="line">  links:</span><br><span class="line">    - db</span><br><span class="line">    - cache</span><br><span class="line"></span><br><span class="line">db:</span><br><span class="line">  image: postgres:latest</span><br><span class="line"></span><br><span class="line">cache:</span><br><span class="line">  image: redis:latest</span><br></pre></td></tr></table></figure>
<p><strong>docker-compose.prod.yml</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">web:</span><br><span class="line">  ports:</span><br><span class="line">    - 80:80</span><br><span class="line">  environment:</span><br><span class="line">    PRODUCTION: &apos;true&apos;</span><br><span class="line"></span><br><span class="line">cache:</span><br><span class="line">  environment:</span><br><span class="line">    TTL: &apos;500&apos;</span><br></pre></td></tr></table></figure>
<p>要使用这个生产compose文件部署, 运行如下命令: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d</span><br></pre></td></tr></table></figure>
<p>这将会使用<code>docker-compose.yml</code>和<code>docker-compose.prod.yml</code>来部署这三个服务</p>
<h2 id="Docker-Machine"><a href="#Docker-Machine" class="headerlink" title="Docker Machine"></a>Docker Machine</h2><p><img src="https://cdn.yangbingdong.com/img/docker-visual-management-and-orchestrate-tools/docker-machine-logo.png" alt></p>
<blockquote>
<p>Docker Machine 是供给和管理 docker 化主机的工具. 有自己的命令行客户端 <code>docker-machine</code>. 提供多种环境的 docker 主机, 可以用 Docker Machine 在一个或者多个虚拟系统（本地或者远程）上安装 Docker Engine. </p>
</blockquote>
<h3 id="Install-2"><a href="#Install-2" class="headerlink" title="Install"></a>Install</h3><p>最新安装请看官方文档: <strong><em><a href="https://docs.docker.com/machine/install-machine/" rel="external nofollow noopener noreferrer" target="_blank">https://docs.docker.com/machine/install-machine/</a></em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">base=https://github.com/docker/machine/releases/download/v0.14.0 &amp;&amp; \</span><br><span class="line">curl -L $base/docker-machine-$(uname -s)-$(uname -m) &gt;/tmp/docker-machine &amp;&amp; \</span><br><span class="line">sudo install /tmp/docker-machine /usr/local/bin/docker-machine</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.yangbingdong.com/img/docker-visual-management-and-orchestrate-tools/docker-machine-version.png" alt></p>
<p><strong>uninstall</strong>: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rm $(which docker-machine)</span><br></pre></td></tr></table></figure>
<h3 id="Zsh命令补全-1"><a href="#Zsh命令补全-1" class="headerlink" title="Zsh命令补全"></a>Zsh命令补全</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/.zsh/completion</span><br><span class="line">curl -L https://raw.githubusercontent.com/docker/machine/master/contrib/completion/zsh/_docker-machine &gt; ~/.zsh/completion/_docker-machine</span><br></pre></td></tr></table></figure>
<p>在<code>~/.zshrc</code>添加: </p>
<p><strong>注意</strong>: (如果是<code>oh-my-zsh</code>, 在<code>$ZSH/oh-my-zsh.sh</code>中添加)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fpath=(~/.zsh/completion $fpath)</span><br></pre></td></tr></table></figure>
<p>执行: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">autoload -Uz compinit &amp;&amp; \</span><br><span class="line">compinit -i &amp;&amp; \</span><br><span class="line">exec $SHELL -l</span><br></pre></td></tr></table></figure>
<h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><p>确保已经安装了<code>virtualbox</code>: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install virtualbox</span><br></pre></td></tr></table></figure>
<p>创建本地实例: </p>
<p>使用 <code>virtualbox</code> 类型的驱动, 创建一台 Docker 主机, 命名为 test. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-machine create -d virtualbox test</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.yangbingdong.com/img/docker-visual-management-and-orchestrate-tools/docker-machine-create.png" alt></p>
<p>你也可以在创建时加上如下参数, 来配置主机或者主机上的 Docker. </p>
<p><code>--engine-opt dns=114.114.114.114</code> 配置 Docker 的默认 DNS</p>
<p><code>--engine-registry-mirror https://registry.docker-cn.com</code> 配置 Docker 的仓库镜像</p>
<p><code>--engine-insecure-registry</code> 可以使用http的仓库</p>
<p><code>--virtualbox-memory 2048</code> 配置主机内存</p>
<p><code>--virtualbox-cpu-count 2</code> 配置主机 CPU</p>
<p>更多参数请使用 <code>docker-machine create --driver virtualbox --help</code> 命令查看. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-machine create --driver virtualbox --help</span><br><span class="line">Usage: docker-machine create [OPTIONS] [arg...]</span><br><span class="line"></span><br><span class="line">Create a machine.</span><br><span class="line"></span><br><span class="line">Run &apos;docker-machine create --driver name&apos; to include the create flags for that driver in the help text.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"></span><br><span class="line">   --driver, -d &quot;none&quot;                                                                                  Driver to create machine with.</span><br><span class="line">   --engine-env [--engine-env option --engine-env option]                                               Specify environment variables to set in the engine</span><br><span class="line">   --engine-insecure-registry [--engine-insecure-registry option --engine-insecure-registry option]     Specify insecure registries to allow with the created engine</span><br><span class="line">   --engine-install-url &quot;https://get.docker.com&quot;                                                        Custom URL to use for engine installation [$MACHINE_DOCKER_INSTALL_URL]</span><br><span class="line">   --engine-label [--engine-label option --engine-label option]                                         Specify labels for the created engine</span><br><span class="line">   --engine-opt [--engine-opt option --engine-opt option]                                               Specify arbitrary flags to include with the created engine in the form flag=value</span><br><span class="line">   --engine-registry-mirror [--engine-registry-mirror option --engine-registry-mirror option]           Specify registry mirrors to use [$ENGINE_REGISTRY_MIRROR]</span><br><span class="line">   --engine-storage-driver                                                                              Specify a storage driver to use with the engine</span><br><span class="line">   --swarm                                                                                              Configure Machine with Swarm</span><br><span class="line">   --swarm-addr                                                                                         addr to advertise for Swarm (default: detect and use the machine IP)</span><br><span class="line">   --swarm-discovery                                                                                    Discovery service to use with Swarm</span><br><span class="line">   --swarm-experimental                                                                                 Enable Swarm experimental features</span><br><span class="line">   --swarm-host &quot;tcp://0.0.0.0:3376&quot;                                                                    ip/socket to listen on for Swarm master</span><br><span class="line">   --swarm-image &quot;swarm:latest&quot;                                                                         Specify Docker image to use for Swarm [$MACHINE_SWARM_IMAGE]</span><br><span class="line">   --swarm-master                                                                                       Configure Machine to be a Swarm master</span><br><span class="line">   --swarm-opt [--swarm-opt option --swarm-opt option]                                                  Define arbitrary flags for swarm</span><br><span class="line">   --swarm-strategy &quot;spread&quot;                                                                            Define a default scheduling strategy for Swarm</span><br><span class="line">   --virtualbox-boot2docker-url                                                                         The URL of the boot2docker image. Defaults to the latest available version [$VIRTUALBOX_BOOT2DOCKER_URL]</span><br><span class="line">   --virtualbox-cpu-count &quot;1&quot;                                                                           number of CPUs for the machine (-1 to use the number of CPUs available) [$VIRTUALBOX_CPU_COUNT]</span><br><span class="line">   --virtualbox-disk-size &quot;20000&quot;                                                                       Size of disk for host in MB [$VIRTUALBOX_DISK_SIZE]</span><br><span class="line">   --virtualbox-host-dns-resolver                                                                       Use the host DNS resolver [$VIRTUALBOX_HOST_DNS_RESOLVER]</span><br><span class="line">   --virtualbox-dns-proxy                                                                               Proxy all DNS requests to the host [$VIRTUALBOX_DNS_PROXY]</span><br><span class="line">   --virtualbox-hostonly-cidr &quot;192.168.99.1/24&quot;                                                         Specify the Host Only CIDR [$VIRTUALBOX_HOSTONLY_CIDR]</span><br><span class="line">   --virtualbox-hostonly-nicpromisc &quot;deny&quot;                                                              Specify the Host Only Network Adapter Promiscuous Mode [$VIRTUALBOX_HOSTONLY_NIC_PROMISC]</span><br><span class="line">   --virtualbox-hostonly-nictype &quot;82540EM&quot;                                                              Specify the Host Only Network Adapter Type [$VIRTUALBOX_HOSTONLY_NIC_TYPE]</span><br><span class="line">   --virtualbox-import-boot2docker-vm                                                                   The name of a Boot2Docker VM to import</span><br><span class="line">   --virtualbox-memory &quot;1024&quot;                                                                           Size of memory for host in MB [$VIRTUALBOX_MEMORY_SIZE]</span><br><span class="line">   --virtualbox-no-share                                                                                Disable the mount of your home directory</span><br></pre></td></tr></table></figure>
<p>创建好主机之后, 查看主机</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-machine ls</span><br><span class="line"></span><br><span class="line">NAME      ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER       ERRORS</span><br><span class="line">test      -        virtualbox   Running   tcp://192.168.99.187:2376           v17.10.0-ce</span><br></pre></td></tr></table></figure>
<p>创建主机成功后, 可以通过 <code>env</code> 命令来让后续操作对象都是目标主机. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-machine env test</span><br></pre></td></tr></table></figure>
<p>后续根据提示在命令行输入命令之后就可以操作 test 主机. </p>
<p><img src="https://cdn.yangbingdong.com/img/docker-visual-management-and-orchestrate-tools/docker-machine-env.png" alt></p>
<p>通过以下命令恢复当前环境: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-machine env -u</span><br></pre></td></tr></table></figure>
<p>也可以通过 <code>SSH</code> 登录到主机. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-machine ssh test</span><br></pre></td></tr></table></figure>
<p>连接到主机之后你就可以在其上使用 Docker 了. </p>
<p><img src="https://cdn.yangbingdong.com/img/docker-visual-management-and-orchestrate-tools/docker-machine-ssh.png" alt></p>
<p><strong>操作命令</strong></p>
<ul>
<li><code>active</code> 查看活跃的 Docker 主机</li>
<li><code>config</code> 输出连接的配置信息</li>
<li><code>create</code> 创建一个 Docker 主机</li>
<li><code>env</code> 显示连接到某个主机需要的环境变量</li>
<li><code>inspect</code> 输出主机更多信息</li>
<li><code>ip</code> 获取主机地址</li>
<li><code>kill</code> 停止某个主机</li>
<li><code>ls</code> 列出所有管理的主机</li>
<li><code>provision</code> 重新设置一个已存在的主机</li>
<li><code>regenerate-certs</code> 为某个主机重新生成 TLS 认证信息</li>
<li><code>restart</code> 重启主机</li>
<li><code>rm</code> 删除某台主机</li>
<li><code>ssh</code> SSH 到主机上执行命令</li>
<li><code>scp</code> 在主机之间复制文件</li>
<li><code>mount</code> 挂载主机目录到本地</li>
<li><code>start</code> 启动一个主机</li>
<li><code>status</code> 查看主机状态</li>
<li><code>stop</code> 停止一个主机</li>
<li><code>upgrade</code> 更新主机 Docker 版本为最新</li>
<li><code>url</code> 获取主机的 URL</li>
<li><code>version</code> 输出 docker-machine 版本信息</li>
<li><code>help</code> 输出帮助信息</li>
</ul>
<p>每个命令, 又带有不同的参数, 可以通过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-machine COMMAND --help</span><br></pre></td></tr></table></figure>
<p>来查看具体的用法. </p>
<p><strong>注意: </strong>docker-machine 安装的 Docker 在 <code>/etc/systemd/system</code> 目录下多出了一个 Docker 相关的目录: <code>docker.service.d</code>. 这个目录中只有一个文件 <code>10-machine.conf</code>, 这个配置文件至关重要, 因为它会覆盖 Docker 默认安装时的配置文件, 从而以 Docker Machine 指定的方式启动 Docker daemon. 至此我们有了一个可以被远程访问的 Docker daemon. </p>
<h3 id="使用KVM引擎启动"><a href="#使用KVM引擎启动" class="headerlink" title="使用KVM引擎启动"></a>使用KVM引擎启动</h3><p><strong><em><a href="https://github.com/dhiltgen/docker-machine-kvm" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/dhiltgen/docker-machine-kvm</a></em></strong></p>
<p>首先确保安装了KVM: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install libvirt-bin qemu-kvm</span><br></pre></td></tr></table></figure>
<p>到 <strong><em><a href="https://github.com/dhiltgen/docker-machine-kvm/releases" rel="external nofollow noopener noreferrer" target="_blank">Release</a></em></strong> 页面下载相关驱动. </p>
<p>Ubuntu 16.04:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo curl -L https://github.com/dhiltgen/docker-machine-kvm/releases/download/v0.10.0/docker-machine-driver-kvm-ubuntu16.04 &gt; /usr/local/bin/docker-machine-driver-kvm &amp;&amp; sudo chmod +x /usr/local/bin/docker-machine-driver-kvm</span><br></pre></td></tr></table></figure>
<p>最后启动: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-machine create -d kvm --engine-registry-mirror=https://vioqnt8w.mirror.aliyuncs.com  --engine-insecure-registry=192.168.122.213 test01</span><br></pre></td></tr></table></figure>
<h2 id="Swarm-Mode"><a href="#Swarm-Mode" class="headerlink" title="Swarm Mode"></a>Swarm Mode</h2><blockquote>
<p> Docker 1.12 <a href="https://docs.docker.com/engine/swarm/" rel="external nofollow noopener noreferrer" target="_blank">Swarm mode</a> 已经内嵌入 Docker 引擎, 成为了 docker 子命令 <code>docker swarm</code>. 请注意与旧的 <code>Docker Swarm</code> 区分开来. </p>
<p> <code>Swarm mode</code> 内置 kv 存储功能, 提供了众多的新特性, 比如: 具有容错能力的去中心化设计、内置服务发现、负载均衡、路由网格、动态伸缩、滚动更新、安全传输等. 使得 Docker 原生的 <code>Swarm</code> 集群具备与 Mesos、Kubernetes 竞争的实力. </p>
</blockquote>
<h3 id="功能特点"><a href="#功能特点" class="headerlink" title="功能特点"></a>功能特点</h3><h4 id="与Docker-Engine集成的集群管理"><a href="#与Docker-Engine集成的集群管理" class="headerlink" title="与Docker Engine集成的集群管理"></a>与Docker Engine集成的集群管理</h4><p>使用Docker Engine CLI创建一组Docker引擎, 您可以在其中部署应用程序服务. 您不需要其他编排软件来创建或管理群集. </p>
<h4 id="节点分散式设计"><a href="#节点分散式设计" class="headerlink" title="节点分散式设计"></a>节点分散式设计</h4><p>Docker Engine不是在部署时处理节点角色之间的差异, 而是在运行时处理角色变化. 您可以使用Docker Engine部署两种类型的节点, 管理节点和工作节点. 这意味着您可以从单个服务器构建整个群集. </p>
<h4 id="声明性服务模型"><a href="#声明性服务模型" class="headerlink" title="声明性服务模型"></a>声明性服务模型</h4><p>Docker Engine使用声明性方法来定义应用程序堆栈中各种服务的所需状态. 例如, 您可以描述由具有消息队列服务和数据库后端的Web前端服务组成的应用程序. </p>
<h4 id="可扩容与缩放容器"><a href="#可扩容与缩放容器" class="headerlink" title="可扩容与缩放容器"></a>可扩容与缩放容器</h4><p>对于每个服务, 您可以声明要运行的任务数. 当您向上或向下缩放时, swarm管理器通过添加或删除任务来自动适应, 以保持所需的任务数量来保证集群的可靠状态. </p>
<h4 id="容器容错状态协调"><a href="#容器容错状态协调" class="headerlink" title="容器容错状态协调"></a>容器容错状态协调</h4><p>群集管理器节点不断监视群集状态, 并协调您表示的期望状态的实际状态之间的任何差异. 例如, 如果设置一个服务以运行容器的10个副本, 并且托管其中两个副本的工作程序计算机崩溃, 则管理器将创建两个新副本以替换崩溃的副本. swarm管理器将新副本分配给正在运行和可用的worker节点上. </p>
<h4 id="多主机网络"><a href="#多主机网络" class="headerlink" title="多主机网络"></a>多主机网络</h4><p>您可以为服务指定覆盖网络. 当swarm管理器初始化或更新应用程序时, 它会自动为覆盖网络上的容器分配地址. </p>
<h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><p>Swarm管理器节点为swarm中的每个服务分配唯一的DNS名称, 并负载平衡运行的容器. 您可以通过嵌入在swarm中的DNS服务器查询在群中运行的每个容器. </p>
<h4 id="负载平衡"><a href="#负载平衡" class="headerlink" title="负载平衡"></a>负载平衡</h4><p>您可以将服务的端口公开给外部负载平衡器. 在内部, swarm允许您指定如何在节点之间分发服务容器. </p>
<h4 id="缺省安全"><a href="#缺省安全" class="headerlink" title="缺省安全"></a>缺省安全</h4><p>群中的每个节点强制执行TLS相互验证和加密, 以保护其自身与所有其他节点之间的通信. 您可以选择使用自签名根证书或来自自定义根CA的证书. </p>
<h4 id="滚动更新"><a href="#滚动更新" class="headerlink" title="滚动更新"></a>滚动更新</h4><p>在已经运行期间, 您可以增量地应用服务更新到节点. swarm管理器允许您控制将服务部署到不同节点集之间的延迟. 如果出现任何问题, 您可以将任务回滚到服务的先前版本. </p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h4><p>运行 Docker 的主机可以主动初始化一个 <code>Swarm</code> 集群或者加入一个已存在的 <code>Swarm</code> 集群, 这样这个运行 Docker 的主机就成为一个 <code>Swarm</code> 集群的节点 (<code>node</code>) . </p>
<p>节点分为管理 (<code>manager</code>) 节点和工作 (<code>worker</code>) 节点. </p>
<p>管理节点用于 <code>Swarm</code> 集群的管理, <code>docker swarm</code> 命令基本只能在管理节点执行（节点退出集群命令 <code>docker swarm leave</code> 可以在工作节点执行）. 一个 <code>Swarm</code> 集群可以有多个管理节点, 但只有一个管理节点可以成为 <code>leader</code>, <code>leader</code> 通过 <code>raft</code> 协议实现. </p>
<p>工作节点是任务执行节点, 管理节点将服务 (<code>service</code>) 下发至工作节点执行. 管理节点默认也作为工作节点. 你也可以通过配置让服务只运行在管理节点. </p>
<p><img src="https://cdn.yangbingdong.com/img/docker-visual-management-and-orchestrate-tools/swarm-diagram.png" alt></p>
<h4 id="服务和任务"><a href="#服务和任务" class="headerlink" title="服务和任务"></a>服务和任务</h4><p>任务 （<code>Task</code>）是 <code>Swarm</code> 中的最小的调度单位, 目前来说就是一个单一的容器. </p>
<p>服务 （<code>Services</code>） 是指一组任务的集合, 服务定义了任务的属性. 服务有两种模式: </p>
<ul>
<li><code>replicated services</code> 按照一定规则在各个工作节点上运行指定个数的任务. </li>
<li><code>global services</code> 每个工作节点上运行一个任务</li>
</ul>
<p>两种模式通过 <code>docker service create</code> 的 <code>--mode</code> 参数指定. </p>
<p><strong>下图解释服务、任务、容器: </strong></p>
<p><img src="https://cdn.yangbingdong.com/img/docker-visual-management-and-orchestrate-tools/services-diagram.png" alt></p>
<p><strong>服务的任务及调试说明: </strong></p>
<p><img src="https://cdn.yangbingdong.com/img/docker-visual-management-and-orchestrate-tools/docker-swarm-task.png" alt></p>
<p><strong>服务部署的复制模式和全局模式说明: </strong></p>
<p><img src="https://cdn.yangbingdong.com/img/docker-visual-management-and-orchestrate-tools/docker-swarm-net.png" alt></p>
<h3 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h3><p>在创建集群前, 如果开启了防火墙, 请确认三台主机的防火墙能让swarm需求的端口开放, 需要打开主机之间的端口, 以下端口必须可用. 在某些系统上, 这些端口默认为打开.<br><strong>2377</strong>: TCP端口2377用于集群管理通信<br><strong>7946</strong>: TCP和UDP端口7946用于节点之间的通信<br><strong>4789</strong>: TCP和UDP端口4789用于覆盖网络流量<br>如果您计划使用加密（–opt加密）创建覆盖网络, 则还需要确保协议50（ESP）已打开. </p>
<p>docker swarm命令: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker swarm init --advertise-addr 172.18.60.133</span><br><span class="line"></span><br><span class="line">#恢复</span><br><span class="line">docker swarm init --advertise-addr 172.18.60.133 --force-new-cluster</span><br><span class="line"></span><br><span class="line">#其它节点加入</span><br><span class="line">docker swarm join --token \</span><br><span class="line">     SWMTKN-1-44gjumnutrh4k9lls54f5hp43kiioxf16iuh7qarjfqjsu7jio-2326b8ikb1xiysm3i7neh9nho 172.18.60.133:2377</span><br><span class="line">     </span><br><span class="line">#输出可以用来以worker角色加入的token</span><br><span class="line">docker swarm join-token worker</span><br><span class="line"></span><br><span class="line">#输出可以用来以manager角色加入的token</span><br><span class="line">docker swarm join-token manager</span><br><span class="line"></span><br><span class="line">#manager节点强制脱离</span><br><span class="line">docker swarm leave --force</span><br><span class="line"></span><br><span class="line">#worker节点脱离</span><br><span class="line">docker swarm leave</span><br><span class="line"></span><br><span class="line">#节点从swarm中移除</span><br><span class="line">docker node rm XXXXX</span><br><span class="line"></span><br><span class="line">#worker节点提升为manager</span><br><span class="line">docker node promote ilog2</span><br><span class="line"></span><br><span class="line">#恢复为worker</span><br><span class="line">docker node demote &lt;NODE&gt;</span><br><span class="line"></span><br><span class="line">#创建服务</span><br><span class="line">docker service create --replicas 3 --name helloworld alpine ping docker.com</span><br></pre></td></tr></table></figure>
<h3 id="节点管理"><a href="#节点管理" class="headerlink" title="节点管理"></a>节点管理</h3><h4 id="查看集群中的docker信息"><a href="#查看集群中的docker信息" class="headerlink" title="查看集群中的docker信息"></a>查看集群中的docker信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker -H 10.0.11.150:2376 info</span><br></pre></td></tr></table></figure>
<h4 id="列出节点"><a href="#列出节点" class="headerlink" title="列出节点"></a>列出节点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker node ls</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.yangbingdong.com/img/docker-visual-management-and-orchestrate-tools/docker-node-ls.png" alt></p>
<p>说明:<br><strong>AVAILABILITY列</strong>:<br>显示调度程序是否可以将任务分配给节点: </p>
<ul>
<li><code>Active</code> 意味着调度程序可以将任务分配给节点. </li>
<li><code>Pause</code> 意味着调度程序不会将新任务分配给节点, 但现有任务仍在运行. </li>
<li><code>Drain</code> 意味着调度程序不会向节点分配新任务. 调度程序关闭所有现有任务并在可用节点上调度它们. </li>
</ul>
<p><strong>MANAGER STATUS列</strong><br>显示节点是属于manager或者worker</p>
<ul>
<li><strong>没有值</strong> 表示不参与群管理的工作节点. </li>
<li><code>Leader</code> 意味着该节点是使得群的所有群管理和编排决策的主要管理器节点. </li>
<li><code>Reachable</code> 意味着节点是管理者节点正在参与Raft共识. 如果领导节点不可用, 则该节点有资格被选为新领导者. </li>
<li><code>Unavailable</code> 意味着节点是不能与其他管理器通信的管理器. 如果管理器节点不可用, 您应该将新的管理器节点加入群集, 或者将工作器节点升级为管理器. </li>
</ul>
<h4 id="查看节点的详细信息"><a href="#查看节点的详细信息" class="headerlink" title="查看节点的详细信息"></a>查看节点的详细信息</h4><p>您可以在管理器节点上运行<code>docker node inspect</code>来查看单个节点的详细信息. 输出默认为JSON格式, 但您可以传递<code>–pretty</code>标志以以可读的yml格式打印结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ybd @ ybd-PC in ~ [9:37:23] </span><br><span class="line">$ docker node inspect --pretty ybd-machine1 </span><br><span class="line">ID:			f917bibevklfp3xjsjoyx2g2t</span><br><span class="line">Hostname:              	ybd-machine1</span><br><span class="line">Joined at:             	2018-01-03 10:00:28.499769713 +0000 utc</span><br><span class="line">Status:</span><br><span class="line"> State:			Ready</span><br><span class="line"> Availability:         	Active</span><br><span class="line"> Address:		192.168.6.113</span><br><span class="line">Platform:</span><br><span class="line"> Operating System:	linux</span><br><span class="line"> Architecture:		x86_64</span><br><span class="line">Resources:</span><br><span class="line"> CPUs:			1</span><br><span class="line"> Memory:		995.9MiB</span><br><span class="line">Plugins:</span><br><span class="line"> Log:		awslogs, fluentd, gcplogs, gelf, journald, json-file, logentries, splunk, syslog</span><br><span class="line"> Network:		bridge, host, macvlan, null, overlay</span><br><span class="line"> Volume:		local</span><br><span class="line">Engine Version:		17.12.0-ce</span><br><span class="line">Engine Labels:</span><br><span class="line"> - provider=virtualbox</span><br><span class="line">TLS Info:</span><br><span class="line"> TrustRoot:</span><br><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">MIIBajCCARCgAwIBAgIUTdhfszkLcL0IC92X4TaOWbQlbZAwCgYIKoZIzj0EAwIw</span><br><span class="line">EzERMA8GA1UEAxMIc3dhcm0tY2EwHhcNMTcxMjIyMDg0NzAwWhcNMzcxMjE3MDg0</span><br><span class="line">NzAwWjATMREwDwYDVQQDEwhzd2FybS1jYTBZMBMGByqGSM49AgEGCCqGSM49AwEH</span><br><span class="line">A0IABEWabJlpAGjNi6x8QWGXnMUFwPe27anM5nHwLX8y05TbgamYvV7Is4CZ1BbU</span><br><span class="line">ypJ/a9FpSp4FbV/6iYveIwwaHLSjQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMB</span><br><span class="line">Af8EBTADAQH/MB0GA1UdDgQWBBR1K7f/HuhGDD2gzDeejaH2r8ZxIzAKBggqhkjO</span><br><span class="line">PQQDAgNIADBFAiEApL0o/FwwzLrhalYddR+buFHg0Hg3jKh37t00TmMU7SICIAOz</span><br><span class="line">YZNcngOkQiY2K2poQqRw+dFU9xOk543G+zDHqX4h</span><br><span class="line">-----END CERTIFICATE-----</span><br><span class="line"></span><br><span class="line"> Issuer Subject:	MBMxETAPBgNVBAMTCHN3YXJtLWNh</span><br><span class="line"> Issuer Public Key:	MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAERZpsmWkAaM2LrHxBYZecxQXA97btqczmcfAtfzLTlNuBqZi9XsizgJnUFtTKkn9r0WlKngVtX/qJi94jDBoctA==</span><br></pre></td></tr></table></figure>
<h4 id="更新节点"><a href="#更新节点" class="headerlink" title="更新节点"></a>更新节点</h4><p>Usage:    docker node update [OPTIONS] NODE</p>
<p>Options:<br>      –availability string   Availability of the node (“active”|”pause”|”drain”)<br>      –label-add list        Add or update a node label (key=value)<br>      –label-rm list         Remove a node label if exists<br>      –role string           Role of the node (“worker”|”manager”)</p>
<h4 id="升级或降级节点"><a href="#升级或降级节点" class="headerlink" title="升级或降级节点"></a>升级或降级节点</h4><p>您可以将工作程序节点提升为manager角色. 这在管理器节点不可用或者您希望使管理器脱机以进行维护时很有用. 类似地, 您可以将管理器节点降级为worker角色.<br>无论您升级或降级节点, 您应该始终在群中维护<strong>奇数个</strong>管理器节点.<br>要升级一个节点或一组节点, 请从管理器节点运行: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker node promote [NODE]</span><br><span class="line">docker node domote [NODE]</span><br></pre></td></tr></table></figure>
<h4 id="退出docker-swarm集群"><a href="#退出docker-swarm集群" class="headerlink" title="退出docker swarm集群"></a>退出docker swarm集群</h4><p>work节点: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker swarm leave</span><br></pre></td></tr></table></figure>
<p>manager节点: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker swarm leave -f</span><br></pre></td></tr></table></figure>
<h3 id="可视化visualizer服务"><a href="#可视化visualizer服务" class="headerlink" title="可视化visualizer服务"></a>可视化visualizer服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">--name=viz \</span><br><span class="line">--publish=8088:8080/tcp \</span><br><span class="line">--constraint=node.role==manager \</span><br><span class="line">--mount=type=bind,src=/var/run/docker.sock,dst=/var/run/docker.sock \</span><br><span class="line">dockersamples/visualizer</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.yangbingdong.com/img/docker-visual-management-and-orchestrate-tools/visualizer.png" alt></p>
<h3 id="Service用法"><a href="#Service用法" class="headerlink" title="Service用法"></a>Service用法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建服务</span><br><span class="line">docker service create \</span><br><span class="line">--image nginx \</span><br><span class="line">--replicas 2 \</span><br><span class="line">nginx</span><br><span class="line"> </span><br><span class="line">更新服务</span><br><span class="line">docker service update \</span><br><span class="line">--image nginx:alpine \</span><br><span class="line">nginx</span><br><span class="line"> </span><br><span class="line">删除服务</span><br><span class="line">docker service rm nginx</span><br><span class="line"> </span><br><span class="line">减少服务实例(这比直接删除服务要好)</span><br><span class="line">docker service scale nginx=0</span><br><span class="line"> </span><br><span class="line">增加服务实例</span><br><span class="line">docker service scale nginx=5</span><br><span class="line"> </span><br><span class="line">查看所有服务</span><br><span class="line">docker service ls</span><br><span class="line"> </span><br><span class="line">查看服务的容器状态</span><br><span class="line">docker service ps nginx</span><br><span class="line"> </span><br><span class="line">查看服务的详细信息. </span><br><span class="line">docker service inspect nginx</span><br></pre></td></tr></table></figure>
<p><strong>实现零宕机部署也非常简单. </strong>这样也可以方便地实现持续部署:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">构建新镜像</span><br><span class="line">docker build -t hub.docker.com/image .</span><br><span class="line"> </span><br><span class="line">将新镜像上传到Docker仓库</span><br><span class="line">docker push hub.docker.com/image</span><br><span class="line"> </span><br><span class="line">更新服务的镜像</span><br><span class="line">docker service update --image hub.docker.com/image service</span><br></pre></td></tr></table></figure>
<p><strong>更新服务要慎重</strong>. 你的容器同时运行在多个主机上. 更新服务时, 只需要更新Docker镜像. 合理的测试和部署流程是保证成功的关键. <strong>Swarm非常容易入门</strong>. 分布式系统通常是非常复杂的. 与其他容器集群系统(Mesos, Kubernetes)相比, Swarm的学习曲线<strong>最低</strong>. </p>
<h1 id="Docker-Visual-Management"><a href="#Docker-Visual-Management" class="headerlink" title="Docker Visual Management"></a>Docker Visual Management</h1><h2 id="Rancher"><a href="#Rancher" class="headerlink" title="Rancher"></a>Rancher</h2><p><a href="http://rancher.com/" rel="external nofollow noopener noreferrer" target="_blank"><strong><em>官方网站</em></strong></a></p>
<p>如果是对集群管理并且管理员只限制Docker命令权限的话, 建议用这个工具, 商店用起来都比较方便, </p>
<p><strong>优点</strong>: 界面中文化, 操作简单易懂,功能强大,容灾机制. </p>
<p><strong>缺点</strong>: 不能团队分配权限, 容器操作权限太大没法满足需求, 部署时相应的Docker 服务也很多, 需要逐一去了解容器作用. </p>
<p><img src="https://cdn.yangbingdong.com/img/docker-visual-management-and-orchestrate-tools/rancher.png" alt></p>
<h2 id="Shipyard"><a href="#Shipyard" class="headerlink" title="Shipyard"></a>Shipyard</h2><p><a href="https://shipyard-project.com/" rel="external nofollow noopener noreferrer" target="_blank"><strong><em>官方网站</em></strong></a></p>
<p>Shipyard是在Docker Swarm的基础上, 管理Docker资源, 包括容器, 镜像, 注册表等. </p>
<p><strong>优点</strong>: </p>
<ol>
<li>支持镜像管理、容器管理. </li>
<li>支持控制台命令</li>
<li>容器资源消耗监控</li>
<li>支持集群swarm, 可以随意增加节点</li>
<li>支持控制用户管理权限, 可以设置某个容器对某个用户只读、管理权限. </li>
<li>有汉化版</li>
</ol>
<p><strong>缺点</strong> : </p>
<ol>
<li>启动容器较多, 占用每个节点的一部分资源</li>
</ol>
<p>部署: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -sSL https://shipyard-project.com/deploy | bash -s</span><br></pre></td></tr></table></figure>
<p>注意: 这将在端口2375上暴露Docker Engine. 如果此节点可以在安全网络之外访问, 建议使用TLS. </p>
<p>支持集群, 所以可以添加节点: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -sSL https://shipyard-project.com/deploy | ACTION=node DISCOVERY=etcd://10.0.0.10:4001 bash -s</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.yangbingdong.com/img/docker-visual-management-and-orchestrate-tools/shipyard-download.png" alt></p>
<p>它会下载并启动7个镜像: </p>
<p><img src="https://cdn.yangbingdong.com/img/docker-visual-management-and-orchestrate-tools/shipyard-need-containers.png" alt></p>
<p>界面: </p>
<p><img src="https://cdn.yangbingdong.com/img/docker-visual-management-and-orchestrate-tools/shipyard-containers.png" alt></p>
<p>容器信息: </p>
<p><img src="https://cdn.yangbingdong.com/img/docker-visual-management-and-orchestrate-tools/shipyard-container-info.png" alt></p>
<p>初体验来说, 感觉跟下面的Portainer功能差不多, 但是Registry总是添加失败</p>
<h2 id="Portainer"><a href="#Portainer" class="headerlink" title="Portainer"></a>Portainer</h2><p><a href="https://portainer.io/" rel="external nofollow noopener noreferrer" target="_blank"><strong><em>官方网站</em></strong></a></p>
<p><img src="https://cdn.yangbingdong.com/img/docker-visual-management-and-orchestrate-tools/portainer-demo.gif" alt></p>
<p><code>Portainer</code>是<code>Docker</code>的图形化管理工具, 提供状态显示面板、应用模板快速部署、容器镜像网络数据卷的基本操作（包括上传下载镜像, 创建容器等操作）、事件日志显示、容器控制台操作、<code>Swarm</code>集群和服务等集中管理和操作、登录用户管理和控制等功能. 功能十分全面, 基本能满足中小型单位对容器管理的全部需求. </p>
<p><strong>优点</strong></p>
<ol>
<li>支持容器管理、镜像管理</li>
<li>轻量级, 消耗资源少</li>
<li>基于docker api, 安全性高, 可指定docker api端口, 支持TLS证书认证. </li>
<li>支持权限分配</li>
<li>支持集群</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>功能不够强大. </li>
<li>容器创建后, 无法通过后台增加端口. </li>
<li>没有容灾机制</li>
</ol>
<p>单机启动: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 9000:9000 \</span><br><span class="line">--name portainer \</span><br><span class="line">--restart=always \</span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">portainer/portainer</span><br></pre></td></tr></table></figure>
<p>swarm模式启动: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">--name portainer \</span><br><span class="line">--publish 9000:9000 \</span><br><span class="line">--constraint &apos;node.role == manager&apos; \</span><br><span class="line">--mount type=bind,src=/var/run/docker.sock,dst=/var/run/docker.sock \</span><br><span class="line">--mount type=bind,src=/path/on/host/data,dst=/data \</span><br><span class="line">portainer/portainer \</span><br><span class="line">-H unix:///var/run/docker.sock</span><br></pre></td></tr></table></figure>
<p>容器管理: </p>
<p><img src="https://cdn.yangbingdong.com/img/docker-visual-management-and-orchestrate-tools/harbor-containers.png" alt></p>
<p>镜像管理: </p>
<p><img src="https://cdn.yangbingdong.com/img/docker-visual-management-and-orchestrate-tools/harbor-images.png" alt></p>
<p>镜像仓库: </p>
<p><img src="https://cdn.yangbingdong.com/img/docker-visual-management-and-orchestrate-tools/harbor-registry.png" alt></p>
<p>Endpoints: </p>
<p><img src="https://cdn.yangbingdong.com/img/docker-visual-management-and-orchestrate-tools/end-point.png" alt></p>
<p><strong>注意</strong>: 添加Endpoints先要暴露节点的2375端口. </p>
<h1 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h1><blockquote>
<p>参考: </p>
<p><strong><em><a href="https://yeasy.gitbooks.io/docker_practice/content/" rel="external nofollow noopener noreferrer" target="_blank">Docker — 从入门到实践</a></em></strong></p>
<p><strong><em><a href="http://www.jiagoumi.com/virtualization/1464.html" rel="external nofollow noopener noreferrer" target="_blank">在生产环境中使用Docker Swarm的一些建议</a></em></strong></p>
<p><strong><em><a href="https://www.jianshu.com/p/8d4fcff97a35" rel="external nofollow noopener noreferrer" target="_blank">使用Docker Harbor搭建私有镜像服务器和Mirror服务器</a></em></strong></p>
<p><strong><em><a href="https://deepzz.com/post/dockerd-and-docker-remote-api.html" rel="external nofollow noopener noreferrer" target="_blank">远程连接docker daemon, Docker Remote API</a></em></strong></p>
</blockquote>
]]></content><categories><category>Docker</category></categories><tags><tag>Docker</tag><tag>Swarm</tag></tags></entry><entry><title>Java基本数据类型传递与引用传递的那点事</title><url>/2017/java-call-by-value/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/java/201611161519205180.png" alt></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>今天在逛博客的时候看到了有意思的东西, 下面代码会输出什么？<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String s)</span> </span>&#123;     </span><br><span class="line">    s = <span class="string">"123"</span>;    </span><br><span class="line">&#125;     </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;     </span><br><span class="line">    String s = <span class="string">"abc"</span>;     </span><br><span class="line">    change(s);     </span><br><span class="line">    System.out.println(s);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>结果是<code>abc</code>.<br>为什么？经过一番查找与理解, 又学习到了…<br><a id="more"></a></p>
<h1 id="捋一捋术语"><a href="#捋一捋术语" class="headerlink" title="捋一捋术语"></a>捋一捋术语</h1><p>Java的值传递和引用传递在面试中一般都会都被涉及到, 今天我们就来聊聊这个问题, 首先我们必须认识到这个问题一般是相对函数而言的, 也就是java中的方法参数, 那么我们先来回顾一下在程序设计语言中有关参数传递给方法（或函数）的两个专业术语: </p>
<ul>
<li>按值调用（call by value）</li>
<li>按引用调用（call by reference）<br>所谓的按值调用表示方法接收的是调用着提供的值, 而按引用调用则表示方法接收的是调用者提供的变量地址(如果是C语言的话来说就是指针啦, 当然java并没有指针的概念). <strong>这里我们需要注意的是一个方法可以修改传递引用所对应的变量值, 而不能修改传递值调用所对应的变量值, 这句话相当重要, 这是按值调用与引用调用的根本区别</strong>. </li>
</ul>
<h1 id="基本数据类型的传递"><a href="#基本数据类型的传递" class="headerlink" title="基本数据类型的传递"></a>基本数据类型的传递</h1><p>前面说过java中并不存在引用调用, 这点是没错的, 因为java程序设计语言确实是采用了按值调用, 即call by value. 也就是说方法得到的是所有参数值的一个拷贝, 方法并不能修改传递给它的任何参数变量的内容. 下面来看一个例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallByValue</span> </span>&#123;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> x=<span class="number">10</span>;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">updateValue</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;  </span><br><span class="line">        value = <span class="number">3</span> * value;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"调用前x的值: "</span>+x);  </span><br><span class="line">        updateValue(x);  </span><br><span class="line">        System.out.println(<span class="string">"调用后x的值: "</span>+x);  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>运行程序, 结果如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">调用前x的值: 10</span><br><span class="line">调用后x的值: 10</span><br></pre></td></tr></table></figure></p>
<p>可以看到x的值并没有变化, 接下来我们一起来看一下具体的执行过程:<br><img src="https://cdn.yangbingdong.com/img/java-call-by-value/java-call-by-value01.png" alt><br> 分析:<br>1）value被初始化为x值的一个拷贝（也就是10）<br>2）value被乘以3后等于30, 但注意此时x的值仍为10！<br>3）这个方法结束后, 参数变量value不再使用, 被回收.<br>结论: <strong>当传递方法参数类型为基本数据类型（数字以及布尔值）时, 一个方法是不可能修改一个基本数据类型的参数</strong>. </p>
<h1 id="引用数据类型的传递"><a href="#引用数据类型的传递" class="headerlink" title="引用数据类型的传递"></a>引用数据类型的传递</h1><p>当然java中除了基本数据类型还有引用数据类型, 也就是对象引用, 那么对于这种数据类型又是怎么样的情况呢？还是一样先来看一个例子:<br>声明一个User对象类型:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name=name;  </span><br><span class="line">        <span class="keyword">this</span>.age=age;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> age;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.age = age;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行类如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallByValue</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> User user=<span class="keyword">null</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(User student)</span></span>&#123;  </span><br><span class="line">        student.setName(<span class="string">"Lishen"</span>);  </span><br><span class="line">        student.setAge(<span class="number">18</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        user = <span class="keyword">new</span> User(<span class="string">"zhangsan"</span>,<span class="number">26</span>);  </span><br><span class="line">        System.out.println(<span class="string">"调用前user的值: "</span>+user.toString());  </span><br><span class="line">        updateUser(user);  </span><br><span class="line">        System.out.println(<span class="string">"调用后user的值: "</span>+user.toString());  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">调用前user的值: User [name=zhangsan, age=26]</span><br><span class="line">调用后user的值: User [name=Lishen, age=18]</span><br></pre></td></tr></table></figure></p>
<p>很显然, User的值被改变了, 也就是说方法参数类型如果是引用类型的话, 引用类型对应的值将会被修改, 下面我们来分析一下这个过程:<br><img src="https://cdn.yangbingdong.com/img/java-call-by-value/java-call-by-value02.png" alt><br> 过程分析:<br>1）student变量被初始化为user值的拷贝, 这里是一个对象的引用.<br>2）调用student变量的set方法作用在这个引用对象上, user和student同时引用的User对象内部值被修改.<br>3）方法结束后, student变量不再使用, 被释放, 而user还是没有变, 依然指向User对象.<br>结论: <strong>当传递方法参数类型为引用数据类型时, 一个方法将修改一个引用数据类型的参数所指向对象的值</strong>. </p>
<h1 id="再来举个例子"><a href="#再来举个例子" class="headerlink" title="再来举个例子"></a>再来举个例子</h1><p>虽然到这里两个数据类型的传递都分析完了, 也明白的基本数据类型的传递和引用数据类型的传递区别, 前者将不会修改原数据的值, 而后者将会修改引用所指向对象的值. 可通过上面的实例我们可能就会觉得java同时拥有按值调用和按引用调用啊, 可惜的是这样的理解是有误导性的, 虽然上面引用传递表面上体现了按引用调用现象, 但是java中确实只有按值调用而没有按引用调用. 到这里估计不少人都蒙逼了, 下面我们通过一个反例来说明（回忆一下开头我们所说明的按值调用与按引用调用的根本区别）.<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallByValue</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> User user=<span class="keyword">null</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> User stu=<span class="keyword">null</span>;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 交换两个对象 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> y </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(User x,User y)</span></span>&#123;  </span><br><span class="line">        User temp =x;  </span><br><span class="line">        x=y;  </span><br><span class="line">        y=temp;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        user = <span class="keyword">new</span> User(<span class="string">"user"</span>,<span class="number">26</span>);  </span><br><span class="line">        stu = <span class="keyword">new</span> User(<span class="string">"stu"</span>,<span class="number">18</span>);  </span><br><span class="line">        System.out.println(<span class="string">"调用前user的值: "</span>+user.toString());  </span><br><span class="line">        System.out.println(<span class="string">"调用前stu的值: "</span>+stu.toString());  </span><br><span class="line">        swap(user,stu);  </span><br><span class="line">        System.out.println(<span class="string">"调用后user的值: "</span>+user.toString());  </span><br><span class="line">        System.out.println(<span class="string">"调用后stu的值: "</span>+stu.toString());  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们通过一个swap函数来交换两个变量user和stu的值, 在前面我们说过, 如果是按引用调用那么一个方法可以修改传递引用所对应的变量值, 也就是说如果java是按引用调用的话, 那么swap方法将能够实现数据的交换, 而实际运行结果是:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">调用前user的值: User [name=user, age=26]</span><br><span class="line">调用前stu的值: User [name=stu, age=18]</span><br><span class="line">调用后user的值: User [name=user, age=26]</span><br><span class="line">调用后stu的值: User [name=stu, age=18]</span><br></pre></td></tr></table></figure></p>
<p>我们发现user和stu的值并没有发生变化, 也就是方法并没有改变存储在变量user和stu中的对象引用. swap方法的参数x和y被初始化为<strong>两个对象引用的拷贝</strong>, 这个方法交换的是这两个拷贝的值而已, 最终, 所做的事都是白费力气罢了. 在方法结束后x, y将被丢弃, 而原来的变量user和stu仍然引用这个方法调用之前所引用的对象.<br><img src="https://cdn.yangbingdong.com/img/java-call-by-value/java-call-by-value03.png" alt><br>这个过程也充分说明了java程序设计语言对对象采用的不是引用调用, 实际上是对象引用进行的是值传递, 当然在这里我们可以简单理解为这就是按值调用和引用调用的区别, 而且必须明白即使java函数在传递引用数据类型时, 也只是拷贝了引用的值罢了, 之所以能修改引用数据是因为它们同时指向了一个对象, 但这仍然是按值调用而不是引用调用.<br>总结: </p>
<ul>
<li><strong>一个方法不能修改一个基本数据类型的参数（数值型和布尔型）</strong></li>
<li><strong>一个方法可以修改一个引用所指向的对象状态, 但这仍然是按值调用而非引用调用</strong></li>
<li><strong>上面两种传递都进行了值拷贝的过程</strong></li>
</ul>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><blockquote>
<p>参考<br><strong><em><a href="http://blog.csdn.net/javazejian/article/details/51192130" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/javazejian/article/details/51192130</a></em></strong><br><strong><em><a href="http://blog.csdn.net/seu_calvin/article/details/70089977" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/seu_calvin/article/details/70089977</a></em></strong></p>
</blockquote>
]]></content><categories><category>Programming</category><category>Java</category></categories><tags><tag>Java</tag><tag>Java basics</tag></tags></entry><entry><title>Java 并发拾遗-并发工具(上)</title><url>/2019/java-concurrent-part2/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/concurrent/java-concurrent-lock-condition-banner.png" alt></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><blockquote>
<p>JDK 并发包中有着许许多多的工具类, 将分为上中下三篇回顾这些工具类以及其简单的使用.</p>
</blockquote>
<a id="more"></a>
<h1 id="Lock-amp-Condition"><a href="#Lock-amp-Condition" class="headerlink" title="Lock&amp;Condition"></a>Lock&amp;Condition</h1><blockquote>
<p>在并发编程领域, 有两大核心问题: 一个是<strong>互斥</strong>, 即同一时刻只允许一个线程访问共享资源; 另一个是<strong>同步</strong>, 即线程之间如何通信、协作. 这两大问题, 管程都是能够解决的. <strong>Java SDK 并发包通过 Lock 和 Condition 两个接口来实现管程, 其中 Lock 用于解决互斥问题, Condition 用于解决同步问题. </strong></p>
</blockquote>
<h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><h3 id="造轮子的理由"><a href="#造轮子的理由" class="headerlink" title="造轮子的理由"></a>造轮子的理由</h3><p>Java 已经提供了管程的相关实现 <code>synchronized</code>, 那么为什么还有一个 <code>Lock</code>, 需要了解一下 <code>synchronized</code> 的局限性. 在 <em><a href="https://yangbingdong.com/2019/java-concurrent-part1/#%E6%AD%BB%E9%94%81">上一篇的死锁问题</a></em> 中, 提出了一个<strong>破坏不可抢占条件</strong>方案, 这个方案 <code>synchronized</code> 没有办法解决. 原因是 <code>synchronized</code> 申请资源的时候, 如果申请不到, 线程直接进入阻塞状态了, 而线程进入阻塞状态, 啥都干不了, 也释放不了线程已经占有的资源. </p>
<p>在 Lock 的API 中, 体现了实现这个方案的三个办法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 支持中断的API</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">// 支持超时的API</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> </span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">// 支持非阻塞获取锁的API</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h3><blockquote>
<p>Java 里多线程的可见性是<strong>通过 Happens-Before 规则保证的</strong>, 而 <code>synchronized</code> 之所以能够保证可见性, 也是因为有一条 <code>synchronized</code> 相关的规则: <code>synchronized</code> 的解锁 Happens-Before 于后续对这个锁的加锁. </p>
</blockquote>
<p>先来看一段代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock rtl =</span><br><span class="line">  <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    rtl.lock();  </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      value+=<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 保证锁能释放</span></span><br><span class="line">      rtl.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>try{}finally{}</code> 是 Lock 使用的经典范式.</p>
</blockquote>
<p>Lock <strong>利用了 <code>volatile</code> 相关的 Happens-Before 规则</strong> 保证可见性. Java SDK 里面的 <code>ReentrantLock</code>, 内部持有一个 <code>volatile</code> 的成员变量 <code>state</code>, 获取锁的时候, 会读写 <code>state</code> 的值; 解锁的时候, 也会读写 <code>state</code> 的值, 简化版代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleLock</span> </span>&#123;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line">  <span class="comment">// 加锁</span></span><br><span class="line">  lock() &#123;</span><br><span class="line">    <span class="comment">// 省略代码无数</span></span><br><span class="line">    state = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 解锁</span></span><br><span class="line">  unlock() &#123;</span><br><span class="line">    <span class="comment">// 省略代码无数</span></span><br><span class="line">    state = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据相关的 Happens-Before 规则: </p>
<ol>
<li><strong>顺序性规则</strong>: 对于线程 T1, <code>value+=1</code> Happens-Before 释放锁的操作 <code>unlock()</code>; </li>
<li><strong><code>volatile</code> 变量规则</strong>: 由于 <code>state = 1</code> 会先读取 <code>state</code>, 所以线程 T1 的 <code>unlock()</code> 操作 Happens-Before 线程 T2 的 <code>lock()</code> 操作; </li>
<li><strong>传递性规则</strong>: 线程 T1 的 <code>value+=1</code> Happens-Before 线程 T2 的 <code>lock()</code> 操作. </li>
</ol>
<h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>上面代码中创建的锁为 <code>ReentrantLock</code>, 翻译过来为可重入锁, 所谓可重入锁, 顾名思义, 指的是<strong>线程可以重复获取同一把锁</strong>. </p>
<p>例如下面代码中, 当线程 T1 执行到 ① 处时, 已经获取到了锁 rtl , 当在 ① 处调用 <code>get()</code> 方法时, 会在 ② 再次对锁 rtl 执行加锁操作. 此时, 如果锁 rtl 是可重入的, 那么线程 T1 可以再次加锁成功; 如果锁 rtl 是不可重入的, 那么线程 T1 此时会被阻塞. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock rtl =</span><br><span class="line">  <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    rtl.lock();         ②</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 保证锁能释放</span></span><br><span class="line">      rtl.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    rtl.lock();  </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      value = <span class="number">1</span> + get(); ①</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 保证锁能释放</span></span><br><span class="line">      rtl.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><p><code>ReentrantLock</code> 这个类有两个构造函数:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无参构造函数: 默认非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据公平策略参数创建锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span></span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() </span><br><span class="line">                : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>锁都对应着一个等待队列, 如果一个线程没有获得锁, 就会进入等待队列, 当有线程释放锁的时候, 就需要从等待队列中唤醒一个等待的线程. 如果是公平锁, 唤醒的策略就是谁等待的时间长, 就唤醒谁, 很公平; 如果是非公平锁, 则不提供这个公平保证, 有可能等待时间短的线程反而先被唤醒. </p>
<p>并发大师 Doug Lea《Java 并发编程: 设计原则与模式》一书中, 推荐的三个用锁的最佳实践, 它们分别是: </p>
<ul>
<li>永远只在更新对象的成员变量时加锁;</li>
<li>永远只在访问可变的成员变量时加锁;</li>
<li>永远不在调用其他对象的方法时加锁.</li>
</ul>
<h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p><strong>Condition 实现了管程模型里面的条件变量</strong>, Java 内置的管程实现只支持一个条件变量, 而 Lock&amp;Condition 实现的管程是<strong>支持多个条件变量</strong>的, 这是二者的一个重要区别.</p>
<p>在很多并发场景下, 支持多个条件变量能够让我们的并发程序可读性更好, 实现起来也更容易. 例如, 实现一个阻塞队列, 就需要两个条件变量:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockedQueue</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Lock lock =</span><br><span class="line">    <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="comment">// 条件变量: 队列不满  </span></span><br><span class="line">  <span class="keyword">final</span> Condition notFull =</span><br><span class="line">    lock.newCondition();</span><br><span class="line">  <span class="comment">// 条件变量: 队列不空  </span></span><br><span class="line">  <span class="keyword">final</span> Condition notEmpty =</span><br><span class="line">    lock.newCondition();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入队</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">enq</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (队列已满)&#123;</span><br><span class="line">        <span class="comment">// 等待队列不满</span></span><br><span class="line">        notFull.await();</span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="comment">// 省略入队操作...</span></span><br><span class="line">      <span class="comment">//入队后,通知可出队</span></span><br><span class="line">      notEmpty.signal();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 出队</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deq</span><span class="params">()</span></span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (队列已空)&#123;</span><br><span class="line">        <span class="comment">// 等待队列不空</span></span><br><span class="line">        notEmpty.await();</span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="comment">// 省略出队操作...</span></span><br><span class="line">      <span class="comment">//出队后, 通知可入队</span></span><br><span class="line">      notFull.signal();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Semaphore-如何快速实现一个限流器"><a href="#Semaphore-如何快速实现一个限流器" class="headerlink" title="Semaphore: 如何快速实现一个限流器"></a>Semaphore: 如何快速实现一个限流器</h1><p>一般被翻译为<strong>信号量</strong>, 由大名鼎鼎的计算机科学家迪杰斯特拉(Dijkstra)于 1965 年提出, 在这之后的 15 年, 信号量一直都是并发编程领域的终结者, 直到 1980 年管程被提出来.</p>
<p>信号量一般用于<strong>控制资源访问的并发数量</strong>, 比如数据库链接资源, 读取千万条数据, 但是数据库链接就只有20个, 需要控制连接池的并发使用数量. </p>
<h2 id="信号量模型"><a href="#信号量模型" class="headerlink" title="信号量模型"></a>信号量模型</h2><p><strong>一个计数器, 一个等待队列, 三个方法. </strong></p>
<p><img src="https://cdn.yangbingdong.com/img/concurrent/java-concurrent-semaphore-module.png" alt></p>
<ul>
<li><code>init()</code>: 设置计数器的初始值. </li>
<li><code>down()</code>: 计数器的值减 1; 如果此时计数器的值小于 0, 则当前线程将被阻塞, 否则当前线程可以继续执行. </li>
<li><code>up()</code>: 计数器的值加 1; 如果此时计数器的值小于或者等于 0, 则唤醒等待队列中的一个线程, 并将其从等待队列中移除. </li>
</ul>
<p>这里提到的三个方法都是原子性的, 并且这个原子性是由信号量模型的实现方保证的. 在 Java SDK 里面, 信号量模型是由 <code>java.util.concurrent.Semaphore</code> 实现的, <code>Semaphore</code> 这个类能够保证这三个方法都是原子操作, 其中, <code>down()</code> 和 <code>up()</code> 对应的则是 <code>acquire()</code> 和 <code>release()</code>. </p>
<blockquote>
<p>在信号量模型里面, <code>down()</code>、<code>up()</code> 这两个操作历史上最早称为 P 操作和 V 操作, 所以信号量模型也被称为 <strong>PV 原语</strong>. </p>
</blockquote>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>实现一个停车场停车限制:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParkingSpotManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;ParkingSpot&gt; parkingSpots = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(MAX_SIZE);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore sem = <span class="keyword">new</span> Semaphore(MAX_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParkingSpotManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ParkingSpot parkingSpot;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_SIZE; i++) &#123;</span><br><span class="line">            parkingSpot = <span class="keyword">new</span> ParkingSpot();</span><br><span class="line">            parkingSpot.setId(i);</span><br><span class="line">            parkingSpots.add(parkingSpot);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Consumer&lt;ParkingSpot&gt; consumer)</span> </span>&#123;</span><br><span class="line">        ParkingSpot parkingSpot = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sem.acquire(<span class="number">1</span>);</span><br><span class="line">            parkingSpot = parkingSpots.remove();</span><br><span class="line">            consumer.accept(parkingSpot);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (parkingSpot != <span class="keyword">null</span>) &#123;</span><br><span class="line">                parkingSpots.add(parkingSpot);</span><br><span class="line">            &#125;</span><br><span class="line">            sem.release(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ParkingSpotManager parkingSpotManager = <span class="keyword">new</span> ParkingSpotManager();</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">50</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; parkingSpotManager.park(parkingSpot -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 拿到车位, 车位号: "</span> + parkingSpot.getId());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(ThreadLocalRandom.current().nextLong(<span class="number">500</span>, <span class="number">1000</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ReadWriteLock-如何快速实现一个完备的缓存"><a href="#ReadWriteLock-如何快速实现一个完备的缓存" class="headerlink" title="ReadWriteLock: 如何快速实现一个完备的缓存"></a>ReadWriteLock: 如何快速实现一个完备的缓存</h1><p>Java 已经实现了管程和信号量这两个同步原语, 那么为什么并发包下还有那么多工具? 答案是<strong>分场景优化性能, 提升易用性. </strong></p>
<p>有一个常见的应用场景: <strong>读多写少</strong>, 比如缓存. 针对读多写少这种并发场景, Java SDK 并发包提供了<strong>读写锁</strong>——<code>ReadWriteLock</code>.</p>
<p>读写锁, 并不是 Java 语言特有的, 而是一个广为使用的通用技术, 所有的读写锁都遵守以下三条基本原则: </p>
<ul>
<li>允许多个线程同时读共享变量; </li>
<li>只允许一个线程写共享变量; </li>
<li>如果一个写线程正在执行写操作, 此时禁止读线程读共享变量. </li>
</ul>
<p>读写锁与互斥锁的一个重要区别就是<strong>读写锁允许多个线程同时读共享变量</strong>, 而互斥锁是不允许的, 这是读写锁在读多写少场景下性能优于互斥锁的关键. 但<strong>读写锁的写操作是互斥的</strong>, 当一个线程在写共享变量的时候, 是不允许其他线程执行写操作和读操作. </p>
<p>一个简单的缓存实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cache</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Map&lt;K, V&gt; m =</span><br><span class="line">    <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">final</span> ReadWriteLock rwl =</span><br><span class="line">    <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">  <span class="comment">// 读锁</span></span><br><span class="line">  <span class="keyword">final</span> Lock r = rwl.readLock();</span><br><span class="line">  <span class="comment">// 写锁</span></span><br><span class="line">  <span class="keyword">final</span> Lock w = rwl.writeLock();</span><br><span class="line">  <span class="comment">// 读缓存</span></span><br><span class="line">  <span class="function">V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    r.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.get(key); &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; r.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 写缓存</span></span><br><span class="line">  <span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    w.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.put(key, v); &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; w.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按需加载, 即当缓存不存在, 再查询数据库:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cache</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Map&lt;K, V&gt; m =</span><br><span class="line">    <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">final</span> ReadWriteLock rwl = </span><br><span class="line">    <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">  <span class="keyword">final</span> Lock r = rwl.readLock();</span><br><span class="line">  <span class="keyword">final</span> Lock w = rwl.writeLock();</span><br><span class="line"> </span><br><span class="line">  <span class="function">V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    V v = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//读缓存</span></span><br><span class="line">    r.lock();         ①</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      v = m.get(key); ②</span><br><span class="line">    &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">      r.unlock();     ③</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//缓存中存在, 返回</span></span><br><span class="line">    <span class="keyword">if</span>(v != <span class="keyword">null</span>) &#123;   ④</span><br><span class="line">      <span class="keyword">return</span> v;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//缓存中不存在, 查询数据库</span></span><br><span class="line">    w.lock();         ⑤</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//再次验证</span></span><br><span class="line">      <span class="comment">//其他线程可能已经查询过数据库</span></span><br><span class="line">      v = m.get(key); ⑥</span><br><span class="line">      <span class="keyword">if</span>(v == <span class="keyword">null</span>)&#123;  ⑦</span><br><span class="line">        <span class="comment">//查询数据库</span></span><br><span class="line">        v=省略代码无数</span><br><span class="line">        m.put(key, v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">      w.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><p>先来看一段代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读缓存</span></span><br><span class="line">r.lock();         ①</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  v = m.get(key); ②</span><br><span class="line">  <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">    w.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//再次验证并更新缓存</span></span><br><span class="line">      <span class="comment">//省略详细代码</span></span><br><span class="line">    &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">      w.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">  r.unlock();     ③</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在①处获取读锁, 在③处释放读锁, 那是否可以在②处的下面增加验证缓存并更新缓存, 这个叫<strong>锁的升级</strong>.</p>
<p>可惜 <code>ReadWriteLock</code> 并不支持这种升级. 在上面的代码示例中, 读锁还没有释放, 此时获取写锁, 会导致写锁永久等待, 最终导致相关线程都被阻塞, 永远也没有机会被唤醒. </p>
<p>不过, 虽然锁的升级是不允许的, 但是<strong>锁的降级</strong>却是允许的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CachedData</span> </span>&#123;</span><br><span class="line">  Object data;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">boolean</span> cacheValid;</span><br><span class="line">  <span class="keyword">final</span> ReadWriteLock rwl =</span><br><span class="line">    <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">  <span class="comment">// 读锁  </span></span><br><span class="line">  <span class="keyword">final</span> Lock r = rwl.readLock();</span><br><span class="line">  <span class="comment">//写锁</span></span><br><span class="line">  <span class="keyword">final</span> Lock w = rwl.writeLock();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">processCachedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取读锁</span></span><br><span class="line">    r.lock();</span><br><span class="line">    <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">      <span class="comment">// 释放读锁, 因为不允许读锁的升级</span></span><br><span class="line">      r.unlock();</span><br><span class="line">      <span class="comment">// 获取写锁</span></span><br><span class="line">      w.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 再次检查状态  </span></span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">          data = ...</span><br><span class="line">          cacheValid = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放写锁前, 降级为读锁</span></span><br><span class="line">        <span class="comment">// 降级是可以的</span></span><br><span class="line">        r.lock(); ①</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放写锁</span></span><br><span class="line">        w.unlock(); </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处仍然持有读锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;use(data);&#125; </span><br><span class="line">    <span class="keyword">finally</span> &#123;r.unlock();&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在代码①处, 获取读锁的时候线程还是持有写锁的, 这种锁的降级是支持的. </p>
<blockquote>
<p>读写锁类似于 <code>ReentrantLock</code>, 也支持公平模式和非公平模式. 读锁和写锁都实现了 <code>java.util.concurrent.locks.Lock</code> 接口, 所以除了支持 <code>lock()</code> 方法外, <code>tryLock()</code>、<code>lockInterruptibly()</code> 等方法也都是支持的. 但是有一点需要注意, 那就是只有写锁支持条件变量, 读锁是不支持条件变量的, 读锁调用 <code>newCondition()</code> 会抛出 <code>UnsupportedOperationException</code> 异常. </p>
</blockquote>
<h1 id="StampedLock-读写锁更快的锁"><a href="#StampedLock-读写锁更快的锁" class="headerlink" title="StampedLock: 读写锁更快的锁"></a>StampedLock: 读写锁更快的锁</h1><p><code>StampedLock</code> 类, 在 JDK1.8 时引入, 是对读写锁 <code>ReentrantReadWriteLock</code> 的增强, 该类提供了一些功能, 优化了读锁、写锁的访问, 同时使读写锁之间可以互相转换, 更细粒度控制并发. 该类的设计初衷是作为一个内部工具类, 用于辅助开发其它线程安全组件, 用得好, 该类可以提升系统性能, 用不好, 容易产生死锁和其它莫名其妙的问题. </p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>StampedLock的主要特点概括一下, 有以下几点: </p>
<ol>
<li>所有获取锁的方法, 都返回一个邮戳(Stamp), Stamp为0表示获取失败, 其余都表示成功; </li>
<li>所有释放锁的方法, 都需要一个邮戳(Stamp), 这个Stamp必须是和成功获取锁时得到的Stamp一致; </li>
<li><code>StampedLock</code> 是不可重入的; (如果一个线程已经持有了写锁, 再去获取写锁的话就会造成死锁)</li>
<li><code>StampedLock</code> 有三种访问模式: <ul>
<li>Reading(读模式): 功能和 <code>ReentrantReadWriteLock</code> 的读锁类似;</li>
<li>Writing(写模式): 功能和 <code>ReentrantReadWriteLock</code> 的写锁类似;</li>
<li>Optimistic reading(<strong>乐观读模式</strong>): 这是一种优化的读模式;</li>
</ul>
</li>
<li><code>StampedLock</code> 支持读锁和写锁的相互转换<br>我们知道 RRW 中, 当线程获取到写锁后, 可以降级为读锁, 但是读锁是不能直接升级为写锁的.<br>StampedLock 提供了读锁和写锁相互转换的功能, 使得该类支持更多的应用场景;</li>
<li>无论写锁还是读锁, 都不支持 Conditon 等待条件.</li>
</ol>
<p>在 <code>ReentrantReadWriteLock</code> 中, 当读锁被使用时, 如果有线程尝试获取写锁, <strong>该写线程会阻塞</strong>.<br>但是, 在 Optimistic reading 中, 即使读线程获取到了读锁, 写线程尝试获取写锁也不会阻塞, 这相当于对读模式的优化, 但是<strong>可能会导致数据不一致的问题</strong>. 所以, 当使用 Optimistic reading 获取到读锁时, <strong>必须对获取结果进行校验</strong>. </p>
<h2 id="乐观读"><a href="#乐观读" class="headerlink" title="乐观读"></a>乐观读</h2><p>读写锁的用法与 <code>ReentrantReadWriteLock</code> 类似, <code>StampedLock</code> 的性能之所以比 <code>ReadWriteLock</code> 还要好, 其关键是 <code>StampedLock</code> 支持乐观读的方式. 注意这里, 用的是”<strong>乐观读</strong>“这个词, 而不是”乐观读锁”, 乐观读这个操作是<strong>无锁</strong>的, 所以相比较 <code>ReadWriteLock</code> 的读锁, 乐观读的性能更好一些. </p>
<p>以下是来自官网乐观读的一段代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用乐观读锁访问共享资源</span></span><br><span class="line"><span class="comment"> * 注意: 乐观读锁在保证数据一致性上需要拷贝一份要操作的变量到方法栈, 并且在操作数据时候可能其他写线程已经修改了数据, </span></span><br><span class="line"><span class="comment"> * 而我们操作的是方法栈里面的数据, 也就是一个快照, 所以最多返回的不是最新的数据, 但是一致性还是得到保障的. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> stamp = sl.tryOptimisticRead();    <span class="comment">// 使用乐观读锁</span></span><br><span class="line">    <span class="keyword">double</span> currentX = x, currentY = y;      <span class="comment">// 拷贝共享资源到本地方法栈中</span></span><br><span class="line">    <span class="keyword">if</span> (!sl.validate(stamp)) &#123;              <span class="comment">// 如果有写锁被占用, 可能造成数据不一致, 所以要切换到普通读锁模式</span></span><br><span class="line">        stamp = sl.readLock();             </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            currentX = x;</span><br><span class="line">            currentY = y;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            sl.unlockRead(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Optimistic reading 的使用必须遵循以下模式: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> stamp = lock.tryOptimisticRead();  <span class="comment">// 非阻塞获取版本信息</span></span><br><span class="line">copyVaraibale2ThreadMemory();           <span class="comment">// 拷贝变量到线程本地堆栈</span></span><br><span class="line"><span class="keyword">if</span>(!lock.validate(stamp))&#123;              <span class="comment">// 校验</span></span><br><span class="line">    <span class="keyword">long</span> stamp = lock.readLock();       <span class="comment">// 获取读锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        copyVaraibale2ThreadMemory();   <span class="comment">// 拷贝变量到线程本地堆栈</span></span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock(stamp);              <span class="comment">// 释放悲观锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">useThreadMemoryVarables();              <span class="comment">// 使用线程本地堆栈里面的数据进行操作</span></span><br></pre></td></tr></table></figure>
<h2 id="锁升级-1"><a href="#锁升级-1" class="headerlink" title="锁升级"></a>锁升级</h2><p><code>StampedLock</code> 支持锁的降级(通过 <code>tryConvertToReadLock()</code> 方法实现)和升级(通过 <code>tryConvertToWriteLock()</code> 方法实现), 但是建议慎重使用. 下面的代码也源自 Java 的官方示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveIfAtOrigin</span><span class="params">(<span class="keyword">double</span> newX, <span class="keyword">double</span> newY)</span> </span>&#123; <span class="comment">// upgrade</span></span><br><span class="line">    <span class="comment">// Could instead start with optimistic, not read mode</span></span><br><span class="line">    <span class="keyword">long</span> stamp = sl.readLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (x == <span class="number">0.0</span> &amp;&amp; y == <span class="number">0.0</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> ws = sl.tryConvertToWriteLock(stamp);  <span class="comment">//读锁转换为写锁</span></span><br><span class="line">            <span class="keyword">if</span> (ws != <span class="number">0L</span>) &#123;</span><br><span class="line">                stamp = ws;</span><br><span class="line">                x = newX;</span><br><span class="line">                y = newY;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sl.unlockRead(stamp);</span><br><span class="line">                stamp = sl.writeLock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        sl.unlock(stamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li><code>StampedLock</code> 不支持重入,重入会导致死锁.</li>
<li>使用 <code>StampedLock</code> 一定不要调用中断操作, 一定使用可中断的悲观读锁 <code>readLockInterruptibly()</code> 和写锁 <code>writeLockInterruptibly()</code>.</li>
</ul>
<h1 id="CountDownLatch和CyclicBarrier-如何让多线程步调一致"><a href="#CountDownLatch和CyclicBarrier-如何让多线程步调一致" class="headerlink" title="CountDownLatch和CyclicBarrier: 如何让多线程步调一致"></a>CountDownLatch和CyclicBarrier: 如何让多线程步调一致</h1><p><code>CountDownLatch</code> 和 <code>CyclicBarrier</code> 是 Java 并发包提供的两个非常易用的<strong>线程同步工具类</strong>, 这两个工具类用法的区别在这里还是有必要再强调一下: </p>
<ul>
<li><code>CountDownLatch</code> 主要用来<strong>解决一个线程等待多个线程的场景</strong>, 可以类比旅游团团长要等待所有的游客到齐才能去下一个景点; </li>
<li>而 <code>CyclicBarrier</code> 是<strong>一组线程之间互相等待</strong>, 更像是几个驴友之间不离不弃. </li>
</ul>
<p>除此之外 <code>CountDownLatch</code> 的计数器是<strong>不能循环利用</strong>的, 也就是说一旦计数器减到 0, 再有线程调用 await(), 该线程会直接通过. 但 <code>CyclicBarrier</code> 的计数器是<strong>可以循环利用</strong>的, 而且具备<strong>自动重置</strong>的功能, 一旦计数器减到 0 会自动重置到你设置的初始值. 除此之外, <code>CyclicBarrier</code> 还可以设置回调函数, 可以说是功能丰富. </p>
<p>举个例子就是做一个对账功能, 首先查询订单, 然后查询派送单, 之后对比订单和派送单, 将差异写入差异库:</p>
<p><img src="https://cdn.yangbingdong.com/img/concurrent/java-concurrent-countdownlatch01.png" alt></p>
<p>抽象代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(存在未对账订单)&#123;</span><br><span class="line">  <span class="comment">// 查询未对账订单</span></span><br><span class="line">  pos = getPOrders();</span><br><span class="line">  <span class="comment">// 查询派送单</span></span><br><span class="line">  dos = getDOrders();</span><br><span class="line">  <span class="comment">// 执行对账操作</span></span><br><span class="line">  diff = check(pos, dos);</span><br><span class="line">  <span class="comment">// 差异写入差异库</span></span><br><span class="line">  save(diff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行流程是这样的:</p>
<p><img src="https://cdn.yangbingdong.com/img/concurrent/java-concurrent-countdownlatch02.png" alt></p>
<p>其实 <code>getPOrders()</code> 与 <code>getDOrders()</code> 是可以并行执行的:</p>
<p><img src="https://cdn.yangbingdong.com/img/concurrent/java-concurrent-countdownlatch03.png" alt></p>
<p>这时候可以使用 <code>CountDownLatch</code> 来实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建2个线程的线程池</span></span><br><span class="line">Executor executor = </span><br><span class="line">  Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span>(存在未对账订单)&#123;</span><br><span class="line">  <span class="comment">// 计数器初始化为2</span></span><br><span class="line">  CountDownLatch latch = </span><br><span class="line">    <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">  <span class="comment">// 查询未对账订单</span></span><br><span class="line">  executor.execute(()-&gt; &#123;</span><br><span class="line">    pos = getPOrders();</span><br><span class="line">    latch.countDown();</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 查询派送单</span></span><br><span class="line">  executor.execute(()-&gt; &#123;</span><br><span class="line">    dos = getDOrders();</span><br><span class="line">    latch.countDown();</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 等待两个查询操作结束</span></span><br><span class="line">  latch.await();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 执行对账操作</span></span><br><span class="line">  diff = check(pos, dos);</span><br><span class="line">  <span class="comment">// 差异写入差异库</span></span><br><span class="line">  save(diff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然, 我们也可以使用线程的 <code>join()</code> 来实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(存在未对账订单)&#123;</span><br><span class="line">  <span class="comment">// 查询未对账订单</span></span><br><span class="line">  Thread T1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    pos = getPOrders();</span><br><span class="line">  &#125;);</span><br><span class="line">  T1.start();</span><br><span class="line">  <span class="comment">// 查询派送单</span></span><br><span class="line">  Thread T2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    dos = getDOrders();</span><br><span class="line">  &#125;);</span><br><span class="line">  T2.start();</span><br><span class="line">  <span class="comment">// 等待T1、T2结束</span></span><br><span class="line">  T1.join();</span><br><span class="line">  T2.join();</span><br><span class="line">  <span class="comment">// 执行对账操作</span></span><br><span class="line">  diff = check(pos, dos);</span><br><span class="line">  <span class="comment">// 差异写入差异库</span></span><br><span class="line">  save(diff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点就是每次都需要创建以及销毁线程, 非常消耗资源.</p>
<p>想一想, 还能再优化吗? 我们将 <code>getPOrders()</code> 和 <code>getDOrders()</code> 这两个查询操作并行了, 但这两个查询操作和对账操作 <code>check()</code>、<code>save()</code> 之间还是串行的. 很显然, 这两个查询操作和对账操作也是可以并行的, 也就是说, 在执行对账操作的时候, 可以同时去执行下一轮的查询操作:</p>
<p><img src="https://cdn.yangbingdong.com/img/concurrent/java-concurrent-countdownlatch04.png" alt></p>
<p>两次查询操作能够和对账操作并行, 对账操作还依赖查询操作的结果, 这明显有点生产者 - 消费者的意思. 那么需要两个队列, 并且两个队列的元素之间还有对应关系:</p>
<p><img src="https://cdn.yangbingdong.com/img/concurrent/java-concurrent-countdownlatch05.png" alt></p>
<p>但线程 T1 和线程 T2 的工作要步调一致, 不能一个跑得太快, 一个跑得太慢, 只有这样才能做到各自生产完 1 条数据的时候, 通知线程 T3. </p>
<p><img src="https://cdn.yangbingdong.com/img/concurrent/java-concurrent-countdownlatch06.png" alt></p>
<p>这时候 <code>CyclicBarrier</code> 就派上用场了:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 订单队列</span></span><br><span class="line">Vector&lt;P&gt; pos;</span><br><span class="line"><span class="comment">// 派送单队列</span></span><br><span class="line">Vector&lt;D&gt; dos;</span><br><span class="line"><span class="comment">// 执行回调的线程池 </span></span><br><span class="line">Executor executor = </span><br><span class="line">  Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">final</span> CyclicBarrier barrier =</span><br><span class="line">  <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, ()-&gt;&#123;</span><br><span class="line">    executor.execute(()-&gt;check());</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">  P p = pos.remove(<span class="number">0</span>);</span><br><span class="line">  D d = dos.remove(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 执行对账操作</span></span><br><span class="line">  diff = check(p, d);</span><br><span class="line">  <span class="comment">// 差异写入差异库</span></span><br><span class="line">  save(diff);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 循环查询订单库</span></span><br><span class="line">  Thread T1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">while</span>(存在未对账订单)&#123;</span><br><span class="line">      <span class="comment">// 查询订单库</span></span><br><span class="line">      pos.add(getPOrders());</span><br><span class="line">      <span class="comment">// 等待</span></span><br><span class="line">      barrier.await();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  T1.start();  </span><br><span class="line">  <span class="comment">// 循环查询运单库</span></span><br><span class="line">  Thread T2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">while</span>(存在未对账订单)&#123;</span><br><span class="line">      <span class="comment">// 查询运单库</span></span><br><span class="line">      dos.add(getDOrders());</span><br><span class="line">      <span class="comment">// 等待</span></span><br><span class="line">      barrier.await();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  T2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有两个注意点:</p>
<ol>
<li>为啥要用线程池, 而不是在回调函数中直接调用? 使用线程池是为了异步操作, 否则回掉函数是同步调用的, 也就是本次对账操作执行完才能进行下一轮的检查. </li>
<li>线程池为啥使用单线程的? 线程数量固定为1, 防止了多线程并发导致的数据不一致, 因为订单和派送单是两个队列, 只有单线程去两个队列中取消息才不会出现消息不匹配的问题. </li>
</ol>
]]></content><categories><category>Programming</category><category>Java</category><category>Concurrent</category></categories><tags><tag>Java</tag><tag>Concurrent</tag></tags></entry><entry><title>Java8 Noob Tutorial</title><url>/2017/java-8-tutorial/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/java/java8.jpg" alt></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><blockquote>
<p>“Java is still not dead—and people are starting to figure that out.”<br>Java 8是自Java  5（2004年）发布以来Java语言最大的一次版本升级, Java 8带来了很多的新特性, 包括Lambda 表达式、方法引用、流(Stream API)、默认方法、Optional、组合式异步编程、新的时间 API, 等等各个方面. 利用这些特征, 我们可以写出如同清泉般的简洁代码= =…</p>
</blockquote>
<a id="more"></a>
<h1 id="Default-Methods-for-Interfaces"><a href="#Default-Methods-for-Interfaces" class="headerlink" title="Default Methods for Interfaces"></a>Default Methods for Interfaces</h1><p>Java 8 允许我们使用<code>default</code>关键字, 为接口声明添加非抽象的方法实现. 这个特性又被称为扩展方法. 下面是我们的第一个例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Formula</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在接口Formula中, 除了抽象方法<code>caculate</code>以外, 还定义了一个默认方法<code>sqrt.Formula</code>的实现类只需要实现抽象方法<code>caculate</code>就可以了. 默认方法<code>sqrt</code>可以直接使用.<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Formula formula = <span class="keyword">new</span> Formula() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqrt(a * <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">formula.calculate(<span class="number">100</span>);     <span class="comment">// 100.0</span></span><br><span class="line">formula.sqrt(<span class="number">16</span>);           <span class="comment">// 4.0</span></span><br></pre></td></tr></table></figure></p>
<p>那么这个新特征<strong>有啥用</strong>呢？<br>我们往往会碰到这样一个情况我们定义的接口根据不同的场景定义了几个不同的实现类, 那么如果需要这几个实现类调用的方法都得到同一个结果或者只有一个实现类需要这个接口方法, 那么我们需要去<strong>重写每个实现了这个接口的类</strong>, 而这大大<strong>增加</strong>了我们的实现需求的<strong>负担</strong>. </p>
<p>正是为了解决Java接口中<strong>只能定义抽象方法</strong>的问题. Java8新增加了<strong>默认方法</strong>的特性. 默认方法可以被<strong>继承接口</strong>重写成抽象方法或者重新定义成默认方法. 除了默认方法, 接口里还可以声明静态方法, 并且可以实现. 例子如下: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">DefaulableFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Interfaces now allow static methods</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Defaulable <span class="title">create</span><span class="params">( Supplier&lt; Defaulable &gt; supplier )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Conflict"><a href="#Conflict" class="headerlink" title="Conflict"></a>Conflict</h2><p>因为一个类可以<strong>实现多个接口</strong>, 所以当一个类实现了多个接口, 而这些接口中<strong>存在两个或两个以上方法签名相同的默认方法时</strong>就会产生冲突, java8定义如下三条原则来解决冲突: </p>
<ol>
<li><strong>类或父类中显式声明的方法, 其优先级高于所有的默认方法</strong>；</li>
<li><strong>如果1规则失效, 则选择与当前类距离最近的具有具体实现的默认方法</strong>；</li>
<li><strong>如果2规则也失效, 则需要显式指定接口</strong>. </li>
</ol>
<h1 id="Lambda-Expressions"><a href="#Lambda-Expressions" class="headerlink" title="Lambda Expressions"></a>Lambda Expressions</h1><p>先来看一段代码: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ActionListener</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">button.addActionListener(<span class="keyword">new</span> ActionListener()) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">    ui.dazzle(e.getModifiers());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匿名类型<strong>最大的问题</strong>就在于其<strong>冗余的语法</strong>. 有人戏称匿名类型导致了“高度问题”（<strong>height problem</strong>）: 比如前面<code>ActionListener</code>的例子里的五行代码中仅有一行在做实际工作.<br>Lambda表达式（又被成为“闭包”或“匿名方法”）是简洁地表示可传递的匿名函数的一种方式, 它提供了轻量级的语法, 从而解决了匿名内部类带来的“高度问题”. </p>
<p>重点留意这四个关键词: <strong>匿名</strong>、<strong>函数</strong>、<strong>传递</strong>、<strong>简洁</strong><br>Lambda的三个部分: </p>
<ul>
<li>参数列表</li>
<li>箭头</li>
<li>Lambda 主体</li>
</ul>
<p>Lambda的基本语法大概就是下面这样子的了: </p>
<ul>
<li><code>(parameters) -&gt; expression</code></li>
<li><code>(parameters) -&gt; { statements; }</code></li>
</ul>
<p>来看个例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"D"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"A"</span>);</span><br><span class="line">Collections.sort(names, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>使用Lambda来表示:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">&#125;);</span><br><span class="line">或者是</span><br><span class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</span><br><span class="line">亦或是</span><br><span class="line">Collections.sort(names, (a, b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure></p>
<p>在IDEA里面, 对于可以写成Lambda表达式的, 按下<code>Alt</code>+<code>Enter</code> 它会智能地提示转换</p>
<h2 id="Lexiacal-Scope"><a href="#Lexiacal-Scope" class="headerlink" title="Lexiacal Scope"></a>Lexiacal Scope</h2><h3 id="访问局部变量"><a href="#访问局部变量" class="headerlink" title="访问局部变量"></a>访问局部变量</h3><p>1、可以直接在Lambda表达式中访问外层的局部变量, 但是和匿名对象不同的是, Lambda表达式的局部变量可以<strong>不用声明为<code>final</code></strong>, 不过局部变量必须不可被后面的代码修改（<strong>即隐性的具有final的语义</strong>）.<br>eg: 下面代码无法编译</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>; </span><br><span class="line">Converter&lt;Integer, String&gt; s =  (param) -&gt; String.valueOf(param + num);  </span><br><span class="line">num = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>在Lambda表达式中试图修改局部变量是不允许的！</p>
<p>2、在 Lambda 表达式当中被引用的变量的值<strong>不可以被更改</strong>. </p>
<p>3、在 Lambda 表达式当中<strong>不允许</strong>声明一个与局部变量同名的参数或者局部变量. </p>
<h3 id="访问对象字段与静态变量"><a href="#访问对象字段与静态变量" class="headerlink" title="访问对象字段与静态变量"></a>访问对象字段与静态变量</h3><p>和局部变量不同的是, Lambda内部对于实例的字段（即: 成员变量）以及静态变量是<strong>即可读又可写</strong>. </p>
<h3 id="不能访问接口的默认方法"><a href="#不能访问接口的默认方法" class="headerlink" title="不能访问接口的默认方法"></a>不能访问接口的默认方法</h3><p>Lambda表达式中是<strong>无法访问到默认方法</strong>的. </p>
<p><strong>补充</strong>: Lambda表达式对<strong>值</strong>封闭, 对<strong>变量</strong>开放的原文是: lambda expressions close over <strong>values</strong>, not <strong>variables</strong>, 在这里增加一个例子以说明这个特性: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">list.forEach(e -&gt; &#123; sum += e.size(); &#125;); <span class="comment">// Illegal, close over values</span></span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; aList = <span class="keyword">new</span> List&lt;&gt;();</span><br><span class="line">list.forEach(e -&gt; &#123; aList.add(e); &#125;); <span class="comment">// Legal, open over variables</span></span><br></pre></td></tr></table></figure>
<h2 id="匿名内部类的简写？"><a href="#匿名内部类的简写？" class="headerlink" title="匿名内部类的简写？"></a>匿名内部类的简写？</h2><p><strong>Lambda表达式通过<code>invokedynamic</code>指令实现, 书写Lambda表达式不会产生新的类</strong>. 如果有如下代码, 编译之后只有一个<code>class</code>文件: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MainLambda &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		new Thread(</span><br><span class="line">				() -&gt; System.out.println(&quot;Lambda Thread run()&quot;)</span><br><span class="line">			).start();;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译之后的结果: </p>
<p><img src="https://cdn.yangbingdong.com/img/java/2-Lambda.png" alt></p>
<p>通过javap反编译命名, 我们更能看出Lambda表达式内部表示的不同: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// javap -c -p MainLambda.class</span><br><span class="line">public class MainLambda &#123;</span><br><span class="line">  ...</span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #2                  // class java/lang/Thread</span><br><span class="line">       3: dup</span><br><span class="line">       4: invokedynamic #3,  0              // InvokeDynamic #0:run:()Ljava/lang/Runnable; /*使用invokedynamic指令调用*/</span><br><span class="line">       9: invokespecial #4                  // Method java/lang/Thread.&quot;&lt;init&gt;&quot;:(Ljava/lang/Runnable;)V</span><br><span class="line">      12: invokevirtual #5                  // Method java/lang/Thread.start:()V</span><br><span class="line">      15: return</span><br><span class="line"></span><br><span class="line">  private static void lambda$main$0();  /*Lambda表达式被封装成主类的私有方法*/</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: ldc           #7                  // String Lambda Thread run()</span><br><span class="line">       5: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">       8: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反编译之后我们发现Lambda表达式被封装成了主类的一个私有方法, 并通过<em><code>invokedynamic</code></em>指令进行调用. </p>
<h2 id="Lambda表达式中的this"><a href="#Lambda表达式中的this" class="headerlink" title="Lambda表达式中的this"></a>Lambda表达式中的this</h2><p>既然Lambda表达式不是内部类的简写, 那么Lambda内部的<code>this</code>引用也就跟内部类对象没什么关系了. 在Lambda表达式中<code>this</code>的意义跟在表达式外部完全一样. </p>
<p>eg: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Test2 test = <span class="keyword">new</span> Test2();  </span><br><span class="line">        test.method();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Lambda"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        Runnable runnable = () -&gt; &#123;  </span><br><span class="line">            System.out.println(<span class="keyword">this</span>.toString());  </span><br><span class="line">        &#125;;  </span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显示结果: <code>Lambda</code></p>
<h1 id="Functional-Interfaces"><a href="#Functional-Interfaces" class="headerlink" title="Functional Interfaces"></a>Functional Interfaces</h1><p>任意只包含一个抽象方法的接口, 我们都可以用来做成Lambda表达式. 为了让你定义的接口满足要求, 你应当在接口前加上<code>@FunctionalInterface</code> 标注. 编译器会注意到这个标注, 如果你的接口中定义了第二个抽象方法的话, 编译器会抛出异常.<br>eg:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</span><br><span class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</span><br><span class="line">System.out.println(converted);    <span class="comment">// 123</span></span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>, 如果你不写@FunctionalInterface 标注, 程序也是正确的.<br>下面是Java SE 7中已经存在的函数式接口:<br>· <a href="http://download.oracle.com/javase/7/docs/api/java/lang/Runnable.html" rel="external nofollow noopener noreferrer" target="_blank">java.lang.Runnable</a><br>· <a href="http://download.oracle.com/javase/7/docs/api/java/util/concurrent/Callable.html" rel="external nofollow noopener noreferrer" target="_blank">java.util.concurrent.Callable</a><br>· <a href="http://download.oracle.com/javase/7/docs/api/java/security/PrivilegedAction.html" rel="external nofollow noopener noreferrer" target="_blank">java.security.PrivilegedAction</a><br>· <a href="http://download.oracle.com/javase/7/docs/api/java/util/Comparator.html" rel="external nofollow noopener noreferrer" target="_blank">java.util.Comparator</a><br>· <a href="http://download.oracle.com/javase/7/docs/api/java/io/FileFilter.html" rel="external nofollow noopener noreferrer" target="_blank">java.io.FileFilter</a><br>· <a href="http://www.fxfrog.com/docs_www/api/java/beans/PropertyChangeListener.html" rel="external nofollow noopener noreferrer" target="_blank">java.beans.PropertyChangeListener</a></p>
<p>除此之外, Java SE 8中增加了一个新的包: <code>java.util.function</code>, 它里面包含了常用的函数式接口, 例如:<br>· <code>Predicate&lt;T&gt;</code>——接收<code>T</code>对象并返回<code>boolean</code><br>· <code>Consumer&lt;T&gt;</code>——接收<code>T</code>对象, 不返回值<br>· <code>Function&lt;T, R&gt;</code>——接收<code>T</code>对象, 返回<code>R</code>对象<br>· <code>Supplier&lt;T&gt;</code>——提供<code>T</code>对象（例如工厂）, 不接收值<br>· <code>UnaryOperator&lt;T&gt;</code>——接收<code>T</code>对象, 返回<code>T</code>对象<br>· <code>BinaryOperator&lt;T&gt;</code>——接收两个<code>T</code>对象, 返回<code>T</code>对象</p>
<p>除了上面的这些基本的函数式接口, 我们还提供了一些针对原始类型（Primitive type）的特化（Specialization）函数式接口, 例如<code>IntSupplier</code>和<code>LongBinaryOperator</code>. （我们只为<code>int</code>、<code>long</code>和<code>double</code>提供了特化函数式接口, 如果需要使用其它原始类型则需要进行类型转换）同样的我们也提供了一些针对多个参数的函数式接口, 例如<code>BiFunction&lt;T, U, R&gt;</code>, 它接收<code>T</code>对象和<code>U</code>对象, 返回<code>R</code>对象. </p>
<h1 id="Method-and-Constructor-References"><a href="#Method-and-Constructor-References" class="headerlink" title="Method and Constructor References"></a>Method and Constructor References</h1><p>Lambda表达式允许我们定义一个匿名方法, 并允许我们以函数式接口的方式使用它. 我们也希望能够在<strong>已有的</strong>方法上实现同样的特性.<br>方法引用和Lambda表达式拥有相同的特性（例如, 它们都需要一个目标类型, 并需要被转化为函数式接口的实例）, 不过我们并不需要为方法引用提供方法体, 我们可以直接通过方法名称引用已有方法. </p>
<p>方法引用就是替代那些转发参数的 Lambda 表达式的语法糖.<br>方法引用有很多种, 它们的语法如下:<br>· 静态方法引用: <code>ClassName::methodName</code><br>· 实际上的实例方法引用: <code>instanceReference::methodName</code><br>· 超类上的实例方法引用: <code>super::methodName</code><br>· 类型上的实例方法引用: <code>ClassName::methodName</code><br>· 构造方法引用: <code>Class::new</code><br>· 数组构造方法引用: <code>TypeName[]::new</code></p>
<p>对于静态方法引用, 我们需要在类名和方法名之间加入::分隔符, 例如<code>Integer::sum</code>.<br>结合Lambda可以使我们的代码更加简洁:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>);</span><br><span class="line">strings.stream().map(String::toUpperCase).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">List&lt;Character&gt; chars = Arrays.asList(<span class="string">'a'</span>, <span class="string">'b'</span>);	System.out.println(chars.stream().map(String::valueOf).collect(Collectors.joining(<span class="string">","</span>)));</span><br></pre></td></tr></table></figure></p>
<h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h1><p><code>NullPointException</code>可以说是所有Java程序员都遇到过的一个异常, 虽然Java从设计之初就力图让程序员脱离指针的苦海, 但是指针确实是实际存在的, 而java设计者也只能是让指针在Java语言中变得更加简单、易用, 而不能完全的将其剔除, 所以才有了我们日常所见到的关键字<code>null</code>. </p>
<p>空指针异常是一个运行时异常, 对于这一类异常, 如果没有明确的处理策略, 那么最佳实践在于让程序早点挂掉, 但是很多场景下, <strong>不是开发人员没有具体的处理策略</strong>, <strong>而是根本没有意识到空指针异常的存在</strong>. 当异常真的发生的时候, 处理策略也很简单, 在存在异常的地方添加一个<code>if</code>语句判定即可, 但是这样的应对策略会让我们的程序出现越来越多的<code>null</code>判定, 我们知道一个良好的程序设计, 应该让代码中尽量少出现<code>null</code>关键字, 而Java8所提供的<code>Optional</code>类则在减少<code>NullPointException</code>的同时, 也提升了代码的美观度. 但首先我们需要明确的是, 它并 <strong>不是对<code>null</code>关键字的一种替代, 而是对于<code>null</code>判定提供了一种更加优雅的实现, 从而避免<code>NullPointException</code></strong>. </p>
<p><code>java.util.Optional&lt;T&gt;</code> 对可能缺失的值建模,引入的目的并非是要消除每一个 <code>null</code> 引用, 而是帮助你更好地设计出普适的 API. </p>
<p>创建 <code>Optional</code> 对象,三个静态工厂方法: </p>
<ul>
<li><code>Optional.empty</code>: 创建空的 <code>Optional</code> 对象</li>
<li><code>Optional.of</code>: 依据非空值创建 <code>Optional</code> 对象, 若传空值会抛 <code>NPE</code></li>
<li><code>Optianal.ofNullable</code>: 创建 <code>Optional</code> 对象, 允许传空值</li>
</ul>
<p><code>Optional</code> API: </p>
<ul>
<li><code>isPresent()</code>: 变量存在返回<code>true</code></li>
<li><code>get()</code>: 返回封装的变量值, 或者抛出 <code>NoSuchElementException</code></li>
<li><code>orElse(T other)</code>: 提供默认值</li>
<li><code>orElseGet(Supplier&lt;? extends T&gt; other)</code>: <code>orElse</code> 方法的延迟调用版</li>
<li><code>orElseThrow(Supplier&lt;&gt; extends X&gt; exceptionSupplier)</code>: 类似 <code>get</code>, 但可以定制希望抛出的异常类型</li>
<li><code>ifPresent(Consumer&lt;? super T&gt;)</code>: 变量存在时可以执行一个方法</li>
<li><code>filter(Predicate&lt;? super T&gt; predicate)</code>: 过滤</li>
<li><code>map(Function&lt;? super T, ? extends U&gt; mapper)</code>: 转换</li>
<li><code>flatMap(Function&lt;? super T, Optional&lt;U&gt;&gt; mapper)</code>: 转换成Optional</li>
</ul>
<p>值得注意的是: <code>Optional</code>是一个<strong><code>final</code>类</strong>, 未实现任何接口, 所以当我们在利用该类包装定义类的属性的时候, 如果我们定义的类有序列化的需求, 那么因为<code>Optional</code><strong>没有实现<code>Serializable</code>接口</strong>, 这个时候执行序列化操作就会有问题:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 用户编号 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Optional&lt;Long&gt; phone;  <span class="comment">// 不能序列化</span></span><br><span class="line">    <span class="keyword">private</span> Optional&lt;String&gt; email;  <span class="comment">// 不能序列化</span></span><br></pre></td></tr></table></figure></p>
<p>不过我们可以采用如下替换策略:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> phone;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;Long&gt; <span class="title">getPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(<span class="keyword">this</span>.phone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Optional</code> 类设计的初衷仅仅是要支持能返回 <code>Optional</code> 对象的方法, 没有考虑将它作为类的字段使用…</p>
<p><strong>另外, 在Java9中对Optional添加了三个新的方法: </strong></p>
<ol>
<li><p><code>public Optional&lt;T&gt; or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier)</code><br><code>or</code> 方法的作用是, 如果一个 <code>Optional</code> 包含值, 则返回自己；否则返回由参数 <em>supplier</em> 获得的 <code>Optional</code></p>
</li>
<li><p><code>public void ifPresentOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction)</code><br><code>ifPresentOrElse</code> 方法的用途是, 如果一个 <code>Optional</code> 包含值, 则对其包含的值调用函数 <em>action</em>, 即 <code>action.accept(value)</code>, 这与 <code>ifPresent</code> 一致；与 <code>ifPresent</code> 方法的区别在于, <code>ifPresentOrElse</code> 还有第二个参数 <code>emptyAction</code> —— 如果 <code>Optional</code> 不包含值, 那么 <code>ifPresentOrElse</code> 便会调用 <code>emptyAction</code>, 即 <code>emptyAction.run()</code></p>
</li>
<li><p><code>public Stream&lt;T&gt; stream()</code><br><code>stream</code> 方法的作用就是将 <code>Optional</code> 转为一个 <code>Stream</code>, 如果该 <code>Optional</code> 中包含值, 那么就返回包含这个值的 <code>Stream</code>；否则返回一个空的 <code>Stream</code>（<code>Stream.empty()</code>）. </p>
<p>举个例子, 在 Java8, 我们会写下面的代码: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 此处 getUserById 返回的是 Optional&lt;User&gt;</span><br><span class="line">public List&lt;User&gt; getUsers(Collection&lt;Integer&gt; userIds) &#123;</span><br><span class="line">       return userIds.stream()</span><br><span class="line">            .map(this::getUserById)     // 获得 Stream&lt;Optional&lt;User&gt;&gt;</span><br><span class="line">            .filter(Optional::isPresent)// 去掉不包含值的 Optional</span><br><span class="line">            .map(Optional::get)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而有了 <code>Optional.stream()</code>, 我们就可以将其简化为: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public List&lt;User&gt; getUsers(Collection&lt;Integer&gt; userIds) &#123;</span><br><span class="line">    return userIds.stream()</span><br><span class="line">            .map(this::getUserById)    // 获得 Stream&lt;Optional&lt;User&gt;&gt;</span><br><span class="line">            .flatMap(Optional::stream) // Stream 的 flatMap 方法将多个流合成一个流</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h1><p><img src="https://cdn.yangbingdong.com/img/java/Java_stream_Interfaces.png" alt></p>
<h2 id="流是什么"><a href="#流是什么" class="headerlink" title="流是什么"></a>流是什么</h2><p>先来一段代码: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.asList(<span class="string">"a1"</span>, <span class="string">"a2"</span>, <span class="string">"b1"</span>, <span class="string">"c2"</span>, <span class="string">"c1"</span>).stream()</span><br><span class="line">                                           .filter(s -&gt; s.startsWith(<span class="string">"c"</span>))</span><br><span class="line">                                           .map(String::toUpperCase)</span><br><span class="line">                                           .sorted()</span><br><span class="line">                                           .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>流是Java SE 8类库中新增的关键抽象, 它被定义于<code>java.util.stream</code>（这个包里有若干流类型: <code>Stream&lt;T&gt;</code>代表对象引用流, 此外还有一系列特化（specialization）流, 比如<code>IntStream</code>代表整形数字流）. 每个流代表一个值序列, 流提供一系列常用的聚集操作, 使得我们可以便捷的在它上面进行各种运算. 集合类库也提供了便捷的方式使我们可以以操作流的方式使用集合、数组以及其它数据结构. 流的操作可以被组合成流水线（Pipeline）. </p>
<p>引入的原因: </p>
<ul>
<li>声明性方式处理数据集合</li>
<li>透明地并行处理, 提高性能</li>
</ul>
<p><strong>流</strong> 的定义: 从支持数据处理操作的源生成的元素序列<br>两个重要特点: </p>
<ul>
<li>流水线</li>
<li>内部迭代</li>
</ul>
<p>流与集合: </p>
<ul>
<li>集合与流的差异就在于什么时候进行计算    <ul>
<li>集合是内存中的数据结构, 包含数据结构中目前所有的值</li>
<li>流的元素则是按需计算/生成</li>
</ul>
</li>
<li>另一个关键区别在于遍历数据的方式    <ul>
<li>集合使用 Collection 接口, 需要用户去做迭代, 称为外部迭代</li>
<li>流的 Streams 库使用内部迭代</li>
</ul>
</li>
</ul>
<p>流的使用: </p>
<ul>
<li>一个数据源（如集合）来执行一个查询；</li>
<li>一个中间操作链, 形成一条流的流水线；</li>
<li>一个终端操作, 执行流水线, 并能生成结果. </li>
</ul>
<p>流的流水线背后的理念类似于构建器模式. 常见的中间操作有<code>filter</code>,<code>map</code>,<code>limit</code>,<code>sorted</code>,<code>distinct</code>；常见的终端操作有 <code>forEach</code>,<code>count</code>,<code>collect</code>. </p>
<p><img src="https://cdn.yangbingdong.com/img/java/stream.png" alt><br>流的操作类型分为两种: </p>
<ul>
<li><code>Intermediate</code>: 一个流可以后面跟随零个或多个 <code>intermediate</code> 操作. 其目的主要是<strong>打开流</strong>, 做出某种程度的数据映射/过滤, 然后返回一个新的流, 交给下一个操作使用. 这类操作都是<strong>惰性化的</strong>（<strong>lazy</strong>）, 就是说, 仅仅调用到这类方法, <strong>并没有真正开始流的遍历</strong>. </li>
<li><code>Terminal</code>: 一个流只能有一个 <code>terminal</code> 操作, 当这个操作执行后, 流就被使用“光”了, 无法再被操作. 所以这必定是流的<strong>最后一个操作</strong>. <code>Terminal</code> 操作的执行, <strong>才会真正开始流的遍历</strong>, 并且会生成一个结果, 或者一个 <strong>side effect</strong>. </li>
</ul>
<h2 id="流的使用"><a href="#流的使用" class="headerlink" title="流的使用"></a>流的使用</h2><h3 id="构建流"><a href="#构建流" class="headerlink" title="构建流"></a>构建流</h3><ul>
<li>由值创建流: <code>Stream.of</code>、<code>Stream.empty</code>、<code>IntStream.range</code></li>
<li>由集合创建流: <code>Collection.stream</code>、<code>Collection.parallelStream</code></li>
<li>由数组创建流: <code>Arrays.stream(数组变量)</code></li>
<li>由文件生成流: <code>Files.lines</code>、<code>Files.walk</code></li>
<li>由BufferedReader创建流: <code>java.io.BufferedReader.lines</code></li>
<li>由函数生成流: 创建无限流,    <ul>
<li>迭代: <code>Stream.iterate</code>（接受一个种子值, 和一个<code>UnaryOperator</code>）</li>
<li>生成: <code>Stream.generate</code>（接收一个<code>Supplier</code>接口）</li>
</ul>
</li>
</ul>
<h3 id="使用流"><a href="#使用流" class="headerlink" title="使用流"></a>使用流</h3><h4 id="Intermediate（中间操作）"><a href="#Intermediate（中间操作）" class="headerlink" title="Intermediate（中间操作）:"></a>Intermediate（中间操作）:</h4><ul>
<li>筛选:    <ul>
<li>谓词筛选: <code>filter</code></li>
<li>筛选互异的元素: <code>distinct</code></li>
<li>忽略头几个元素: <code>skip</code></li>
<li>截短至指定长度: <code>limit</code></li>
<li>排序: <code>sorted</code></li>
<li>偷瞄（输出）: <code>peek</code></li>
<li>平行化: <code>parallel</code></li>
<li>串行化: <code>sequential</code></li>
</ul>
</li>
<li>映射:<ul>
<li>对流中每个元素应用函数: <code>map</code></li>
<li>流的扁平化: <code>flatMap</code></li>
<li>转为原始流: <code>mapToInt</code>、<code>mapToInt</code>、<code>mapToInt</code></li>
<li>从原始流转为普通流: <code>boxed</code></li>
</ul>
</li>
<li>数值范围: <ul>
<li><code>range</code>:<code>[起始值, 结束值)</code></li>
<li><code>rangeClosed</code>:<code>[起始值, 结束值]</code></li>
</ul>
</li>
</ul>
<h4 id="Terminal（终结操作）"><a href="#Terminal（终结操作）" class="headerlink" title="Terminal（终结操作）"></a>Terminal（终结操作）</h4><ul>
<li>查找和匹配:<ul>
<li>检查谓词是否至少匹配一个元素: <code>anyMatch</code></li>
<li>检查谓词是否匹配所有元素: <code>allMatch</code>/<code>noneMatch</code></li>
<li>查找元素: <code>findAny</code></li>
<li>查找第一个元素: <code>findFirst</code></li>
</ul>
</li>
<li>归约（折叠）: <code>reduce</code>(初值, 结合操作)<ul>
<li>元素求和: <code>count</code>、<code>sum</code></li>
<li>最大值和最小值: <code>min</code>、 <code>max</code></li>
</ul>
</li>
<li>遍历: <code>forEach</code>、 <code>forEachOrdered</code></li>
</ul>
<p><code>anyMatch</code>,<code>allMatch</code>,<code>noneMatch</code> 都用到了短路；<code>distinct</code>,<code>sorted</code>是有状态且无界的, <code>skip</code>,<code>limit</code>,<code>reduce</code>是有状态且有界的.<br>原始类型流特化: <code>IntStream</code>,<code>DoubleStream</code>,<code>LongStream</code>, 避免暗含的装箱成本. </p>
<ul>
<li>映射到数值流: <code>mapToInt</code>,<code>mapToDouble</code>,<code>mapToLong</code></li>
<li>转换回流对象: <code>boxed</code></li>
<li>默认值: <code>OptionalInt</code>,<code>OptionalDouble</code>,<code>OptionalLong</code></li>
</ul>
<h3 id="用流收集数据"><a href="#用流收集数据" class="headerlink" title="用流收集数据"></a>用流收集数据</h3><p>对流调用 <code>collect</code> 方法将对流中的元素触发归约操作（由 <code>Collector</code> 来参数化）.<br>Collectors 实用类提供了许多静态工厂方法, 用来创建常见收集器的实例, 主要提供三大功能: </p>
<ul>
<li>将流元素归约和汇总为一个值</li>
<li>元素分组</li>
<li>元素分区</li>
</ul>
<p>归约和汇总(<code>Collectors</code> 类中的工厂方法): </p>
<ul>
<li>统计个数: <code>Collectors.counting</code></li>
<li>查找流中最大值和最小值: <code>Collectors.maxBy</code>,<code>Collectors.minBy</code></li>
<li>汇总: <code>Collectors.summingInt</code>,<code>Collectors.averagingInt</code>,<code>summarizingInt</code>/<code>IntSummaryStatistics</code>. 还有对应的 long 和 double 类型的函数</li>
<li>连接字符串: <code>joining</code></li>
<li>广义的归约汇总: <code>Collectors.reducing(起始值, 映射方法, 二元结合)</code>/<code>Collectors.reducing(二元结合)</code>. <code>Collectors.reducing</code> 工厂方法是所有上述特殊情况的一般化. </li>
</ul>
<p><code>collect vs. reduce</code>, 两者都是 <code>Stream</code> 接口的方法, 区别在于: </p>
<ul>
<li>语意问题    <ul>
<li><code>reduce</code> 方法旨在把两个值结合起来生成一个新值, 是不可变的归约；</li>
<li><code>collect</code> 方法设计就是要改变容器, 从而累积要输出的结果</li>
</ul>
</li>
<li>实际问题    <ul>
<li>以错误的语义使用 <code>reduce</code> 会导致归约过程不能并行工作</li>
</ul>
</li>
</ul>
<p>分组和分区</p>
<ul>
<li>分组: <code>Collectors.groupingBy</code><ul>
<li>多级分组</li>
<li>按子数组收集数据: <code>maxBy</code><ul>
<li>把收集器的结果转换为另一种结果 <code>collectingAndThen</code></li>
<li>与 <code>groupingBy</code> 联合使用的其他收集器例子: <code>summingInt</code>,<code>mapping</code></li>
</ul>
</li>
</ul>
</li>
<li>分区: <code>Collectors.partitioningBy</code>是分组的特殊情况, 由一个谓词作为分类函数(分区函数), 返回一个Map, 只有两个Boolean类型的key. </li>
</ul>
<h4 id="Ex1-使用collect-生成Collection"><a href="#Ex1-使用collect-生成Collection" class="headerlink" title="Ex1:使用collect()生成Collection"></a>Ex1:使用collect()生成Collection</h4><p>前面已经提到通过<code>collect()</code>方法将<em>Stream</em>转换成容器的方法, 这里再汇总一下. 将<em>Stream</em>转换成<em>List</em>或<em>Set</em>是比较常见的操作, 所以<em>Collectors</em>工具已经为我们提供了对应的收集器, 通过如下代码即可完成: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 将Stream转换成List或Set</span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;);</span><br><span class="line">List&lt;String&gt; list = stream.collect(Collectors.toList()); // (1)</span><br><span class="line">Set&lt;String&gt; set = stream.collect(Collectors.toSet()); // (2)</span><br></pre></td></tr></table></figure>
<p>上述代码能够满足大部分需求, 但由于返回结果是接口类型, 我们并不知道类库实际选择的容器类型是什么, 有时候我们可能会想要人为指定容器的实际类型, 这个需求可通过<code>Collectors.toCollection(Supplier&lt;C&gt; collectionFactory)</code>方法完成. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 使用toCollection()指定规约容器的类型</span><br><span class="line">ArrayList&lt;String&gt; arrayList = stream.collect(Collectors.toCollection(ArrayList::new));// (3)</span><br><span class="line">HashSet&lt;String&gt; hashSet = stream.collect(Collectors.toCollection(HashSet::new));// (4)</span><br></pre></td></tr></table></figure>
<p>上述代码(3)处指定规约结果是<em>ArrayList</em>, 而(4)处指定规约结果为<em>HashSet</em>. 一切如你所愿. </p>
<h4 id="Ex2-使用collect-生成Map"><a href="#Ex2-使用collect-生成Map" class="headerlink" title="Ex2:使用collect()生成Map"></a>Ex2:使用collect()生成Map</h4><p>前面已经说过<em>Stream</em>背后依赖于某种数据源, 数据源可以是数组、容器等, 但不能是<em>Map</em>. 反过来从<em>Stream</em>生成<em>Map</em>是可以的, 但我们要想清楚<em>Map</em>的<em>key</em>和<em>value</em>分别代表什么, 根本原因是我们要想清楚要干什么. 通常在三种情况下<code>collect()</code>的结果会是<em>Map</em>: </p>
<ol>
<li>使用<code>Collectors.toMap()</code>生成的收集器, 用户需要指定如何生成<em>Map</em>的<em>key</em>和<em>value</em>. </li>
<li>使用<code>Collectors.partitioningBy()</code>生成的收集器, 对元素进行二分区操作时用到. </li>
<li>使用<code>Collectors.groupingBy()</code>生成的收集器, 对元素做<em>group</em>操作时用到. </li>
</ol>
<p>情况1: 使用<code>toMap()</code>生成的收集器, 这种情况是最直接的, 前面例子中已提到, 这是和<code>Collectors.toCollection()</code>并列的方法. 如下代码展示将学生列表转换成由&lt;学生, GPA&gt;组成的<em>Map</em>. 非常直观, 无需多言. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 使用toMap()统计学生GPA</span><br><span class="line">Map&lt;Student, Double&gt; studentToGPA =</span><br><span class="line">     students.stream().collect(Collectors.toMap(Functions.identity(),// 如何生成key</span><br><span class="line">                                     student -&gt; computeGPA(student)));// 如何生成value</span><br></pre></td></tr></table></figure>
<p>情况2: 使用<code>partitioningBy()</code>生成的收集器, 这种情况适用于将<code>Stream</code>中的元素依据某个二值逻辑（满足条件, 或不满足）分成互补相交的两部分, 比如男女性别、成绩及格与否等. 下列代码展示将学生分成成绩及格或不及格的两部分. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Partition students into passing and failing</span><br><span class="line">Map&lt;Boolean, List&lt;Student&gt;&gt; passingFailing = students.stream()</span><br><span class="line">         .collect(Collectors.partitioningBy(s -&gt; s.getGrade() &gt;= PASS_THRESHOLD));</span><br></pre></td></tr></table></figure>
<p>情况3: 使用<code>groupingBy()</code>生成的收集器, 这是比较灵活的一种情况. 跟SQL中的<em>group by</em>语句类似, 这里的<em>groupingBy()也是按照某个属性对数据进行分组, 属性相同的元素会被对应到Map</em>的同一个<em>key</em>上. 下列代码展示将员工按照部门进行分组: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Group employees by department</span><br><span class="line">Map&lt;Department, List&lt;Employee&gt;&gt; byDept = employees.stream()</span><br><span class="line">            .collect(Collectors.groupingBy(Employee::getDepartment));</span><br></pre></td></tr></table></figure>
<p>以上只是分组的最基本用法, 有些时候仅仅分组是不够的. 在SQL中使用<em>group by</em>是为了协助其他查询, 比如<em>1. 先将员工按照部门分组, 2. 然后统计每个部门员工的人数</em>. Java类库设计者也考虑到了这种情况, 增强版的<code>groupingBy()</code>能够满足这种需求. 增强版的<code>groupingBy()</code>允许我们对元素分组之后再执行某种运算, 比如求和、计数、平均值、类型转换等. 这种先将元素分组的收集器叫做<strong>上游收集器</strong>, 之后执行其他运算的收集器叫做<strong>下游收集器</strong>(<em>downstream Collector</em>). </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 使用下游收集器统计每个部门的人数</span><br><span class="line">Map&lt;Department, Integer&gt; totalByDept = employees.stream()</span><br><span class="line">                    .collect(Collectors.groupingBy(Employee::getDepartment,</span><br><span class="line">                                                   Collectors.counting()));// 下游收集器</span><br></pre></td></tr></table></figure>
<p>上面代码的逻辑是不是越看越像SQL？高度非结构化. 还有更狠的, 下游收集器还可以包含更下游的收集器, 这绝不是为了炫技而增加的把戏, 而是实际场景需要. 考虑将员工按照部门分组的场景, 如果<em>我们想得到每个员工的名字（字符串）, 而不是一个个</em>Employee<em>对象</em>, 可通过如下方式做到: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 按照部门对员工分布组, 并只保留员工的名字</span><br><span class="line">Map&lt;Department, List&lt;String&gt;&gt; byDept = employees.stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Employee::getDepartment,</span><br><span class="line">                        Collectors.mapping(Employee::getName,// 下游收集器</span><br><span class="line">                                Collectors.toList())));// 更下游的收集器</span><br></pre></td></tr></table></figure>
<h2 id="Notice-And-Optimization"><a href="#Notice-And-Optimization" class="headerlink" title="Notice And Optimization"></a>Notice And Optimization</h2><ul>
<li>流不可被复用</li>
<li>一般先<code>filter</code>、<code>limit</code>、<code>skip</code>操作后再进行<code>sorted</code>、<code>peek</code>、<code>map</code>等操作以达到<code>short-circuiting</code> 目的</li>
</ul>
<table>
<thead>
<tr>
<th>Stream操作分类</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>中间操作(Intermediate operations)</td>
<td>无状态(Stateless)</td>
<td>unordered() filter() map() mapToInt() mapToLong() mapToDouble() flatMap() flatMapToInt() flatMapToLong() flatMapToDouble() peek()</td>
</tr>
<tr>
<td>有状态(Stateful)</td>
<td>distinct() sorted() sorted() limit() skip()</td>
<td></td>
</tr>
<tr>
<td>结束操作(Terminal operations)</td>
<td>非短路操作</td>
<td>forEach() forEachOrdered() toArray() reduce() collect() max() min() count()</td>
</tr>
<tr>
<td>短路操作(short-circuiting)</td>
<td>anyMatch() allMatch() noneMatch() findFirst() findAny()</td>
</tr>
</tbody>
</table>
<p>Stream上的所有操作分为两类: 中间操作和结束操作, 中间操作只是一种标记, 只有结束操作才会触发实际计算. 中间操作又可以分为无状态的(<em><code>Stateless</code></em>)和有状态的(<em><code>Stateful</code></em>), 无状态中间操作是指元素的处理不受前面元素的影响, 而有状态的中间操作必须等到所有元素处理之后才知道最终结果, 比如排序是有状态操作, 在读取所有元素之前并不能确定排序结果；结束操作又可以分为短路操作和非短路操作, 短路操作是指不用处理全部元素就可以返回结果, 比如<em>找到第一个满足条件的元素</em>. 之所以要进行如此精细的划分, 是因为底层对每一种情况的处理方式不同. </p>
<h1 id="Annotations"><a href="#Annotations" class="headerlink" title="Annotations"></a>Annotations</h1><p>Java 8中的注解是可重复的.<br>首先, 我们定义一个包装注解, 它包括了一个实际注解的数组:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@interface</span> Hints &#123;</span><br><span class="line">    Hint[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repeatable</span>(Hints<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">interface</span> <span class="title">Hint</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只要在前面加上注解名: <code>@Repeatable</code>, Java 8 允许我们对同一类型使用多重注解<br>变体1: 使用注解容器（老方法）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Hints(&#123;@Hint(&quot;hint1&quot;), @Hint(&quot;hint2&quot;)&#125;)</span><br><span class="line">class Person &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>变体2: 使用可重复注解（新方法）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Hint(&quot;hint1&quot;)</span><br><span class="line">@Hint(&quot;hint2&quot;)</span><br><span class="line">class Person &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用变体2, Java编译器能够在内部自动对@Hint进行设置. 这对于通过反射来读取注解信息来说, 是非常重要的.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hint hint = Person.class.getAnnotation(Hint.class);</span><br><span class="line">System.out.println(hint);                   // null</span><br><span class="line"></span><br><span class="line">Hints hints1 = Person.class.getAnnotation(Hints.class);</span><br><span class="line">System.out.println(hints1.value().length);  // 2</span><br><span class="line"></span><br><span class="line">Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class);</span><br><span class="line">System.out.println(hints2.length);          // 2</span><br></pre></td></tr></table></figure></p>
<p>尽管我们绝对不会在<code>Person</code>类上声明<code>@Hints</code>注解, 但是它的信息仍然可以通过<code>getAnnotation(Hints.class)</code>来读取. 并且, <code>getAnnotationsByType</code>方法会更方便, 因为它赋予了所有<code>@Hints</code>注解标注的方法直接的访问权限.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE_PARAMETER, ElementType.TYPE_USE&#125;)</span><br><span class="line">@interface MyAnnotation &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Time-API"><a href="#Time-API" class="headerlink" title="Time API"></a>Time API</h1><h2 id="现有API存在的问题"><a href="#现有API存在的问题" class="headerlink" title="现有API存在的问题"></a>现有API存在的问题</h2><ul>
<li>线程安全: <code>Date</code>和<code>Calendar</code><strong>不是线程安全的</strong>, 你需要编写额外的代码处理线程安全问题</li>
<li>API设计和易用性: 由于<code>Date</code>和<code>Calendar</code>的设计不当你无法完成日常的日期操作</li>
<li><code>ZonedDate</code>和<code>Time</code>: 你必须编写额外的逻辑处理时区和那些旧的逻辑</li>
</ul>
<p>好在<a href="http://link.zhihu.com/?target=http%3A//jcp.org/en/jsr/detail%3Fid%3D310" rel="external nofollow noopener noreferrer" target="_blank">JSR 310</a>规范中为Java8添加了新的API<br>在<code>java.time</code>包中, 新的API纠正了过去的缺陷</p>
<h2 id="新的日期API"><a href="#新的日期API" class="headerlink" title="新的日期API"></a>新的日期API</h2><ul>
<li><code>ZoneId</code>: 时区ID, 用来确定<code>Instant</code>和<code>LocalDateTime</code>互相转换的规则</li>
<li><code>Instant</code>: 用来表示时间线上的一个点</li>
<li><code>LocalDate</code>: 表示没有时区的日期, <code>LocalDate</code>是不可变并且<strong>线程安全</strong>的</li>
<li><code>LocalTime</code>: 表示没有时区的时间, <code>LocalTime</code>是不可变并且<strong>线程安全</strong>的</li>
<li><code>LocalDateTime</code>: 表示没有时区的日期时间, <code>LocalDateTime</code>是不可变并且线程安全的</li>
<li><code>Clock</code>: 用于访问当前时刻、日期、时间, 用到时区</li>
<li><code>Duration</code>: 用秒和纳秒表示时间的数量</li>
</ul>
<p>最常用的就是<code>LocalDate</code>、<code>LocalTime</code>、<code>LocalDateTime</code></p>
<h2 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h2><p><code>Clock</code>提供了对当前时间和日期的访问功能. <code>Clock</code>是对当前时区敏感的, 并可用于替代<code>System.currentTimeMillis()</code>方法来获取当前的毫秒时间. 当前时间线上的时刻可以用<code>Instance</code>类来表示. Instance也能够用于创建原先的<code>java.util.Date</code>对象. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Clock clock = Clock.systemDefaultZone();</span><br><span class="line">long millis = clock.millis();</span><br><span class="line"></span><br><span class="line">Instant instant = clock.instant();</span><br><span class="line">Date legacyDate = Date.from(instant); // legacy java.util.Date</span><br></pre></td></tr></table></figure>
<h2 id="Timezones"><a href="#Timezones" class="headerlink" title="Timezones"></a>Timezones</h2><p>时区类可以用一个<code>ZoneId</code>来表示. 时区类的对象可以通过静态工厂方法方便地获取. 时区类还定义了一个偏移量, 用来在当前时刻或某时间与目标时区时间之间进行转换. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.println(ZoneId.getAvailableZoneIds());</span><br><span class="line">// prints all available timezone ids</span><br><span class="line"></span><br><span class="line">ZoneId zone1 = ZoneId.of(&quot;Europe/Berlin&quot;);</span><br><span class="line">ZoneId zone2 = ZoneId.of(&quot;Brazil/East&quot;);</span><br><span class="line">System.out.println(zone1.getRules());</span><br><span class="line">System.out.println(zone2.getRules());</span><br><span class="line"></span><br><span class="line">// ZoneRules[currentStandardOffset=+01:00]</span><br><span class="line">// ZoneRules[currentStandardOffset=-03:00]</span><br></pre></td></tr></table></figure>
<h2 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h2><p><code>LocalDate</code>代表一个IOS格式(<code>yyyy-MM-dd</code>)的日期, 它有多个构造方法: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalDate.now();</span><br><span class="line">LocalDate.of(2018, 8, 15);</span><br><span class="line">LocalDate.parse(&quot;2018-08-15&quot;);</span><br><span class="line">LocalDate.parse(&quot;2018.08.15&quot;, DateTimeFormatter.ofPattern(&quot;yyyy.MM.dd&quot;))</span><br></pre></td></tr></table></figure>
<p>其他API: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 获取明天</span><br><span class="line">LocalDate tomorrow = LocalDate.now().plusDays(1);</span><br><span class="line"></span><br><span class="line">// 上一个月的今天</span><br><span class="line">LocalDate prevMonth = LocalDate.now().minus(1, ChronoUnit.MONTHS);</span><br><span class="line"></span><br><span class="line">// 获取今天是星期几</span><br><span class="line">DayOfWeek thursday = LocalDate.parse(&quot;2018-09-27&quot;).getDayOfWeek();</span><br><span class="line"></span><br><span class="line">// 获取今天是几号</span><br><span class="line">int dayOfMonth = LocalDate.parse(&quot;2018-09-27&quot;).getDayOfMonth();</span><br><span class="line"></span><br><span class="line">// 今年是不是闰年</span><br><span class="line">boolean leapYear = LocalDate.now().isLeapYear();</span><br></pre></td></tr></table></figure>
<p>日期比较: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalDate now = LocalDate.now();</span><br><span class="line">LocalDate tomorrow = now.plusDays(1);</span><br><span class="line">System.out.println(now.isBefore(tomorrow));</span><br><span class="line">System.out.println(tomorrow.isAfter(now));</span><br></pre></td></tr></table></figure>
<p>获取这个月的第一天</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalDate firstDayOfMonth = LocalDate.parse(&quot;2018-08-15&quot;).with(TemporalAdjusters.firstDayOfMonth());</span><br><span class="line">System.out.println(&quot;这个月的第一天: &quot; + firstDayOfMonth);</span><br><span class="line">firstDayOfMonth = firstDayOfMonth.withDayOfMonth(1);</span><br><span class="line">System.out.println(&quot;这个月的第一天: &quot; + firstDayOfMonth);</span><br></pre></td></tr></table></figure>
<p>判断否是生日</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalDate birthday = LocalDate.of(1994, 04, 15);</span><br><span class="line">MonthDay birthdayMd = MonthDay.of(birthday.getMonth(), birthday.getDayOfMonth());</span><br><span class="line">MonthDay today = MonthDay.from(LocalDate.now());</span><br><span class="line">System.out.println(&quot;否是生日: &quot; + today.equals(birthdayMd));</span><br></pre></td></tr></table></figure>
<p>固定的日期, 比如信用卡过期时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YearMonth currentYearMonth = YearMonth.now();</span><br><span class="line">System.out.printf(&quot;Days in month year %s: %d%n&quot;, currentYearMonth,currentYearMonth.lengthOfMonth()); </span><br><span class="line">YearMonth creditCardExpiry = YearMonth.of(2018, Month.FEBRUARY); </span><br><span class="line">System.out.printf(&quot;Your credit card expires on %s %n&quot;, creditCardExpiry);</span><br></pre></td></tr></table></figure>
<h2 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h2><p>构造方法与LocalDate类似: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalTime.now();</span><br><span class="line">LocalTime.parse(&quot;15:02&quot;);</span><br><span class="line">LocalTime.of(15, 02);</span><br></pre></td></tr></table></figure>
<p>时间加减: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalTime.parse(&quot;15:02&quot;).plus(1, ChronoUnit.HOURS);</span><br><span class="line">LocalTime.now().plusHours(1);</span><br></pre></td></tr></table></figure>
<p>获取时间的小时、分钟:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int hour = LocalTime.parse(&quot;15:02&quot;).getHour();</span><br><span class="line">int minute = LocalTime.parse(&quot;15:02&quot;).getMinute();</span><br></pre></td></tr></table></figure>
<p>时间比较: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalTime.parse(&quot;15:02&quot;).isBefore(LocalTime.parse(&quot;16:02&quot;));</span><br><span class="line">LocalTime.parse(&quot;15:02&quot;).isAfter(LocalTime.parse(&quot;16:02&quot;));</span><br></pre></td></tr></table></figure>
<p>一天的开始与结束: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.out.println(LocalTime.MAX);</span><br><span class="line">System.out.println(LocalTime.MIN);</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">23:59:59.999999999</span><br><span class="line">00:00</span><br></pre></td></tr></table></figure>
<h2 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h2><p>这个应该是最常用的了, 构造方法与上面两个类似: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalDateTime.now();</span><br><span class="line">LocalDateTime.of(2018, Month.AUGUST, 15, 15, 18);</span><br><span class="line">LocalDateTime.parse(&quot;2018-08-15T15:18:00&quot;);</span><br></pre></td></tr></table></figure>
<p>时间加减操作与上面差不多: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalDateTime tomorrow = now.plusDays(1);</span><br><span class="line">LocalDateTime minusTowHour = now.minusHours(2);</span><br></pre></td></tr></table></figure>
<p>时间比较:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tomorrow.isAfter(minusTowHour)</span><br></pre></td></tr></table></figure>
<p>获取特定单位: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Month month = now.getMonth();</span><br></pre></td></tr></table></figure>
<p>转换成<code>LocalDate</code>和<code>LocalTime</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">now.toLocalDate();</span><br><span class="line">now.toLocalTime();</span><br></pre></td></tr></table></figure>
<p>获取某天的开始: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">LocalDateTime startOfDay = now.toLocalDate().atStartOfDay();</span><br></pre></td></tr></table></figure>
<h2 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalDateTime now = LocalDateTime.now();</span><br><span class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">System.out.println(&quot;默认格式化: &quot; + now);</span><br><span class="line">System.out.println(&quot;自定义格式化: &quot; + now.format(dateTimeFormatter));</span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.parse(&quot;2018-08-15 15:27:44&quot;, dateTimeFormatter);</span><br><span class="line">System.out.println(&quot;字符串转LocalDateTime: &quot; + localDateTime);</span><br></pre></td></tr></table></figure>
<p>也可以使用<code>DateTimeFormatter</code>的<code>format</code>方法将日期、时间格式化为字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">String dateString = dateTimeFormatter.format(LocalDate.now());</span><br><span class="line">System.out.println(&quot;日期转字符串: &quot; + dateString);</span><br></pre></td></tr></table></figure>
<h2 id="日期周期"><a href="#日期周期" class="headerlink" title="日期周期"></a>日期周期</h2><p><code>Period</code>类用于修改给定日期或获得的两个日期之间的区别. </p>
<p>给初始化的日期添加5天:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalDate initialDate = LocalDate.parse(&quot;2018-08-15&quot;);</span><br><span class="line">LocalDate finalDate = initialDate.plus(Period.ofDays(5));</span><br></pre></td></tr></table></figure>
<p>周期API中提供给我们可以比较两个日期的差别, 像下面这样获取差距天数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long between = ChronoUnit.DAYS.between(initialDate, finalDate);</span><br></pre></td></tr></table></figure>
<p>上面的代码会返回5, 当然你想获取两个日期相差多少小时也是简单的. </p>
<h2 id="与Date转换"><a href="#与Date转换" class="headerlink" title="与Date转换"></a>与Date转换</h2><p><code>Date</code>和<code>Instant</code>互相转换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Date date = Date.from(Instant.now());</span><br><span class="line">Instant instant = date.toInstant();</span><br></pre></td></tr></table></figure>
<p><code>Date</code>转换为<code>LocalDateTime</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LocalDateTime now = LocalDateTime.ofInstant(new Date().toInstant(), ZoneId.systemDefault());</span><br></pre></td></tr></table></figure>
<p><code>LocalDateTime</code>转<code>Date</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Date date = Date.from(LocalDateTime.now().atZone(ZoneId.systemDefault()).toInstant());</span><br></pre></td></tr></table></figure>
<p><code>LocalDate</code>转<code>Date</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Date date = Date.from(LocalDate.now().atStartOfDay().atZone(ZoneId.systemDefault()).toInstant());</span><br></pre></td></tr></table></figure>
<h1 id="Other-Extend"><a href="#Other-Extend" class="headerlink" title="Other Extend"></a>Other Extend</h1><h2 id="Lambda表达式遇上检测型异常"><a href="#Lambda表达式遇上检测型异常" class="headerlink" title="Lambda表达式遇上检测型异常"></a>Lambda表达式遇上检测型异常</h2><p>先来看一段代码: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long count = Files.walk(Paths.get(&quot;/home/test&quot;))                      // 获得项目目录下的所有目录及文件</span><br><span class="line">                .filter(file -&gt; !Files.isDirectory(file))          // 筛选出文件</span><br><span class="line">                .filter(file -&gt; file.toString().endsWith(&quot;.java&quot;)) // 筛选出 java 文件</span><br><span class="line">                .flatMap(file -&gt; Files.lines(file))                // 按行获得文件中的文本</span><br><span class="line">                .filter(line -&gt; !line.trim().isEmpty())            // 过滤掉空行</span><br><span class="line">                .count();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;代码行数: &quot; + count);</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>Files.walk(Path)</code> 在 JDK1.8 时添加, 深度优先遍历一个 <code>Path</code> （目录）, 返回这个目录下所有的 <code>Path</code>（目录和文件）, 通过 <code>Stream&lt;Path&gt;</code> 返回；</li>
<li><code>Files.lines(Path)</code> 也是在 JDK1.8 时添加, 功能是返回指定 <code>Path</code> （文件）中所有的行, 通过 <code>Stream&lt;String&gt;</code> 返回. </li>
</ul>
</blockquote>
<p>然后, 编译不过 —— 因为 <code>Files.lines(Path)</code> 会抛出 <code>IOException</code>, 如果要编译通过, 得这样写: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long count = Files.walk(Paths.get(&quot;/home/test&quot;))                      // 获得项目目录下的所有文件</span><br><span class="line">                .filter(file -&gt; !Files.isDirectory(file))          // 筛选出文件</span><br><span class="line">                .filter(file -&gt; file.toString().endsWith(&quot;.java&quot;)) // 筛选出 java 文件</span><br><span class="line">                .flatMap(file -&gt; &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        return Files.lines(file);</span><br><span class="line">                    &#125; catch (IOException ex) &#123;</span><br><span class="line">                        ex.printStackTrace(System.err);</span><br><span class="line">                        return Stream.empty();                     // 抛出异常时返回一个空的 Stream</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)                                                 // 按行获得文件中的文本</span><br><span class="line">                .filter(line -&gt; !line.trim().isEmpty())            // 过滤掉空行</span><br><span class="line">                .count();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;代码行数: &quot; + count);</span><br></pre></td></tr></table></figure>
<p>对于有强迫症的程序员来说这简直是噩梦, <em><code>one-liner expression</code></em> 的 Lambda需要绝对的简介明了. </p>
<p>这里有两种做法, 比较偷懒的就是每个会抛出异常的地方我们独自捕获处理, 这样带来的问题就是不够通用, 每个异常方法都要捕获一次: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    long count = Files.walk(Paths.get(&quot;/home/test&quot;))                       // 获得项目目录下的所有文件</span><br><span class="line">                    .filter(file -&gt; !Files.isDirectory(file))           // 筛选出文件</span><br><span class="line">                    .filter(file -&gt; file.toString().endsWith(&quot;.java&quot;))  // 筛选出 java 文件</span><br><span class="line">                    .flatMap(file -&gt; getLines(file))                    // 按行获得文件中的文本</span><br><span class="line">                    .filter(line -&gt; !line.trim().isEmpty())             // 过滤掉空行</span><br><span class="line">                    .count();</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;代码行数: &quot; + count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Stream&lt;String&gt; getLines(Path file) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return Files.lines(file);</span><br><span class="line">    &#125; catch (IOException ex) &#123;</span><br><span class="line">        ex.printStackTrace(System.err);</span><br><span class="line">        return Stream.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种解决方法下, 我们需要处理受检异常 —— 即在程序抛出异常的时候, 我们需要告诉程序怎么去做（<code>getLines</code> 方法中抛出异常时我们输出了异常, 并返回一个空的 <code>Stream</code>）</p>
<p>上面方式当然是不可取的啦, 我们选择更偷懒的方式, <strong>将会抛出异常的函数进行包装, 使其不抛出受检异常</strong>. </p>
<p>如果一个 <em><code>FunctionInterface</code></em> 的方法会抛出受检异常（比如 <code>Exception</code>）, 那么该 <em><code>FunctionInterface</code></em> 便可以作为会抛出受检异常的 Lambda 的目标类型.<br>我们定义如下一个 <em><code>FunctionInterface</code></em>: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface UncheckedFunction&lt;T, R&gt; &#123;</span><br><span class="line">	R apply(T t) throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么该 <em><code>FunctionInterface</code></em> 便可以作为类似于 <code>file -&gt; File.lines(file)</code> 这类会抛出受检异常的 Lambda 的目标类型, 此时 Lambda 中并不需要捕获异常（因为目标类型的 <code>apply</code> 方法已经将异常抛出了）—— 之所以原来的 Lambda 需要捕获异常, 就是因为在流式操作 <code>flatMap</code> 中使用的 <code>java.util.function</code> 包下的 <code>Function&lt;T, R&gt;</code> 没有抛出异常: </p>
<p><img src="https://cdn.yangbingdong.com/img/java-8-tutorial-extend/java-8-function.png" alt></p>
<p>那我们如何使用 <code>UncheckedFunction</code> 到流式操作的 Lambda 中呢？<br>首先我们定义一个 <code>Trier</code> 类, 它的 <code>tryFunction</code> 方法提供将 <code>UncheckedFunction</code> 包装为 <code>Function</code> 的功能: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Trier &#123;</span><br><span class="line">   private static final Logger LOGGER = LoggerFactory.getLogger(Trier.class);</span><br><span class="line"></span><br><span class="line">   public static &lt;T, R&gt; Function&lt;T, R&gt; tryFunction(UncheckedFunction&lt;T, R&gt; function) &#123;</span><br><span class="line">      requireNonNull(function);</span><br><span class="line">      return t -&gt; &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">            return function.apply(t);</span><br><span class="line">         &#125; catch (Exception e) &#123;</span><br><span class="line">            throw logAndThrow(e);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">    @FunctionalInterface</span><br><span class="line">    public static interface UncheckedFunction&lt;T, R&gt; &#123;</span><br><span class="line"></span><br><span class="line">        R apply(T t) throws Exception;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在原先的代码中, 我们使用 <code>Trier.tryFunction</code> 方法来对会抛出受检异常的 Lambda 进行包装: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long count = Files.walk(Paths.get(&quot;/home/test&quot;))              // 获得项目目录下的所有文件</span><br><span class="line">                .filter(file -&gt; !Files.isDirectory(file))          // 筛选出文件</span><br><span class="line">                .filter(file -&gt; file.toString().endsWith(&quot;.java&quot;)) // 筛选出 java 文件</span><br><span class="line">        </span><br><span class="line">                .flatMap(Trier.tryFunction(file -&gt; Files.lines(file)))        // 将 会抛出受检异常的 Lambda 包装为 抛出非受检异常的 Lambda</span><br><span class="line">        </span><br><span class="line">                .filter(line -&gt; !line.trim().isEmpty())            // 过滤掉空行</span><br><span class="line">                .count();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;代码行数: &quot; + count);</span><br></pre></td></tr></table></figure>
<p>指定默认值的包装方法, 即如果抛出异常, 那么就返回默认值: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static &lt;T, R&gt; Function&lt;T, R&gt; tryFunction(UncheckedFunction&lt;T, R&gt; function, R defaultValue) &#123;</span><br><span class="line">		requireNonNull(function);</span><br><span class="line">		return t -&gt; &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				return function.apply(t);</span><br><span class="line">			&#125; catch (Exception e) &#123;</span><br><span class="line">				return logAndReturn(e, defaultValue);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">private static &lt;R&gt; R logAndReturn(Exception e, R defaultValue) &#123;</span><br><span class="line">		LOGGER.error(&quot;Trier catch an exception: &quot; + getFullStackTrace(e) + &quot;\n And return default value: &quot; + defaultValue);</span><br><span class="line">		return defaultValue;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>比如我们前面的例子, 如果 <code>file -&gt; Files.lines(file)</code> 抛出异常了, 说明在访问 <em>file</em> 类的时候出了问题, 我们可以就假设这个文件的行数为 0 , 那么默认值就是个空的 <code>Stream&lt;String&gt;</code>: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">long count = Files.walk(Paths.get(&quot;/home/test&quot;))              // 获得项目目录下的所有文件</span><br><span class="line">                .filter(file -&gt; !Files.isDirectory(file))          // 筛选出文件</span><br><span class="line">                .filter(file -&gt; file.toString().endsWith(&quot;.java&quot;)) // 筛选出 java 文件</span><br><span class="line">        </span><br><span class="line">                .flatMap(Trier.tryFunction(file -&gt; Files.lines(file), Stream.empty()))</span><br><span class="line">        </span><br><span class="line">                .filter(line -&gt; !line.trim().isEmpty())            // 过滤掉空行</span><br><span class="line">                .count();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;代码行数: &quot; + count);</span><br></pre></td></tr></table></figure>
<p>如此类推, 我们可以创建<code>UncheckedConsumer</code>、<code>UncheckedSupplier</code>等: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Trier &#123;</span><br><span class="line">	private static final Logger LOGGER = LoggerFactory.getLogger(Trier.class);</span><br><span class="line"></span><br><span class="line">	public static &lt;T, R&gt; Function&lt;T, R&gt; tryFunction(UncheckedFunction&lt;T, R&gt; function) &#123;</span><br><span class="line">		requireNonNull(function);</span><br><span class="line">		return t -&gt; &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				return function.apply(t);</span><br><span class="line">			&#125; catch (Exception e) &#123;</span><br><span class="line">				throw logAndThrow(e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static &lt;T, R&gt; Function&lt;T, R&gt; tryFunction(UncheckedFunction&lt;T, R&gt; function, R defaultValue) &#123;</span><br><span class="line">		requireNonNull(function);</span><br><span class="line">		return t -&gt; &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				return function.apply(t);</span><br><span class="line">			&#125; catch (Exception e) &#123;</span><br><span class="line">				return logAndReturn(e, defaultValue);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static &lt;T&gt; Supplier&lt;T&gt; trySupplier(UncheckedSupplier&lt;T&gt; supplier) &#123;</span><br><span class="line">		requireNonNull(supplier);</span><br><span class="line">		return () -&gt; &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				return supplier.get();</span><br><span class="line">			&#125; catch (Exception e) &#123;</span><br><span class="line">				throw logAndThrow(e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static &lt;T&gt; Supplier&lt;T&gt; trySupplier(UncheckedSupplier&lt;T&gt; supplier, T defaultValue) &#123;</span><br><span class="line">		requireNonNull(supplier);</span><br><span class="line">		return () -&gt; &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				return supplier.get();</span><br><span class="line">			&#125; catch (Exception e) &#123;</span><br><span class="line">				return logAndReturn(e, defaultValue);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static &lt;T&gt; Consumer&lt;T&gt; tryConsumer(UncheckedConsumer&lt;T&gt; consumer) &#123;</span><br><span class="line">		requireNonNull(consumer);</span><br><span class="line">		return t -&gt; &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				consumer.accept(t);</span><br><span class="line">			&#125; catch (Exception e) &#123;</span><br><span class="line">				throw logAndThrow(e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static &lt;T&gt; Predicate&lt;T&gt; tryPredicate(UncheckedPredicate&lt;T&gt; predicate) &#123;</span><br><span class="line">		requireNonNull(predicate);</span><br><span class="line">		return t -&gt; &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				return predicate.test(t);</span><br><span class="line">			&#125; catch (Exception e) &#123;</span><br><span class="line">				throw logAndThrow(e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static &lt;T&gt; Predicate&lt;T&gt; tryPredicate(UncheckedPredicate&lt;T&gt; predicate, boolean defaultValue) &#123;</span><br><span class="line">		requireNonNull(predicate);</span><br><span class="line">		return t -&gt; &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				return predicate.test(t);</span><br><span class="line">			&#125; catch (Exception e) &#123;</span><br><span class="line">				return logAndReturn(e, defaultValue);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static void log(Exception e) &#123;</span><br><span class="line">		LOGGER.error(&quot;Trier catch an exception: &quot; + getFullStackTrace(e));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static &lt;R&gt; R logAndReturn(Exception e, R defaultValue) &#123;</span><br><span class="line">		LOGGER.error(&quot;Trier catch an exception: &quot; + getFullStackTrace(e) + &quot;\n And return default value: &quot; + defaultValue);</span><br><span class="line">		return defaultValue;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static RuntimeException logAndThrow(Exception e) &#123;</span><br><span class="line">		log(e);</span><br><span class="line">		throw new RuntimeException(e);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@FunctionalInterface</span><br><span class="line">	public interface UncheckedFunction&lt;T, R&gt; &#123;</span><br><span class="line">		R apply(T t) throws Exception;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@FunctionalInterface</span><br><span class="line">	public interface UncheckedSupplier&lt;T&gt; &#123;</span><br><span class="line">		T get() throws Exception;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@FunctionalInterface</span><br><span class="line">	public interface UncheckedConsumer&lt;T&gt; &#123;</span><br><span class="line">		void accept(T t) throws Exception;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@FunctionalInterface</span><br><span class="line">	public interface UncheckedPredicate&lt;T&gt; &#123;</span><br><span class="line">		boolean test(T t) throws Exception;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Java8-对字符串连接的改进"><a href="#Java8-对字符串连接的改进" class="headerlink" title="Java8 对字符串连接的改进"></a>Java8 对字符串连接的改进</h2><p>有时候, 我们会有一种需求就是将若干个字符串用某个<strong>链接符</strong>衔接起来, 例如有一个 List<string>, 将其格式化为 元素1, 元素2, 元素3, … 元素N 的字符串形式. </string></p>
<p>以前我们的一般做法就是使用<code>StringBuilder</code>: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static String formatList(List&lt;String&gt; list, String delimiter) &#123;</span><br><span class="line">    StringBuilder result = new StringBuilder();</span><br><span class="line">    for (String str : list) &#123;</span><br><span class="line">        result.append(str).append(delimiter);</span><br><span class="line">    &#125;</span><br><span class="line">    // 删除末尾多余的 delimiter</span><br><span class="line">    result.delete(result.length() - delimiter.length(), result.length()); </span><br><span class="line">    </span><br><span class="line">    return result.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;使用 StringBuilder: &quot;);</span><br><span class="line">    String format = formatList(list, &quot;,&quot;);</span><br><span class="line">    System.out.println(format);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用 StringBuilder: </span><br><span class="line">a,b,c,d,e,f,g</span><br></pre></td></tr></table></figure>
<p>JDK1.8 时, 添加了一个新的用于字符串连接的类, 专门用于这种需要 <strong>分隔符</strong> 的场合, 它就是 <code>StringJoiner</code>. <code>StringJoiner</code> 在构造时可以指定一个分隔符（<em><code>delimiter</code></em>）, 然后每连接一个元素它便会加上一个 <em><code>delimiter</code></em>, 使用 <code>StringJoiner</code> 改写 <code>formatList</code>: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static String formatList(List&lt;String&gt; list, String delimiter) &#123;</span><br><span class="line">    StringJoiner result = new StringJoiner(delimiter);</span><br><span class="line">    for (String str : list) &#123;</span><br><span class="line">        result.add(str);</span><br><span class="line">    &#125;</span><br><span class="line">    return result.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;使用 StringJoiner: &quot;);</span><br><span class="line">    String format = formatList(list, &quot;,&quot;);</span><br><span class="line">    System.out.println(format);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果与上面一样. </p>
<p>或者使用<code>String.join</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static String formatList(List&lt;String&gt; list, String delimiter) &#123;</span><br><span class="line">    return String.join(delimiter, list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的底层也是调用<code>StringJoiner</code>: </p>
<p><img src="https://cdn.yangbingdong.com/img/java-8-tutorial-extend/string-join.png" alt></p>
<p>但是我们看到了 <code>String.join</code> 方法的不足 —— 它不能指定前缀和后缀 —— 比如我们如果想要直接将 <code>List&lt;String&gt;</code> 格式化为 <strong>{ 元素1, 元素2, 元素3, … 元素N }</strong> 呢？（此时前缀为 <code>&quot;{ &quot;</code>, 后缀为 <code>&quot; }&quot;</code>）</p>
<p>查看 <code>StringJoiner</code> 的构造方法, 发现 <code>StringJoiner</code> 除了指定 分隔符 的构造方法, 还有一个可以指定 分隔符、前缀和后缀 的构造方法: </p>
<p><img src="https://cdn.yangbingdong.com/img/java-8-tutorial-extend/stringjoiner.png" alt></p>
<p>修改 <code>formatList</code>: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static String formatList(</span><br><span class="line">        List&lt;String&gt; list, String delimiter, String prefix, String suffix) &#123;</span><br><span class="line"></span><br><span class="line">    StringJoiner result = new StringJoiner(delimiter, prefix, suffix);</span><br><span class="line">    for (String str : list) &#123;</span><br><span class="line">        result.add(str);</span><br><span class="line">    &#125;</span><br><span class="line">    return result.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;使用 StringJoiner, 带前缀和后缀: &quot;);</span><br><span class="line">    String format = formatList(list, &quot;, &quot;, &quot;&#123; &quot;, &quot; &#125;&quot;);</span><br><span class="line">    System.out.println(format);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用 StringJoiner, 带前缀和后缀: </span><br><span class="line">&#123; a, b, c, d, e, f, g &#125;</span><br></pre></td></tr></table></figure>
<p>事实上, Java8 对于字符串集合的连接操作提供了一个专门的流式 API, 即 <code>Collectors.joining</code> 函数:<br><img src="https://cdn.yangbingdong.com/img/java-8-tutorial-extend/collectors-joining.png" alt="img"></p>
<ul>
<li>无参的 <code>joining()</code> 方法, 即不存在连接符（底层实现为 <code>StringBuilder</code>）；</li>
<li><code>joining(CharSequence delimiter)</code> 方法, 即分隔符为 <em>delimiter</em>（底层实现为 <code>StringJoiner</code>）；</li>
<li><code>joining(CharSequence delimiter, CharSequence prefix, CharSequence suffix)</code>方法, 即分隔符为 <em>delimiter</em>, 前缀为 <em>prefix</em>, 后缀为 <em>suffix</em>（底层实现为 <code>StringJoiner</code>）. </li>
</ul>
<p>那怎么使用呢？ 我们直接使用三个参数的 <code>Collectors.joining</code> 方法改写 <code>formatList</code>: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static String formatList(</span><br><span class="line">        List&lt;String&gt; list, String delimiter, String prefix, String suffix) &#123;</span><br><span class="line"></span><br><span class="line">    return list.stream().collect(Collectors.joining(delimiter, prefix, suffix));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;使用 Collectors.joining: &quot;);</span><br><span class="line">    String format = formatList(list, &quot;, &quot;, &quot;&#123; &quot;, &quot; &#125;&quot;);</span><br><span class="line">    System.out.println(format);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果同上. </p>
<h2 id="Java8-中-Map-接口的新方法"><a href="#Java8-中-Map-接口的新方法" class="headerlink" title="Java8 中 Map 接口的新方法"></a>Java8 中 Map 接口的新方法</h2><p>假如现在我们存在这样的需求: 给定一个 <code>List&lt;String&gt;</code>, 统计每个元素出现的所有位置. </p>
<p>比如, 给定 <em>list</em>: <code>[&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;, &quot;c&quot;, &quot;c&quot;, &quot;d&quot;, &quot;d&quot;, &quot;d&quot;, &quot;f&quot;, &quot;f&quot;, &quot;g&quot;]</code> , 那么应该返回: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a : [0]</span><br><span class="line">b : [1, 2]</span><br><span class="line">c : [3, 4, 5]</span><br><span class="line">d : [6, 7, 8]</span><br><span class="line">f : [9, 10]</span><br><span class="line">g : [11]</span><br></pre></td></tr></table></figure>
<p>很明显, 我们很适合使用 Map 来完成这件事情: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Map&lt;String, List&lt;Integer&gt;&gt; getElementPositions(List&lt;String&gt; list) &#123;</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; positionsMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">        String str = list.get(i);</span><br><span class="line">        List&lt;Integer&gt; positions = positionsMap.get(str);</span><br><span class="line"></span><br><span class="line">        if (positions == null) &#123; // 如果 positionsMap 还不存在 str 这个键及其对应的 List&lt;Integer&gt;</span><br><span class="line">            positions = new ArrayList&lt;&gt;(1);</span><br><span class="line">            positionsMap.put(str, positions); // 将 str 及其对应的 positions 放入 positionsMap</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        positions.add(i); // 将索引加入 str 相关联的 List&lt;Integer&gt; 中</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return positionsMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;, &quot;c&quot;, &quot;c&quot;, &quot;d&quot;, &quot;d&quot;, &quot;d&quot;, &quot;f&quot;, &quot;f&quot;, &quot;g&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;使用 Java8 之前的 API: &quot;);</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; elementPositions = getElementPositions(list);</span><br><span class="line">    System.out.println(elementPositions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用 Java8 之前的 API: </span><br><span class="line">&#123;a=[0], b=[1, 2], c=[3, 4, 5], d=[6, 7, 8], f=[9, 10], g=[11]&#125;</span><br></pre></td></tr></table></figure>
<p>在Java8之后, <code>Map</code>添加了一下新的方法签名: </p>
<p><img src="https://cdn.yangbingdong.com/img/java-8-tutorial-extend/map-java-8-new-method.png" alt></p>
<p>查看源码发现<code>computeIfAbsent</code>很符合上面需求: </p>
<p><img src="https://cdn.yangbingdong.com/img/java-8-tutorial-extend/map-compute-if-absent.png" alt></p>
<p>我们可以改造成这样子: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Map&lt;String, List&lt;Integer&gt;&gt; getElementPositions(List&lt;String&gt; list) &#123;</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; positionsMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">        positionsMap.computeIfAbsent(list.get(i), k -&gt; new ArrayList&lt;&gt;(1)).add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return positionsMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;, &quot;c&quot;, &quot;c&quot;, &quot;d&quot;, &quot;d&quot;, &quot;d&quot;, &quot;f&quot;, &quot;f&quot;, &quot;g&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;使用 computeIfAbsent: &quot;);</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; elementPositions = getElementPositions(list);</span><br><span class="line">    System.out.println(elementPositions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果一样, 但是代码优雅整洁了很多. </p>
<h2 id="当-forEach-需要索引"><a href="#当-forEach-需要索引" class="headerlink" title="当 forEach 需要索引"></a>当 forEach 需要索引</h2><p>上面的例子通过Java8新增的<code>Map</code>方法可以很<strong>优雅</strong>地实现一些需求: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Map&lt;String, List&lt;Integer&gt;&gt; getElementPositions(List&lt;String&gt; list) &#123;</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; positionsMap = new HashMap&lt;&gt;();</span><br><span class="line">    for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">        positionsMap.computeIfAbsent(list.get(i), k -&gt; new ArrayList&lt;&gt;(1)).add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    return positionsMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是方法里面的<code>for</code>循环似乎让这个方法不太优雅了, Java8中<code>Iterable</code>提供的<code>foreach</code>并不带索引的: </p>
<p><img src="https://cdn.yangbingdong.com/img/java-8-tutorial-extend/java-8-iterable-foreach.png" alt></p>
<p>我们可以自己写一个: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    public static &lt;E&gt; void forEach(</span><br><span class="line">            Iterable&lt;? extends E&gt; elements, BiConsumer&lt;Integer, ? super E&gt; action) &#123;</span><br><span class="line">        Objects.requireNonNull(elements);</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line"></span><br><span class="line">        int index = 0;</span><br><span class="line">        for (E element : elements) &#123;</span><br><span class="line">            action.accept(index++, element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后改造<code>getElementPositions</code>方法: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Map&lt;String, List&lt;Integer&gt;&gt; getElementPositions(List&lt;String&gt; list) &#123;</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; positionsMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Iterables.forEach(list, (index, str) -&gt; &#123;</span><br><span class="line">        positionsMap.computeIfAbsent(str, k -&gt; new ArrayList&lt;&gt;(1)).add(index);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return positionsMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用Lambda代替字符串"><a href="#使用Lambda代替字符串" class="headerlink" title="使用Lambda代替字符串"></a>使用Lambda代替字符串</h2><p>定义接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Fn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">apply</span><span class="params">(T source)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写Entity:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer bar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取<code>Fn</code>的信息的工具类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.beans.Introspector;</span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.SerializedLambda;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reflections</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Reflections</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">fnToFieldName</span><span class="params">(Fn fn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method method = fn.getClass().getDeclaredMethod(<span class="string">"writeReplace"</span>);</span><br><span class="line">            method.setAccessible(Boolean.TRUE);</span><br><span class="line">            SerializedLambda serializedLambda = (SerializedLambda) method.invoke(fn);</span><br><span class="line">            String getter = serializedLambda.getImplMethodName();</span><br><span class="line">            String fieldName = Introspector.decapitalize(getter.replace(<span class="string">"get"</span>, <span class="string">""</span>));</span><br><span class="line">            <span class="keyword">return</span> fieldName;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ReflectiveOperationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FnConverter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convertFnToString</span><span class="params">(Fn&lt;T&gt; fn)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Reflections.fnToFieldName(fn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FnConverter&lt;Foo&gt; fnConverter = <span class="keyword">new</span> FnConverter&lt;&gt;();</span><br><span class="line">        String fieldName = fnConverter.convertFnToString(Foo::getBar);</span><br><span class="line">        System.out.println(<span class="string">"方法名："</span>+fieldName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法名：bar</span><br></pre></td></tr></table></figure>
<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>关于java8的介绍与使用网上有太多太多了, 如<strong><em><a href="https://zhuanlan.zhihu.com/p/27424997" rel="external nofollow noopener noreferrer" target="_blank">java8最佳技巧</a></em></strong>等等…</p>
<p>更加深入理解函数式编程请参考<strong><em><a href="https://github.com/CarpenterLee/JavaLambdaInternals" rel="external nofollow noopener noreferrer" target="_blank">Java Functional Programming Internals</a></em></strong></p>
<blockquote>
<p>参考<br><strong><em><a href="http://blog.didispace.com/books/java8-tutorial/" rel="external nofollow noopener noreferrer" target="_blank">Java8简明教程</a></em></strong><br><strong><em><a href="https://zhuanlan.zhihu.com/java8" rel="external nofollow noopener noreferrer" target="_blank">知乎专栏</a></em></strong><br><strong><em><a href="http://www.cnblogs.com/CarpenterLee/" rel="external nofollow noopener noreferrer" target="_blank">CarpenterLee</a></em></strong><br><strong><em><a href="http://winterbe.com/posts/2014/03/16/java-8-tutorial/" rel="external nofollow noopener noreferrer" target="_blank">http://winterbe.com/posts/2014/03/16/java-8-tutorial/</a></em></strong><br><strong><em><a href="http://brianway.github.io/2017/03/29/javase-java8/#%E6%B5%81stream-api" rel="external nofollow noopener noreferrer" target="_blank">http://brianway.github.io/2017/03/29/javase-java8/#%E6%B5%81stream-api</a></em></strong><br><strong><em><a href="https://segmentfault.com/a/1190000007832130" rel="external nofollow noopener noreferrer" target="_blank">https://segmentfault.com/a/1190000007832130</a></em></strong></p>
</blockquote>
]]></content><categories><category>Programming</category><category>Java</category></categories><tags><tag>Java</tag></tags></entry><entry><title>Java 并发拾遗-并发工具(中)</title><url>/2019/java-concurrent-part3/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/concurrent/java-concurrent-part3-banner2.jpg" alt></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><blockquote>
<p>此篇聊聊 线程安全的容器 以及 JDK 原子类的简单使用.</p>
</blockquote>
<a id="more"></a>
<h1 id="线程安全的容器"><a href="#线程安全的容器" class="headerlink" title="线程安全的容器"></a>线程安全的容器</h1><h2 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h2><p>Java 1.5 之前提供的<strong>同步容器</strong>虽然也能保证线程安全, 但是性能很差. Java 中的容器主要可以分为四个大类, 分别是 <code>List</code>、<code>Map</code>、<code>Set</code> 和 <code>Queue</code>, 但并不是所有的 Java 容器都是线程安全的. 例如, 我们常用的 <code>ArrayList</code>、<code>HashMap</code> 就不是线程安全的. </p>
<p>那么如何将非线程安全的容器变成线程安全的容器? 之前说过, 只要把<strong>非线程安全的容器封装在对象内部</strong>, 然后控制好访问路径就可以了. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SafeArrayList&lt;T&gt;&#123;</span><br><span class="line">  <span class="comment">//封装ArrayList</span></span><br><span class="line">  List&lt;T&gt; c = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">//控制访问路径</span></span><br><span class="line">  <span class="keyword">synchronized</span></span><br><span class="line">  <span class="function">T <span class="title">get</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c.get(idx);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> idx, T t)</span> </span>&#123;</span><br><span class="line">    c.add(idx, t);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">addIfNotExist</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!c.contains(t)) &#123;</span><br><span class="line">      c.add(t);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK 的 <code>Collections</code> 这个类中还提供了一套完备的包装类, 比如下面的示例代码中, 分别把 <code>ArrayList</code>、<code>HashSet</code> 和 <code>HashMap</code> 包装成了线程安全的 <code>List</code>、<code>Set</code> 和 <code>Map</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = Collections.</span><br><span class="line">  synchronizedList(<span class="keyword">new</span> ArrayList());</span><br><span class="line">Set set = Collections.</span><br><span class="line">  synchronizedSet(<span class="keyword">new</span> HashSet());</span><br><span class="line">Map map = Collections.</span><br><span class="line">  synchronizedMap(<span class="keyword">new</span> HashMap());</span><br></pre></td></tr></table></figure>
<p>组合操作需要注意<strong>竞态条件问题</strong>, 例如上面提到的 <code>addIfNotExist()</code> 方法就包含组合操作. 组合操作往往隐藏着<strong>竞态条件</strong>问题, 即便每个操作都能保证原子性, 也并不能保证组合操作的原子性, 这个一定要注意. </p>
<p>在容器领域一个<strong>容易被忽视的“坑”是用迭代器遍历容器</strong>, 例如在下面的代码中, 通过迭代器遍历容器 list, 对每个元素调用 <code>foo()</code> 方法, 这就存在并发问题, 这些组合的操作不具备原子性:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = Collections.</span><br><span class="line">  synchronizedList(<span class="keyword">new</span> ArrayList());</span><br><span class="line">Iterator i = list.iterator(); </span><br><span class="line"><span class="keyword">while</span> (i.hasNext())</span><br><span class="line">  foo(i.next());</span><br></pre></td></tr></table></figure>
<p>正确的写法应该是这样:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = Collections.</span><br><span class="line">  synchronizedList(<span class="keyword">new</span> ArrayList());</span><br><span class="line">Iterator i = list.iterator(); </span><br><span class="line"><span class="keyword">while</span> (i.hasNext())</span><br><span class="line">  foo(i.next());</span><br></pre></td></tr></table></figure>
<p>上面提到的这些经过包装后线程安全容器, 都是<strong>基于 <code>synchronized</code> 这个同步关键字实现</strong>的, 所以也被称为<strong>同步容器</strong>. Java 提供的同步容器还有 <code>Vector</code>、<code>Stack</code> 和 <code>Hashtable</code>, 这三个容器不是基于包装类实现的, 但同样是基于 <code>synchronized</code> 实现的, 对这三个容器的遍历, 同样要加锁保证互斥. </p>
<h2 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h2><p>上面提到的同步容器都是基于 <code>synchronized</code> 来实现的, 因此性能不高, 因此 Java 在 1.5 及之后版本提供了性能更高的容器, 我们一般称为并发容器. </p>
<p><img src="https://cdn.yangbingdong.com/img/concurrent/java-concurrent-container01.png" alt></p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List 里面只有一个实现类就是 <code>CopyOnWriteArrayList</code>. CopyOnWrite, 顾名思义就是写的时候会将共享变量新复制一份出来, 这样做的好处是读操作完全无锁. </p>
<p>如果在遍历 <code>CopyOnWriteArrayList</code> 的同时, 还有一个写操作, <code>CopyOnWriteArrayList</code> 会将 array 复制一份, 然后在新复制处理的数组上执行增加元素的操作, 执行完之后再将 array 指向这个新的数组. 读写是可以并行的, 遍历操作一直都是基于原 array 执行, 而写操作则是基于新 array 进行:</p>
<p><img src="https://cdn.yangbingdong.com/img/concurrent/java-concurrent-copyonwritelist.png" alt></p>
<p>使用 <code>CopyOnWriteArrayList</code> 需要注意的“坑”主要有两个方面. </p>
<ul>
<li>一个是应用场景, <code>CopyOnWriteArrayList</code> 仅适用于写操作非常少的场景, 而且能够容忍读写的短暂不一致. 例如上面的例子中, 写入的新元素并不能立刻被遍历到;</li>
<li>另一个需要注意的是, <code>CopyOnWriteArrayList</code> 迭代器是只读的, 不支持增删改. 因为迭代器遍历的仅仅是一个快照, 而<strong>对快照进行增删改是没有意义的</strong>.</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map 接口的两个实现是 <code>ConcurrentHashMap</code> 和 <code>ConcurrentSkipListMap</code>, 它们从应用的角度来看, 主要区别在于 <code>ConcurrentHashMap</code> 的 key 是<strong>无序</strong>的, 而 <code>ConcurrentSkipListMap</code> 的 key 是<strong>有序</strong>的, 就像 <code>HashMap</code> 与 <code>TreeMap</code> 一样.</p>
<p>使用 <code>ConcurrentHashMap</code> 和 <code>ConcurrentSkipListMap</code> 需要注意的地方是, 它们的 key 和 value 都不能为空, 否则会抛出 <code>NullPointerException</code> 这个运行时异常, 因为在多线程环境下, 调用 <code>get(KEY)</code> 拿到的 null 值无法判断是设置进去的 null 还是被别的线程删除了.</p>
<p><img src="https://cdn.yangbingdong.com/img/concurrent/java-concurrent-map.png" alt></p>
<p><code>ConcurrentSkipListMap</code> 里面的 <code>SkipList</code> 本身就是一种数据结构, 中文一般都翻译为“跳表”, 以空间换时间. 跳表插入、删除、查询操作平均的时间复杂度是 <code>O(log n)</code>, 理论上和并发线程数没有关系, 所以在并发度非常高的情况下, 若对 <code>ConcurrentHashMap</code> 的性能还不满意, 可以尝试一下 <code>ConcurrentSkipListMap</code>. </p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set 接口的两个实现是 <code>CopyOnWriteArraySet</code> 和 <code>ConcurrentSkipListSet</code>, 使用场景可以参考前面讲述的 <code>CopyOnWriteArrayList</code> 和 <code>ConcurrentSkipListMap</code>, 它们的原理都是一样的, 这里就不再赘述了. </p>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>Java 并发包里面 Queue 这类并发容器是最复杂的, 你可以从以下两个维度来分类. 一个维度是<strong>阻塞与非阻塞</strong>, 所谓阻塞指的是当队列已满时, 入队操作阻塞; 当队列已空时, 出队操作阻塞. 另一个维度是<strong>单端与双端</strong>, 单端指的是只能队尾入队, 队首出队; 而双端指的是队首队尾皆可入队出队. Java 并发包里<strong>阻塞队列都用 Blocking 关键字标识, 单端队列使用 Queue 标识, 双端队列使用 Deque 标识</strong>. </p>
<p>这两个维度组合后, 可以将 Queue 细分为四大类, 分别是: </p>
<p>第一, <strong>单端阻塞队列</strong>: 其实现有 <code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code>、<code>SynchronousQueue</code>、<code>LinkedTransferQueue</code>、<code>PriorityBlockingQueue</code> 和 <code>DelayQueue</code>. 内部一般会持有一个队列, 这个队列可以是数组(其实现是 <code>ArrayBlockingQueue</code>)也可以是链表(其实现是 <code>LinkedBlockingQueue</code>); 甚至还可以不持有队列(其实现是 <code>SynchronousQueue</code>), 此时生产者线程的入队操作必须等待消费者线程的出队操作. 而 <code>LinkedTransferQueue</code> 融合 <code>LinkedBlockingQueue</code> 和 <code>SynchronousQueue</code> 的功能, 性能比 <code>LinkedBlockingQueue</code> 更好; <code>PriorityBlockingQueue</code> 支持按照优先级出队; <code>DelayQueue</code> 支持延时出队. </p>
<p><img src="https://cdn.yangbingdong.com/img/concurrent/java-concurrent-queue01.png" alt></p>
<p>第二, <strong>双端阻塞队列</strong>: 其实现是 <code>LinkedBlockingDeque</code>. </p>
<p><img src="https://cdn.yangbingdong.com/img/concurrent/java-concurrent-queue02.png" alt></p>
<p>第三, <strong>单端非阻塞队列</strong>: 其实现是 <code>ConcurrentLinkedQueue</code>. </p>
<p>第四, <strong>双端非阻塞队列</strong>: 其实现是 <code>ConcurrentLinkedDeque</code>. </p>
<p>另外, 使用队列时, 需要格外注意队列是否支持<strong>有界</strong>(所谓有界指的是内部的队列是否有容量限制). 实际工作中, 一般都不建议使用无界的队列, 因为数据量大了之后很容易<strong>导致 OOM</strong>. 上面我们提到的这些 Queue 中, 只有 ArrayBlockingQueue 和 LinkedBlockingQueue 是支持有界的, <strong>所以在使用其他无界队列时, 一定要充分考虑是否存在导致 OOM 的隐患. </strong></p>
<h1 id="原子类-无锁工具类的典范"><a href="#原子类-无锁工具类的典范" class="headerlink" title="原子类: 无锁工具类的典范"></a>原子类: 无锁工具类的典范</h1><p>对于一些需要并发累加的操作, 现在我们也许第一时间想到的是 Atomic 相关的类比如 <code>AtomicLong</code> 等, 这些类使用 CAS指令(Compare And Swap, 即”比较并交换”) 实现<strong>无锁</strong>的<strong>高性能</strong>操作, 并且作为一条 CPU 指令, CAS 指令本身是能够保证<strong>原子性</strong>的. </p>
<p>CAS 指令包含 3 个参数: 共享变量的内存地址 A、用于比较的值 B 和共享变量的新值 C; 并且只有当内存中地址 A 处的值等于 B 时, 才能将内存中地址 A 处的值更新为新值 C. </p>
<p>Java SDK 并发包里提供的原子类内容很丰富, 我们可以将它们分为五个类别: <strong>原子化的基本数据类型</strong>、<strong>原子化的对象引用类型</strong>、<strong>原子化数组</strong>、<strong>原子化对象属性更新器</strong>和<strong>原子化的累加器</strong>. </p>
<p><img src="https://cdn.yangbingdong.com/img/concurrent/java-concurrent-atomic-family.png" alt></p>
<h2 id="原子化的基本数据类型"><a href="#原子化的基本数据类型" class="headerlink" title="原子化的基本数据类型"></a>原子化的基本数据类型</h2><p>相关实现有 <code>AtomicBoolean</code>、<code>AtomicInteger</code> 和 <code>AtomicLong</code>, 提供的方法主要有以下这些:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getAndIncrement() <span class="comment">//原子化i++</span></span><br><span class="line">getAndDecrement() <span class="comment">//原子化的i--</span></span><br><span class="line">incrementAndGet() <span class="comment">//原子化的++i</span></span><br><span class="line">decrementAndGet() <span class="comment">//原子化的--i</span></span><br><span class="line"><span class="comment">//当前值+=delta, 返回+=前的值</span></span><br><span class="line">getAndAdd(delta) </span><br><span class="line"><span class="comment">//当前值+=delta, 返回+=后的值</span></span><br><span class="line">addAndGet(delta)</span><br><span class="line"><span class="comment">//CAS操作, 返回是否成功</span></span><br><span class="line">compareAndSet(expect, update)</span><br><span class="line"><span class="comment">//以下四个方法</span></span><br><span class="line"><span class="comment">//新值可以通过传入func函数来计算</span></span><br><span class="line">getAndUpdate(func)</span><br><span class="line">updateAndGet(func)</span><br><span class="line">getAndAccumulate(x,func)</span><br><span class="line">accumulateAndGet(x,func)</span><br></pre></td></tr></table></figure>
<h2 id="原子化的对象引用类型"><a href="#原子化的对象引用类型" class="headerlink" title="原子化的对象引用类型"></a>原子化的对象引用类型</h2><p>相关实现有 <code>AtomicReference</code>、<code>AtomicStampedReference</code> 和 <code>AtomicMarkableReference</code>, 利用它们可以实现<strong>对象引用的原子化更新</strong>. <code>AtomicReference</code> 提供的方法和原子化的基本数据类型差不多, 这里不再赘述. 不过需要注意的是, 对象引用的更新需要重点关注 <strong>ABA 问题</strong>, <code>AtomicStampedReference</code> 和 <code>AtomicMarkableReference</code> 这两个原子类可以解决 ABA 问题. </p>
<p>解决 ABA 问题的思路其实很简单, 增加一个版本号维度就可以了, 每次执行 CAS 操作, 附加再更新一个版本号, 只要保证版本号是递增的, 那么即便 A 变成 B 之后再变回 A, 版本号也不会变回来(版本号递增的). <code>AtomicStampedReference</code> 实现的 CAS 方法就增加了版本号参数, 方法签名如下: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  V expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">  V newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> newStamp)</span></span></span><br></pre></td></tr></table></figure>
<p><code>AtomicMarkableReference</code> 的实现机制则更简单, 将版本号简化成了一个 <code>Boolean</code> 值, 方法签名如下: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  V expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">  V newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">boolean</span> expectedMark,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">boolean</span> newMark)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="原子化数组"><a href="#原子化数组" class="headerlink" title="原子化数组"></a>原子化数组</h2><p>相关实现有 <code>AtomicIntegerArray</code>、<code>AtomicLongArray</code> 和 <code>AtomicReferenceArray</code>, 利用这些原子类, 我们可以原子化地更新数组里面的每一个元素. 这些类提供的方法和原子化的基本数据类型的区别仅仅是: 每个方法多了一个数组的索引参数, 所以这里也不再赘述了. </p>
<h2 id="原子化对象属性更新器"><a href="#原子化对象属性更新器" class="headerlink" title="原子化对象属性更新器"></a>原子化对象属性更新器</h2><p>相关实现有 <code>AtomicIntegerFieldUpdater</code>、<code>AtomicLongFieldUpdater</code> 和 <code>AtomicReferenceFieldUpdater</code>, 利用它们可以原子化地更新对象的属性, 这三个方法都是利用反射机制实现的, 创建更新器的方法如下: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt;</span><br><span class="line">AtomicXXXFieldUpdater&lt;U&gt; </span><br><span class="line">newUpdater(Class&lt;U&gt; tclass, </span><br><span class="line">  String fieldName)</span><br></pre></td></tr></table></figure>
<p>需要注意的是, <strong>对象属性必须是 <code>volatile</code> 类型的, 只有这样才能保证可见性</strong>; 如果对象属性不是 <code>volatile</code> 类型的, <code>newUpdater()</code> 方法会抛出 <code>IllegalArgumentException</code> 这个运行时异常. </p>
<p>你会发现 <code>newUpdater()</code> 的方法参数只有类的信息, 没有对象的引用, 而更新对象的属性, 一定需要对象的引用, 那这个参数是在哪里传入的呢? 是在原子操作的方法参数中传入的. 例如 <code>compareAndSet()</code> 这个原子操作, 相比原子化的基本数据类型多了一个对象引用 obj. 原子化对象属性更新器相关的方法, 相比原子化的基本数据类型仅仅是多了对象引用参数, 所以这里也不再赘述了. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  T obj, </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> expect, </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> update)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="原子化的累加器"><a href="#原子化的累加器" class="headerlink" title="原子化的累加器"></a>原子化的累加器</h2><p><code>DoubleAccumulator</code>、<code>DoubleAdder</code>、<code>LongAccumulator</code> 和 <code>LongAdder</code>, 这四个类仅仅用来执行累加操作, 相比原子化的基本数据类型, 速度更快, 但是不支持 <code>compareAndSet()</code> 方法. 如果你仅仅需要累加操作, 使用原子化的累加器性能会更好. </p>
]]></content><categories><category>Programming</category><category>Java</category><category>Concurrent</category></categories><tags><tag>Java</tag><tag>Concurrent</tag></tags></entry><entry><title>Java 并发拾遗-并发理论基础</title><url>/2019/java-concurrent-part1/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/concurrent/java-concurrnt-part1-banner.jpeg" alt></p>
<blockquote>
<p>时代在进步, 硬件也在进步, 为了提高 CPU 以及 IO 的利用率, 并发编程已经慢慢成为一项必备技能. 过往总对并发编程感到恐惧, 应为对其的陌生导致了编码方面的困难以及诸多的 BUG, 学习并发编程, 一定需要有一个系统性的学习过程.</p>
</blockquote>
<a id="more"></a>
<p>并发编程可以总结为三个核心问题: <strong>分工</strong>、<strong>同步</strong>、<strong>互斥</strong>. </p>
<p>所谓分工指的是如何高效地拆解任务并分配给线程, 而同步指的是线程之间如何协作, 互斥则是保证同一时刻只允许一个线程访问共享资源. </p>
<ul>
<li><p>分工 -&gt; <code>Executor</code>、<code>Fork/Join</code>、<code>Future</code>等</p>
</li>
<li><p>同步(核心技术是<strong>管程</strong>) -&gt; <code>CountDownLatch</code>、<code>CyclicBarrier</code>、<code>Phaser</code>、<code>Exchanger</code> 等</p>
</li>
<li><p>互斥(线程安全) -&gt; <code>synchronized</code>、<code>ReadWriteLock</code>、<code>StampedLock</code>、<code>ThreadLocal</code> 等</p>
</li>
</ul>
<p><img src="https://cdn.yangbingdong.com/img/concurrent/java-concurrent-generalization.png" alt></p>
<h1 id="并发编程Bug的源头"><a href="#并发编程Bug的源头" class="headerlink" title="并发编程Bug的源头"></a>并发编程Bug的源头</h1><p>现代CPU, 内存以及硬盘之间的速度差了个天跟地, 为了弥补短板, 计算机体系以及操作系统作出了重大贡献:</p>
<ul>
<li>CPU 增加了缓存, 以均衡与内存的速度差异; </li>
<li>操作系统增加了进程、线程, 以分时复用 CPU, 进而均衡 CPU 与 I/O 设备的速度差异; </li>
<li>编译程序优化指令执行次序, 使得缓存能够得到更加合理地利用. </li>
</ul>
<p><strong>源头之一: 缓存导致的可见性问题</strong>.</p>
<p>两核两个线程同时对变量i进行10000次+1操作, 但结果并不是20000, 而是小于20000. 因为CPU-A加完后的结果对CPU-B并不是马上可见的.</p>
<p><strong>源头之二: 线程切换带来的原子性问题.</strong></p>
<p>执行count += 1, 至少需要三条 CPU 指令:</p>
<ul>
<li>指令 1: 首先, 需要把变量 count 从内存加载到 CPU 的寄存器; </li>
<li>指令 2: 之后, 在寄存器中执行 +1 操作; </li>
<li>指令 3: 最后, 将结果写入内存(缓存机制导致可能写入的是 CPU 缓存而不是内存). </li>
</ul>
<p>有可能执行到指令1就发生了线程切换, 导致执行结果不符合预期.</p>
<p>操作系统做任务切换, 可以发生在<strong>任何一条CPU 指令</strong>执行完, 是的, 是 CPU 指令, 而不是高级语言里的一条语句CPU , 能保证的原子操作是 CPU 指令级别的. </p>
<p><strong>源头之三: 编译优化带来的有序性问题</strong>.</p>
<p>编译器为了优化性能, 有时候会改变程序中语句的先后顺序, 例如程序中: “a=6; b=7; “编译器优化后可能变成”b=7; a=6; “, 在这个例子中, 编译器调整了语句的顺序, 但是不影响程序的最终结果. </p>
<p>在 Java 领域一个经典的案例就是利用双重检查创建单例对象:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键点在 new 上面:</p>
<ol>
<li>分配一块内存 M; </li>
<li>在内存 M 上初始化 Singleton 对象; </li>
<li>然后 M 的地址赋值给 instance 变量. </li>
</ol>
<p>但是实际上优化后的执行路径却是这样的: </p>
<ol>
<li>分配一块内存 M; </li>
<li>将 M 的地址赋值给 instance 变量; </li>
<li>最后在内存 M 上初始化 Singleton 对象. </li>
</ol>
<h1 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h1><p>上面说到了并发编程 Bug 源头的其中两个就是可见性与有序性, 那么解决这两个问题最直接的办法就是<strong>禁用缓存和编译优化</strong>.</p>
<p>Java 内存模型通过定义多项规则对编译器和处理器进行限制, 主要是针对可见性和有序性. 这是个很复杂的规范, 可以从不同的视角来解读, 站在我们这些程序员的视角, 本质上可以理解为, Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法. 具体来说, 这些方法包括 <code>volatile</code>、<code>synchronized</code> 和 <code>final</code> 三个关键字, 以及 <strong>Happens-Before</strong> 规则. </p>
<p>先来看一段代码(假设线程A调用writer, 线程B调用reader方法):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">boolean</span> v = <span class="keyword">false</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x = <span class="number">42</span>;</span><br><span class="line">    v = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">// 这里x会是多少呢？</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Happens-Before 的几条规则:</p>
<ul>
<li>程序的顺序性规则: 在一个线程内, 按照程序代码顺序, 书写在前面的操作先行发生于书写在后面的操作. 准确地说, 应该是控制流顺序而不是程序代码顺序, 因为要考虑分支、循环等结构. </li>
<li>volatile 变量规则: 如果 A Happens-Before B, 且 B Happens-Before C, 那么 A Happens-Before C. </li>
<li>管程中锁的规则(<strong>管程</strong>是一种通用的同步原语, 在 Java 中指的就是 synchronized, synchronized 是 Java 里对管程的实现): 对一个锁的解锁 Happens-Before 于后续对这个锁的加锁. </li>
<li>线程 <code>start()</code> 规则: 主线程 A 启动子线程 B 后, 子线程 B 能够看到主线程在启动子线程 B 前的操作. </li>
<li>线程 <code>join()</code> 规则: 主线程 A 等待子线程 B 完成(主线程 A 通过调用子线程 B 的 <code>join()</code> 方法实现), 当子线程 B 完成后(主线程 A 中 <code>join()</code> 方法返回), 主线程能够看到子线程的操作. 当然所谓的”看到”, 指的是对共享变量的操作. </li>
<li>线程中断规则: 对线程 <code>interrupt()</code> 方法的调用先行发生于被中断线程的代码检测到中断事件的发生, 可以通过 <code>Thread.interrupted()</code> 方法检测到是否有中断发生. </li>
<li>对象终结规则: 一个对象的初始化完成(构造函数执行结束)先行发生于它的 <code>finalize()</code> 方法的开始. </li>
</ul>
<h1 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h1><blockquote>
<p><strong>锁, 应是私有的、不可变的、不可重用的.</strong></p>
</blockquote>
<p>原子性问题的源头是<strong>线程切换</strong>, 在单核时代, 可以通过禁用线程切换做到, 但并不适合多核 CPU.</p>
<p>32 位 CPU 上执行 long 型变量的写操作, long 型变量是 64 位, 在 32 位 CPU 上执行写操作会被拆分成两次写操作, 单核 CPU 可以通过禁止 CPU 中断保证原子性. 但在多核 CPU 上, 此时禁止 CPU 中断, 只能保证 CPU 上的线程连续执行, 并不能保证同一时刻只有一个线程执行.</p>
<p>互斥是为了<strong>同一时刻只有一个线程执行</strong>, 保证原子性. 如果我们能够保证对共享变量的修改是互斥的, 那么, 无论是单核 CPU 还是多核 CPU, 就都能保证原子性了. </p>
<p>Java 中通过 <code>synchronized</code> 关键字提供锁技术.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 修饰非静态方法</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 修饰静态方法</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 修饰代码块</span></span><br><span class="line">  Object obj = <span class="keyword">new</span> Object(); </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">baz</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">      <span class="comment">// 临界区</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.yangbingdong.com/img/concurrent/java-sync-lock-module.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line">  <span class="comment">// 转账</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Account target, <span class="keyword">int</span> amt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt) &#123;</span><br><span class="line">      <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">      target.balance += amt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码只能对 <code>this.balance</code> 进行临界保护, 但 <code>target.balance</code> 可能会出现并发问题. 可采取使用同一个锁(在构造函数中传入)或者直接将 <code>Account.class</code> 作为锁对象(性能慢).</p>
<p><strong>一个合理的受保护资源与锁之间的关联关系应该是 N:1</strong>.</p>
<h2 id="错误的加锁方式"><a href="#错误的加锁方式" class="headerlink" title="错误的加锁方式"></a>错误的加锁方式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeCalc</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">new</span> Object()) &#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">new</span> Object()) &#123;</span><br><span class="line">      value += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的 <code>synchronized (new Object())</code> 代码, 每次加锁都是不同的锁, 相当于无锁, JVM 开启逃逸分析之后, <code>synchronized (new Object())</code> 这行代码在实际执行的时候会被优化掉, 也就是说在真实执行的时候, 这行代码压根就不存在.  </p>
<p>再来看一段代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 账户余额  </span></span><br><span class="line">  <span class="keyword">private</span> Integer balance;</span><br><span class="line">  <span class="comment">// 账户密码</span></span><br><span class="line">  <span class="keyword">private</span> String password;</span><br><span class="line">  <span class="comment">// 取款</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(balance) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt)&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 更改密码</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">updatePassword</span><span class="params">(String pw)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(password) &#123;</span><br><span class="line">      <span class="keyword">this</span>.password = pw;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码有两个核心问题:</p>
<ul>
<li><code>balance</code> 以及 <code>password</code> 是可变的, 一变化就是去了互斥的功能.</li>
<li>Integer 以及 String 都是可能被重用, 如果别的代码锁住没有释放的完了.</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>上面提到的同步方案中将 <code>Account.class</code> 作为所对象, 相当于串行化了, 性能大打折扣, 为了取得更高的性能, 可以采用细粒度锁, 使用细粒度锁可以提高并行度, 是性能优化的一个重要手段.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line">  <span class="comment">// 转账</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account target, <span class="keyword">int</span> amt)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 锁定转出账户</span></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;              </span><br><span class="line">      <span class="comment">// 锁定转入账户</span></span><br><span class="line">      <span class="keyword">synchronized</span>(target) &#123;           </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt) &#123;</span><br><span class="line">          <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">          target.balance += amt;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码会出现死锁, 如果两个线程分别调用 Account-A 以及 Account-B 转账操作, 会出现相互等待的情况.</p>
<p><img src="https://cdn.yangbingdong.com/img/concurrent/java-sync-dead-lock.png" alt></p>
<p>只有以下这四个条件都发生时才会出现死锁: </p>
<ol>
<li>互斥, 共享资源 X 和 Y 只能被一个线程占用; </li>
<li>占有且等待, 线程 T1 已经取得共享资源 X, 在等待共享资源 Y 的时候, 不释放共享资源 X; </li>
<li>不可抢占, 其他线程不能强行抢占线程 T1 占有的资源; </li>
<li>循环等待, 线程 T1 等待线程 T2 占有的资源, 线程 T2 等待线程 T1 占有的资源, 就是循环等待. </li>
</ol>
<p><strong>只要破坏其中一个, 就可以成功避免死锁的发生. </strong></p>
<p>其中互斥不能破坏, 其他三个都是可破坏的.</p>
<ol>
<li><p>对于”占用且等待”, 我们可以一次性申请所有的资源. </p>
</li>
<li><p>对于”不可抢占”这个条件, 占用部分资源的线程进一步申请其他资源时, 如果申请不到, 可以主动释放它占有的资源.</p>
</li>
<li><p>对于”循环等待”这个条件, 可以靠按序申请资源来预防(加锁顺序一直). </p>
</li>
</ol>
<p>对于破坏占用且等待条件(增加一个管理员, 只有同时拿到两个资源才能执行转账操作):</p>
<p><img src="https://cdn.yangbingdong.com/img/concurrent/java-break-dead-lock.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Object&gt; als =</span><br><span class="line">    <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">// 一次性申请所有资源</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Object from, Object to)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(als.contains(from) ||</span><br><span class="line">         als.contains(to))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      als.add(from);</span><br><span class="line">      als.add(to);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 归还资源</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Object from, Object to)</span></span>&#123;</span><br><span class="line">    als.remove(from);</span><br><span class="line">    als.remove(to);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="comment">// actr应该为单例</span></span><br><span class="line">  <span class="keyword">private</span> Allocator actr;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line">  <span class="comment">// 转账</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account target, <span class="keyword">int</span> amt)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 一次性申请转出账户和转入账户, 直到成功</span></span><br><span class="line">    <span class="keyword">while</span>(!actr.apply(<span class="keyword">this</span>, target))</span><br><span class="line">      ; </span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="comment">// 锁定转出账户</span></span><br><span class="line">      <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;              </span><br><span class="line">        <span class="comment">// 锁定转入账户</span></span><br><span class="line">        <span class="keyword">synchronized</span>(target)&#123;           </span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt)&#123;</span><br><span class="line">            <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">            target.balance += amt;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      actr.free(<span class="keyword">this</span>, target)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="等待-通知"><a href="#等待-通知" class="headerlink" title="等待-通知"></a>等待-通知</h1><p>在上面<strong>破坏占用且等待条件</strong>的时候, 使用了死循环的方式来循环等待, 核心代码如下: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一次性申请转出账户和转入账户, 直到成功</span></span><br><span class="line"><span class="keyword">while</span>(!actr.apply(<span class="keyword">this</span>, target))</span><br><span class="line">  ;</span><br></pre></td></tr></table></figure>
<p>这种写法太消耗性能, 比较好的做法就是不满足条件, 则等待, 满足后, 同时等待的线程重新执行.</p>
<p>类比(就医流程): </p>
<ol>
<li>患者先去挂号, 然后到就诊门口分诊, 等待叫号; </li>
<li>当叫到自己的号时, 患者就可以找大夫就诊了; </li>
<li>就诊过程中, 大夫可能会让患者去做检查, 同时叫下一位患者; </li>
<li>当患者做完检查后, 拿检测报告重新分诊, 等待叫号; </li>
<li>当大夫再次叫到自己的号时, 患者再去找大夫就诊. </li>
</ol>
<p>在 Java 语言里, 等待 - 通知机制可以有多种实现方式, 比如 Java 语言内置的 <code>synchronized</code> 配合 <code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code> 这三个方法就能轻松实现. </p>
<p><img src="https://cdn.yangbingdong.com/img/concurrent/java-break-dead-lock02.png" alt></p>
<p>这个等待队列和互斥锁是一对一的关系, 每个互斥锁都有自己独立的等待队列. </p>
<p><code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code> 都是在 <code>synchronized{}</code>内部被调用的. 如果在 <code>synchronized{}</code>外部调用, 或者锁定的 <code>this</code>, 而用 <code>target.wait()</code> 调用的话, JVM 会抛出一个运行时异常: <code>java.lang.IllegalMonitorStateException</code>. </p>
<p>将之前的 <code>Allocator</code> 改造一下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Object&gt; als;</span><br><span class="line">  <span class="comment">// 一次性申请所有资源</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Object from, Object to)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 经典写法</span></span><br><span class="line">    <span class="keyword">while</span>(als.contains(from) ||</span><br><span class="line">         als.contains(to))&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        wait();</span><br><span class="line">      &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">      &#125;   </span><br><span class="line">    &#125; </span><br><span class="line">    als.add(from);</span><br><span class="line">    als.add(to);  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 归还资源</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Object from, Object to)</span></span>&#123;</span><br><span class="line">    als.remove(from);</span><br><span class="line">    als.remove(to);</span><br><span class="line">    notifyAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>wait与sleep区别在于: </p>
<ol>
<li>wait会释放所有锁而sleep不会释放锁资源.</li>
<li>wait只能在同步方法和同步块中使用, 而sleep任何地方都可以.</li>
<li>wait无需捕捉异常, 而sleep需要.</li>
<li>sleep是Thread的方法, 而wait是Object类的方法.</li>
</ol>
<p>两者相同点: 都会让渡CPU执行时间, 等待再次调度！</p>
<h1 id="安全性、活跃性以及性能问题"><a href="#安全性、活跃性以及性能问题" class="headerlink" title="安全性、活跃性以及性能问题"></a>安全性、活跃性以及性能问题</h1><p><strong>安全性</strong>: </p>
<ul>
<li>数据竞争:  多个线程同时访问一个数据, 并且至少有一个线程会写这个数据. </li>
<li>竞态条件:  程序的执行结果依赖程序执行的顺序. </li>
</ul>
<p><strong>活跃性</strong>: </p>
<ul>
<li>死锁: 破坏造成死锁的条件, <ol>
<li>使用等待-通知机制的Allocator; </li>
<li>主动释放占有的资源; </li>
<li>按顺序获取资源. </li>
</ol>
</li>
<li>活锁: 虽然没有发生阻塞, 但仍会存在执行不下去的情况(两个线程相互谦让). 解决办法, 等待随机的时间, 例如Raft算法中重新选举leader. </li>
<li>饥饿: 我想到了没有引入时间片概念时, cpu处理作业. 如果遇到长作业, 会导致短作业饥饿. 如果优先处理短作业, 则会饿死长作业. 长作业就可以类比持有锁的时间过长, 而时间片可以让cpu资源公平地分配给各个作业. 当然, 如果有无穷多的cpu, 就可以让每个作业得以执行, 就不存在饥饿了. </li>
</ul>
<p><strong>性能</strong>: </p>
<p>核心就是在保证安全性和活跃性的前提下, 根据实际情况, 尽量降低锁的粒度. 即尽量减少持有锁的时间. JDK的并发包里, 有很多特定场景针对并发性能的设计. 还有很多无锁化的设计, 例如MVCC, TLS, COW等, 可以根据不同的场景选用不同的数据结构或设计. </p>
<p><strong>并发编程是一个复杂的技术领域, 微观上涉及到原子性问题、可见性问题和有序性问题, 宏观则表现为安全性、活跃性以及性能问题. </strong></p>
<h1 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h1><p>管程是一种<strong>概念</strong>, 任何语言都可以通用, 对应的英文是 Monitor, 很多 Javaer 都喜欢将其翻译成”监视器”, 这是直译. </p>
<p>所谓管程, 指的是<strong>管理共享变量以及对共享变量的操作过程</strong>, 让他们支持并发. </p>
<p>在管程的发展史上, 先后出现过三种不同的管程模型, 分别是: Hasen 模型、Hoare 模型和 MESA 模型. 其中, 现在广泛应用的是 MESA 模型, 并且 Java 管程的实现参考的也是 MESA 模型. </p>
<p><img src="https://cdn.yangbingdong.com/img/concurrent/monitor-module01.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockedQueue</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Lock lock =</span><br><span class="line">    <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="comment">// 条件变量: 队列不满  </span></span><br><span class="line">  <span class="keyword">final</span> Condition notFull =</span><br><span class="line">    lock.newCondition();</span><br><span class="line">  <span class="comment">// 条件变量: 队列不空  </span></span><br><span class="line">  <span class="keyword">final</span> Condition notEmpty =</span><br><span class="line">    lock.newCondition();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入队</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">enq</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (队列已满)&#123;</span><br><span class="line">        <span class="comment">// 等待队列不满 </span></span><br><span class="line">        notFull.await();</span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="comment">// 省略入队操作...</span></span><br><span class="line">      <span class="comment">//入队后,通知可出队</span></span><br><span class="line">      notEmpty.signal();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 出队</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deq</span><span class="params">()</span></span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (队列已空)&#123;</span><br><span class="line">        <span class="comment">// 等待队列不空</span></span><br><span class="line">        notEmpty.await();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 省略出队操作...</span></span><br><span class="line">      <span class="comment">//出队后, 通知可入队</span></span><br><span class="line">      notFull.signal();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Java-线程"><a href="#Java-线程" class="headerlink" title="Java 线程"></a>Java 线程</h1><p>在 Java 领域, 实现并发程序的主要手段就是多线程. 线程是操作系统里的一个概念, 虽然各种不同的开发语言如 Java、C# 等都对其进行了封装, 但是万变不离操作系统. Java 语言里的线程本质上就是操作系统的线程, 它们是一一对应的. </p>
<p>通用的线程生命周期:</p>
<p><img src="https://cdn.yangbingdong.com/img/concurrent/general-thread-module.png" alt></p>
<p>Java 中线程的生命周期(对应 Thread.State 枚举类):</p>
<p><img src="https://cdn.yangbingdong.com/img/concurrent/java-thread-module.png" alt></p>
<ul>
<li>RUNNABLE 与 BLOCKED 的状态转换: 只有一种场景会触发这种转换, 就是线程等待 synchronized 的隐式锁. </li>
<li>RUNNABLE 与 WAITING 的状态转换(三种场景):<ul>
<li>第一种场景, 获得 <code>synchronized</code> 隐式锁的线程, 调用无参数的 Object.wait() 方法; </li>
<li>第二种场景, 调用无参数的 <code>Thread.join()</code> 方法; </li>
<li>第三种场景, 调用 <code>LockSupport.park()</code> 方法. </li>
</ul>
</li>
<li>RUNNABLE 与 TIMED_WAITING 的状态转换(五种场景):<ul>
<li>调用<strong>带超时参数</strong>的 <code>Thread.sleep(long millis)</code> 方法; </li>
<li>获得 synchronized 隐式锁的线程, 调用<strong>带超时参数</strong>的 <code>Object.wait(long timeout)</code> 方法; </li>
<li>调用<strong>带超时参数</strong>的 <code>Thread.join(long millis)</code> 方法; </li>
<li>调用<strong>带超时参数</strong>的 <code>LockSupport.parkNanos(Object blocker, long deadline)</code> 方法; </li>
<li>调用<strong>带超时参数</strong>的 <code>LockSupport.parkUntil(long deadline)</code> 方法. </li>
</ul>
</li>
<li>从 NEW 到 RUNNABLE 状态: 调用了 <code>Thread.start()</code> 实例方法.</li>
<li>从 RUNNABLE 到 TERMINATED 状态: <ul>
<li><code>run()</code> 方法跑完;</li>
<li>程序异常退出终止;</li>
<li>调用 <code>interrupt()</code> 抛出 throws InterruptedException 异常. </li>
</ul>
</li>
</ul>
<p><strong>stop() 和 interrupt() 方法的主要区别</strong>:</p>
<p><code>stop()</code> 方法会真的<strong>杀死</strong>线程, 不给线程喘息的机会, 如果线程持有 <code>ReentrantLock</code> 锁, 被 <code>stop()</code> 的线程并不会自动调用 <code>ReentrantLock</code> 的 <code>unlock()</code> 去释放锁, 那其他线程就再也没机会获得 <code>ReentrantLock</code> 锁, 这实在是太危险了. 所以该方法就不建议使用了, 类似的方法还有 <code>suspend()</code> 和 <code>resume()</code> 方法, 这两个方法同样也都不建议使用了.</p>
<p>而 interrupt 是一个状态, 当线程 A 处于 WAITING、TIMED_WAITING 状态时, 如果其他线程调用线程 A 的 <code>interrupt()</code> 方法, 会使线程 A 返回到 RUNNABLE 状态, 同时线程 A 的代码会触发 <code>InterruptedException</code> 异常. 上面我们提到转换到 WAITING、TIMED_WAITING 状态的触发条件, 都是调用了类似 <code>wait()</code>、<code>join()</code>、<code>sleep()</code> 这样的方法, 我们看这些方法的签名, 发现都会 <code>throws InterruptedException</code> 这个异常. 这个异常的触发条件就是: 其他线程调用了该线程的 <code>interrupt()</code> 方法. </p>
<h2 id="创建多少线程才合适"><a href="#创建多少线程才合适" class="headerlink" title="创建多少线程才合适"></a>创建多少线程才合适</h2><p>多线程的本质就是提高 CPU 以及 IO 的利用率, 但是对于设置多少线程, 对于不同的场景计算方式不一样.</p>
<p>对于 <strong>CPU 密集型</strong>的计算场景, 理论上”线程的数量 =CPU 核数”就是最合适的. 不过在工程上, 线程的数量一般会设置为”<strong>CPU 核数 +1</strong>“, 这样的话, 当线程因为偶尔的内存页失效或其他原因导致阻塞时, 这个额外的线程可以顶上, 从而保证 CPU 的利用率. </p>
<p>对于 <strong>IO 密集型</strong>的场景, 最佳线程数 = CPU 核数 * [ 1 +(I/O 耗时 / CPU 耗时)].</p>
<h2 id="为什么局部变量是线程安全的"><a href="#为什么局部变量是线程安全的" class="headerlink" title="为什么局部变量是线程安全的"></a>为什么局部变量是线程安全的</h2><p>CPU 去哪里找到调用方法的参数和返回地址: 通过 CPU 的<strong>堆栈寄存器</strong>, CPU 支持一种栈结构, 就像手枪的弹夹, 先入后出. 因为这个栈是和方法调用相关的, 因此经常被称为<strong>调用栈</strong>. </p>
<p>每个方法在调用栈里都有自己的独立空间, 称为<strong>栈帧</strong>, 每个栈帧里都有对应方法需要的参数和返回地址. 当<strong>调用</strong>方法时, 会创建新的栈帧, 并<strong>压入</strong>调用栈; 当方法<strong>返回</strong>时, 对应的栈帧就会被自动<strong>弹出</strong>. 也就是说, <strong>栈帧和方法是同生共死的</strong>. </p>
<p>局部变量的<strong>作用域是方法内部</strong>, 而方法与调用栈共存亡, 所以<strong>局部变量就是放到了调用栈里</strong>.</p>
<p><img src="https://cdn.yangbingdong.com/img/concurrent/method-stack.png" alt></p>
<p><strong>调用栈与线程的关系</strong>: 每个线程都有自己独立的调用栈. 因为每个线程都有自己的调用栈, 局部变量保存在线程各自的调用栈里面, <strong>不会共享</strong>, 所以自然也就没有并发问题. 没有共享, 就没有伤害. </p>
<h1 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h1><blockquote>
<p>参考: <strong><em><a href="https://time.geekbang.org/column/intro/159" rel="external nofollow noopener noreferrer" target="_blank">https://time.geekbang.org/column/intro/159</a></em></strong></p>
</blockquote>
]]></content><categories><category>Programming</category><category>Java</category><category>Concurrent</category></categories><tags><tag>Java</tag><tag>Concurrent</tag></tags></entry><entry><title>Java 并发拾遗-并发工具(下)</title><url>/2019/java-concurrent-part4/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/concurrent/java-concurrent-part4-banner-min.png" alt></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><blockquote>
<p>这一篇关于线程池与Future相关.</p>
</blockquote>
<a id="more"></a>
<h1 id="Executor与线程池"><a href="#Executor与线程池" class="headerlink" title="Executor与线程池"></a>Executor与线程池</h1><p>多线程应用中, 创建线程是必然的, 但是在 Java 中创建一个线程，却需要调用操作系统内核的 API，然后操作系统要为线程分配一系列的资源，这个成本就很高了，所以<strong>线程是一个重量级的对象，应该避免频繁创建和销毁</strong>.</p>
<p>一般采用线程池, 线程池是一种<strong>生产者 - 消费者模式</strong>, 下面是一个简单的线程池模型:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简化的线程池，仅用来说明工作原理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThreadPool</span></span>&#123;</span><br><span class="line">  <span class="comment">//利用阻塞队列实现生产者-消费者模式</span></span><br><span class="line">  BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line">  <span class="comment">//保存内部工作线程</span></span><br><span class="line">  List&lt;WorkerThread&gt; threads </span><br><span class="line">    = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">// 构造方法</span></span><br><span class="line">  MyThreadPool(<span class="keyword">int</span> poolSize, </span><br><span class="line">    BlockingQueue&lt;Runnable&gt; workQueue)&#123;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="comment">// 创建工作线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> idx=<span class="number">0</span>; idx&lt;poolSize; idx++)&#123;</span><br><span class="line">      WorkerThread work = <span class="keyword">new</span> WorkerThread();</span><br><span class="line">      work.start();</span><br><span class="line">      threads.add(work);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 提交任务</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>&#123;</span><br><span class="line">    workQueue.put(command);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 工作线程负责消费任务，并执行任务</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">WorkerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//循环取任务并执行</span></span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>)&#123; ①</span><br><span class="line">        Runnable task = workQueue.take();</span><br><span class="line">        task.run();</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 下面是使用示例 **/</span></span><br><span class="line"><span class="comment">// 创建有界阻塞队列</span></span><br><span class="line">BlockingQueue&lt;Runnable&gt; workQueue = </span><br><span class="line">  <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 创建线程池  </span></span><br><span class="line">MyThreadPool pool = <span class="keyword">new</span> MyThreadPool(</span><br><span class="line">  <span class="number">10</span>, workQueue);</span><br><span class="line"><span class="comment">// 提交任务  </span></span><br><span class="line">pool.execute(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Java 中线程池实现的核心原理也是这样, 当然, 功能更强大也更复杂, Java 提供的线程池相关的工具类中，最核心的是 <code>ThreadPoolExecutor</code>. 来看一下它的构造函数:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor(</span><br><span class="line">  <span class="keyword">int</span> corePoolSize,</span><br><span class="line">  <span class="keyword">int</span> maximumPoolSize,</span><br><span class="line">  <span class="keyword">long</span> keepAliveTime,</span><br><span class="line">  TimeUnit unit,</span><br><span class="line">  BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">  ThreadFactory threadFactory,</span><br><span class="line">  RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>corePoolSize</code>：表示线程池保有的最小线程数。有些项目很闲，但是也不能把人都撤了，至少要留 <code>corePoolSize</code> 个人坚守阵地。</li>
<li><code>maximumPoolSize</code>：表示线程池创建的最大线程数。当项目很忙时，就需要加人，但是也不能无限制地加，最多就加到 <code>maximumPoolSize</code> 个人。当项目闲下来时，就要撤人了，最多能撤到 <code>corePoolSize</code> 个人。</li>
<li><code>keepAliveTime</code> &amp; <code>unit</code>：上面提到项目根据忙闲来增减人员，那在编程世界里，如何定义忙和闲呢？很简单，一个线程如果在一段时间内，都没有执行任务，说明很闲，<code>keepAliveTime</code> 和 <code>unit</code> 就是用来定义这个“一段时间”的参数。也就是说，如果一个线程空闲了<code>keepAliveTime</code> &amp; <code>unit</code> 这么久，而且线程池的线程数大于 <code>corePoolSize</code> ，那么这个空闲的线程就要被回收了。</li>
<li><code>workQueue</code>：工作队列，和上面示例代码的工作队列同义。</li>
<li><code>threadFactory</code>：通过这个参数你可以自定义如何创建线程，例如你可以给线程指定一个有意义的名字。</li>
<li><code>handler</code>：通过这个参数你可以自定义任务的拒绝策略。如果线程池中所有的线程都在忙碌，并且工作队列也满了（前提是工作队列是有界队列），那么此时提交任务，线程池就会拒绝接收。至于拒绝的策略，你可以通过 <code>handler</code> 这个参数来指定。<code>ThreadPoolExecutor</code> 已经提供了以下 4 种策略。<code>CallerRunsPolicy</code>：提交任务的线程自己去执行该任务。<code>AbortPolicy</code>：默认的拒绝策略，会 throws <code>RejectedExecutionException</code>。<code>DiscardPolicy</code>：直接丢弃任务，没有任何异常抛出。<code>DiscardOldestPolicy</code>：丢弃最老的任务，其实就是把最早进入工作队列的任务丢弃，然后把新任务加入到工作队列。</li>
</ul>
<p>Java 在 1.6 版本还增加了 <code>allowCoreThreadTimeOut(boolean value)</code> 方法，它可以让所有线程都支持超时，这意味着如果项目很闲，就会将项目组的成员都撤走。</p>
<p>考虑到 <code>ThreadPoolExecutor</code> 的构造函数实在是有些复杂，所以 Java 并发包里提供了一个线程池的静态工厂类 <code>Executors</code>，利用 <code>Executors</code> 你可以快速创建线程池。不过目前大厂的编码规范中基本上都<strong>不建议使用 <code>Executors</code></strong> 了.</p>
<p>使用 <code>ThreadPoolExecutor</code> 要注意几个问题:</p>
<p>第一, <code>Executors</code> 提供的很多方法默认使用的都是无界的 <code>LinkedBlockingQueue</code>，高负载情境下，<strong>无界队列很容易导致 OOM</strong>，而 OOM 会导致所有请求都无法处理，这是致命问题。所以<strong>强烈建议使用有界队列</strong>。</p>
<p>第二, 使用有界队列，当任务过多时，线程池会触发执行拒绝策略，线程池默认的拒绝策略会 throw <code>RejectedExecutionException</code> 这是个运行时异常，对于运行时异常编译器并不强制 catch 它，所以开发人员很容易忽略。因此<strong>默认拒绝策略要慎重使用</strong>。如果线程池处理的任务非常重要，建议自定义自己的拒绝策略；并且在实际工作中，自定义的拒绝策略往往和降级策略配合使用。</p>
<p>第三, 使用线程池，还要注意<strong>异常处理的问题</strong>，例如通过 <code>ThreadPoolExecutor</code> 对象的 <code>execute()</code> 方法提交任务时，如果任务在执行的过程中出现运行时异常，会导致执行任务的线程终止；不过，最致命的是任务虽然异常了，但是你却获取不到任何通知，这会让你误以为任务都执行得很正常。虽然线程池提供了很多用于异常处理的方法，但是最稳妥和简单的方案还是捕获所有异常并按需处理:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//业务逻辑</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">  <span class="comment">//按需处理</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">  <span class="comment">//按需处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Future与FutureTask"><a href="#Future与FutureTask" class="headerlink" title="Future与FutureTask"></a>Future与FutureTask</h1><p><code>ThreadPoolExecutor</code> 除了 <code>execute()</code> 方法执行任务, 还提供的 3 个 <code>submit()</code> 方法和 1 个 <code>FutureTask</code> 工具类来支持获得任务执行结果的需求:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提交Runnable任务</span></span><br><span class="line">Future&lt;?&gt; </span><br><span class="line">  submit(Runnable task);</span><br><span class="line"><span class="comment">// 提交Callable任务</span></span><br><span class="line">&lt;T&gt; Future&lt;T&gt; </span><br><span class="line">  submit(Callable&lt;T&gt; task);</span><br><span class="line"><span class="comment">// 提交Runnable任务及结果引用  </span></span><br><span class="line">&lt;T&gt; Future&lt;T&gt; </span><br><span class="line">  submit(Runnable task, T result);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>第一个 <code>submit</code> 由于传进去的是 <code>Runnable</code>, 所以返回的 <code>Future</code> 仅可以用来断言任务已经结束了，类似于 Thread.join()。</p>
</li>
<li><p>第二个 <code>submit</code> 返回的 <code>Future</code> 对象可以通过调用其 <code>get()</code> 方法来获取任务的执行结果。</p>
</li>
<li><p>第三个 <code>submit</code>, 这个方法很有意思，假设这个方法返回的 <code>Future</code> 对象是 <code>f</code>，<code>f.get()</code> 的返回值就是传给 <code>submit()</code> 方法的参数 <code>result</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executor </span><br><span class="line">  = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 创建Result对象r</span></span><br><span class="line">Result r = <span class="keyword">new</span> Result();</span><br><span class="line">r.setAAA(a);</span><br><span class="line"><span class="comment">// 提交任务</span></span><br><span class="line">Future&lt;Result&gt; future = </span><br><span class="line">  executor.submit(<span class="keyword">new</span> Task(r), r);  </span><br><span class="line">Result fr = future.get();</span><br><span class="line"><span class="comment">// 下面等式成立</span></span><br><span class="line">fr === r;</span><br><span class="line">fr.getAAA() === a;</span><br><span class="line">fr.getXXX() === x</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">  Result r;</span><br><span class="line">  <span class="comment">//通过构造函数传入result</span></span><br><span class="line">  Task(Result r)&#123;</span><br><span class="line">    <span class="keyword">this</span>.r = r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可以操作result</span></span><br><span class="line">    a = r.getAAA();</span><br><span class="line">    r.setXXX(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面三个方法返回的都是 <code>Future</code> 接口, <code>Future</code> 有5个方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取消任务</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"><span class="comment">// 判断任务是否已取消  </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 判断任务是否已结束</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获得任务执行结果</span></span><br><span class="line">get();</span><br><span class="line"><span class="comment">// 获得任务执行结果，支持超时</span></span><br><span class="line">get(<span class="keyword">long</span> timeout, TimeUnit unit);</span><br></pre></td></tr></table></figure>
<p>其中这两个 <code>get()</code> 方法都是<strong>阻塞</strong>式的.</p>
<p>下面来介绍 <code>FutureTask</code> 工具类。前面我们提到的 <code>Future</code> 是一个接口，而 <code>FutureTask</code> 是一个实实在在的工具类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FutureTask(Callable&lt;V&gt; callable);</span><br><span class="line">FutureTask(Runnable runnable, V result);</span><br></pre></td></tr></table></figure>
<p><code>FutureTask</code> 实现了 <code>Runnable</code> 和 <code>Future</code> 接口，由于实现了 <code>Runnable</code> 接口，所以可以将 <code>FutureTask</code> 对象作为任务提交给 <code>ThreadPoolExecutor</code> 去执行，也可以直接被 <code>Thread</code> 执行；又因为实现了 <code>Future</code> 接口，所以也能用来获得任务的执行结果。下面的示例代码是将 <code>FutureTask</code> 对象提交给 <code>ThreadPoolExecutor</code> 去执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建FutureTask</span></span><br><span class="line">FutureTask&lt;Integer&gt; futureTask</span><br><span class="line">  = <span class="keyword">new</span> FutureTask&lt;&gt;(()-&gt; <span class="number">1</span>+<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 创建线程池</span></span><br><span class="line">ExecutorService es = </span><br><span class="line">  Executors.newCachedThreadPool();</span><br><span class="line"><span class="comment">// 提交FutureTask </span></span><br><span class="line">es.submit(futureTask);</span><br><span class="line"><span class="comment">// 获取计算结果</span></span><br><span class="line">Integer result = futureTask.get();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建FutureTask</span></span><br><span class="line">FutureTask&lt;Integer&gt; futureTask</span><br><span class="line">  = <span class="keyword">new</span> FutureTask&lt;&gt;(()-&gt; <span class="number">1</span>+<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 创建并启动线程</span></span><br><span class="line">Thread T1 = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">T1.start();</span><br><span class="line"><span class="comment">// 获取计算结果</span></span><br><span class="line">Integer result = futureTask.get();</span><br></pre></td></tr></table></figure>
<h1 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h1><p><code>CompletableFuture</code> 是 JDK 1.8 推出的异步编程工具类, 方法比较多也比较复杂, 但是灵活性很高.</p>
<p>先来举个烧茶的例子, 首先需要先完成分工方案，在下面的程序中，我们分了 3 个任务：任务 1 负责洗水壶、烧开水，任务 2 负责洗茶壶、洗茶杯和拿茶叶，任务 3 负责泡茶。其中任务 3 要等待任务 1 和任务 2 都完成后才能开始。</p>
<p><img src="https://cdn.yangbingdong.com/img/concurrent/java-concurrent-part4-tea-process.png" alt></p>
<p>使用 <code>CompletableFuture</code> 完成:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//任务1：洗水壶-&gt;烧开水</span></span><br><span class="line">CompletableFuture&lt;Void&gt; f1 = </span><br><span class="line">  CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">  System.out.println(<span class="string">"T1:洗水壶..."</span>);</span><br><span class="line">  sleep(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"T1:烧开水..."</span>);</span><br><span class="line">  sleep(<span class="number">15</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//任务2：洗茶壶-&gt;洗茶杯-&gt;拿茶叶</span></span><br><span class="line">CompletableFuture&lt;String&gt; f2 = </span><br><span class="line">  CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">  System.out.println(<span class="string">"T2:洗茶壶..."</span>);</span><br><span class="line">  sleep(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"T2:洗茶杯..."</span>);</span><br><span class="line">  sleep(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">"T2:拿茶叶..."</span>);</span><br><span class="line">  sleep(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"龙井"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//任务3：任务1和任务2完成后执行：泡茶</span></span><br><span class="line">CompletableFuture&lt;String&gt; f3 = </span><br><span class="line">  f1.thenCombine(f2, (__, tf)-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">"T1:拿到茶叶:"</span> + tf);</span><br><span class="line">    System.out.println(<span class="string">"T1:泡茶..."</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"上茶:"</span> + tf;</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">//等待任务3执行结果</span></span><br><span class="line">System.out.println(f3.join());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">int</span> t, TimeUnit u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    u.sleep(t);</span><br><span class="line">  &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一次执行结果：</span></span><br><span class="line">T1:洗水壶...</span><br><span class="line">T2:洗茶壶...</span><br><span class="line">T1:烧开水...</span><br><span class="line">T2:洗茶杯...</span><br><span class="line">T2:拿茶叶...</span><br><span class="line">T1:拿到茶叶:龙井</span><br><span class="line">T1:泡茶...</span><br><span class="line">上茶:龙井</span><br></pre></td></tr></table></figure>
<h2 id="创建-CompletableFuture-对象"><a href="#创建-CompletableFuture-对象" class="headerlink" title="创建 CompletableFuture 对象"></a>创建 CompletableFuture 对象</h2><p>先来看一下4个构造器:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用默认线程池</span></span><br><span class="line"><span class="keyword">static</span> CompletableFuture&lt;Void&gt; </span><br><span class="line">  runAsync(Runnable runnable)</span><br><span class="line"><span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; </span><br><span class="line">  supplyAsync(Supplier&lt;U&gt; supplier)</span><br><span class="line"><span class="comment">//可以指定线程池  </span></span><br><span class="line"><span class="keyword">static</span> CompletableFuture&lt;Void&gt; </span><br><span class="line">  runAsync(Runnable runnable, Executor executor)</span><br><span class="line"><span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; </span><br><span class="line">  supplyAsync(Supplier&lt;U&gt; supplier, Executor executor)</span><br></pre></td></tr></table></figure>
<p><code>runAsync(Runnable)</code> 与 <code>supplyAsync(Supplier)</code> 的区别是前者没有返回值, 后者<strong>有返回值</strong>. 而前两个方法和后两个方法的区别在于：后两个方法可以<strong>指定线程池参数</strong>。</p>
<p>默认情况下 <code>CompletableFuture</code> 会使用公共的 <code>ForkJoinPool</code> 线程池，这个线程池默认创建的线程数是 CPU 的核数（也可以通过 JVM 参数: <code>-Djava.util.concurrent.ForkJoinPool.common.parallelism</code> 来设置 <code>ForkJoinPool</code> 线程池的线程数）。如果所有 <code>CompletableFuture</code> 共享一个线程池，那么一旦有任务执行一些很慢的 I/O 操作，就会导致线程池中所有线程都阻塞在 I/O 操作上，从而造成<strong>线程饥饿</strong>，进而影响整个系统的性能。所以，强烈建议<strong>要根据不同的业务类型创建不同的线程池，以避免互相干扰</strong>。</p>
<p>创建完 <code>CompletableFuture</code> 对象之后，会自动地异步执行 <code>runnable.run()</code> 方法或者 <code>supplier.get()</code> 方法，对于一个异步操作，需要关注两个问题：一个是异步操作什么时候结束，另一个是如何获取异步操作的执行结果。因为 <code>CompletableFuture</code> 类实现了 <code>Future</code> 接口，所以这两个问题你都可以通过 <code>Future</code> 接口来解决。另外，<code>CompletableFuture</code> 类还实现了 <code>CompletionStage</code> 接口，这个接口内容实在是太丰富了，在 1.8 版本里有 40 个方法</p>
<h2 id="如何理解-CompletionStage-接口"><a href="#如何理解-CompletionStage-接口" class="headerlink" title="如何理解 CompletionStage 接口"></a>如何理解 CompletionStage 接口</h2><p>可分为: <strong>串行关系</strong>, <strong>AND 汇聚关系</strong>, <strong>OR 汇聚关系</strong>(依赖的任务只要有一个完成就可以执行当前任务)以及<strong>异常处理</strong>.</p>
<p>一下提到的方法一般有三个”重载”, 比如 <code>thenAccept(fn)</code>, 另外还有两个是 <code>thenAcceptAsync(fn)</code> 和 <code>thenAcceptAsync(fn, executor)</code>. 第一个使用前一个函数所在的同一个线程, 后两个则是异步执行, 没有指定线程池, 则使用的是 <code>ForkJoinPool</code>, 后者使用指定的线程池.</p>
<h3 id="描述串行关系"><a href="#描述串行关系" class="headerlink" title="描述串行关系"></a>描述串行关系</h3><p><code>CompletionStage</code> 接口里面描述串行关系，主要是 <code>thenApply</code>、<code>thenAccept</code>、<code>thenRun</code> 和 <code>thenCompose</code> 这四个系列的接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">CompletionStage&lt;R&gt; <span class="title">thenApply</span><span class="params">(fn)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">thenAccept</span><span class="params">(consumer)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">thenRun</span><span class="params">(action)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;R&gt; <span class="title">thenCompose</span><span class="params">(fn)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>thenApply</code> 接收的是 <code>Function&lt;T, R&gt;</code>, 所以这个方法既<strong>能接收参数也支持返回值</strong>;</li>
<li><code>thenAccept</code> 接收的是 <code>Consumer&lt;T&gt;</code>, <strong>只能接收参数没有返回值</strong>, 所以返回的是 <code>CompletionStage&lt;Void&gt;</code>;</li>
<li><code>thenRun</code> 接收的是 <code>Runnable</code>, <strong>不接受参数也不返回</strong>;</li>
<li><code>thenCompose</code> 与 <code>thenApply</code> 类似, 不同的在于它接收的是 <code>Function&lt;T, ? extends CompletionStage&lt;U&gt;&gt;</code>, 返回值需要是 <code>CompletionStage&lt;U&gt;</code> 或其子类.</li>
</ul>
<p>示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; f0 = </span><br><span class="line">  CompletableFuture.supplyAsync(</span><br><span class="line">    () -&gt; <span class="string">"Hello World"</span>)      <span class="comment">//①</span></span><br><span class="line">  .thenApply(s -&gt; s + <span class="string">" QQ"</span>)  <span class="comment">//②</span></span><br><span class="line">  .thenApply(String::toUpperCase);<span class="comment">//③</span></span><br><span class="line"></span><br><span class="line">System.out.println(f0.join());</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">HELLO WORLD QQ</span><br></pre></td></tr></table></figure>
<p>虽然这是一个异步流程，但任务①②③却是串行执行的，②依赖①的执行结果，③依赖②的执行结果。</p>
<h3 id="描述-AND-汇聚关系"><a href="#描述-AND-汇聚关系" class="headerlink" title="描述 AND 汇聚关系"></a>描述 AND 汇聚关系</h3><p>方法签名:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">CompletionStage&lt;R&gt; <span class="title">thenCombine</span><span class="params">(other, fn)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">thenAcceptBoth</span><span class="params">(other, consumer)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">runAfterBoth</span><span class="params">(other, action)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这些接口的区别也是源自 <code>fn</code>、<code>consumer</code>、<code>action</code> 这三个核心参数不同。它们的使用你可以参考上面烧水泡茶的实现程序，这里就不赘述了。</p>
<h3 id="描述-OR-汇聚关系"><a href="#描述-OR-汇聚关系" class="headerlink" title="描述 OR 汇聚关系"></a>描述 OR 汇聚关系</h3><p>OR 汇聚关系指的是依赖的任务只要有一个完成就可以执行当前任务.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">CompletionStage&lt;R&gt; <span class="title">thenCombine</span><span class="params">(other, fn)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">thenAcceptBoth</span><span class="params">(other, consumer)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">runAfterBoth</span><span class="params">(other, action)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这些接口的区别也是源自 fn、consumer、action 这三个核心参数不同。</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>虽然上面我们提到的 <code>fn</code>、<code>consumer</code>、<code>action</code> 它们的核心方法都不允许抛出可检查异常，<strong>但是却无法限制它们抛出运行时异常</strong>，例如下面的代码，执行 7/0 就会出现除零错误这个运行时异常。非异步编程里面，我们可以使用 <code>try{}catch{}</code> 来捕获并处理异常，那在异步编程里面，异常该如何处理呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; </span><br><span class="line">  f0 = CompletableFuture.</span><br><span class="line">    .supplyAsync(()-&gt;(<span class="number">7</span>/<span class="number">0</span>))</span><br><span class="line">    .thenApply(r-&gt;r*<span class="number">10</span>);</span><br><span class="line">System.out.println(f0.join());</span><br></pre></td></tr></table></figure>
<p><code>CompletionStage</code> 接口给我们提供的方案非常简单，比 <code>try{}catch{}</code> 还要简单，下面是相关的方法，使用这些方法进行异常处理和串行操作是一样的，都支持链式编程方式:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">CompletionStage <span class="title">exceptionally</span><span class="params">(fn)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;R&gt; <span class="title">whenComplete</span><span class="params">(consumer)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;R&gt; <span class="title">whenCompleteAsync</span><span class="params">(consumer)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;R&gt; <span class="title">handle</span><span class="params">(fn)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;R&gt; <span class="title">handleAsync</span><span class="params">(fn)</span></span>;</span><br></pre></td></tr></table></figure>
<p>下面的示例代码展示了如何使用 <code>exceptionally()</code> 方法来处理异常，<code>exceptionally()</code> 的使用非常类似于 <code>try{}catch{}</code> 中的 <code>catch{}</code>，但是由于支持链式编程方式，所以相对更简单:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; </span><br><span class="line">  f0 = CompletableFuture</span><br><span class="line">    .supplyAsync(()-&gt;<span class="number">7</span>/<span class="number">0</span>))</span><br><span class="line">    .thenApply(r-&gt;r*<span class="number">10</span>)</span><br><span class="line">    .exceptionally(e-&gt;<span class="number">0</span>);</span><br><span class="line">System.out.println(f0.join());</span><br></pre></td></tr></table></figure>
<p>既然有 <code>try{}catch{}</code>，那就一定还有 <code>try{}finally{}</code>，<code>whenComplete()</code> 和 <code>handle()</code> 系列方法就类似于 <code>try{}finally{}</code>中的 <code>finally{}</code>，无论是否发生异常都会执行 <code>whenComplete()</code> 中的回调函数 <code>consumer</code> 和 <code>handle()</code> 中的回调函数 <code>fn</code>。<code>whenComplete()</code> 和 <code>handle()</code> 的区别在于 <code>whenComplete()</code> 不支持返回结果，而 <code>handle()</code> 是支持返回结果的。</p>
<h2 id="CompletionService"><a href="#CompletionService" class="headerlink" title="CompletionService"></a>CompletionService</h2><p>如何批量执行异步任务? 举个例子, 应用需要从三个电商询价，然后保存在自己的数据库里。核心示例代码如下所示，由于是串行的，所以性能很慢:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向电商S1询价，并保存</span></span><br><span class="line">r1 = getPriceByS1();</span><br><span class="line">save(r1);</span><br><span class="line"><span class="comment">// 向电商S2询价，并保存</span></span><br><span class="line">r2 = getPriceByS2();</span><br><span class="line">save(r2);</span><br><span class="line"><span class="comment">// 向电商S3询价，并保存</span></span><br><span class="line">r3 = getPriceByS3();</span><br><span class="line">save(r3);</span><br></pre></td></tr></table></figure>
<p>使用 <code>ThreadPoolExecutor</code> + <code>Future</code> 完成是这样的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建线程池</span></span><br><span class="line">ExecutorService executor =</span><br><span class="line">  Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 异步向电商S1询价</span></span><br><span class="line">Future&lt;Integer&gt; f1 = </span><br><span class="line">  executor.submit(</span><br><span class="line">    ()-&gt;getPriceByS1());</span><br><span class="line"><span class="comment">// 异步向电商S2询价</span></span><br><span class="line">Future&lt;Integer&gt; f2 = </span><br><span class="line">  executor.submit(</span><br><span class="line">    ()-&gt;getPriceByS2());</span><br><span class="line"><span class="comment">// 异步向电商S3询价</span></span><br><span class="line">Future&lt;Integer&gt; f3 = </span><br><span class="line">  executor.submit(</span><br><span class="line">    ()-&gt;getPriceByS3());</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获取电商S1报价并保存</span></span><br><span class="line">r=f1.get();</span><br><span class="line">executor.execute(()-&gt;save(r));</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 获取电商S2报价并保存</span></span><br><span class="line">r=f2.get();</span><br><span class="line">executor.execute(()-&gt;save(r));</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 获取电商S3报价并保存  </span></span><br><span class="line">r=f3.get();</span><br><span class="line">executor.execute(()-&gt;save(r));</span><br></pre></td></tr></table></figure>
<p>上面的这个方案本身没有太大问题，但是有个地方的处理需要你注意，那就是如果获取电商 S1 报价的耗时很长，那么即便获取电商 S2 报价的耗时很短，也无法让保存 S2 报价的操作先执行，因为这个主线程都阻塞在了 <code>f1.get()</code> 操作上。</p>
<p>那么如何优化? 可以增加一个阻塞队列，获取到 S1、S2、S3 的报价都进入阻塞队列，然后在主线程中消费阻塞队列，这样就能保证先获取到的报价先保存到数据库了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建阻塞队列</span></span><br><span class="line">BlockingQueue&lt;Integer&gt; bq =</span><br><span class="line">  <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line"><span class="comment">//电商S1报价异步进入阻塞队列  </span></span><br><span class="line">executor.execute(()-&gt;</span><br><span class="line">  bq.put(f1.get()));</span><br><span class="line"><span class="comment">//电商S2报价异步进入阻塞队列  </span></span><br><span class="line">executor.execute(()-&gt;</span><br><span class="line">  bq.put(f2.get()));</span><br><span class="line"><span class="comment">//电商S3报价异步进入阻塞队列  </span></span><br><span class="line">executor.execute(()-&gt;</span><br><span class="line">  bq.put(f3.get()));</span><br><span class="line"><span class="comment">//异步保存所有报价  </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">  Integer r = bq.take();</span><br><span class="line">  executor.execute(()-&gt;save(r));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但在实际项目中, 我们可以使用 JDK 为我们提供的 <code>CompletionService</code> 去执行批量任务.</p>
<p><code>CompletionService</code> 的实现原理也是内部维护了一个阻塞队列，当任务执行结束就把任务的执行结果加入到阻塞队列中，不同的是 <code>CompletionService</code> 是把任务执行结果的 <code>Future</code> 对象加入到阻塞队列中，而上面的示例代码是把任务最终的执行结果放入了阻塞队列中。</p>
<p><code>CompletionService</code> 接口的实现类是 <code>ExecutorCompletionService</code>，这个实现类的构造方法有两个，分别是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorCompletionService(Executor executor)</span><br><span class="line">ExecutorCompletionService(Executor executor, BlockingQueue&gt; completionQueue)</span><br></pre></td></tr></table></figure>
<p>下面使用 <code>CompletionService</code> 来优化一下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建线程池</span></span><br><span class="line">ExecutorService executor = </span><br><span class="line">  Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 创建CompletionService</span></span><br><span class="line">CompletionService&lt;Integer&gt; cs = <span class="keyword">new</span> </span><br><span class="line">  ExecutorCompletionService&lt;&gt;(executor);</span><br><span class="line"><span class="comment">// 异步向电商S1询价</span></span><br><span class="line">cs.submit(()-&gt;getPriceByS1());</span><br><span class="line"><span class="comment">// 异步向电商S2询价</span></span><br><span class="line">cs.submit(()-&gt;getPriceByS2());</span><br><span class="line"><span class="comment">// 异步向电商S3询价</span></span><br><span class="line">cs.submit(()-&gt;getPriceByS3());</span><br><span class="line"><span class="comment">// 将询价结果异步保存到数据库</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">  Integer r = cs.take().get();</span><br><span class="line">  executor.execute(()-&gt;save(r));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看一下 <code>CompletionService</code> 的方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Future&lt;V&gt; <span class="title">submit</span><span class="params">(Callable&lt;V&gt; task)</span></span>;</span><br><span class="line"><span class="function">Future&lt;V&gt; <span class="title">submit</span><span class="params">(Runnable task, V result)</span></span>;</span><br><span class="line"><span class="function">Future&lt;V&gt; <span class="title">take</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function">Future&lt;V&gt; <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Future&lt;V&gt; <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> </span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>
<p>前面两个 <code>submit()</code> 是提交任务的, <code>take()</code>、<code>poll()</code> 都是从阻塞队列中获取并移除一个元素；它们的区别在于如果阻塞队列是空的，那么调用 <code>take()</code> 方法的线程会被<strong>阻塞</strong>，而 <code>poll()</code> 方法会<strong>返回 null 值</strong>。 <code>poll(long timeout, TimeUnit unit)</code> 方法支持以超时的方式获取并移除阻塞队列头部的一个元素，如果等待了 timeout unit 时间，阻塞队列还是空的，那么该方法会返回 null 值。</p>
<p>对于简单的并行任务，可以通过”线程池 + <code>Future</code>“的方案来解决；如果任务之间有聚合关系，无论是 AND 聚合还是 OR 聚合，都可以通过 <code>CompletableFuture</code> 来解决；而批量的并行任务，则可以通过 <code>CompletionService</code> 来解决。</p>
<h1 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork/Join"></a>Fork/Join</h1><p>Fork/Join 是一个并行计算的框架，主要就是用来支持<strong>分治任务</strong>模型的，<strong>这个计算框架里的 Fork 对应的是分治任务模型里的任务分解，Join 对应的是结果合并</strong>。Fork/Join 计算框架主要包含两部分，一部分是<strong>分治任务的线程池 <code>ForkJoinPool</code></strong>，另一部分是<strong>分治任务 <code>ForkJoinTask</code></strong>。这两部分的关系类似于 <code>ThreadPoolExecutor</code> 和 Runnable 的关系，都可以理解为提交任务到线程池，只不过分治任务有自己独特类型 <code>ForkJoinTask</code>。</p>
<p><code>ForkJoinTask</code> 是一个抽象类，它的方法有很多，最核心的是 <code>fork()</code> 方法和 <code>join()</code> 方法，其中 <code>fork()</code> 方法会异步地执行一个子任务，而 <code>join()</code> 方法则会阻塞当前线程来等待子任务的执行结果。<code>ForkJoinTask</code> 有两个子类——<code>RecursiveAction</code> 和 <code>RecursiveTask</code>，通过名字你就应该能知道，它们都是用递归的方式来处理分治任务的。这两个子类都定义了抽象方法 <code>compute()</code>，不过区别是 <code>RecursiveAction</code> 定义的 <code>compute()</code> 没有返回值，而 <code>RecursiveTask</code> 定义的 <code>compute()</code> 方法是有返回值的。这两个子类也是抽象类，在使用的时候，需要自定义子类去扩展。</p>
<p>先来看一个简单的例子, 累加数组:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> length = <span class="number">3000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span>[] numbers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        numbers = <span class="keyword">new</span> <span class="keyword">long</span>[length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            numbers[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ForkJoinPool forkJoinPool = ForkJoinPool.commonPool();</span><br><span class="line">        ForkCalculator forkCalculator = <span class="keyword">new</span> ForkCalculator(numbers, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Long invoke = forkJoinPool.invoke(forkCalculator);</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"并行耗时: "</span> + (end - start) + <span class="string">" 毫秒"</span>);</span><br><span class="line">        System.out.println(<span class="string">"结果: "</span> + invoke);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">calc</span><span class="params">(<span class="keyword">long</span>[] numbers, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                r += numbers[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkCalculator</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span>[] numbers;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ForkCalculator</span><span class="params">(<span class="keyword">long</span>[] numbers, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.numbers = numbers;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (end - start &lt;= THRESHOLD) &#123;</span><br><span class="line">                <span class="keyword">return</span> calc(numbers, start, end);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> middle = (end + start) / <span class="number">2</span>;</span><br><span class="line">            ForkCalculator left = <span class="keyword">new</span> ForkCalculator(numbers, start, middle);</span><br><span class="line">            ForkCalculator right = <span class="keyword">new</span> ForkCalculator(numbers, middle + <span class="number">1</span>, end);</span><br><span class="line">            invokeAll(left, right);</span><br><span class="line">            <span class="keyword">return</span> left.join() + right.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ForkJoinPool</code> 本质上也是一个生产者 - 消费者的实现, 但它是每个线程对应一个<strong>双端队列</strong>, 因为它还采取了一种叫做<strong>任务窃取</strong>的机制, 以便有空闲线程出现的时候可以窃取其他线程的任务.</p>
<p>不过需要注意的是，默认情况下所有的并行流计算都<strong>共享一个</strong> <code>ForkJoinPool</code>，这个共享的 <code>ForkJoinPool</code> 默认的线程数是 CPU 的核数；如果所有的并行流计算都是 CPU 密集型计算的话，完全没有问题，但是如果存在 I/O 密集型的并行流计算，那么很可能会因为一个很慢的 I/O 计算而拖慢整个系统的性能。所以建议<strong>用不同的 <code>ForkJoinPool</code> 执行不同类型的计算任务</strong>。</p>
]]></content><categories><category>Programming</category><category>Java</category><category>Concurrent</category></categories><tags><tag>Java</tag><tag>Concurrent</tag></tags></entry><entry><title>并发设计模式</title><url>/2019/java-concurrent-part5/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/concurrent/java-concurrent-part5-banner.jpg" alt></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><blockquote>
<p>并发领域中也有诸多的设计模式.</p>
</blockquote>
<a id="more"></a>
<h1 id="Immutability模式"><a href="#Immutability模式" class="headerlink" title="Immutability模式"></a>Immutability模式</h1><p>解决并发问题，其实最简单的办法就是让共享变量<strong>只有读操作</strong>，而<strong>没有写操作</strong>。这个办法如此重要，以至于被上升到了一种解决并发问题的设计模式：<strong>不变性（Immutability）模式</strong>。所谓不变性，简单来讲，就是<strong>对象一旦被创建之后，状态就不再发生变化</strong>。换句话说，就是变量一旦被赋值，就不允许修改了（没有写操作）；没有修改操作，也就是保持了不变性。</p>
<p>实现一个具备不可变性的类，还是挺简单的。<strong>将一个类所有的属性都设置成 final 的，并且只允许存在只读方法，那么这个类基本上就具备不可变性了</strong>。更严格的做法是<strong>这个类本身也是 final 的</strong>，也就是不允许继承。因为子类可以覆盖父类的方法，有可能改变不可变性，所以推荐你在实际工作中，使用这种更严格的做法。</p>
<p>Java 中非常经典的例子就是 <code>String</code>、<code>Integer</code>、<code>Long</code> 以及 <code>Double</code> 等基础类型的包装类. 它们都严格遵守不可变类的三点要求：类和属性都是 final 的，所有方法均是只读的。</p>
<p>但是 <code>String</code> 中有一些方法类似 <code>replace()</code> 这种操作这种操作是怎么实现的? 很简单, <strong>对象不可变那就返回一个新的对象</strong>. 那是不是有点浪费内存呢? 确实会的, 但是可以通过一种<strong>享元模式(Flyweight Pattern)</strong>来使这个消耗减小. Java 语言里面 <code>Long</code>、<code>Integer</code>、<code>Short</code>、<code>Byte</code> 等这些基本数据类型的包装类都用到了享元模式, <strong>享元模式本质上其实就是一个对象池</strong>:</p>
<p><img src="https://cdn.yangbingdong.com/img/concurrent/java-concurrent-part5-long-cache.png" alt></p>
<p>之前有提过, 基本上所有的基础类型的包装类都不适合做锁, 因为这些类基本都使用了享元模式, 看上去是私有, 但实际上可能是公共的, 以下就是错误示范:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  Long al=Long.valueOf(<span class="number">1</span>);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAX</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (al) &#123;</span><br><span class="line">      <span class="comment">//省略代码无数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  Long bl=Long.valueOf(<span class="number">1</span>);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBY</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (bl) &#123;</span><br><span class="line">      <span class="comment">//省略代码无数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用 <code>Immutability</code> 模式的时候，需要注意以下两点：</p>
<ul>
<li>对象的所有属性都是 final 的，并不能保证不可变性(对象属性也可能是一个对象)；</li>
<li>不可变对象也需要正确发布。</li>
</ul>
<h1 id="Copy-on-Write模式"><a href="#Copy-on-Write模式" class="headerlink" title="Copy-on-Write模式"></a>Copy-on-Write模式</h1><p>上面说到 String 这个类在实现 <code>replace()</code> 方法的时候，并没有更改原字符串里面 <code>value[]</code> 数组的内容，而是<strong>创建了一个新字符串</strong>，这种方法在解决不可变对象的修改问题时经常用到, 这本质上是 <strong>Copy-on-Write</strong> 方法, 也就是<strong>写时复制</strong>. </p>
<p>Java 并发包中比较经典的实现就是 <code>CopyOnWriteArrayList</code> 和 <code>CopyOnWriteArraySet</code> 这两个类. 当然, 这并不是 Java 独有的模式, 这个模式也普遍存在与其他的领域, 比如类 Unix 操作系统中的 fork 子进程, 文件系统中的Btrfs (B-Tree File System), Docker 容器镜像, 甚至分布式源码管理系统 Git 背后的设计思想都有 Copy-on-Write…</p>
<p>不过，<strong>Copy-on-Write 最大的应用领域还是在函数式编程领域</strong>。函数式编程的基础是不可变性（Immutability），所以函数式编程里面所有的修改操作都需要 Copy-on-Write 来解决。你或许会有疑问，“所有数据的修改都需要复制一份，性能是不是会成为瓶颈呢?”你的担忧是有道理的，之所以函数式编程早年间没有兴起，性能绝对拖了后腿。但是随着硬件性能的提升，性能问题已经慢慢变得可以接受了。而且，Copy-on-Write 也远不像 Java 里的 <code>CopyOnWriteArrayList</code> 那样笨：整个数组都复制一遍。</p>
<p><code>CopyOnWriteArrayList</code> 和 <code>CopyOnWriteArraySet</code> 这两个 Copy-on-Write 容器在修改的时候会复制整个数组，所以如果容器经常被修改或者这个数组本身就非常大的时候，是不建议使用的。反之，如果是修改非常少、数组数量也不大，并且对读性能要求苛刻的场景，使用 Copy-on-Write 容器效果就非常好了。一个比较经典的场景就是 RPC 框架的注册路由表, 对读的要求很高, 写比较少, 对一致性要求不高:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//路由信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Router</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String  ip;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Integer port;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String  iface;</span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Router</span><span class="params">(String ip, </span></span></span><br><span class="line"><span class="function"><span class="params">      Integer port, String iface)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.ip = ip;</span><br><span class="line">    <span class="keyword">this</span>.port = port;</span><br><span class="line">    <span class="keyword">this</span>.iface = iface;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//重写equals方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Router) &#123;</span><br><span class="line">      Router r = (Router)obj;</span><br><span class="line">      <span class="keyword">return</span> iface.equals(r.iface) &amp;&amp;</span><br><span class="line">             ip.equals(r.ip) &amp;&amp;</span><br><span class="line">             port.equals(r.port);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略hashCode相关代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//路由表信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RouterTable</span> </span>&#123;</span><br><span class="line">  <span class="comment">//Key:接口名</span></span><br><span class="line">  <span class="comment">//Value:路由集合</span></span><br><span class="line">  ConcurrentHashMap&lt;String, CopyOnWriteArraySet&lt;Router&gt;&gt; </span><br><span class="line">    rt = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  <span class="comment">//根据接口名获取路由表</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Set&lt;Router&gt; <span class="title">get</span><span class="params">(String iface)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rt.get(iface);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//删除路由</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Router router)</span> </span>&#123;</span><br><span class="line">    Set&lt;Router&gt; set=rt.get(router.iface);</span><br><span class="line">    <span class="keyword">if</span> (set != <span class="keyword">null</span>) &#123;</span><br><span class="line">      set.remove(router);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//增加路由</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Router router)</span> </span>&#123;</span><br><span class="line">    Set&lt;Router&gt; set = rt.computeIfAbsent(</span><br><span class="line">      route.iface, r -&gt; </span><br><span class="line">        <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;());</span><br><span class="line">    set.add(router);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Copy-on-Write 是一项非常通用的技术方案，在很多领域都有着广泛的应用。不过，它也有缺点的，那就是<strong>消耗内存，每次修改都需要复制一个新的对象出来</strong>，好在随着自动垃圾回收（GC）算法的成熟以及硬件的发展，这种内存消耗已经渐渐可以接受了。</p>
<h1 id="线程本地存储模式"><a href="#线程本地存储模式" class="headerlink" title="线程本地存储模式"></a>线程本地存储模式</h1><p>之前提到过<strong>线程封闭</strong>这个概念, 其本质上就是避免共享, Java 中提供了 <code>ThreadLocal</code> 类来实现这个东西.</p>
<p><code>ThreadLocal</code> 基本原理如下:</p>
<p><img src="https://cdn.yangbingdong.com/img/concurrent/java-concurrent-threadlocal.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="comment">//内部持有ThreadLocalMap</span></span><br><span class="line">  ThreadLocal.ThreadLocalMap </span><br><span class="line">    threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先获取线程持有的</span></span><br><span class="line">    <span class="comment">//ThreadLocalMap</span></span><br><span class="line">    ThreadLocalMap map =</span><br><span class="line">      Thread.currentThread()</span><br><span class="line">        .threadLocals;</span><br><span class="line">    <span class="comment">//在ThreadLocalMap中</span></span><br><span class="line">    <span class="comment">//查找变量</span></span><br><span class="line">    Entry e = </span><br><span class="line">      map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> e.value;  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span></span>&#123;</span><br><span class="line">    <span class="comment">//内部是数组而不是Map</span></span><br><span class="line">    Entry[] table;</span><br><span class="line">    <span class="comment">//根据ThreadLocal查找Entry</span></span><br><span class="line">    <span class="function">Entry <span class="title">getEntry</span><span class="params">(ThreadLocal key)</span></span>&#123;</span><br><span class="line">      <span class="comment">//省略查找逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Entry定义</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">    <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&gt;</span>&#123;</span><br><span class="line">      Object value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要注意一点, 最好采用 <code>try{}finally{}</code> 手动释放资源<strong>避免内存泄露</strong>.</p>
<p>线程本地存储模式本质上是一种<strong>避免共享</strong>的方案，由于没有共享，所以自然也就没有并发问题。如果你需要在并发场景中使用一个线程不安全的工具类，最简单的方案就是避免共享。避免共享有两种方案，一种方案是将这个工具类作为局部变量使用，另外一种方案就是线程本地存储模式。这两种方案，局部变量方案的缺点是在高并发场景下会频繁创建对象，而线程本地存储方案，每个线程只需要创建一个工具类的实例，所以不存在频繁创建对象的问题。</p>
<h1 id="Guarded-Suspension模式"><a href="#Guarded-Suspension模式" class="headerlink" title="Guarded Suspension模式"></a>Guarded Suspension模式</h1><p>假设有这么一个场景, 服务调用是通过MQ来调用的, 比如需要Web端请求一个文件, 服务A发送MessageA, 服务B消费MessageA并发送MessageB, 但是A消费MessageB是异步的,   但是对于Web端来说这个请求是同步的.</p>
<p><img src="https://cdn.yangbingdong.com/img/concurrent/java-concurrent-guarded-suspension.png" alt></p>
<p>伪代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span></span>&#123;</span><br><span class="line">  String id;</span><br><span class="line">  String content;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该方法可以发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">  <span class="comment">//省略相关代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//MQ消息返回后会调用该方法</span></span><br><span class="line"><span class="comment">//该方法的执行线程不同于</span></span><br><span class="line"><span class="comment">//发送消息的线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">  <span class="comment">//省略相关代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理浏览器发来的请求</span></span><br><span class="line"><span class="function">Respond <span class="title">handleWebReq</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//创建一消息</span></span><br><span class="line">  Message msg1 = <span class="keyword">new</span> </span><br><span class="line">    Message(<span class="string">"1"</span>,<span class="string">"&#123;...&#125;"</span>);</span><br><span class="line">  <span class="comment">//发送消息</span></span><br><span class="line">  send(msg1);</span><br><span class="line">  <span class="comment">//如何等待MQ返回的消息呢？</span></span><br><span class="line">  String result = ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于MQ返回消息需要等待服务提供方消费完成, 本质上是<strong>等待一个条件满足</strong>. 这类需求可以通过 Lock 与 Condition 来实现. 前人将其总结成一个模式: <strong>Guarded Suspension</strong>, 直译过来就是”保护性地暂停”.</p>
<p>下图就是 Guarded Suspension 模式的结构图，非常简单，一个对象 <code>GuardedObject</code>，内部有一个成员变量——受保护的对象，以及两个成员方法——<code>get(Predicate p)</code>和<code>onChanged(T obj)</code>方法。</p>
<p><img src="https://cdn.yangbingdong.com/img/concurrent/java-concurrent-guarded-suspension-struct.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GuardedObject</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="comment">//受保护的对象</span></span><br><span class="line">  T obj;</span><br><span class="line">  <span class="keyword">final</span> Lock lock = </span><br><span class="line">    <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">final</span> Condition done =</span><br><span class="line">    lock.newCondition();</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> timeout=<span class="number">1</span>;</span><br><span class="line">  <span class="comment">//获取受保护对象  </span></span><br><span class="line">  <span class="function">T <span class="title">get</span><span class="params">(Predicate&lt;T&gt; p)</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//MESA管程推荐写法</span></span><br><span class="line">      <span class="keyword">while</span>(!p.test(obj))&#123;</span><br><span class="line">        done.await(timeout, </span><br><span class="line">          TimeUnit.SECONDS);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回非空的受保护对象</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//事件通知方法</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onChanged</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.obj = obj;</span><br><span class="line">      done.signalAll();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上面场景, 我们可以这样实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//处理浏览器发来的请求</span></span><br><span class="line"><span class="function">Respond <span class="title">handleWebReq</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//创建一消息</span></span><br><span class="line">  Message msg1 = <span class="keyword">new</span> </span><br><span class="line">    Message(<span class="string">"1"</span>,<span class="string">"&#123;...&#125;"</span>);</span><br><span class="line">  <span class="comment">//发送消息</span></span><br><span class="line">  send(msg1);</span><br><span class="line">  <span class="comment">//利用GuardedObject实现等待</span></span><br><span class="line">  GuardedObject&lt;Message&gt; go</span><br><span class="line">    =<span class="keyword">new</span> GuardObjec&lt;&gt;();</span><br><span class="line">  Message r = go.get(</span><br><span class="line">    t-&gt;t != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">  <span class="comment">//如何找到匹配的go？</span></span><br><span class="line">  GuardedObject&lt;Message&gt; go=???</span><br><span class="line">  go.onChanged(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这里的问题就是, <code>GuardedObject</code> 是在 <code>handleWebReq()</code> 方法中new出来的, 如何传递到 <code>onMessage()</code> 方法?</p>
<p>很简单, 做一个消息的映射就行了, <code>Dubbo</code> 中 <code>DefaultFuture</code> 这个类也是采用的这种方式的.</p>
<h1 id="Balking模式"><a href="#Balking模式" class="headerlink" title="Balking模式"></a>Balking模式</h1><p>我们经常会遇到<strong>防御性 return</strong> 的场景, 比如只加载一次或者只执行一次, 伪代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但往往会有多个线程去执行这段逻辑, 这又变成了另外一种”多线程版本的 if”, 叫做 <strong>Balking 模式</strong>.</p>
<p>Balking 模式和 Guarded Suspension 模式从实现上看似乎没有多大的关系，Balking 模式只需要用互斥锁就能解决，而 Guarded Suspension 模式则要用到管程这种高级的并发原语；但是从应用的角度来看，它们解决的都是”线程安全的 if”语义，不同之处在于，Guarded Suspension 模式会等待 if 条件为真，而 Balking 模式不会等待。</p>
<h1 id="Thread-Per-Message模式"><a href="#Thread-Per-Message模式" class="headerlink" title="Thread-Per-Message模式"></a>Thread-Per-Message模式</h1><p>这个模式说白了就是就是每个请求都委托给一个新的线程, Thread-Per-Message 模式的一个最经典的应用场景是<strong>网络编程里服务端的实现</strong>，服务端为每个客户端请求创建一个独立的线程，当线程处理完请求后，自动销毁，这是一种最简单的并发处理网络请求的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> ServerSocketChannel ssc = </span><br><span class="line">  ServerSocketChannel.open().bind(</span><br><span class="line">    <span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line"><span class="comment">//处理请求    </span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 接收请求</span></span><br><span class="line">    SocketChannel sc = ssc.accept();</span><br><span class="line">    <span class="comment">// 每个请求都创建一个线程</span></span><br><span class="line">    <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 读Socket</span></span><br><span class="line">        ByteBuffer rb = ByteBuffer</span><br><span class="line">          .allocateDirect(<span class="number">1024</span>);</span><br><span class="line">        sc.read(rb);</span><br><span class="line">        <span class="comment">//模拟处理请求</span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="comment">// 写Socket</span></span><br><span class="line">        ByteBuffer wb = </span><br><span class="line">          (ByteBuffer)rb.flip();</span><br><span class="line">        sc.write(wb);</span><br><span class="line">        <span class="comment">// 关闭Socket</span></span><br><span class="line">        sc.close();</span><br><span class="line">      &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UncheckedIOException(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  ssc.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面方案显然不适用于生产环境, 毕竟 Java 中的线程是一个重量级的对象，创建成本很高，一方面创建线程比较耗时，另一方面线程占用的内存也比较大. </p>
<p>Thread-Per-Message 在 Java 中的知名度不大, 是因为线程的成本很高, 但是在别的语言当中却很响亮, 业界中有一种方案叫<strong>轻量级线程</strong>, 也叫<strong>协程</strong>, Go 语言、Lua 语言当中都有实现. 幸运的是, ava 语言目前也已经意识到轻量级线程的重要性了，OpenJDK 有个 Loom 项目，就是要解决 Java 语言的轻量级线程问题，在这个项目中，轻量级线程被叫做 Fiber。</p>
<blockquote>
<p>有一个java库叫Quasar Fiber ，通过javaagent技术可以实现轻量级线程<br>官网: <strong><em><a href="http://www.paralleluniverse.co/quasar/" rel="external nofollow noopener noreferrer" target="_blank">http://www.paralleluniverse.co/quasar/</a></em></strong></p>
<p>阿里也有一个 wisp2, 不过目前没开源.</p>
</blockquote>
<h1 id="Worker-Thread模式"><a href="#Worker-Thread模式" class="headerlink" title="Worker Thread模式"></a>Worker Thread模式</h1><p>这个模式的经典实现就是 JDK 中的线程池了, 关于线程池的东西这里也不多说了, 主要还是重复一下注意事项吧:</p>
<ul>
<li><strong>使用有界队列</strong></li>
<li><strong>拒绝策略要慎重使用</strong></li>
<li><strong>异常处理的问题</strong></li>
<li><strong>有意义的线程名称</strong></li>
</ul>
<p>还有一个问题需要注意, <strong>死锁</strong>. 如果提交到相同线程池的任务不是相互独立的，而是有依赖关系的，那么就有可能导致线程死锁。实际工作中，我就亲历过这种线程死锁的场景。具体现象是应用每运行一段时间偶尔就会处于无响应的状态，监控数据看上去一切都正常，但是实际上已经不能正常工作了。</p>
<p>以下是一段死锁代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//L1、L2阶段共用的线程池</span></span><br><span class="line">ExecutorService es = Executors.</span><br><span class="line">  newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//L1阶段的闭锁    </span></span><br><span class="line">CountDownLatch l1=<span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)&#123;</span><br><span class="line">  System.out.println(<span class="string">"L1"</span>);</span><br><span class="line">  <span class="comment">//执行L1阶段任务</span></span><br><span class="line">  es.execute(()-&gt;&#123;</span><br><span class="line">    <span class="comment">//L2阶段的闭锁 </span></span><br><span class="line">    CountDownLatch l2=<span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//执行L2阶段子任务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">2</span>; j++)&#123;</span><br><span class="line">      es.execute(()-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">"L2"</span>);</span><br><span class="line">        l2.countDown();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//等待L2阶段任务执行完</span></span><br><span class="line">    l2.await();</span><br><span class="line">    l1.countDown();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等着L1阶段任务执行完</span></span><br><span class="line">l1.await();</span><br><span class="line">System.out.println(<span class="string">"end"</span>);</span><br></pre></td></tr></table></figure>
<p>当应用出现类似问题时，首选的诊断方法是查看线程栈。下图是上面示例代码停止响应后的线程栈，你会发现线程池中的两个线程全部都阻塞在 <code>l2.await();</code> 这行代码上了，也就是说，线程池里所有的线程都在等待 L2 阶段的任务执行完，那 L2 阶段的子任务什么时候能够执行完呢？永远都没那一天了，为什么呢？因为线程池里的线程都阻塞了，没有空闲的线程执行 L2 阶段的任务了。其实这种问题通用的解决方案是<strong>为不同的任务创建不同的线程池</strong>。</p>
<p>最后再次强调一下：<strong>提交到相同线程池中的任务一定是相互独立的，否则就一定要慎重</strong>。</p>
<h1 id="两阶段终止模式"><a href="#两阶段终止模式" class="headerlink" title="两阶段终止模式"></a>两阶段终止模式</h1><p>Java 语言的 Thread 类中曾经提供了一个 <code>stop()</code> 方法，用来终止线程，可是早已不建议使用了，原因是这个方法用的就是一剑封喉的做法，<strong>被终止的线程没有机会料理后事</strong>。</p>
<p>前辈们经过认真对比分析，已经总结出了一套成熟的方案，叫做<strong>两阶段终止模式</strong>。顾名思义，就是将终止过程分成两个阶段，其中第一个阶段主要是线程 T1 向线程 T2<strong>发送终止指令</strong>，而第二阶段则是线程 T2<strong>响应终止指令</strong>。</p>
<p><img src="https://cdn.yangbingdong.com/img/concurrent/java-concurrent-two-phase-terminal.png" alt></p>
<p>在 Java 中我们可以使用 Thread 提供的 interrupt() 以及自定义标志位来实现, 举个例子: 实际工作中，有些监控系统需要动态地采集一些数据，一般都是监控系统发送采集指令给被监控系统的监控代理，监控代理接收到指令之后，从监控目标收集数据，然后回传给监控系统，详细过程如下图所示。出于对性能的考虑（有些监控项对系统性能影响很大，所以不能一直持续监控），动态采集功能一般都会有终止操作。</p>
<p><img src="https://cdn.yangbingdong.com/img/concurrent/java-concurrent-two-phase-terminal2.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> </span>&#123;</span><br><span class="line">  <span class="comment">//线程终止标志位</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">boolean</span> terminated = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">//采集线程</span></span><br><span class="line">  Thread rptThread;</span><br><span class="line">  <span class="comment">//启动采集功能</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//不允许同时启动多个采集线程</span></span><br><span class="line">    <span class="keyword">if</span> (started) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    started = <span class="keyword">true</span>;</span><br><span class="line">    terminated = <span class="keyword">false</span>;</span><br><span class="line">    rptThread = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">      <span class="keyword">while</span> (!terminated)&#123;</span><br><span class="line">        <span class="comment">//省略采集、回传实现</span></span><br><span class="line">        report();</span><br><span class="line">        <span class="comment">//每隔两秒钟采集、回传一次数据</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">          <span class="comment">//重新设置线程中断状态</span></span><br><span class="line">          Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//执行到此处说明线程马上终止</span></span><br><span class="line">      started = <span class="keyword">false</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    rptThread.start();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//终止采集功能</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//设置中断标志位</span></span><br><span class="line">    terminated = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//中断线程rptThread</span></span><br><span class="line">    rptThread.interrupt();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要注意两点, 第一是没有使用 <code>Thread.currentThread().isInterrupted()</code> 来判断是因为代码中有可能会使用到第三方类库, 而我们没有办法保证第三方类库正确处理了线程的中断异常，例如第三方类库在捕获到 <code>Thread.sleep()</code> 方法抛出的中断异常后，没有重新设置线程的中断状态，那么就会导致线程不能够正常终止。还有一点是 <code>terminated</code> 标志位使用了 <code>volatile</code> 修饰来保证可见性.</p>
<h1 id="生产者-消费者模式"><a href="#生产者-消费者模式" class="headerlink" title="生产者-消费者模式"></a>生产者-消费者模式</h1><p>这个的经典实现就是线程池了, 这里不在多说.</p>
<h1 id="STM-amp-MVCC"><a href="#STM-amp-MVCC" class="headerlink" title="STM&amp;MVCC"></a>STM&amp;MVCC</h1><p>STM: Software Transactional Memory(<strong>软件事务内存</strong>), 也是解决并发方面问题的一种模式, 在数据库中见的比较多. 其中一种实现是 MVCC(Multi-Version Concurrency Control), 也就是<strong>多版本并发控制</strong>.</p>
<p>MVCC 可以简单地理解为数据库事务在开启的时候，会给数据库打一个快照，以后所有的读写都是基于这个快照的。当提交事务的时候，如果所有读写过的数据在该事务执行期间没有发生过变化，那么就可以提交；如果发生了变化，说明该事务和有其他事务读写的数据冲突了，这个时候是不可以提交的。</p>
<p>为了记录数据是否发生了变化，可以给每条数据增加一个版本号，这样每次成功修改数据都会增加版本号的值。有不少 STM 的实现方案都是基于 MVCC 的，例如知名的 Clojure STM。</p>
<p>代码示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//带版本号的对象引用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">VersionedRef</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> T value;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VersionedRef</span><span class="params">(T value, <span class="keyword">long</span> version)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.version = version;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//支持事务的引用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TxnRef</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//当前数据，带版本号</span></span><br><span class="line">    <span class="keyword">volatile</span> VersionedRef curRef;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TxnRef</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.curRef = <span class="keyword">new</span> VersionedRef(value, <span class="number">0L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前事务中的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">(Txn txn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> txn.get(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在当前事务中设置数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value, Txn txn)</span> </span>&#123;</span><br><span class="line">        txn.set(<span class="keyword">this</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事务接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Txn</span> </span>&#123;</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(TxnRef&lt;T&gt; ref)</span></span>;</span><br><span class="line">    &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(TxnRef&lt;T&gt; ref, T value)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//STM事务实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">STMTxn</span> <span class="keyword">implements</span> <span class="title">Txn</span> </span>&#123;</span><br><span class="line">    <span class="comment">//事务ID生成器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicLong txnSeq = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前事务所有的相关数据</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;TxnRef, VersionedRef&gt; inTxnMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//当前事务所有需要修改的数据</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;TxnRef, Object&gt; writeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//当前事务ID</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> txnId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数，自动生成当前事务ID</span></span><br><span class="line">    STMTxn() &#123;</span><br><span class="line">        txnId = txnSeq.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前事务中的数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(TxnRef&lt;T&gt; ref)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将需要读取的数据，加入inTxnMap</span></span><br><span class="line">        <span class="keyword">if</span> (!inTxnMap.containsKey(ref)) &#123;</span><br><span class="line">            inTxnMap.put(ref, ref.curRef);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) inTxnMap.get(ref).value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在当前事务中修改数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(TxnRef&lt;T&gt; ref, T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将需要修改的数据，加入inTxnMap</span></span><br><span class="line">        <span class="keyword">if</span> (!inTxnMap.containsKey(ref)) &#123;</span><br><span class="line">            inTxnMap.put(ref, ref.curRef);</span><br><span class="line">        &#125;</span><br><span class="line">        writeMap.put(ref, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (STM.commitLock) &#123;</span><br><span class="line">            <span class="comment">//是否校验通过</span></span><br><span class="line">            <span class="keyword">boolean</span> isValid = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//校验所有读过的数据是否发生过变化</span></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;TxnRef, VersionedRef&gt; entry : inTxnMap.entrySet()) &#123;</span><br><span class="line">                VersionedRef curRef = entry.getKey().curRef;</span><br><span class="line">                VersionedRef readRef = entry.getValue();</span><br><span class="line">                <span class="comment">//通过版本号来验证数据是否发生过变化</span></span><br><span class="line">                <span class="keyword">if</span> (curRef.version != readRef.version) &#123;</span><br><span class="line">                    isValid = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果校验通过，则所有更改生效</span></span><br><span class="line">            <span class="keyword">if</span> (isValid) &#123;</span><br><span class="line">                writeMap.forEach((k, v) -&gt; &#123;</span><br><span class="line">                    k.curRef = <span class="keyword">new</span> VersionedRef(v, txnId);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> isValid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TxnRunnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(Txn txn)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//STM</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">STM</span> </span>&#123;</span><br><span class="line">    <span class="comment">//私有化构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">STM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提交数据需要用到的全局锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Object commitLock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原子化提交方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">atomic</span><span class="params">(TxnRunnable action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> committed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//如果没有提交成功，则一直重试</span></span><br><span class="line">        <span class="keyword">while</span> (!committed) &#123;</span><br><span class="line">            <span class="comment">//创建新的事务</span></span><br><span class="line">            STMTxn txn = <span class="keyword">new</span> STMTxn();</span><br><span class="line">            <span class="comment">//执行业务逻辑</span></span><br><span class="line">            action.run(txn);</span><br><span class="line">            <span class="comment">//提交事务</span></span><br><span class="line">            committed = txn.commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="comment">//余额</span></span><br><span class="line">    <span class="keyword">private</span> TxnRef&lt;Integer&gt; balance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">int</span> balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = <span class="keyword">new</span> TxnRef&lt;&gt;(balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转账操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account target, <span class="keyword">int</span> amt)</span> </span>&#123;</span><br><span class="line">        STM.atomic((txn) -&gt; &#123;</span><br><span class="line">            Integer from = balance.getValue(txn);</span><br><span class="line">            balance.setValue(from - amt, txn);</span><br><span class="line">            Integer to = target.balance.getValue(txn);</span><br><span class="line">            target.balance.setValue(to + amt, txn);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总的来说其实就是通过版本号来控制并发, 只不过这里面还多了个<strong>副本</strong>的概念.</p>
<p>STM 借鉴的是数据库的经验，数据库虽然复杂，但仅仅存储数据，而编程语言除了有共享变量之外，还会执行各种 I/O 操作，<strong>很显然 I/O 操作是很难支持回滚的</strong>。所以，STM 也不是万能的。目前支持 STM 的编程语言主要是函数式语言，函数式语言里的数据天生具备不可变性，利用这种不可变性实现 STM 相对来说更简单。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>Immutability 模式</strong>、<strong>Copy-on-Write 模式</strong>和<strong>线程本地存储模式</strong>本质上都是为了<strong>避免共享</strong>，只是实现手段不同而已。这 3 种设计模式的实现都很简单，但是实现过程中有些细节还是需要格外注意的。例如，<strong>使用 Immutability 模式需要注意对象属性的不可变性</strong>，<strong>使用 Copy-on-Write 模式需要注意性能问题</strong>，<strong>使用线程本地存储模式需要注意异步执行问题</strong>。</p>
<p><strong>Guarded Suspension 模式</strong>和 <strong>Balking 模式</strong>都可以简单地理解为”多线程版本的 if”，但它们的区别在于前者会等待 if 条件变为真，而后者则不需要等待。</p>
<p><strong>Thread-Per-Message 模式</strong>、<strong>Worker Thread 模式</strong>和<strong>生产者 - 消费者模式</strong>是三种<strong>最简单实用的多线程分工方法</strong>。Thread-Per-Message 模式在实现的时候需要注意是否存在线程的频繁创建、销毁以及是否可能导致 <strong>OOM</strong>。Worker Thread 模式的实现，需要注意潜在的线程<strong>死锁问题</strong>, 以及<strong>任务之间没有依赖关系</strong>这个因素要慎重考虑。</p>
]]></content><categories><category>Programming</category><category>Java</category><category>Concurrent</category></categories><tags><tag>Java</tag><tag>Concurrent</tag></tags></entry><entry><title>Java开发人员最常犯的10个错误以及35个代码性能优化小结</title><url>/2017/java-dev-ten-mistake-and-some-advice/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/java/mistake.jpg" alt></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>人非圣贤孰能无过, 编程更是一门要求非常严谨的学问, 难免会在敲代码时一个不留神就产生一个BUG, 解决一个BUG难免又会出现十个BUG.<br>代码优化, 一个很重要的课题. 可能有些人觉得没用, 一些细小的地方有什么好修改的, 改与不改对于代码的运行效率有什么影响呢？这个问题我是这么考虑的, 就像大海里面的鲸鱼一样, 它吃一条小虾米有用吗？没用, 但是, 吃的小虾米一多之后, 鲸鱼就被喂饱了. 代码优化也是一样, 如果项目着眼于尽快无BUG上线, 那么此时可以抓大放小, 代码的细节可以不精打细磨；但是如果有足够的时间开发、维护代码, 这时候就必须考虑每个可以优化的细节了, 一个一个细小的优化点累积起来, 对于代码的运行效率绝对是有提升的.<br>下面博主就分享一下Java开发人员最常犯的10个错误以及一些代码优化, 也希望自己把这些优化当成习惯融入平时.<br><a id="more"></a></p>
</blockquote>
<h1 id="一、把数组转成ArrayList"><a href="#一、把数组转成ArrayList" class="headerlink" title="一、把数组转成ArrayList"></a>一、把数组转成ArrayList</h1><p>为了将数组转换为ArrayList, 开发者经常会这样做:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(arr);</span><br></pre></td></tr></table></figure></p>
<p>使用<code>Arrays.asList()</code>方法可以得到一个<code>ArrayList</code>, 但是得到这个<code>ArrayList</code>其实是定义在<code>Arrays</code>类中的一个私有的静态内部类. 这个类虽然和j<code>ava.util.ArrayList</code>同名, 但是并不是同一个类. <code>java.util.Arrays.ArrayList</code>类中实现了<code>set()</code>, <code>get()</code>, <code>contains()</code>等方法, 但是并<strong>没有定义向其中增加元素的方法</strong>. 也就是说通过<code>Arrays.asList()</code>得到的<code>ArrayList</code>的大小是<strong>固定</strong>的. </p>
<p>如果在开发过程中, 想得到一个真正的<code>ArrayList</code>对象（<code>java.util.ArrayList</code>的实例）, 可以通过以下方式:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(Arrays.asList(arr));</span><br></pre></td></tr></table></figure></p>
<p><code>java.util.ArrayList</code>中包含一个可以接受集合类型参数的构造函数. 因为<code>java.util.Arrays.ArrayList</code>这个内部类继承了<code>AbstractList</code>类, 所以, 该类也是<code>Collection</code>的子类. </p>
<h1 id="二、判断一个数组是否包含某个值"><a href="#二、判断一个数组是否包含某个值" class="headerlink" title="二、判断一个数组是否包含某个值"></a>二、判断一个数组是否包含某个值</h1><p>在判断一个数组中是否包含某个值的时候, 开发者经常这样做:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(arr));</span><br><span class="line"><span class="keyword">return</span> set.contains(targetValue);</span><br></pre></td></tr></table></figure></p>
<p>在在<strong><em><a href="http://www.hollischuang.com/archives/1269" rel="external nofollow noopener noreferrer" target="_blank">Java中如何高效的判断数组中是否包含某个元素</a></em></strong>一文中, 深入分析过, 以上方式虽然可以实现功能, 但是效率却比较低. 因为将数组压入<code>Collection</code>类型中, 首先要将数组元素遍历一遍, 然后再使用集合类做其他操作. </p>
<p>在判断一个数组是否包含某个值的时候, 推荐使用<strong><code>for</code>循环遍历</strong>的形式或者使用<code>Apache</code> <code>Commons</code>类库中提供的<code>ArrayUtils</code>类的<code>contains</code>方法. </p>
<h1 id="三、在循环中删除列表中的元素"><a href="#三、在循环中删除列表中的元素" class="headerlink" title="三、在循环中删除列表中的元素"></a>三、在循环中删除列表中的元素</h1><p>在讨论这个问题之前, 先考虑以下代码的输出结果:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">    list.remove(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure></p>
<p>输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[b,d]</span><br></pre></td></tr></table></figure></p>
<p>以上代码的目的是想遍历删除<code>list</code>中所有元素, 但是结果却没有成功. 原因是忽略了一个关键的问题: 当一个元素被删除时, <strong>列表的大小缩小</strong>并且<strong>下标也会随之变化</strong>, 所以当你想要在一个循环中用下标删除多个元素的时候, 它并不会正常的生效. </p>
<p>也有些人知道以上代码的问题就由于数组下标变换引起的. 所以, 他们想到使用增强for循环的形式:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>));</span><br><span class="line"><span class="keyword">for</span>(String s:list)&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.equals(<span class="string">"a"</span>))&#123;</span><br><span class="line">        list.remove(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是, 很不幸的是, 以上代码会抛出<code>ConcurrentModificationException</code>, 有趣的是, 如果在<code>remove</code>操作后增加一个<code>break</code>, 代码就不会报错:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;));</span><br><span class="line">for(String s:list)&#123;</span><br><span class="line">    if(s.equals(&quot;a&quot;))&#123;</span><br><span class="line">        list.remove(s);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Java中的<strong><em><a href="http://www.hollischuang.com/archives/33" rel="external nofollow noopener noreferrer" target="_blank">fail-fast</a></em></strong>机制一文中, 深入分析了几种在遍历数组的同时删除其中元素的方法以及各种方法存在的问题. 其中就介绍了上面的代码出错的原因. </p>
<blockquote>
<p>迭代器（<code>Iterator</code>）是工作在一个独立的线程中, 并且拥有一个 <code>mutex</code> 锁. 迭代器被创建之后会建立一个<strong>指向</strong>原来对象的<strong>单链索引表</strong>, 当原来的对象数量发生<strong>变化</strong>时, 这个索引表的内容<strong>不会同步改变</strong>, 所以当索引指针往后移动的时候就找不到要迭代的对象, 所以按照 <code>fail-fast</code> 原则迭代器会马上抛出<code>java.util.ConcurrentModificationException</code>异常. </p>
</blockquote>
<p>所以, 正确的在遍历过程中删除元素的方法应该是使用<code>Iterator</code>:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>));</span><br><span class="line">Iterator&lt;String&gt; iter = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">    String s = iter.next();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s.equals(<span class="string">"a"</span>)) &#123;</span><br><span class="line">        iter.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>next()</code>方法必须在调用<code>remove()</code>方法之前调用. 如果在循环过程中先调用<code>remove()</code>, 再调用<code>next()</code>, 就会导致异常<code>ConcurrentModificationException</code>. 原因如上. </p>
<h1 id="四、HashTable-和-HashMap-的选择"><a href="#四、HashTable-和-HashMap-的选择" class="headerlink" title="四、HashTable 和 HashMap 的选择"></a>四、HashTable 和 HashMap 的选择</h1><p>了解算法的人可能对<code>HashTable</code>比较熟悉, 因为他是一个数据结构的名字. 但在Java里边, 用<code>HashMap</code>来表示这样的数据结构. <code>Hashtable</code>和<code>HashMap</code>的一个关键性的不同是, <code>HashTable</code>是同步的, 而<code>HashMap</code>不是. 所以通常不需要<code>HashTable</code>, <code>HashMap</code>用的更多. </p>
<p><strong><em><a href="http://www.hollischuang.com/archives/82" rel="external nofollow noopener noreferrer" target="_blank">HashMap完全解读</a></em></strong>、<strong><em><a href="http://www.hollischuang.com/archives/442" rel="external nofollow noopener noreferrer" target="_blank">Java中常见亲属比较</a></em></strong>等文章中介绍了他们的区别和如何选择. </p>
<h1 id="五、使用原始集合类型"><a href="#五、使用原始集合类型" class="headerlink" title="五、使用原始集合类型"></a>五、使用原始集合类型</h1><p>在Java里边, 原始类型和无界通配符类型很容易混合在一起. 以<code>Set</code>为例, <code>Set</code>是一个原始类型, 而<code>Set&lt; ? &gt;</code>是一个无界通配符类型. （可以把原始类型理解为没有使用泛型约束的类型）</p>
<p>考虑下面使用原始类型List作为参数的代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void add(List list, Object o)&#123;</span><br><span class="line">    list.add(o);</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">    add(list, 10);</span><br><span class="line">    String s = list.get(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码将会抛出异常:<br><code>java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</code></p>
<p>使用原始集合类型是很危险的, 因为原始集合类型跳过了泛型类型检查, 是不安全的. <code>Set</code>、<code>Set&lt; ? &gt;</code>和<code>Set&lt; Object &gt;</code>之间有很大差别. 关于泛型, 可以参考下列文章: <strong><em><a href="http://www.hollischuang.com/archives/1182" rel="external nofollow noopener noreferrer" target="_blank">《成神之路-基础篇》Java基础知识——泛型</a></em></strong></p>
<h1 id="六、访问级别"><a href="#六、访问级别" class="headerlink" title="六、访问级别"></a>六、访问级别</h1><p>程序员们经常使用<code>public</code>作为类中的字段的修饰符, 因为这样可以很简单的通过引用得到值, 但这并不是好的设计, 按照经验, 分配给成员变量的访问级别应该尽可能的低. 参考<strong><em><a href="http://www.hollischuang.com/archives/1334" rel="external nofollow noopener noreferrer" target="_blank">Java中的四种访问级别</a></em></strong></p>
<h1 id="七、ArrayList与LinkedList的选择"><a href="#七、ArrayList与LinkedList的选择" class="headerlink" title="七、ArrayList与LinkedList的选择"></a>七、ArrayList与LinkedList的选择</h1><p>当程序员们不知道<code>ArrayList</code>与<code>LinkedList</code>的区别时, 他们经常使用<code>ArrayList</code>, 因为它看起来比较熟悉. 然而, 它们之前有巨大的性能差别. 在<strong><em><a href="http://www.hollischuang.com/archives/1349" rel="external nofollow noopener noreferrer" target="_blank">ArrayList vs LinkedList vs Vector 区别</a></em></strong>、<strong><em><a href="http://www.hollischuang.com/archives/442" rel="external nofollow noopener noreferrer" target="_blank">Java中常见亲属比较</a></em></strong>等文章中介绍过, 简而言之, 如果有大量的增加删除操作并且没有很多的随机访问元素的操作, 应该首先LinkedList. （LinkedList更适合从中间插入或者删除（链表的特性））</p>
<h1 id="八、可变与不可变"><a href="#八、可变与不可变" class="headerlink" title="八、可变与不可变"></a>八、可变与不可变</h1><p>在<strong><em><a href="http://www.hollischuang.com/archives/1246" rel="external nofollow noopener noreferrer" target="_blank">为什么Java要把字符串设计成不可变的</a></em></strong>一文中介绍过, 不可变对象有许多的优点, 比如简单, 安全等等. 同时, 也有人提出疑问: 既然不可变有这么多好处, 为什么不把所有类都搞成不可变的呢？</p>
<p>通常情况下, 可变对象可以用来避免产生过多的中间对象. 一个经典的实例就是连接大量的字符串, 如果使用不可变的字符串, 将会产生大量的需要进行垃圾回收的对象. 这会浪费CPU大量的时间, 使用可变对象才是正确的方案(比如<code>StringBuilder</code>).<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String result=&quot;&quot;;</span><br><span class="line">for(String s: arr)&#123;</span><br><span class="line">    result = result + s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong><em><a href="http://stackoverflow.com/questions/23616211/why-we-need-mutable-classes" rel="external nofollow noopener noreferrer" target="_blank">StackOverflow</a></em></strong>中也有关于这个的讨论. </p>
<h1 id="九、父类和子类的构造函数"><a href="#九、父类和子类的构造函数" class="headerlink" title="九、父类和子类的构造函数"></a>九、父类和子类的构造函数</h1><p>首先, 我们都知道: </p>
<ul>
<li>如果一个类没有定义构造函数, 编译器将会插入一个无参数的默认构造函数. </li>
<li>如果一个类中定义了一个带参数的构造函数, 那么编译器就不会再帮我们创建无参的构造函数. </li>
<li><code>Super</code>类中定义了一个带参数的构造函数. 编译器将不会插入默认的无参数构造函数. </li>
</ul>
<p>我们还应该知道: </p>
<ul>
<li>子类的所有构造函数（无论是有参还是无参）在执行时, 都会调用父类的<strong>无参构造函数</strong>. </li>
</ul>
<p>所以, 编译器试图调用<code>Super</code>类中的无参构造函数. 但是父类默认的构造函数未定义, 编译器就会报出这个错误信息.<br>要解决这个问题, 可以简单的通过</p>
<ul>
<li><p>1)在父类中添加一个<code>Super()</code>构造方法, 就像这样: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Super()&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2)移除自定义的父类构造函数</p>
</li>
<li><p>3)在子类的构造函数中调用父类的<code>super(value)</code>. </p>
</li>
</ul>
<h1 id="十、””还是构造函数？"><a href="#十、””还是构造函数？" class="headerlink" title="十、””还是构造函数？"></a>十、””还是构造函数？</h1><p>关于这个问题, 也是程序员经常出现困惑的地方, 在<strong><em><a href="http://www.hollischuang.com/archives/1249" rel="external nofollow noopener noreferrer" target="_blank">该如何创建字符串, 使用” “还是构造函数？</a></em></strong>中也介绍过. </p>
<blockquote>
<p>如果你只需要创建一个字符串, 你可以使用双引号的方式, 如果你需要在堆中创建一个新的对象, 你可以选择构造函数的方式. </p>
</blockquote>
<p>在<code>String d = new String(&quot;abcd&quot;)</code>时, 因为字面值“abcd”已经是字符串类型, 那么使用构造函数方式只会创建一个额外没有用处的对象. </p>
<h1 id="35个Java代码性能优化总结"><a href="#35个Java代码性能优化总结" class="headerlink" title="35个Java代码性能优化总结"></a>35个Java代码性能优化总结</h1><p><strong>代码优化的目标是: </strong></p>
<ul>
<li>减小代码的体积</li>
<li>提高代码运行的效率</li>
</ul>
<h2 id="1、尽量指定类、方法的final修饰符"><a href="#1、尽量指定类、方法的final修饰符" class="headerlink" title="1、尽量指定类、方法的final修饰符"></a>1、尽量指定类、方法的final修饰符</h2><p>带有final修饰符的类是不可派生的. 在Java核心API中, 有许多应用final的例子, 例如<code>java.lang.String</code>, 整个类都是final的. 为类指定final修饰符可以让类不可以被继承, 为方法指定final修饰符可以让方法不可以被重写. 如果指定了一个类为final, 则该类所有的方法都是final的. Java编译器会寻找机会<strong>内联</strong>所有的final方法, <strong>内联对于提升Java运行效率作用重大, 具体参见Java运行期优化. 此举能够使性能平均提高50%</strong>. </p>
<h2 id="2、尽量重用对象"><a href="#2、尽量重用对象" class="headerlink" title="2、尽量重用对象"></a>2、尽量重用对象</h2><p>特别是String对象的使用, 出现字符串连接时应该使用<code>StringBuilder</code>/<code>StringBuffer</code>代替. 由于Java虚拟机不仅要花时间生成对象, 以后可能还需要花时间对这些对象进行垃圾回收和处理, 因此, 生成过多的对象将会给程序的性能带来很大的影响. </p>
<h2 id="3、尽可能使用局部变量"><a href="#3、尽可能使用局部变量" class="headerlink" title="3、尽可能使用局部变量"></a>3、尽可能使用局部变量</h2><p>调用方法时传递的参数以及在调用中创建的临时变量都<strong>保存在栈中速度较快</strong>, 其他变量, 如静态变量、实例变量等, 都在堆中创建, 速度较慢. 另外, 栈中创建的变量, <strong>随着方法的运行结束</strong>, 这些内容就没了, 不需要额外的垃圾回收. </p>
<h2 id="4、及时关闭流"><a href="#4、及时关闭流" class="headerlink" title="4、及时关闭流"></a>4、及时关闭流</h2><p>Java编程过程中, 进行数据库连接、I/O流操作时务必小心, 在使用完毕后, 及时关闭以释放资源. 因为对这些大对象的操作会造成系统大的开销, 稍有不慎, 将会导致严重的后果. </p>
<h2 id="5、尽量减少对变量的重复计算"><a href="#5、尽量减少对变量的重复计算" class="headerlink" title="5、尽量减少对变量的重复计算"></a>5、尽量减少对变量的重复计算</h2><p>明确一个概念, <strong>对方法的调用</strong>, 即使方法中只有一句语句, 也是有消耗的, 包括<strong>创建栈帧</strong>、<strong>调用方法时保护现场</strong>、<strong>调用方法完毕时恢复现场</strong>等. 所以例如下面的操作:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>建议替换为: </strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, <span class="keyword">int</span> length = list.size(); i &lt; length; i++)</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样, 在<code>list.size()</code>很大的时候, 就减少了很多的消耗</p>
<h2 id="6、尽量采用懒加载的策略-即在需要的时候才创建"><a href="#6、尽量采用懒加载的策略-即在需要的时候才创建" class="headerlink" title="6、尽量采用懒加载的策略, 即在需要的时候才创建"></a>6、尽量采用懒加载的策略, 即在需要的时候才创建</h2><p>例如:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"aaa"</span>;<span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">list.add(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>建议替换为:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">String str = <span class="string">"aaa"</span>;</span><br><span class="line"></span><br><span class="line">list.add(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="7、慎用异常"><a href="#7、慎用异常" class="headerlink" title="7、慎用异常"></a>7、慎用异常</h2><p><strong>异常对性能不利</strong>. 抛出异常首先要创建一个新的对象, <code>Throwable</code>接口的构造函数调用名为<code>fillInStackTrace()</code>的本地同步方法, <code>fillInStackTrace()</code>方法检查堆栈, 收集调用跟踪信息. 只要有异常被抛出, Java虚拟机就必须调整调用堆栈, 因为在处理过程中创建了一个新的对象. 异常只能用于错误处理, 不应该用来控制程序流程. </p>
<h2 id="8、不要在循环中使用try…catch…-应该把其放在最外层"><a href="#8、不要在循环中使用try…catch…-应该把其放在最外层" class="headerlink" title="8、不要在循环中使用try…catch…, 应该把其放在最外层"></a>8、不要在循环中使用try…catch…, 应该把其放在最外层</h2><p>除非不得已. 如果毫无理由地这么写了, 只要你的领导资深一点、有强迫症一点, 八成就要骂你为什么写出这种垃圾代码来了. </p>
<h2 id="9、如果能估计到待添加的内容长度-为底层以数组方式实现的集合、工具类指定初始长度"><a href="#9、如果能估计到待添加的内容长度-为底层以数组方式实现的集合、工具类指定初始长度" class="headerlink" title="9、如果能估计到待添加的内容长度, 为底层以数组方式实现的集合、工具类指定初始长度"></a>9、如果能估计到待添加的内容长度, 为底层以数组方式实现的集合、工具类指定初始长度</h2><p>比如<code>ArrayList</code>、<code>LinkedLlist</code>、<code>StringBuilder</code>、<code>StringBuffer</code>、<code>HashMap</code>、<code>HashSet</code>等等, 以<code>StringBuilder</code>为例:<br>（1）<code>StringBuilder()</code>　　　　　　// 默认分配16个字符的空间<br>（2）<code>StringBuilder(int size)</code>　　// 默认分配size个字符的空间<br>（3）<code>StringBuilder(String str)</code>　// 默认分配16个字符+str.length()个字符空间<br>可以通过类（这里指的不仅仅是上面的<code>StringBuilder</code>）的来设定它的初始化容量, 这样可以明显地提升性能. 比如<code>StringBuilder</code>吧, <code>length</code>表示当前的<code>StringBuilder</code>能保持的字符数量. 因为当<code>StringBuilde</code>r达到最大容量的时候, 它会将自身容量增加到当前的2倍再加2, 无论何时只要<code>StringBuilder</code>达到它的最大容量, 它就不得不创建一个新的字符数组然后将旧的字符数组内容拷贝到新字符数组中—-这是十分耗费性能的一个操作. 试想, 如果能预估到字符数组中大概要存放5000个字符而不指定长度, 最接近5000的2次幂是4096, 每次扩容加的2不管, 那么:<br>（1）在4096 的基础上, 再申请8194个大小的字符数组, 加起来相当于一次申请了12290个大小的字符数组, 如果一开始能指定5000个大小的字符数组, 就节省了一倍以上的空间<br>（2）把原来的4096个字符拷贝到新的的字符数组中去<br>这样, 既浪费内存空间又降低代码运行效率. 所以, 给底层以数组实现的集合、工具类设置一个合理的初始化容量是错不了的, 这会带来立竿见影的效果. 但是, 注意, 像<code>HashMap</code>这种是以数组+链表实现的集合, 别把初始大小和你估计的大小设置得一样, 因为一个table上只连接一个对象的可能性几乎为0. 初始大小建议设置为2的N次幂, 如果能估计到有2000个元素, 设置成<code>new HashMap(128)</code>、<code>new HashMap(256)</code>都可以. </p>
<h2 id="10、当复制大量数据时-使用System-arraycopy-命令"><a href="#10、当复制大量数据时-使用System-arraycopy-命令" class="headerlink" title="10、当复制大量数据时, 使用System.arraycopy()命令"></a>10、当复制大量数据时, 使用System.arraycopy()命令</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Object dest,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> length)</span></span></span><br></pre></td></tr></table></figure>
<p>src:源数组；    srcPos:源数组要复制的起始位置；<br>dest:目的数组；    destPos:目的数组放置的起始位置；    length:复制的长度. </p>
<p>注意: src and dest都必须是同类型或者可以进行转换类型的数组．<br>有趣的是这个函数可以实现自己到自己复制, 比如:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] fun =&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;; </span><br><span class="line">System.arraycopy(fun,<span class="number">0</span>,fun,<span class="number">3</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure></p>
<p>则结果为: {0,1,2,0,1,2,6};<br>实现过程是这样的, 先生成一个长度为length的临时数组,将fun数组中srcPos<br>到<code>srcPos+length-1</code>之间的数据拷贝到临时数组中, 再执行<code>System.arraycopy(临时数组,0,fun,3,3)</code>.</p>
<h2 id="11、乘法和除法使用移位操作"><a href="#11、乘法和除法使用移位操作" class="headerlink" title="11、乘法和除法使用移位操作"></a>11、乘法和除法使用移位操作</h2><p>例如:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (val = <span class="number">0</span>; val &lt; <span class="number">100000</span>; val += <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">a = val * <span class="number">8</span>;</span><br><span class="line">b = val / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用移位操作可以极大地提高性能, 因为在计算机底层, 对位的操作是最方便、最快的, 因此建议修改为:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (val = <span class="number">0</span>; val &lt; <span class="number">100000</span>; val += <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">a = val &lt;&lt; <span class="number">3</span>;</span><br><span class="line">b = val &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>移位操作虽然快, 但是可能会使代码不太好理解, 因此最好加上相应的注释. </p>
<h2 id="12、循环内不要不断创建对象引用"><a href="#12、循环内不要不断创建对象引用" class="headerlink" title="12、循环内不要不断创建对象引用"></a>12、循环内不要不断创建对象引用</h2><p>例如:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; i++)</span><br><span class="line">&#123;</span><br><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种做法会导致内存中有<code>count</code>份<code>Object</code>对象引用存在, <code>count</code>很大的话, 就耗费内存了, 建议为改为:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">null</span>;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= count; i++) &#123; obj = <span class="keyword">new</span> Object(); &#125;</span><br></pre></td></tr></table></figure></p>
<p>这样的话, 内存中只有一份Object对象引用, 每次<code>new Object()</code>的时候, <code>Object</code>对象引用指向不同的<code>Object</code>罢了, 但是内存中只有一份, 这样就大大节省了内存空间了. </p>
<h2 id="13、基于效率和类型检查的考虑-应该尽可能使用array-无法确定数组大小时才使用ArrayList"><a href="#13、基于效率和类型检查的考虑-应该尽可能使用array-无法确定数组大小时才使用ArrayList" class="headerlink" title="13、基于效率和类型检查的考虑, 应该尽可能使用array, 无法确定数组大小时才使用ArrayList"></a>13、基于效率和类型检查的考虑, 应该尽可能使用array, 无法确定数组大小时才使用ArrayList</h2><h2 id="14、尽量使用HashMap、ArrayList、StringBuilder"><a href="#14、尽量使用HashMap、ArrayList、StringBuilder" class="headerlink" title="14、尽量使用HashMap、ArrayList、StringBuilder"></a>14、尽量使用HashMap、ArrayList、StringBuilder</h2><p>除非线程安全需要, 否则不推荐使用<code>Hashtable</code>、<code>Vector</code>、<code>StringBuffer</code>, 后三者由于使用同步机制而导致了性能开销</p>
<h2 id="15、不要将数组声明为public-static-final"><a href="#15、不要将数组声明为public-static-final" class="headerlink" title="15、不要将数组声明为public static final"></a>15、不要将数组声明为public static final</h2><p>因为这毫无意义, 这样只是定义了引用为<code>static final</code>, 数组的内容还是可以随意改变的, 将数组声明为<code>public</code>更是一个安全漏洞, 这意味着这个数组可以被外部类所改变</p>
<h2 id="16、尽量在合适的场合使用单例"><a href="#16、尽量在合适的场合使用单例" class="headerlink" title="16、尽量在合适的场合使用单例"></a>16、尽量在合适的场合使用单例</h2><p>使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率, 但并不是所有地方都适用于单例, 简单来说, 单例主要适用于以下三个方面:<br>（1）控制资源的使用, 通过线程同步来控制资源的并发访问<br>（2）控制实例的产生, 以达到节约资源的目的<br>（3）控制数据的共享, 在不建立直接关联的条件下, 让多个不相关的进程或线程之间实现通信</p>
<h2 id="17、尽量避免随意使用静态变量"><a href="#17、尽量避免随意使用静态变量" class="headerlink" title="17、尽量避免随意使用静态变量"></a>17、尽量避免随意使用静态变量</h2><p>要知道, 当某个对象被定义为<code>static</code>的变量所引用, 那么gc通常是不会回收这个对象所占有的堆内存的, 如:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> B b = <span class="keyword">new</span> B();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="18、及时清除不再需要的会话"><a href="#18、及时清除不再需要的会话" class="headerlink" title="18、及时清除不再需要的会话"></a>18、及时清除不再需要的会话</h2><p>为了清除不再活动的会话, 许多应用服务器都有默认的会话超时时间, 一般为30分钟. 当应用服务器需要保存更多的会话时, 如果内存不足, 那么操作系统会把部分数据转移到磁盘, 应用服务器也可能根据MRU（最近最频繁使用）算法把部分不活跃的会话转储到磁盘, 甚至可能抛出内存不足的异常. 如果会话要被转储到磁盘, 那么必须要先被序列化, 在大规模集群中, 对对象进行序列化的代价是很昂贵的. 因此, 当会话不再需要时, 应当及时调用<code>HttpSession</code>的<code>invalidate()</code>方法清除会话.<br>此时静态变量b的生命周期与A类相同, 如果A类不被卸载, 那么引用B指向的B对象会常驻内存, 直到程序终止. </p>
<h2 id="19、实现RandomAccess接口的集合比如ArrayList-应当使用最普通的for循环而不是foreach循环来遍历"><a href="#19、实现RandomAccess接口的集合比如ArrayList-应当使用最普通的for循环而不是foreach循环来遍历" class="headerlink" title="19、实现RandomAccess接口的集合比如ArrayList, 应当使用最普通的for循环而不是foreach循环来遍历"></a>19、实现RandomAccess接口的集合比如ArrayList, 应当使用最普通的for循环而不是foreach循环来遍历</h2><p>这是JDK推荐给用户的. JDK API对于<code>RandomAccess</code>接口的解释是: 实现<code>RandomAccess</code>接口用来表明其支持快速随机访问, 此接口的主要目的是允许一般的算法更改其行为, 从而将其应用到随机或连续访问列表时能提供良好的性能. 实际经验表明, <strong>实现<code>RandomAccess</code>接口的类实例, 假如是随机访问的, 使用普通for循环效率将高于使用foreach循环；反过来, 如果是顺序访问的, 则使用Iterator会效率更高</strong>. 可以使用类似如下的代码作判断:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess)</span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)&#123;&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">Iterator&lt;?&gt; iterator = list.iterable(); <span class="keyword">while</span> (iterator.hasNext())&#123;iterator.next()&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>foreach</code>循环的底层实现原理就是迭代器<code>Iterator</code>, 参见Java语法糖1: 可变长度参数以及<code>foreach</code>循环原理. 所以后半句”反过来, 如果是顺序访问的, 则使用<code>Iterator</code>会效率更高”的意思就是顺序访问的那些类实例, 使用foreach循环去遍历. </p>
<h2 id="20、使用同步代码块替代同步方法"><a href="#20、使用同步代码块替代同步方法" class="headerlink" title="20、使用同步代码块替代同步方法"></a>20、使用同步代码块替代同步方法</h2><p>这点在多线程模块中的<code>synchronized</code>锁方法块一文中已经讲得很清楚了, 除非能确定一整个方法都是需要进行同步的, 否则尽量使用同步代码块, 避免对那些不需要进行同步的代码也进行了同步, 影响了代码执行效率. </p>
<h2 id="21、将常量声明为static-final-并以大写命名"><a href="#21、将常量声明为static-final-并以大写命名" class="headerlink" title="21、将常量声明为static final, 并以大写命名"></a>21、将常量声明为static final, 并以大写命名</h2><p>这样在编译期间就可以把这些内容放入常量池中, 避免运行期间计算生成常量的值. 另外, 将常量的名字以大写命名也可以方便区分出常量与变量</p>
<h2 id="22、不要创建一些不使用的对象-不要导入一些不使用的类"><a href="#22、不要创建一些不使用的对象-不要导入一些不使用的类" class="headerlink" title="22、不要创建一些不使用的对象, 不要导入一些不使用的类"></a>22、不要创建一些不使用的对象, 不要导入一些不使用的类</h2><p>这毫无意义, 如果代码中出现”The value of the local variable i is not used”、”The import java.util is never used”, 那么请删除这些无用的内容</p>
<h2 id="23、程序运行过程中避免使用反射"><a href="#23、程序运行过程中避免使用反射" class="headerlink" title="23、程序运行过程中避免使用反射"></a>23、程序运行过程中避免使用反射</h2><p>关于, 请参见反射. 反射是Java提供给用户一个很强大的功能, 功能强大往往意味着效率不高. 不建议在程序运行过程中使用尤其是频繁使用反射机制, 特别是<code>Method</code>的<code>invoke</code>方法, 如果确实有必要, 一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存—-用户只关心和对端交互的时候获取最快的响应速度, 并不关心对端的项目启动花多久时间. </p>
<h2 id="24、使用数据库连接池和线程池"><a href="#24、使用数据库连接池和线程池" class="headerlink" title="24、使用数据库连接池和线程池"></a>24、使用数据库连接池和线程池</h2><p>这两个池都是用于重用对象的, 前者可以避免频繁地打开和关闭连接, 后者可以避免频繁地创建和销毁线程</p>
<h2 id="25、使用带缓冲的输入输出流进行IO操作"><a href="#25、使用带缓冲的输入输出流进行IO操作" class="headerlink" title="25、使用带缓冲的输入输出流进行IO操作"></a>25、使用带缓冲的输入输出流进行IO操作</h2><p>带缓冲的输入输出流, 即<code>BufferedReader</code>、<code>BufferedWriter</code>、<code>BufferedInputStream</code>、<code>BufferedOutputStream</code>, 这可以极大地提升IO效率. </p>
<h2 id="26、顺序插入和随机访问比较多的场景使用ArrayList-元素删除和中间插入比较多的场景使用LinkedList"><a href="#26、顺序插入和随机访问比较多的场景使用ArrayList-元素删除和中间插入比较多的场景使用LinkedList" class="headerlink" title="26、顺序插入和随机访问比较多的场景使用ArrayList, 元素删除和中间插入比较多的场景使用LinkedList"></a>26、顺序插入和随机访问比较多的场景使用ArrayList, 元素删除和中间插入比较多的场景使用LinkedList</h2><p>这个, 理解<code>ArrayList</code>和<code>LinkedList</code>的原理就知道了</p>
<h2 id="27、不要让public方法中有太多的形参"><a href="#27、不要让public方法中有太多的形参" class="headerlink" title="27、不要让public方法中有太多的形参"></a>27、不要让public方法中有太多的形参</h2><p>public方法即对外提供的方法, 如果给这些方法太多形参的话主要有两点坏处:<br>1、违反了面向对象的编程思想, Java讲求一切都是对象, 太多的形参, 和面向对象的编程思想并不契合<br>2、参数太多势必导致方法调用的出错概率增加<br>至于这个”太多”指的是多少个, 3、4个吧. 比如我们用JDBC写一个<code>insertStudentInfo</code>方法, 有10个学生信息字段要插如<code>Student</code>表中, 可以把这10个参数封装在一个实体类中, 作为<code>insert</code>方法的形参. </p>
<h2 id="28、字符串变量和字符串常量equals的时候将字符串常量写在前面"><a href="#28、字符串变量和字符串常量equals的时候将字符串常量写在前面" class="headerlink" title="28、字符串变量和字符串常量equals的时候将字符串常量写在前面"></a>28、字符串变量和字符串常量equals的时候将字符串常量写在前面</h2><p>这是一个比较常见的小技巧了, 如果有以下代码:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">if</span> (str.equals(<span class="string">"123"</span>)) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>建议修改为:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">"123"</span>.equals(str))</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这么做主要是可以避免空指针异常</p>
<h2 id="29、请知道-在java中if-i-1-和if-1-i-是没有区别的-但从阅读习惯上讲-建议使用前者"><a href="#29、请知道-在java中if-i-1-和if-1-i-是没有区别的-但从阅读习惯上讲-建议使用前者" class="headerlink" title="29、请知道, 在java中if (i == 1)和if (1 == i)是没有区别的, 但从阅读习惯上讲, 建议使用前者"></a>29、请知道, 在java中if (i == 1)和if (1 == i)是没有区别的, 但从阅读习惯上讲, 建议使用前者</h2><p>平时有人问, ”if (i == 1)”和”if (1== i)”有没有区别, 这就要从C/C++讲起.<br>在C/C++中, ”if (i == 1)”判断条件成立, 是以0与非0为基准的, 0表示false, 非0表示true, 如果有这么一段代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int i = 2;</span><br><span class="line">if (i == 1)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;else&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C/C++判断”i==1″不成立, 所以以0表示, 即false. 但是如果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int i = 2;if (i = 1) &#123; ... &#125;else&#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>万一程序员一个不小心, 把”if (i == 1)”写成”if (i = 1)”, 这样就有问题了. 在if之内将i赋值为1, if判断里面的内容非0, 返回的就是true了, 但是明明i为2, 比较的值是1, 应该返回的false. 这种情况在C/C++的开发中是很可能发生的并且会导致一些难以理解的错误产生, 所以, 为了避免开发者在if语句中不正确的赋值操作, 建议将if语句写为:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int i = 2;if (1 == i) &#123; ... &#125;else&#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>这样, 即使开发者不小心写成了”1 = i”, C/C++编译器也可以第一时间检查出来, 因为我们可以对一个变量赋值i为1, 但是不能对一个常量赋值1为i.<br>但是, 在Java中, C/C++这种”if (i = 1)”的语法是不可能出现的, 因为一旦写了这种语法, Java就会编译报错”Type mismatch: cannot convert from int to boolean”. 但是, 尽管Java的”if (i == 1)”和”if (1 == i)”在语义上没有任何区别, 但是从阅读习惯上讲, 建议使用前者会更好些. </p>
<h2 id="33、把一个基本数据类型转为字符串-基本数据类型-toString-是最快的方式、String-valueOf-数据-次之、数据-””最慢"><a href="#33、把一个基本数据类型转为字符串-基本数据类型-toString-是最快的方式、String-valueOf-数据-次之、数据-””最慢" class="headerlink" title="33、把一个基本数据类型转为字符串, 基本数据类型.toString()是最快的方式、String.valueOf(数据)次之、数据+””最慢"></a>33、把一个基本数据类型转为字符串, 基本数据类型.toString()是最快的方式、String.valueOf(数据)次之、数据+””最慢</h2><p>把一个基本数据类型转为一般有三种方式, 我有一个<code>Integer</code>型数据<code>i</code>, 可以使用<code>i.toString()</code>、<code>String.valueOf(i)</code>、<code>i+”&quot;</code>三种方式, 三种方式的效率如何, 看一个测试:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">int</span> loopTime = <span class="number">50000</span>;</span><br><span class="line"></span><br><span class="line">Integer i = <span class="number">0</span>; <span class="keyword">long</span> startTime = System.currentTimeMillis(); <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; loopTime; j++)</span><br><span class="line">&#123;</span><br><span class="line">String str = String.valueOf(i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"String.valueOf(): "</span> + (System.currentTimeMillis() - startTime) + <span class="string">"ms"</span>);</span><br><span class="line"></span><br><span class="line">startTime = System.currentTimeMillis(); <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; loopTime; j++)</span><br><span class="line">&#123;</span><br><span class="line">String str = i.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Integer.toString(): "</span> + (System.currentTimeMillis() - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">startTime = System.currentTimeMillis(); <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; loopTime; j++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">String str = i + <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"i + \"\": "</span> + (System.currentTimeMillis() - startTime) + <span class="string">"ms"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果为:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String.valueOf(): <span class="number">11</span>ms Integer.toString(): <span class="number">5</span>ms i + <span class="string">""</span>: <span class="number">25</span>ms</span><br></pre></td></tr></table></figure></p>
<p>所以以后遇到把一个基本数据类型转为<code>String</code>的时候, 优先考虑使用<code>toString()</code>方法. 至于为什么, 很简单:<br>1、<code>String.valueOf()</code>方法底层调用了<code>Integer.toString()</code>方法, 但是会在调用前做空判断<br>2、<code>Integer.toString()</code>方法就不说了, 直接调用了<br>3、<code>i + “”</code>底层使用了<code>StringBuilder</code>实现, 先用<code>append</code>方法拼接, 再用<code>toString()</code>方法获取字符串<br>三者对比下来, 明显是2最快、1次之、3最慢. </p>
<h2 id="34、使用最有效率的方式去遍历Map"><a href="#34、使用最有效率的方式去遍历Map" class="headerlink" title="34、使用最有效率的方式去遍历Map"></a>34、使用最有效率的方式去遍历Map</h2><p>遍历<code>Map</code>的方式有很多, 通常场景下我们需要的是遍历<code>Map</code>中的<code>Key</code>和<code>Value</code>, 那么推荐使用的、效率最高的方式是:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">HashMap&lt;String, String&gt; hm = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">hm.put(<span class="string">"111"</span>, <span class="string">"222"</span>);</span><br><span class="line"></span><br><span class="line">Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = hm.entrySet();</span><br><span class="line"></span><br><span class="line">Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iter = entrySet.iterator(); <span class="keyword">while</span> (iter.hasNext())</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Map.Entry&lt;String, String&gt; entry = iter.next();</span><br><span class="line"></span><br><span class="line">System.out.println(entry.getKey() + <span class="string">"\t"</span> + entry.getValue());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你只是想遍历一下这个<code>Map</code>的<code>key</code>值, 那用”<code>Set&lt;String&gt; keySet = hm.keySet()</code>;”会比较合适一些</p>
<h2 id="35、对资源的close-建议分开操作"><a href="#35、对资源的close-建议分开操作" class="headerlink" title="35、对资源的close()建议分开操作"></a>35、对资源的close()建议分开操作</h2><p>意思是, 比如我有这么一段代码:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">XXX.close();</span><br><span class="line"></span><br><span class="line">YYY.close();</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>建议修改为:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try</span><br><span class="line">&#123; </span><br><span class="line">XXX.close(); </span><br><span class="line">&#125;catch (Exception e) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">try</span><br><span class="line">&#123; </span><br><span class="line">YYY.close(); </span><br><span class="line">&#125;catch (Exception e) </span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>虽然有些麻烦, 却能避免资源泄露. 我们想, 如果没有修改过的代码, 万一<code>XXX.close()</code>抛异常了, 那么就进入了<code>cath</code>块中了, <code>YYY.close()</code>不会执行, <code>YYY</code>这块资源就不会回收了, 一直占用着, 这样的代码一多, 是可能引起资源句柄泄露的. 而改为下面的写法之后, 就保证了无论如何<code>XXX</code>和<code>YYY</code>都会被<code>close</code>掉. </p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><strong><em><a href="http://www.programcreek.com/2014/05/top-10-mistakes-java-developers-make/" rel="external nofollow noopener noreferrer" target="_blank">Top 10 Mistakes Java Developers Make</a></em></strong><br><strong><em><a href="http://www.hollischuang.com/archives/1360" rel="external nofollow noopener noreferrer" target="_blank">http://www.hollischuang.com/archives/1360</a></em></strong><br><strong><em><a href="http://www.jianshu.com/p/436943216526" rel="external nofollow noopener noreferrer" target="_blank">http://www.jianshu.com/p/436943216526</a></em></strong></p>
</blockquote>
]]></content><categories><category>Programming</category><category>Java</category></categories><tags><tag>Java</tag></tags></entry><entry><title>JVM知识杂汇</title><url>/2017/jvm-knowledge-collect-01/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/jvm/structure.png" alt></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>想要深刻地理解Java, 那么就要深入地理解底层——JVM(Java Virtual Machine | Java虚拟机).<br>JVM（Java Virtual Machine）Java 虚拟机是整个 java 平台的基石, 是 java 系统实现硬件无关与操作系统无关的关键部分, 是保障用户机器免于恶意代码损害的屏障. Java开发人员不需要了解JVM是如何工作的, 但是, 了解 JVM 有助于我们更好的开（通）发（过） java（公司） 程（面）序（试）<br>博主经过一番查阅, 找到了自认为写的好的一些文章, 并记录总结, 方便不定时的看.<br>希望每次看都会有新的领悟, 不断提高自己. </p>
</blockquote>
<a id="more"></a>
<h1 id="Java虚拟机架构"><a href="#Java虚拟机架构" class="headerlink" title="Java虚拟机架构"></a>Java虚拟机架构</h1><h2 id="什么是JVM"><a href="#什么是JVM" class="headerlink" title="什么是JVM"></a>什么是JVM</h2><p>要想说明白什么 JVM 就不得不提另外两个概念, JRE 和 JDK, 初学者总是把这几个概念搞混.<br><img src="https://cdn.yangbingdong.com/img/jvm/java-tutorial.png" alt><br>JVM, JRE, JDK 都是 Java 语言的支柱, 他们分工协作. 但不同的是 <strong>JDK 和 JRE 是真实存在的</strong>, 而 JVM 是一个<strong>抽象</strong>的概念, 并不真实存在. </p>
<h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>JDK(Java Development Kit) 是 Java 语言的软件开发工具包（SDK）. JDK 物理存在, 是 programming tools、JRE 和 JVM 的一个集合.<br><img src="https://cdn.yangbingdong.com/img/jvm/jdk.png" alt></p>
<h3 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h3><p>JRE（Java Runtime Environment）Java 运行时环境, JRE 物理存在, 主要由Java API 和 JVM 组成, 提供了用于执行 Java 应用程序最低要求的环境.<br><img src="https://cdn.yangbingdong.com/img/jvm/jre.png" alt></p>
<h3 id="JVM（Java-Virtual-Machine）"><a href="#JVM（Java-Virtual-Machine）" class="headerlink" title="JVM（Java Virtual Machine）"></a>JVM（Java Virtual Machine）</h3><p>JVM(Java Virtual Machine) 是一种软件实现, 执行像物理机程序的机器（即电脑）.<br>本来, Java被设计基于从物理机器分离实现WORA（ 写一次, 随处运行 ）的虚拟机上运行, 虽然这个目标已经几乎被遗忘.<br>JVM 并不是专为 Java 所实现的运行时, 实际上只要有其他编程语言的编译器能生成正确 Java bytecode 文件, 则这个语言也能实现在JVM上运行.<br>因此, JVM 通过执行 Java bytecode 可以使 java 代码在不改变的情况下运行在各种硬件之上. </p>
<p>JVM实现了Java语言最重要的特征: 即平台无关性.<br><strong>平台无关性原理</strong>: 编译后的 Java程序（<code>.class</code>文件）由<strong>JVM执行</strong>. JVM<strong>屏蔽了与具体平台相关的信息</strong>, 使程序可以在多种平台上不加修改地运行. Java虚拟机在执行字节码时, 把字节码解释成具体平台上的机器指令执行. 因此实现<strong>Java平台无关性</strong>. </p>
<h2 id="JVM结构图"><a href="#JVM结构图" class="headerlink" title="JVM结构图"></a>JVM结构图</h2><p><img src="https://cdn.yangbingdong.com/img/jvm/jvm-frame-diagram.png" alt><br><strong>JVM = 类加载器 classloader+ 执行引擎 executionengine + 运行时数据区域 runtime data area</strong><br>首先Java源代码文件被Java编译器编译为字节码文件, 然后JVM中的<strong>类加载器</strong>加载完毕之后, 交由JVM<strong>执行引擎</strong>执行. 在整个程序执行过程中, JVM中的<strong>运行时数据区（内存）</strong>会用来存储程序执行期间需要用到的数据和相关信息.<br>因此, <strong>在Java中我们常常说到的内存管理就是针对这段空间进行管理</strong>（如何分配和回收内存空间）. </p>
<h2 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h2><p>ClassLoader把硬盘上的class文件<strong>加载到JVM中的运行时数据区域</strong>, 但是它不负责这个类文件能否执行, 而这个是执行引擎负责的. </p>
<h2 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h2><p>作用: <strong>执行字节码, 或者执行本地方法. </strong></p>
<h2 id="Runtime-DataArea"><a href="#Runtime-DataArea" class="headerlink" title="Runtime DataArea"></a>Runtime DataArea</h2><p>JVM运行时数据区 (JVM RuntimeArea)其实就是指 JVM在<strong>运行期间</strong>, 其<strong>对JVM内存空间的划分和分配</strong>. JVM在运行时将数据划分为了<strong>以下几个区域来存储</strong>.<br>程序员写的所有程序都被加载到运行时数据区域中.<br><img src="https://cdn.yangbingdong.com/img/jvm/jvm-runtime-area.png" alt><br>（图注: <strong>JDK1.7已经把常量池转移到堆里面了！</strong>）</p>
<h3 id="PC寄存器（The-pc-Register）"><a href="#PC寄存器（The-pc-Register）" class="headerlink" title="PC寄存器（The pc Register）"></a>PC寄存器（The pc Register）</h3><p>（1）每一个Java线程<strong>都有一个PC寄存器</strong>, 用以<strong>记录当前执行到哪个指令</strong>.<br>（2）用于存储每个线程下一步将执行的JVM指令, 如该方法是Java方法, 则记录的是<strong>正在执行的虚拟机字节码地址</strong>, 如该方法为native的, 则<strong>计数器值为空</strong>.<br>（3）此内存区域是<strong>唯一一个在JVM中没有规定任何OutOfMemoryError情况</strong>的区域. </p>
<h3 id="JVM栈（Java-Virtual-Machine-Stacks）"><a href="#JVM栈（Java-Virtual-Machine-Stacks）" class="headerlink" title="JVM栈（Java Virtual Machine Stacks）"></a>JVM栈（Java Virtual Machine Stacks）</h3><p>（1）JVM栈是<strong>线程私有的, 并且生命周期与线程相同</strong>. 并且当线程运行完毕后, 相应内存也就被<strong>自动回收</strong>.<br>（2）栈里面存放的元素叫<strong>栈帧</strong>, 每个函数从调用到执行结束, 其实是对应一个栈帧的<strong>入栈和出栈</strong>.<br>（栈帧好像很复杂的样子, 其实它很简单！）它里面具体存放的是执行的函数的一些数据, 如<strong>局部变量、操作数</strong>栈（执行引擎计算时需要）, <strong>方法出口</strong>等等.<br>（3）这个区域可能有两种异常: 如果线程请求的栈深度大于虚拟机所允许的深度, 将抛出<code>StackOverflowError</code>异常（如: 将一个函数反复递归自己, 最终会出现这种异常）. 如果JVM栈可以动态扩展（大部分JVM是可以的）, 当扩展时无法申请到足够内存则抛出<code>OutOfMemoryError</code>异常. </p>
<p>下面来实现一个栈溢出:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.antd.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackOverFlowMock</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackOver</span><span class="params">()</span></span>&#123;</span><br><span class="line">		num++;</span><br><span class="line">		stackOver();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		StackOverFlowMock stackOverFlowTest = <span class="keyword">new</span> StackOverFlowMock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			stackOverFlowTest.stackOver();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">			System.out.println(<span class="string">"迭代深度: "</span>+stackOverFlowTest.getNum());</span><br><span class="line">			t.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出为:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">迭代深度: <span class="number">17781</span></span><br><span class="line">java.lang.StackOverflowError</span><br><span class="line">	at org.antd.test.StackOverFlowMock.stackOver(StackOverFlowMock.java:<span class="number">10</span>)</span><br><span class="line">	at org.antd.test.StackOverFlowMock.stackOver(StackOverFlowMock.java:<span class="number">10</span>)</span><br><span class="line">	at org.antd.test.StackOverFlowMock.stackOver(StackOverFlowMock.java:<span class="number">10</span>)</span><br><span class="line">	at org.antd.test.StackOverFlowMock.stackOver(StackOverFlowMock.java:<span class="number">10</span>)</span><br><span class="line">	at org.antd.test.StackOverFlowMock.stackOver(StackOverFlowMock.java:<span class="number">10</span>)</span><br><span class="line">	at org.antd.test.StackOverFlowMock.stackOver(StackOverFlowMock.java:<span class="number">10</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="本地方法栈（Native-Method-Stacks）"><a href="#本地方法栈（Native-Method-Stacks）" class="headerlink" title="本地方法栈（Native Method Stacks）"></a>本地方法栈（Native Method Stacks）</h3><p>（1）本地方法栈与虚拟机栈所发挥的作用很相似, 他们的区别在于<strong>虚拟机栈为执行Java代码方法服务, 而本地方法栈是为Native方法服务</strong>.<br>（2）和JVM栈一样, 这个区域也会抛出<code>StackOverflowError</code>和<code>OutOfMemoryError</code>异常. </p>
<h3 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h3><p>（1）在方法区中, 存储了每个<strong>类的信息</strong>、<strong>静态变量</strong>等. 如, 当程序中通过<code>getName</code>、<code>isInterface</code>等方法来获取信息时, 这些数据来源于<strong>方法区</strong>.<br>（2）方法区域是<strong>全局共享</strong>的, 比如<strong>每个线程都可以访问同一个类的静态变量</strong>.<br>（3）由于使用<strong>反射机制</strong>的原因, 虚拟机<strong>很难推测哪个类信息不再使用</strong>, 因此这块区域的<strong>回收很难</strong>！另外, 对这块区域主要是针对<strong>常量池</strong>回收, <strong>值得注意的是JDK1.7已经把常量池转移到堆里面了</strong>.<br>（4）同样, 当方法区<strong>无法满足内存分配需求</strong>时, 会抛出<code>OutOfMemoryError</code>. 下面演示一下造成方法区内的OOM场景.<br>执行之前, 可以把虚拟机的参数<code>-XXpermSize</code>和<code>-XX: MaxPermSize</code>限制方法区大小.<br>那么实现一下OOM:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOomMock</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		List&lt;<span class="keyword">byte</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">byte</span>[]&gt;();</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">while</span> (flag) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				i++;</span><br><span class="line">				list.add(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]);<span class="comment">// 每次增加一个1M大小的数组对象</span></span><br><span class="line">			&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">				flag = <span class="keyword">false</span>;</span><br><span class="line">				System.out.println(<span class="string">"count="</span> + i);<span class="comment">// 记录运行的次数</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>控制台输出:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">count=3422</span><br><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at org.antd.test.HeapOomMock.main(HeapOomMock.java:14)</span><br></pre></td></tr></table></figure></p>
<h3 id="运行时常量池（Runtime-Constant-Pool）"><a href="#运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="运行时常量池（Runtime Constant Pool）"></a>运行时常量池（Runtime Constant Pool）</h3><p>（1）存放类中固定的常量信息、方法引用信息等, 其空间从方法区域（JDK1.7后为堆空间）中分配.<br>（2）Class文件中除了有类的版本、字段、方法、接口等描述等信息外, 还有就是<strong>常量表</strong>(constant_pool table), 用于存放<strong>编译期已可知的常量</strong>, 这部分内容将在<strong>类加载后进入方法区（永久代）存放</strong>. 但是Java语言并不要求常量一定只有编译期预置入Class的常量表的内容才能进入方法区常量池, 运行期间也可将新内容放入常量池（最典型的<code>String.intern()</code>方法）.<br>（3）当常量池无法在申请到内存时会抛出<code>OutOfMemoryError</code>异常.<br>再来一段代码展示以下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//不断将字符串添加到常量池, 最终导致内存不足抛出方法区的OOM </span><br><span class="line">List&lt;String&gt; list =new ArrayList&lt;String&gt;(); </span><br><span class="line">int i =0; </span><br><span class="line">while(true)&#123; </span><br><span class="line">    list.add(String.valueOf(i).intern()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>String的intern函数的作用就不多赘述了, 在这篇博文<strong><em><a href="#%E9%80%9A%E8%BF%87String%E7%B1%BB%E7%9A%84intern-%E4%BA%86%E8%A7%A3%E5%86%85%E5%AD%98%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%B8%B8%E9%87%8F%E6%B1%A0">了解String类的intern()方法</a></em></strong>有所介绍. 关于JDK1.6和JDK1.7之后常量池位置的变化对该函数的影响, 也在链接文中阐述了. </p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>（1）Java堆是JVM所管理的<strong>最大的一块内存</strong>. 它是被<strong>所有线程共享的一块内存区域, 在虚拟机启动时创建</strong>.<br>（2）几乎所有的<strong>实例对象都是在这块区域中存放</strong>. （JIT编译器貌似不是这样的）.<br>（3）Java堆是<strong>垃圾搜集管理</strong>的主要战场. 所有Java堆可以细分为: <strong>新生代</strong>和<strong>老年代</strong>. 再细致分就是把新生代分为: <strong>Eden空间</strong>、<strong>FromSurvivor空间</strong>、<strong>To Survivor空间</strong>.<br>（4）根据<strong>Java虚拟机规范</strong>的规定, Java堆可以处于物理上<strong>不连续的内存空间</strong>中, 只要<strong>逻辑上是连续</strong>的即可, 就像我们的磁盘空间一样. 如果在<strong>堆中没有内存完成实例分配</strong>, 并且<strong>堆也无法再扩展时</strong>, 将会抛出<code>OutOfMemoryError</code>异常. </p>
<h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><p>这是一个非常常见的面试题, 主要从以下几个方面来回答. </p>
<h3 id="各司其职"><a href="#各司其职" class="headerlink" title="各司其职"></a>各司其职</h3><p>最主要的区别就是<strong>栈内存用来存储局部变量和方法调用</strong>.<br>而堆内存用来存储<strong>Java中的对象</strong>. 无论是成员变量、局部变量还是类变量, 它们指向的对象都存储在堆内存中. </p>
<h3 id="空间大小"><a href="#空间大小" class="headerlink" title="空间大小"></a>空间大小</h3><p><strong>栈的内存要远远小于堆内存</strong>, 如果你使用<strong>递归</strong>的话, 那么你的栈很快就会充满并产生<code>StackOverFlowError</code>. </p>
<h3 id="独有还是共享"><a href="#独有还是共享" class="headerlink" title="独有还是共享"></a>独有还是共享</h3><p>栈内存归属于<strong>线程的私有内存</strong>, 每个线程都会有一个栈内存, 其存储的变量只能在其所属线程中可见.<br>而堆内存中的对象<strong>对所有线程可见</strong>, 可以被所有线程访问. </p>
<h3 id="异常错误"><a href="#异常错误" class="headerlink" title="异常错误"></a>异常错误</h3><p>如果线程请求的<strong>栈深度</strong>大于虚拟机所允许的深度, 将抛出<code>StackOverflowError</code>异常.<br>如果JVM栈可以动态扩展（大部分JVM是可以的）, 当扩展时<strong>无法申请到足够内存</strong>则抛出<code>OutOfMemoryError</code>异常.<br>而堆内存没有可用的空间存储生成的对象, JVM会抛出<code>java.lang.OutOfMemoryError</code>. </p>
<p>以上便是关于JVM架构的相关知识. </p>
<h1 id="内存管理和垃圾回收"><a href="#内存管理和垃圾回收" class="headerlink" title="内存管理和垃圾回收"></a>内存管理和垃圾回收</h1><h2 id="何为GC"><a href="#何为GC" class="headerlink" title="何为GC"></a>何为GC</h2><p>Java与C语言相比的一个优势是, 可以通过自己的JVM<strong>自动分配和回收内存空间</strong>.<br>垃圾回收机制是由垃圾搜集器Garbage Collection来实现的, GC是后台一个<strong>低优先级的守护进程</strong>. 在内存中低到一定限度时才会自动运行, 因此垃圾<strong>回收的时间是不确定的</strong>. </p>
<p><strong>为何要这样设计</strong>: 因为GC也要消耗CPU等资源, 如果GC执行过于频繁会对Java的程序的执行产生较大的影响, 因此实行<strong>不定期的GC</strong>. </p>
<p><strong>与GC有关的是</strong>: JVM运行时数据区中的堆（对象实例会存储在这里）和 gabagecollector方法.<br>垃圾回收GC<strong>只能回收通过new关键字申请的内存</strong>（在堆上）, 但是堆上的内存并不完全是通过new申请分配的. 还有一些本地方法, 这些内存如果不手动释放, 就会导致内存泄露, 所以需要在finalize中用本地方法(nativemethod)如<strong>free操作等, 再使用gc</strong>方法.<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.gc();</span><br></pre></td></tr></table></figure></p>
<h2 id="何为垃圾"><a href="#何为垃圾" class="headerlink" title="何为垃圾"></a>何为垃圾</h2><p>Java中那些<strong>不可达</strong>的对象就会变成垃圾. 对象之间的引用可以抽象成树形结构, 通过树根（GC Roots）作为起点, 从这些树根往下搜索, 搜索走过的链称为引用链.<br><strong>当一个对象到GC Roots没有任何引用链相连时, 则证明这个对象为可回收的对象</strong>.<br><strong>可以作为GC Roots的主要有以下几种</strong>:<br>（1）<strong>栈帧中的本地变量表</strong>所引用的对象.<br>（2）方法区中<strong>类静态属性和常量</strong>引用的对象.<br>（3）本地方法栈中JNI（<strong>Native方法</strong>）引用的对象.<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//垃圾产生的情况举例: </span></span><br><span class="line"><span class="comment">//1.改变对象的引用, 如置为null或者指向其他对象 </span></span><br><span class="line">Object obj1 = <span class="keyword">new</span> Object(); </span><br><span class="line">Object obj2 = <span class="keyword">new</span> Object(); </span><br><span class="line">obj1 = obj2; <span class="comment">//obj1成为垃圾 </span></span><br><span class="line">obj1 = obj2 = <span class="keyword">null</span> ; <span class="comment">//obj2成为垃圾</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.引用类型 </span></span><br><span class="line"><span class="comment">//第2句在内存不足的情况下会将String对象判定为可回收对象, 第3句无论什么情况下String对象都会被判定为可回收对象 </span></span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"hello"</span>); </span><br><span class="line">SoftReference&lt;String&gt; sr = <span class="keyword">new</span> SoftReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">"java"</span>)); </span><br><span class="line">WeakReference&lt;String&gt; wr = <span class="keyword">new</span> WeakReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">"world"</span>));</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3.循环每执行完一次, 生成的Object对象都会成为可回收的对象 </span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123; </span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();  </span><br><span class="line">        System.out.println(obj.getClass());  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//4.类嵌套 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123; </span><br><span class="line">   A a; </span><br><span class="line">&#125; </span><br><span class="line">A x = <span class="keyword">new</span> A();<span class="comment">//分配了一个空间 </span></span><br><span class="line">x.a = <span class="keyword">new</span> A();<span class="comment">//又分配了一个空间 </span></span><br><span class="line">x = <span class="keyword">null</span>;<span class="comment">//产生两个垃圾</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5.线程中的垃圾 </span></span><br><span class="line">calss A implements Runnable&#123; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="comment">//....  </span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//main </span></span><br><span class="line">A x = <span class="keyword">new</span> A(); </span><br><span class="line">x.start(); </span><br><span class="line">x=<span class="keyword">null</span>; <span class="comment">//线程执行完成后x对象才被认定为垃圾</span></span><br></pre></td></tr></table></figure>
<h2 id="四种引用类型"><a href="#四种引用类型" class="headerlink" title="四种引用类型"></a>四种引用类型</h2><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>
<p>这里的obj引用便是一个强引用, 强引用不会被GC回收. 即使抛出<code>OutOfMemoryError</code>错误, 使程序异常终止. </p>
<h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>如果内存空间足够, 垃圾回收器就不会回收它, 如果内存空间不足了, 就会回收这些对象的内存. 软引用可用来实现内存敏感的高速缓存.<br>软引用可以和一个引用队列（ReferenceQueue）联合使用, 如果软引用所引用的对象被垃圾回收, Java虚拟机就会把这个软引用加入到与之关联的引用队列中. </p>
<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>弱引用与软引用的区别在于: 垃圾回收器一旦发现了弱引用的对象, 不管当前内存空间足够与否, 都会回收它的内存. 不过由于垃圾回收器是一个优先级很低的线程, 因此不一定会很快发现那些弱引用的对象.<br>弱引用可以和一个引用队列（ReferenceQueue）联合使用, 如果弱引用所引用的对象被垃圾回收, Java虚拟机就会把这个弱引用加入到与之关联的引用队列中. </p>
<h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>虚引用与软引用和弱引用的一个区别在于: 虚引用必须和引用队列（ReferenceQueue）联合使用. 当垃圾回收器发现一个对象有虚引用时, 就会把这个虚引用对象加入到与之关联的引用队列中. 此时该对象并没有被GC回收. 而是要等到引用队列被真正的处理后才会被回收.<br>程序可以通过判断引用队列中是否已经加入了虚引用, 来了解被引用的对象是否将要被垃圾回收.<br>（由于<code>Object.finalize()</code>方法的不安全性、低效性, 常常使用虚引用完成对象回收前的资源释放工作. ）<br>这里特别需要注意: 当JVM将虚引用插入到引用队列的时候, 虚引用执行的对象内存还是存在的. 但是PhantomReference并没有暴露API返回对象. 所以如果想做清理工作, 需要继承PhantomReference类, 以便访问它指向的对象. 如NIO直接内存的自动回收, 就使用到了sun.misc.Cleaner. </p>
<h2 id="典型的垃圾回收算法"><a href="#典型的垃圾回收算法" class="headerlink" title="典型的垃圾回收算法"></a>典型的垃圾回收算法</h2><p>在确定了哪些垃圾可以被回收后, 垃圾搜集器要做的事情就是开始进行垃圾回收, 但是这里面涉及到一个问题是: <strong>如何高效地进行垃圾回收</strong>.<br>下面讨论几种常见的<strong>垃圾搜集算法</strong>. </p>
<h3 id="Mark-Sweep（标记-清除）算法"><a href="#Mark-Sweep（标记-清除）算法" class="headerlink" title="Mark-Sweep（标记-清除）算法"></a>Mark-Sweep（标记-清除）算法</h3><p>标记-清除算法分为两个阶段: 标记阶段和清除阶段.<br><strong>标记阶段</strong>的任务是标记出所有需要被回收的对象, <strong>清除阶段</strong>就是回收被标记的对象所占用的空间.<br>标记-清除算法实现起来比较容易, 但是有一个比较严重的问题就是<strong>容易产生内存碎片</strong>, 碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发GC. </p>
<h3 id="Copying（复制）算法"><a href="#Copying（复制）算法" class="headerlink" title="Copying（复制）算法"></a>Copying（复制）算法</h3><p>Copying算法将可用内存<strong>按容量划分为大小相等的两块</strong>, <strong>每次只使用其中的一块</strong>. 当这一块的内存用完了, 就<strong>将还存活着的对象复制到另外一块上面</strong>, 然后再把第一块内存上的空间一次清理掉, 这样就<strong>不容易出现内存碎片</strong>的问题, 并且<strong>运行高效</strong>.<br>但是该算法导致<strong>能够使用的内存缩减到原来的一半</strong>. 而且, 该算法的<strong>效率跟存活对象的数目多少有很大的关系</strong>, 如果存活对象<strong>很多</strong>, 那么Copying算法的<strong>效率将会大大降低</strong>. （这也是为什么后面提到的新生代采用Copying算法）</p>
<h3 id="Mark-Compact（标记-整理）算法"><a href="#Mark-Compact（标记-整理）算法" class="headerlink" title="Mark-Compact（标记-整理）算法"></a>Mark-Compact（标记-整理）算法</h3><p>为了解决Copying算法的缺陷, 充分利用内存空间, 提出了Mark-Compact算法.<br>该算法标<strong>记阶段标</strong>记出所有需要被回收的对象, 但是在完成标记之后不是直接清理可回收对象, 而是<strong>将存活的对象都移向一端</strong>, 然后<strong>清理掉端边界以外的所有内存</strong>（<strong>只留下存活对象</strong>）. </p>
<h3 id="以上三种算法对比"><a href="#以上三种算法对比" class="headerlink" title="以上三种算法对比"></a>以上三种算法对比</h3><p>它们的共同点主要有以下两点:<br>1、<strong>三个算法都基于根搜索算法去判断一个对象是否应该被回收, 而支撑根搜索算法可以正常工作的理论依据, 就是语法中变量作用域的相关内容. 因此, 要想防止内存泄露, 最根本的办法就是掌握好变量作用域, 而不应该使用前面内存管理杂谈一章中所提到的C/C++式内存管理方式. </strong><br>2、<strong>在GC线程开启时, 或者说GC过程开始时, 它们都要暂停应用程序（stop the world）. </strong><br>它们的区别按照下面几点来给各位展示. （&gt;表示前者要优于后者, =表示两者效果一样）<br><strong>效率: 复制算法&gt;标记-整理算法&gt;标记-清除算法（此处的效率只是简单的对比时间复杂度, 实际情况不一定如此）. </strong><br><strong>内存整齐度: 复制算法=标记-整理算法&gt;标记-清除算法. </strong><br><strong>内存利用率: 标记-整理算法=标记-清除算法&gt;复制算法. </strong><br>可以看到标记-清除算法是比较落后的算法了, 但是后两种算法却是在此基础上建立的, 俗话说“吃水不忘挖井人”, 因此各位也莫要忘记了标记-清除这一算法前辈. 而且, 在某些时候, 标记-清除也会有用武之地. </p>
<p>到此我们已经将三个算法了解清楚了, 可以看出, 效率上来说, 复制算法是当之无愧的老大, 但是却浪费了太多内存, 而为了尽量兼顾上面所提到的三个指标, 标记-整理算法相对来说更平滑一些, 但效率上依然不尽如人意, 它比复制算法多了一个标记的阶段, 又比标记-清除多了一个整理内存的过程.<br>难道就没有一种最优算法吗？<br>当然是没有的, 这个世界是公平的, 任何东西都有两面性, 试想一下, 你怎么可能找到一个又漂亮又勤快又有钱又通情达理, 性格又合适, 家境也合适, 身高长相等等等等都合适的女人？就算你找到了, 至少有一点这个女人也肯定不满足, 那就是她不会爱上你. 你是不是想说你比博主强太多了, 那博主只想对你说, 高富帅是不会爬在电脑前看技术文章的, 0.0.<br>但是古人就是给力, 古人说了, 找媳妇不一定要找最好的, 而是要找最合适的, 听完这句话, 瞬间感觉世界美好了许多.<br>算法也是一样的, <strong>没有最好的算法, 只有最合适的算法</strong>.<br>既然这三种算法都各有缺陷, 高人们自然不会容许这种情况发生. 因此, 高人们提出可以根据对象的不同特性, 使用不同的算法处理, 类似于萝卜白菜各有所爱的原理. 于是奇迹发生了, 高人们终于找到了GC算法中的神级算法—–<strong>分代搜集算法</strong>. </p>
<h3 id="Generational-Collection（分代搜集）算法"><a href="#Generational-Collection（分代搜集）算法" class="headerlink" title="Generational Collection（分代搜集）算法"></a>Generational Collection（分代搜集）算法</h3><p>分代搜集算法是针对对象的不同特性, 而使用适合的算法, 这里面并没有实际上的新算法产生. <strong>与其说分代搜集算法是第四个算法, 不如说它是对前三个算法的实际应用</strong>.<br><strong>分代搜集算法</strong>是目前大部分JVM的垃圾搜集器采用的算法.<br>它的核心思想是<strong>将堆区划分为老年代（Tenured Generation）和新生代（Young Generation）</strong>, 老年代的特点是每次垃圾搜集时只有<strong>少量</strong>对象需要被回收, 而新生代的特点是每次垃圾回收时都有<strong>大量</strong>的对象需要被回收, 那么就可以在<strong>不同代的采取不同的最适合的搜集算法</strong>. </p>
<p>目前大部分垃圾搜集器对于<strong>新生代都采取Copying算法</strong>, 因为新生代中每次垃圾回收都要<strong>回收大部分对象</strong>, 也就是说需要<strong>复制的操作次数较少</strong>, 该算法效率在新生代也较高. 但是实际中并不是按照1: 1的比例来划分新生代的空间的, 一般来说是将新生代划分为<strong>一块较大的Eden空间</strong>和<strong>两块较小的Survivor空间</strong>, <strong>每次使用Eden空间和其中的一块Survivor空间</strong>, 当进行回收时, 将还存活的对象复制到另一块Survivor空间中, 然后清理掉Eden和A空间. 在进行了第一次GC之后, 使用的便是Eden space和<strong>B空间</strong>了, 下次GC时会将存活对象复制到<strong>A空间</strong>, 如此<strong>反复循环</strong>. </p>
<p>当对象在<strong>Survivor区</strong>躲过一次GC的话, 其<strong>对象年龄便会加1</strong>, 默认情况下, <strong>对象年龄达到15时</strong>, 就会<strong>移动到老年代中</strong>. 一般来说, 大对象会被直接分配到老年代, 所谓的大对象是指需要大量连续存储空间的对象, 最常见的一种大对象就是大数组, 比如: <code>byte[]</code> <code>data</code> <code>=</code> <code>new</code> <code>byte[4*1024*1024]</code>.<br>当然分配的规则并不是百分之百固定的, 这要取决于当前使用的是哪种垃圾搜集器组合和JVM的相关参数. 这些<strong>搬运工作都是GC完成的</strong>, GC不仅负责在Heap中搬运实例, 同时负责回收存储空间.<br>最后, 因为每次回收都只回收少量对象, 所以<strong>老年代一般使用的是标记整理算法</strong>. </p>
<p><strong>注意</strong>, 在方法区中有一个<strong>永久代</strong>（Permanet Generation）, 它用来存储class类、常量、方法描述等. 对永久代的回收主要回收两部分内容: <strong>废弃常量</strong>和<strong>无用的类</strong>.<br><img src="https://cdn.yangbingdong.com/img/jvm/java-heap-memory.png" alt><br>有关查看垃圾回收信息的JVM常见配置方式:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:+PrintGCDetails</span><br></pre></td></tr></table></figure></p>
<p>最后介绍一下有关堆的JVM常见配置方式:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xss //选置栈内存的大小  </span><br><span class="line">-Xms: //初始堆大小  </span><br><span class="line">-Xmx: //最大堆大小  </span><br><span class="line">-XX:NewSize=n: //设置年轻代大小  </span><br><span class="line">-XX:NewRatio=n: //设置年轻代和年老代的比值. 比如设置为3, 表示年轻代与年老代比值为1: 3  </span><br><span class="line">-XX:SurvivorRatio=n: //年轻代中Eden区与两个Survivor区的比值. 注意Survivor区有两个. 比如设置为3, 表示Eden: Survivor=3: 2, 一个Survivor区占整个年轻代的1/5.  </span><br><span class="line">-XX:MaxPermSize=n: //设置持久代大小</span><br></pre></td></tr></table></figure></p>
<h2 id="典型的垃圾回收器"><a href="#典型的垃圾回收器" class="headerlink" title="典型的垃圾回收器"></a>典型的垃圾回收器</h2><p>垃圾搜集算法是内存回收的理论基础, 而垃圾搜集器就是内存回收的具体实现.<br>下面介绍一下<strong>HotSpot</strong>（JDK 7)虚拟机提供的几种垃圾搜集器, 用户可以根据自己的需求组合出各个年代使用的搜集器. </p>
<h3 id="Serial-amp-Serial-Old"><a href="#Serial-amp-Serial-Old" class="headerlink" title="Serial&amp;Serial Old"></a>Serial&amp;Serial Old</h3><p><code>Serial</code>和<code>Serial Old</code>搜集器是最基本最古老的搜集器, 是一个<strong>单线程</strong>搜集器, 并且在它进行垃圾搜集时, 必须<strong>暂停所有用户线程</strong>. <code>Serial</code>搜集器是<strong>针对新生代</strong>的搜集器, 采用的是<strong>Copying算法</strong>, <code>Serial Old</code>搜集器是针对<strong>老年代的搜集器</strong>, 采用的是<strong>Mark-Compact算法</strong>. 它的优点是实现简单高效, 但是缺点是会给用户带来停顿. </p>
<h3 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h3><p><code>ParNew</code>搜集器是<code>Serial</code>搜集器的<strong>多线程版本</strong>, 使用多个线程进行垃圾搜集. </p>
<h3 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h3><p><code>Parallel Scavenge</code>搜集器是一个<strong>新生代的多线程搜集器（并行搜集器）</strong>, 它在回收期间<strong>不需要暂停其他用户线程</strong>, 其采用的是<strong>Copying算法</strong>, 该搜集器与前两个搜集器有所不同, 它主要是为了达到一个<strong>可控的吞吐量</strong>. </p>
<h3 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h3><p><code>Parallel Old</code>是<code>Parallel Scavenge</code>搜集器的<strong>老年代版本（并行搜集器）</strong>, 使用多线程和<strong>Mark-Compact算法</strong>. </p>
<h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p><code>CMS</code>（Current Mark Sweep）搜集器是一种以<strong>获取最短回收停顿时间</strong>为目标的搜集器, 它是一种<strong>并发</strong>搜集器, 采用的是<strong>Mark-Sweep算法</strong>. </p>
<h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p>G1搜集器是当今搜集器技术发展最前沿的成果, 它是一款<strong>面向服务端应用</strong>的搜集器, 它能充分利用<strong>多CPU</strong>、<strong>多核</strong>环境. 因此它是一款<strong>并行与并发</strong>搜集器, 并且它能建立<strong>可预测的停顿时间</strong>模型.<br>最后介绍一下有关搜集器设置的JVM常见配置方式:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:+UseSerialGC: //设置串行搜集器  </span><br><span class="line">-XX:+UseParallelGC: //设置并行搜集器  </span><br><span class="line">-XX:+UseParalledlOldGC: //设置并行年老代搜集器  </span><br><span class="line">-XX:+UseConcMarkSweepGC: //设置并发搜集器  </span><br><span class="line">//并行搜集器设置  </span><br><span class="line">-XX:ParallelGCThreads=n: //设置并行搜集器搜集时使用的CPU数, 并行搜集线程数  </span><br><span class="line">-XX:MaxGCPauseMillis=n: //设置并行搜集最大暂停时间  </span><br><span class="line">-XX:GCTimeRatio=n: //设置垃圾回收时间占程序运行时间的百分比, 公式为1/(1+n)  </span><br><span class="line">//并发搜集器设置  </span><br><span class="line">-XX:+CMSIncrementalMode: //设置为增量模式. 适用于单CPU情况  </span><br><span class="line">-XX:ParallelGCThreads=n: //设置并发搜集器年轻代搜集方式为并行搜集时, 使用的CPU数. 并行搜集线程数</span><br></pre></td></tr></table></figure></p>
<h1 id="Java类加载机制总结"><a href="#Java类加载机制总结" class="headerlink" title="Java类加载机制总结"></a>Java类加载机制总结</h1><p><img src="https://cdn.yangbingdong.com/img/jvm/class.png" alt></p>
<h2 id="类加载器的组织结构"><a href="#类加载器的组织结构" class="headerlink" title="类加载器的组织结构"></a>类加载器的组织结构</h2><p>类加载器 <code>ClassLoader</code>是具有层次结构的, 也就是父子关系. 其中, <strong><code>Bootstrap</code>是所有类加载器的父亲</strong>.<br>（1）<code>Bootstrapclass loader</code>: <strong>启动类加载器</strong><br>当运行Java虚拟机时, 这个类加载器被创建, 它负责加载虚拟机的<strong>核心类库</strong>, 如<code>java.lang.*</code>等.<br>（2）<code>Extensionclass loader</code>: <strong>标准扩展类加载器</strong><br>用于加载除了基本 API之外的一些拓展类.<br>（3）<code>AppClassLoader</code>: 加载应用程序和程序员<strong>自定义的类</strong>.<br>运行下面的程序, 结果也显示出来了:<br><img src="https://cdn.yangbingdong.com/img/jvm/classlodertest.png" alt><br>从运行结果可以看出加载器之间的<strong>父子关系</strong>, <code>ExtClassLoader</code>的父<code>Loader</code>返回了null<br>原因是<code>BootstrapLoader</code>（启动类加载器）是用<strong><code>C</code>语言实现</strong>的, 找不到一个确定的返回父<code>Loader</code>的方式. </p>
<h2 id="类的加载机制"><a href="#类的加载机制" class="headerlink" title="类的加载机制"></a>类的加载机制</h2><p>类被加载到虚拟机内存包括<strong>加载</strong>、<strong>链接</strong>、<strong>初始化</strong>几个阶段. 其中<strong>链接又细化分为验证</strong>、<strong>准备</strong>、<strong>解析</strong>.<br>这里需要注意的是, 解析阶段在某些情况下可以在初始化阶段之后再开始, 这是为了支持Java的运行时绑定. 各个阶段的作用整理如下: </p>
<h3 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h3><p><strong>加载阶段</strong>可以使用系统提供的<strong>类加载器</strong>(ClassLoader)来完成, 也可以由用户<strong>自定义的类加载器</strong>完成, 开发人员可以通过定义类加载器去<strong>控制字节流的获取方式</strong>.<br>（1）通过类的<strong>全名</strong>产生对应类的<strong>二进制数据流</strong>（注意, 若未找到该类文件, 只有在类<strong>实际使用时</strong>才<strong>抛出</strong>错误）.<br>（2）分析并将这些二进制数据流转换为<strong>方法区的运行时数据结构</strong>.<br>（3）创建代表这个类的<code>java.lang.Class</code>对象. 作为方法区这些数据的访问入口. </p>
<h3 id="链接阶段（实现-Java-的动态性的重要一步）"><a href="#链接阶段（实现-Java-的动态性的重要一步）" class="headerlink" title="链接阶段（实现 Java 的动态性的重要一步）"></a>链接阶段（实现 Java 的动态性的重要一步）</h3><p>（1）<strong>验证</strong>: 主要的目的是确保class文件的字节流中包含的信息符合当前虚拟机的要求, 并且<strong>不会危害虚拟机自身安全</strong>. 验证点可能包括: class文件格式规范、这个类是否继承了不允许被继承的类(被final修饰的)、如果这个类的父类是抽象类, 是否实现了起父类或接口中要求实现的所有方法、不能把一个父类对象赋值给子类数据类型、方法的访问性(private、protected、public、default)是否可被当前类访问等等.<br>（2）<strong>准备</strong>: 准备阶段为<strong>类的成员变量分配内存空间</strong>并设置类变量<strong>初始值</strong>的阶段, 这些变量所使用的内存都在<strong>方法区</strong>中分配. <strong>所有原始类型的值都为0</strong>. 如<code>float</code>为0f、 <code>int</code>为0、<code>boolean</code>为0、引用类型为<code>null</code>.<br>（3）<strong>解析</strong>: 解析阶段是把虚拟机中<strong>常量池的符号引用</strong>替换为<strong>直接引用</strong>的过程. </p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>类初始化时类加载的最后一步, 前面除了<strong>加载阶段用户可以通过自定义类加载器参与</strong>以外, 其余都是<strong>虚拟机</strong>主导和控制. 到了初始化阶段, 才是<strong>真正执行类中定义Java程序代码</strong>. 初始化阶段, <strong>根据程序中的定制</strong>, <strong>初始化类变量</strong>.<br><strong>初始化过程其实是执行类构造器方法的过程</strong>.<br>（<strong>类构造器方法是由编译器自动搜集类中所有类变量的赋值动作和静态语句块中的语句合并产生的</strong>. ）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//静态语句块中只能访问定义在静态语句块之前的变量, 定义在它之后的变量可以赋值, 但不能访问  </span><br><span class="line">public class Test&#123;  </span><br><span class="line">    static&#123;  </span><br><span class="line">        i=0;//給变量赋值, 可以通过编译  </span><br><span class="line">        System.out.print(i);//这句编译器会提示非法向前引用  </span><br><span class="line">    &#125;  </span><br><span class="line">    static int i=1;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>初始化过程会被触发执行的条件汇总</strong>:<br>（1）使用<code>new</code>关键字<strong>实例化对象</strong>、读取或设置一个类的<strong>静态字段</strong>（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候, 以及调用类的<strong>静态方法*的时候.<br>（2）</strong>对类进行反射调用<strong>的时候.<br>（3）当初始化一个类的时候, 如果发现其</strong>父类还没有进行过初始化<strong>, 则进行</strong>父类的初始化<strong>.<br>（4）JVM启动时, 用</strong>户指定执行的主类**（包含main方法所在类）, 虚拟机会先初始化这个类. </p>
<p>【<strong>关于构造器方法拓展知识</strong>】（可以不看）<br>（1）类构造器<code>&lt;clinit&gt;()</code>方法与<strong>类的构造函数不同</strong>, 它不需要<strong>显式</strong>调用父类构造, 虚拟机会保证在子类<code>&lt;clinit&gt;()</code>方法执行之前, 父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕. 因此在虚拟机中的<strong>第一个执行的<code>&lt;clinit&gt;()</code>方法的类肯定是<code>java.lang.Object</code></strong>.<br>（2）由于父类的<code>&lt;clinit&gt;()</code>方法先执行, 也就意味着父类中定义的<strong>静态语句块要优先于子类的变量赋值</strong>操作.<br>（3）<code>&lt;clinit&gt;()</code>方法对于类或接口来说<strong>并不是必须的</strong>, 如果一个类中<strong>没有静态语句</strong>, <strong>也没有变量赋值的操作</strong>, 那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法.<br>（4）<strong>接口中不能使用静态语句块</strong>, 和类不同的是, 执行接口的<code>&lt;clinit&gt;()</code>方法<strong>不需要先执行父接口</strong>的<code>&lt;clinit&gt;()</code>方法. 只有当父接口中定义的变量<strong>被使用</strong>时, 父接口才会被初始化. 另外, 接口的<strong>实现类在初始化</strong>时也一样不会执行接口的<code>&lt;clinit&gt;()</code>方法.<br>（5）虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法<strong>在多线程环境中被正确加锁和同步</strong>, 可能会导致阻塞. </p>
<h2 id="类的整个加载过程触发的的三种方式"><a href="#类的整个加载过程触发的的三种方式" class="headerlink" title="类的整个加载过程触发的的三种方式"></a>类的整个加载过程触发的的三种方式</h2><p>遇到 <code>new</code>、 <code>getstatic</code>、 <code>putstatic</code> 或 <code>invokestatic</code> 这4条字节码指令时,如果类没有进行过初始化, 则需要先触发其初始化, 生成这4条指令的最常见的 Java代码场景是:</p>
<ul>
<li>由 <code>new</code> 关键字创建一个类的实例. </li>
<li>调用 <code>Class.forName()</code> 方法, 通过反射加载类. </li>
<li>调用某个<code>ClassLoader</code>实例的<code>loadClass()</code>方法. </li>
</ul>
<p>三者的区别汇总如下:<br>（1）方法1和2都是使用的<strong>当前类加载器</strong>（<code>this.getClass.getClassLoader</code>）. 方法3由<strong>用户指定类加载器</strong>并且加载的类与当前类<strong>分属不同的命名空间</strong>.<br>（2）方法1是<strong>静态加载</strong>, 2、3是<strong>动态加载</strong>.<br>（3）对于两种动态加载, 区别如下. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(className);  </span><br><span class="line"><span class="comment">//实际上是调用的是:  </span></span><br><span class="line">Class.forName(className, <span class="keyword">true</span>, <span class="keyword">this</span>.getClass().getClassLoader());<span class="comment">//第二个参数设置Class被loading后是不是必须被初始化, 默认初始化</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader.loadClass(className);  </span><br><span class="line"><span class="comment">//实际上调用的是:  </span></span><br><span class="line">ClassLoader.loadClass(name, <span class="keyword">false</span>);<span class="comment">//第二个参数指Class是否被链接, 默认为false</span></span><br></pre></td></tr></table></figure>
<p><strong>通过上面的描述, 如果程序依赖于<code>Class</code>是否被初始化, 就必须用<code>Class.forName(name)</code>了</strong></p>
<h1 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h1><p><img src="https://cdn.yangbingdong.com/img/jvm/calssloader.png" alt></p>
<h2 id="为什么需要自定义类加载器"><a href="#为什么需要自定义类加载器" class="headerlink" title="为什么需要自定义类加载器"></a>为什么需要自定义类加载器</h2><p>网上的大部分自定义类加载器文章, 几乎都是贴一段实现代码, 然后分析一两句自定义ClassLoader的原理. 但是个人觉得首先得把为什么需要自定义加载器这个问题搞清楚, 因为如果不明白它的作用的情况下, 还要去学习它显然是很让人困惑的.<br>首先介绍自定义类的<strong>应用场景</strong>:<br>（1）<strong>加密</strong>: Java代码可以轻易的被<strong>反编译</strong>, 如果你需要把自己的代码进行<strong>加密以防止反编译</strong>, 可以先将<strong>编译后的代码</strong>用某种<strong>加密算法加密</strong>, 类加密后就不能再用Java的<code>ClassLoader</code>去加载类了, 这时就需要<strong>自定义<code>ClassLoader</code></strong>在加载类的时候<strong>先解密类</strong>, 然后再加载.<br>（2）<strong>从非标准的来源加载代码</strong>: 如果你的字节码是放在数据库、甚至是在云端, 就可以自定义类加载器, 从指定的来源加载类.<br>（3）<strong>以上两种情况在实际中的综合运用</strong>: 比如你的应用需要<strong>通过网络来传输 Java 类的字节码</strong>, 为了安全性, 这些字节码经过了加密处理. 这个时候你就需要自定义类加载器来从某个网络地址上读取加密后的字节代码, 接着进行解密和验证, 最后定义出在Java虚拟机中运行的类. </p>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>在实现自己的<code>ClassLoade</code>r之前, 我们先了解一下系统是如何加载类的, 那么就不得不介绍<strong>双亲委派模型的特点和实现过程</strong>.<br>双亲委派模型<strong>特点</strong>:<br>该模型要求除了顶层的<code>Bootstrapclassloader</code>启动类加载器外, 其余的类加载器都应当<strong>有自己的父类加载器</strong>. 子类加载器和父类加载器<strong>不是</strong>以继承（Inheritance）的关系来实现, 而是<strong>通过组合（Composition）关系</strong>来<strong>复用</strong>父加载器的代码.<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双亲委派模型的工作过程源码  </span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)  </span><br><span class="line"><span class="keyword">throws</span> ClassNotFoundException  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="comment">// First, check if the class has already been loaded  </span></span><br><span class="line">Class c = findLoadedClass(name);  </span><br><span class="line"><span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;  </span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line"><span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;  </span><br><span class="line">c = parent.loadClass(name, <span class="keyword">false</span>);  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">c = findBootstrapClassOrNull(name);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;  </span><br><span class="line"><span class="comment">// ClassNotFoundException thrown if class not found  </span></span><br><span class="line"><span class="comment">// from the non-null parent class loader  </span></span><br><span class="line"><span class="comment">//父类加载器无法完成类加载请求  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;  </span><br><span class="line"><span class="comment">// If still not found, then invoke findClass in order to find the class  </span></span><br><span class="line"><span class="comment">//子加载器进行类加载   </span></span><br><span class="line">c = findClass(name);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">if</span> (resolve) &#123;<span class="comment">//判断是否需要链接过程, 参数传入  </span></span><br><span class="line">resolveClass(c);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> c;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>双亲委派模型的工作过程如下:<br>（1）代码中一开始的<strong>判空</strong>操作是当前 <code>ClassLoader</code>从自己已经加载的类中<strong>查询是否此类已经加载</strong>, 如果已经加载则直接返回原来已经加载的类. （每个类加载器都有自己的加载缓存, 当一个类被加载了以后就会放入缓存, 等下次加载的时候就可以直接返回）<br>（2）当前 <code>ClassLoader</code>的缓存中<strong>没有找到被加载的类的时候</strong>, 它自己不会尝试去加载该类, 而是<strong>委托父类加载器去加载</strong>, 如代码<code>c</code> <code>=</code> <code>parent.loadClass(name, false)</code>所示（父类加载器采用<strong>同样的策略</strong>, 递归了<code>loadClass</code>函数）, 首先查看自己的缓存, 没有就<strong>委托父类的父类去加载</strong>, 一直到 <code>BootStrap ClassLoader</code>. 如代码所示, 如果父加载器为空则默认使用启动类加载器（<code>BootStrap ClassLoader</code>）作为父加载器去加载, 如代码<code>findBootstrapClassOrNull(name)</code>所示（为何父类为<code>BootStrap ClassLoader</code>会返回空, 原因在<strong><em><a href="#Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93">Java类加载机制总结</a></em></strong>中介绍过了）.<br>（3）如果<strong><code>BootStrapClassLoader</code>加载失败</strong>（例如在<code>$JAVA_HOME/jre/lib</code>里未查找到该<code>class</code>）, 会使用<code>ExtClassLoader</code>来尝试加载； 若<code>ExtClassLoader</code>也加载失败, 则会使用<code>AppClassLoader</code>来加载, 如果<code>AppClassLoader</code>也加载失败, 则会抛出<code>ClassNotFoundException</code>. <strong>最后再调用当前加载器的<code>findClass()</code>方法进行加载</strong>. </p>
<p>双亲委派模型的<strong>好处</strong>:<br>（1）主要是为了<strong>安全性</strong>, <strong>避免用户自己编写的类动态替换Java的一些核心类</strong>, 比如 <code>String</code>.<br>（2）同时也<strong>避免重复加载</strong>, 因为 JVM中区分不同类, 不仅仅是根据类名, 相同的<code>class</code>文件被<strong>不同的 <code>ClassLoader</code>加载就是不同的两个类</strong>. </p>
<h2 id="自定义类加载器-1"><a href="#自定义类加载器-1" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>（1）从上面源码可以看出, 在调用<code>loadClass</code>方法时, 会先根据委派模型在父加载器中加载, 如果加载失败, 则会<strong>调用自己的<code>findClass</code>方法来完成加载</strong>.<br>（2）因此我们自定义的类加载器只需要<strong>继承ClassLoader, 并覆盖findClass方法</strong>.<br>（3）下面是一个实际例子, 在该例中我们用自定义的类加载器去加载我们事先准备好的class文件. </p>
<h3 id="自定义一个People-java类做例子"><a href="#自定义一个People-java类做例子" class="headerlink" title="自定义一个People.java类做例子"></a>自定义一个People.java类做例子</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;  </span><br><span class="line"><span class="comment">//该类写在记事本里, 在用javac命令行编译成class文件, 放在d盘根目录下  </span></span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">()</span> </span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"I am a people, my name is "</span> + name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义类加载器-2"><a href="#自定义类加载器-2" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>自定义一个类加载器, 需要继承<strong><code>ClassLoader</code>类, 并实现<code>findClass</code>方法</strong>. 其中<code>defineClass</code>方法可以把二进制流字节组成的文件转换为一个<code>java.lang.Class</code>（只要二进制字节流的内容符合Class文件规范）.<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span>  </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(ClassLoader parent)</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>(parent);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException  </span><br><span class="line">    &#123;  </span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"D:/People.class"</span>);  </span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            <span class="keyword">byte</span>[] bytes = getClassBytes(file);  </span><br><span class="line">            <span class="comment">//defineClass方法可以把二进制流字节组成的文件转换为一个java.lang.Class  </span></span><br><span class="line">            Class&lt;?&gt; c = <span class="keyword">this</span>.defineClass(name, bytes, <span class="number">0</span>, bytes.length);  </span><br><span class="line">            <span class="keyword">return</span> c;  </span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">catch</span> (Exception e)  </span><br><span class="line">        &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.findClass(name);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassBytes(File file) <span class="keyword">throws</span> Exception  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">// 这里要读入.class的字节, 因此要使用字节流  </span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);  </span><br><span class="line">        FileChannel fc = fis.getChannel();  </span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();  </span><br><span class="line">        WritableByteChannel wbc = Channels.newChannel(baos);  </span><br><span class="line">        ByteBuffer by = ByteBuffer.allocate(<span class="number">1024</span>);  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;  </span><br><span class="line">            <span class="keyword">int</span> i = fc.read(by);  </span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == -<span class="number">1</span>)  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">            by.flip();  </span><br><span class="line">            wbc.write(by);  </span><br><span class="line">            by.clear();  </span><br><span class="line">        &#125;  </span><br><span class="line">        fis.close();  </span><br><span class="line">        <span class="keyword">return</span> baos.toByteArray();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="在主函数里使用"><a href="#在主函数里使用" class="headerlink" title="在主函数里使用"></a>在主函数里使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyClassLoader mcl = <span class="keyword">new</span> MyClassLoader();   </span><br><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">"People"</span>, <span class="keyword">true</span>, mcl);   </span><br><span class="line">Object obj = clazz.newInstance();  </span><br><span class="line">         </span><br><span class="line">System.out.println(obj);  </span><br><span class="line">System.out.println(obj.getClass().getClassLoader());<span class="comment">//打印出我们的自定义类加载器</span></span><br></pre></td></tr></table></figure>
<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="https://cdn.yangbingdong.com/img/jvm/result.png" alt></p>
<p>至此关于自定义<code>ClassLoader</code>的内容总结完毕. </p>
<h1 id="看懂-JavaGC-日志"><a href="#看懂-JavaGC-日志" class="headerlink" title="看懂 JavaGC 日志"></a>看懂 JavaGC 日志</h1><h2 id="JVM-GC-相关的参数"><a href="#JVM-GC-相关的参数" class="headerlink" title="JVM GC 相关的参数"></a>JVM GC 相关的参数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:+PrintGC 输出 GC 日志</span><br><span class="line">-XX:+PrintGCDetails 输出 GC 的详细日志</span><br><span class="line">-XX:+PrintGCTimeStamps 输出 GC 的时间戳（以基准时间的形式）</span><br><span class="line">-XX:+PrintGCDateStamps 输出 GC 的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）</span><br><span class="line">-XX:+PrintHeapAtGC 在进行 GC 的前后打印出堆的信息-Xloggc:D:/gc.log 日志文件的输出路径</span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>比如在某个应用中，配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:D:/gc.log</span><br></pre></td></tr></table></figure>
<p>启动后打印如下 GC 日志：</p>
<h2 id="YongGC"><a href="#YongGC" class="headerlink" title="YongGC"></a>YongGC</h2><blockquote>
<p>2019-04-18T14:52:06.790+0800: 2.653: [GC (Allocation Failure) [PSYoungGen: 33280K-&gt;5113K(38400K)] 33280K-&gt;5848K(125952K), 0.0095764 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]</p>
</blockquote>
<p>含义：</p>
<p>2019-04-18T14:52:06.790+0800（当前时间戳）: 2.653（应用启动基准时间）: [GC (Allocation Failure) [PSYoungGen（表示 Young GC）: 33280K（年轻代回收前大小）-&gt;5113K（年轻代回收后大小）(38400K（年轻代总大小）)] 33280K（整个堆回收前大小）-&gt;5848K（整个堆回收后大小）(125952K（堆总大小）), 0.0095764（耗时） secs] [Times: user=0.00（用户耗时） sys=0.00（系统耗时）, real=0.01（实际耗时） secs]</p>
<h2 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h2><blockquote>
<p>2019-04-18T14:52:15.359+0800: 11.222: [Full GC (Metadata GC Threshold) [PSYoungGen: 6129K-&gt;0K(143360K)] [ParOldGen: 13088K-&gt;13236K(55808K)] 19218K-&gt;13236K(199168K), [Metaspace: 20856K-&gt;20856K(1069056K)], 0.1216713 secs] [Times: user=0.44 sys=0.02, real=0.12 secs]</p>
</blockquote>
<p>含义：</p>
<p>2019-04-18T14:52:15.359+0800（当前时间戳）: 11.222（应用启动基准时间）: [Full GC (Metadata GC Threshold) [PSYoungGen: 6129K（年轻代回收前大小）-&gt;0K（年轻代回收后大小）(143360K（年轻代总大小）)] [ParOldGen: 13088K（老年代回收前大小）-&gt;13236K（老年代回收后大小）(55808K（老年代总大小）)] 19218K（整个堆回收前大小）-&gt;13236K（整个堆回收后大小）(199168K（堆总大小）), [Metaspace: 20856K（持久代回收前大小）-&gt;20856K（持久代回收后大小）(1069056K（持久代总大小）)], 0.1216713（耗时） secs] [Times: user=0.44（用户耗时） sys=0.02（系统耗时）, real=0.12（实际耗时） secs]</p>
<h1 id="查看Class字节码"><a href="#查看Class字节码" class="headerlink" title="查看Class字节码"></a>查看Class字节码</h1><p>通过 java 自带命令可以查看:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javap -c Test</span><br></pre></td></tr></table></figure>
<p>查看16进制字节码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ xxd Test.class </span><br><span class="line">00000000: cafe babe 0000 0034 0023 0a00 0600 1509  .......4.#......</span><br><span class="line">00000010: 0016 0017 0800 180a 0019 001a 0700 1b07  ................</span><br><span class="line">00000020: 001c 0100 063c 696e 6974 3e01 0003 2829  .....&lt;init&gt;...()</span><br><span class="line">00000030: 5601 0004 436f 6465 0100 0f4c 696e 654e  V...Code...LineN</span><br><span class="line">00000040: 756d 6265 7254 6162 6c65 0100 124c 6f63  umberTable...Loc</span><br><span class="line">00000050: 616c 5661 7269 6162 6c65 5461 626c 6501  alVariableTable.</span><br><span class="line">00000060: 0004 7468 6973 0100 134c 636f 6d2f 6d64  ..this...Lcom/md</span><br><span class="line">00000070: 642f 7379 6e63 2f54 6573 743b 0100 046d  d/sync/Test;...m</span><br><span class="line">00000080: 6169 6e01 0016 285b 4c6a 6176 612f 6c61  ain...([Ljava/la</span><br><span class="line">00000090: 6e67 2f53 7472 696e 673b 2956 0100 0461  ng/String;)V...a</span><br><span class="line">000000a0: 7267 7301 0013 5b4c 6a61 7661 2f6c 616e  rgs...[Ljava/lan</span><br><span class="line">000000b0: 672f 5374 7269 6e67 3b01 0010 4d65 7468  g/String;...Meth</span><br><span class="line">000000c0: 6f64 5061 7261 6d65 7465 7273 0100 0a53  odParameters...S</span><br><span class="line">000000d0: 6f75 7263 6546 696c 6501 0009 5465 7374  ourceFile...Test</span><br><span class="line">000000e0: 2e6a 6176 610c 0007 0008 0700 1d0c 001e  .java...........</span><br><span class="line">000000f0: 001f 0100 0ce6 8891 e5a4 aae9 9abe e4ba  ................</span><br></pre></td></tr></table></figure>
<p>留意开头的魔数, 这是 Java 之父詹姆斯·高斯林（James Gosling）留下的彩蛋.</p>
<h1 id="常用的JVM参数"><a href="#常用的JVM参数" class="headerlink" title="常用的JVM参数"></a>常用的JVM参数</h1><blockquote>
<p>来自 <strong><em><a href="https://mp.weixin.qq.com/s?__biz=MzU3NDY4NzQwNQ==&amp;mid=2247483820&amp;idx=1&amp;sn=8418f0f6a618bb0f0ca0980af09a816f&amp;chksm=fd2fd06eca5859786ab124dd204a7ec9b1ad3ed230b9b531086cc6729a277a05d3e8307b7e0d&amp;scene=21#wechat_redirect" rel="external nofollow noopener noreferrer" target="_blank">无敌码农</a></em></strong></p>
</blockquote>
<p>java启动参数共分为三类:</p>
<p>其一是标准参数（ <code>-</code>），所有的JVM实现都必须实现这些参数的功能，而且向后兼容</p>
<p>其二是非标准参数（ <code>-X</code>），默认jvm实现这些参数的功能，但是并不保证所有jvm实现都满足，且不保证向后兼容</p>
<p>其三是非Stable参数（ <code>-XX</code>），此类参数各个jvm实现会有所不同，将来可能会随时取消，需要慎重使用</p>
<p><img src="https://cdn.yangbingdong.com/img/jvm/jvm-param.webp" alt></p>
<p>正确打印日志:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line">-Xloggc:/home/GCEASY/gc-%t.log</span><br></pre></td></tr></table></figure>
<p>打印ClassLoader日志(这个参数会在控制台打印所有类加载/卸载信息):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:+TraceClassLoading </span><br><span class="line">-XX:+TraceClassUnloading</span><br></pre></td></tr></table></figure>
<p>OOM时Dump内存:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError </span><br><span class="line">-XX:HeapDumpPath=/crashes/my-heap-dump.hprof</span><br></pre></td></tr></table></figure>
<p>OOM时执行脚本（比如重启）:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:OnOutOfMemoryError=/scripts/restart-myapp.sh</span><br></pre></td></tr></table></figure>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>附上两张来自 <strong><em><a href="https://mp.weixin.qq.com/s?__biz=MzU3NDY4NzQwNQ==&amp;mid=2247483820&amp;idx=1&amp;sn=8418f0f6a618bb0f0ca0980af09a816f&amp;chksm=fd2fd06eca5859786ab124dd204a7ec9b1ad3ed230b9b531086cc6729a277a05d3e8307b7e0d&amp;scene=21#wechat_redirect" rel="external nofollow noopener noreferrer" target="_blank">无敌码农</a></em></strong> 的图片: </p>
<p><img src="https://cdn.yangbingdong.com/img/jvm/jvm-men-thread.webp" alt></p>
<blockquote>
<p><strong>参考并转载于: </strong><br><strong><em><a href="http://blog.csdn.net/seu_calvin/article/details/51404589" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/seu_calvin/article/details/51404589</a></em></strong><br><strong><em><a href="http://blog.csdn.net/seu_calvin/article/details/51892567" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/seu_calvin/article/details/51892567</a></em></strong><br><strong><em><a href="http://blog.csdn.net/seu_calvin/article/details/52301541" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/seu_calvin/article/details/52301541</a></em></strong><br><strong><em><a href="http://www.importnew.com/23774.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.importnew.com/23774.html</a></em></strong><br><strong><em><a href="http://www.importnew.com/23780.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.importnew.com/23774.html</a></em></strong></p>
</blockquote>
<p>更多JVM汇总请看: </p>
<p><strong><em><a href="http://www.ityouknow.com/jvm.html" rel="external nofollow noopener noreferrer" target="_blank">Jvm系列文章</a></em></strong></p>
<p><strong><em><a href="https://mp.weixin.qq.com/s/4c9K5eYMFGVV2WyKaYXVBA" rel="external nofollow noopener noreferrer" target="_blank">关于Jvm知识看这一篇就够了</a></em></strong></p>
]]></content><categories><category>Programming</category><category>Java</category></categories><tags><tag>Java</tag><tag>JVM</tag></tags></entry><entry><title>线上问题定位常用技巧</title><url>/2019/localize-server-problem/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/online-debug/locate.png" alt></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><blockquote>
<p>线上问题无可避免, 人为BUG, 系统资源限制等, 通过合理的手段可让问题现出原形, 这里记录一些常用的排查手段.</p>
</blockquote>
<a id="more"></a>
<h1 id="线上问题定位常用方法"><a href="#线上问题定位常用方法" class="headerlink" title="线上问题定位常用方法"></a>线上问题定位常用方法</h1><h2 id="查找Java进程"><a href="#查找Java进程" class="headerlink" title="查找Java进程"></a>查找Java进程</h2><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p><code>top</code> 命令定位进程: 输入<code>top</code>命令后，可以按P(shift+p)根据cpu占用排序、按M根据内存占用排序、按T根据运行时间排序.</p>
<h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>通过 <code>jps -mlvV</code> 可以查看当前运行中的Java进程.</p>
<blockquote>
<p>原理：java程序启动后，默认会在<code>/tmp/hsperfdata_userName</code>目录下以该进程的id为文件名新建文件，并在该文件中存储jvm运行的相关信息，其中的userName为当前的用户名，<code>/tmp/hsperfdata_userName</code>目录会存放该用户所有已经启动的java进程信息.而jps、jconsole等工具的数据来源就是这个文件（<code>/tmp/hsperfdata_userName/pid</code>)。所以当该文件不存在或是无法读取时就会出现jps无法查看该进程号，jconsole无法监控等问题.</p>
</blockquote>
<h2 id="CPU100-问题快速定位"><a href="#CPU100-问题快速定位" class="headerlink" title="CPU100%问题快速定位"></a>CPU100%问题快速定位</h2><h3 id="步骤一-找到最耗CPU的进程"><a href="#步骤一-找到最耗CPU的进程" class="headerlink" title="步骤一: 找到最耗CPU的进程"></a>步骤一: 找到最耗CPU的进程</h3><p>1、执行top -c ，显示进程运行信息列表<br>2、键入P (大写p)，进程按照CPU使用率排序<br>3、第一个进程为最耗CPU，假设其PID为 2333</p>
<h3 id="步骤二-找到最耗CPU的线程"><a href="#步骤二-找到最耗CPU的线程" class="headerlink" title="步骤二: 找到最耗CPU的线程"></a>步骤二: 找到最耗CPU的线程</h3><p>1、top -Hp 2333 ，显示一个进程的线程运行信息列表<br>2、键入P (大写p)，线程按照CPU使用率排序<br>3、第一个为最耗CPU线程，假设其PID为 666</p>
<h3 id="步骤三-将线程PID转化为16进制"><a href="#步骤三-将线程PID转化为16进制" class="headerlink" title="步骤三: 将线程PID转化为16进制"></a>步骤三: 将线程PID转化为16进制</h3><p>输入: <code>printf &quot;%x\n&quot; 666</code> 得到 29a<br>666对应的16进制是0x29a<br>之所以要转化为16进制，是因为堆栈里，线程id是用16进制表示的</p>
<h3 id="步骤四-查看堆栈，找到线程在干嘛"><a href="#步骤四-查看堆栈，找到线程在干嘛" class="headerlink" title="步骤四: 查看堆栈，找到线程在干嘛"></a>步骤四: 查看堆栈，找到线程在干嘛</h3><p><code>jstack 2333 | grep &quot;0x29a&quot; -C5 --color</code><br>即可打印堆栈.</p>
<h2 id="内存OOM问题定位"><a href="#内存OOM问题定位" class="headerlink" title="内存OOM问题定位"></a>内存OOM问题定位</h2><h3 id="一、确认是不是内存本身就分配过小"><a href="#一、确认是不是内存本身就分配过小" class="headerlink" title="一、确认是不是内存本身就分配过小"></a>一、确认是不是内存本身就分配过小</h3><p>命令: <code>jmap -heap ${PID}</code><br>注意：Ubuntu系统需要修改一下配置 打开<code>/etc/sysctl.d/10-ptrace.conf</code> 修改为：<code>kernel.yama.ptrace_scope = 0</code> (即将1改成0)</p>
<h3 id="二、找到最耗内存的对象"><a href="#二、找到最耗内存的对象" class="headerlink" title="二、找到最耗内存的对象"></a>二、找到最耗内存的对象</h3><p>命令: <code>jmap -histo:live ${PID} | more</code></p>
<h3 id="三、确认是否是资源耗尽"><a href="#三、确认是否是资源耗尽" class="headerlink" title="三、确认是否是资源耗尽"></a>三、确认是否是资源耗尽</h3><ul>
<li>查看进程的线程数量: <code>ll /proc/${PID}/task | wc -l</code>, 效果等同 <code>pstree -p | wc -l</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ll /proc/17608/task | wc -l</span><br><span class="line">74</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果看到启用了大量线程，就需要审查代码涉及到线程池的使用部分，是否限定了最大线程数量。</p>
</blockquote>
<ul>
<li>查询进程占用的句柄数量: <code>ll /proc/${PID}/fd | wc -l</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ll /proc/17608/fd | wc -l</span><br><span class="line">224</span><br></pre></td></tr></table></figure>
<p><code>jmap -heap</code>输出的非自定义类名说明：</p>
<table>
<thead>
<tr>
<th>BaseType Character</th>
<th>Type</th>
<th>Interpretation</th>
</tr>
</thead>
<tbody>
<tr>
<td>B</td>
<td>byte</td>
<td>signed byte</td>
</tr>
<tr>
<td>C</td>
<td>char</td>
<td>Unicode character</td>
</tr>
<tr>
<td>D</td>
<td>double</td>
<td>double-precision floating-point value</td>
</tr>
<tr>
<td>F</td>
<td>float</td>
<td>single-precision floating-point value</td>
</tr>
<tr>
<td>I</td>
<td>int</td>
<td>integer</td>
</tr>
<tr>
<td>J</td>
<td>long</td>
<td>long integer</td>
</tr>
<tr>
<td>L;</td>
<td>reference</td>
<td>an instance of class</td>
</tr>
<tr>
<td>S</td>
<td>short</td>
<td>signed short</td>
</tr>
<tr>
<td>Z</td>
<td>boolean</td>
<td>true or false</td>
</tr>
<tr>
<td>[</td>
<td>reference</td>
<td>one array dimension</td>
</tr>
</tbody>
</table>
<h2 id="JFR-amp-JMC"><a href="#JFR-amp-JMC" class="headerlink" title="JFR &amp; JMC"></a>JFR &amp; JMC</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Jcmd &lt;pid&gt; JFR.start duration=120s filename=myrecording.jfr</span><br></pre></td></tr></table></figure>
<p>然后，使用 JMC 打开“.jfr 文件”就可以进行分析了，方法、异常、线程、IO 等应有尽有，其功能非常强大</p>
<h1 id="MAT-Memory-Analyzer-Tool"><a href="#MAT-Memory-Analyzer-Tool" class="headerlink" title="MAT(Memory Analyzer Tool)"></a>MAT(Memory Analyzer Tool)</h1><blockquote>
<p>MAT是一款高性能, 具备丰富功能的Java堆内存分析工具, 可以用来排查内存泄漏和内存浪费的问题.</p>
<p>下载地址: <strong><em><a href="https://www.eclipse.org/mat/downloads.php" rel="external nofollow noopener noreferrer" target="_blank">https://www.eclipse.org/mat/downloads.php</a></em></strong></p>
</blockquote>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>下载解压后, 目录中有个 <code>MemoryAnalyzer.ini</code> 的文件, 该文件里面有个 <code>Xmx</code> 参数, 该参数表示最大内存占用量, 默认为 <code>1024m</code>, 根据堆转储文件大小修改该参数即可.</p>
<p>MAT默认的存储展示单位是 <code>Bytes</code>, 可在 <code>Window</code> -&gt; <code>Preferences</code> 中设置:</p>
<p><img src="https://cdn.yangbingdong.com/img/online-debug/mat-setting.png" alt></p>
<ol>
<li>Keep unreachable objects：如果勾选这个，则在分析的时候会包含dump文件中的不可达对象；</li>
<li>Hide the getting started wizard：隐藏分析完成后的首页，控制是否要展示一个对话框，用来展示内存泄漏分析、消耗最多内存的对象排序。</li>
<li>Hide popup query help：隐藏弹出查询帮助，除非用户通过F1或Help按钮查询帮助。</li>
<li>Hide Welcome screen on launch：隐藏启动时候的欢迎界面</li>
<li>Bytes Display：设置分析结果中内存大小的展示单位</li>
</ol>
<h2 id="获取堆转储文件"><a href="#获取堆转储文件" class="headerlink" title="获取堆转储文件"></a>获取堆转储文件</h2><ul>
<li><p>主动获取:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jmap -dump:format=b,file=&lt;dumpfile.hprof&gt; &lt;pid&gt;</span><br><span class="line"></span><br><span class="line"># 或者</span><br><span class="line">jmap -dump:live,format=b,file=&lt;dumpfile.hprof&gt; &lt;pid&gt;</span><br></pre></td></tr></table></figure>
<p><code>live</code> 参数: 这个参数表示我们需要抓取目前在生命周期内的内存对象, 也就是说GC收不走的对象, 然后我们绝大部分情况下, 需要的看的就是这些内存.</p>
</li>
<li><p>内存溢出时自动dump, 在启动参数中添加:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br></pre></td></tr></table></figure>
<p>在Java进程运行过程中发生OOM的时候就会生成一个heapdump文件，并写入到指定目录，一般用<code>-XX:HeapDumpPath=${HOME}/dump/test</code>来设置.</p>
</li>
</ul>
<h2 id="Shallow-Retained-区别"><a href="#Shallow-Retained-区别" class="headerlink" title="Shallow Retained 区别"></a>Shallow Retained 区别</h2><p>当我们打开 <code>Histogram</code> (从类的视角出发) 或者 <code>Dominator Tree</code> (从对象的视角出发) 时, 开到 <code>Shallow Heap</code> 和 <code>Retained Heap</code> 这两列.</p>
<p>简单地说, <code>Shallow</code> 只是对象本身所占用的大小, 而 <code>Retained</code> 则包含了引用对象的大小.</p>
<p><img src="https://cdn.yangbingdong.com/img/online-debug/dump-file-opened.png" alt></p>
<h1 id="转载-如何应对在线故障"><a href="#转载-如何应对在线故障" class="headerlink" title="转载-如何应对在线故障"></a>转载-如何应对在线故障</h1><blockquote>
<p>原创出处: <strong><em><a href="http://www.rowkey.me/blog/2018/11/22/online-debug/" rel="external nofollow noopener noreferrer" target="_blank">http://www.rowkey.me/blog/2018/11/22/online-debug/</a></em></strong></p>
</blockquote>
<p><img src="https://cdn.yangbingdong.com/img/online-debug/online-debug01.jpeg" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/online-debug/online-debug02.jpeg" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/online-debug/online-debug03.jpeg" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/online-debug/online-debug04.jpeg" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/online-debug/online-debug05.jpeg" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/online-debug/online-debug06.jpeg" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/online-debug/online-debug07.jpeg" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/online-debug/online-debug08.jpeg" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/online-debug/online-debug09.jpeg" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/online-debug/online-debug10.jpeg" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/online-debug/online-debug11.jpeg" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/online-debug/online-debug12.jpeg" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/online-debug/online-debug13.jpeg" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/online-debug/online-debug14.jpeg" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/online-debug/online-debug15.jpeg" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/online-debug/online-debug16.jpeg" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/online-debug/online-debug17.jpeg" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/online-debug/online-debug18.jpeg" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/online-debug/online-debug19.jpeg" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/online-debug/online-debug20.jpeg" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/online-debug/online-debug21.jpeg" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/online-debug/online-debug22.jpeg" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/online-debug/online-debug23.jpeg" alt></p>
<h1 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h1><blockquote>
<p>参考：</p>
<p><strong><em><a href="https://mp.weixin.qq.com/s/-K56NWVFiFsL8JSIH42QMA" rel="external nofollow noopener noreferrer" target="_blank">https://mp.weixin.qq.com/s/-K56NWVFiFsL8JSIH42QMA</a></em></strong></p>
<p><strong><em><a href="https://zhuanlan.zhihu.com/p/43435903" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/43435903</a></em></strong></p>
</blockquote>
]]></content><categories><category>Programming</category><category>Java</category></categories><tags><tag>Java</tag><tag>MAT</tag></tags></entry><entry><title>关于微服务的一些调研零散笔记</title><url>/2018/micro-service-ddd-notice/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/micro-service/microservice.png" alt></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><blockquote>
<p><em><a href="https://zh.wikipedia.org/zh-cn/%E5%BE%AE%E6%9C%8D%E5%8B%99" rel="external nofollow noopener noreferrer" target="_blank">微服务架构</a></em>:<br><strong>微服务</strong> (Microservices) 是一种软件架构风格 (Software Architecture Style), 它是以专注于单一责任与功能的小型功能区块 (Small Building Blocks) 为基础, 利用模组化的方式组合出复杂的大型应用程序, 各功能区块使用与<strong>语言无关</strong> (Language-Independent/Language agnostic) 的 <strong>API 集相互通讯</strong>. </p>
</blockquote>
<blockquote>
<p><strong>不拆分存储的微服务是伪服务</strong>: 在实践中, 我们常常见到一种架构, 后端存储是全部和在一个数据库中, 仅仅把前端的业务逻辑拆分到不同的服务进程中, 本质上和一个Monolithic一样, 只是把模块之间的进程内调用改为进程间调用, 这种切分不可取, 违反了分布式第一原则, <strong>模块耦合没有解决</strong>, <strong>性能却受到了影响</strong>. </p>
</blockquote>
<a id="more"></a>
<h1 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h1><p><strong>DDD</strong>: Domain-Driver Design 领域驱动设计</p>
<p><strong>CQRS</strong>: Command Query Responsibility Segregation 命令查询职责分离</p>
<p><strong><a href="http://microservices.io/patterns/data/event-sourcing.html" rel="external nofollow noopener noreferrer" target="_blank">Event Sourcing</a></strong>: 事件溯源</p>
<p><strong>Event-driven Architecture</strong>: 事件驱动架构, 使用事件来实现跨多个服务的业务逻辑</p>
<p><strong>Saga</strong>: 长时间活动的事务(Long Lived Transaction, 简称为LLT)<br>SEC(Saga Execution Coordinator): 一个基于事件驱动的状态机的协调器<br><em><a href="http://newtech.club/2017/07/16/Design%20for%20Failure-Saga%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%B6%88%E6%81%AF%E9%A9%B1%E5%8A%A8/" rel="external nofollow noopener noreferrer" target="_blank">Saga模式和事件驱动</a></em></p>
<p><strong>贫血模型</strong>: 对象只用于在各层之间传输数据用, <strong>只有数据字段和Get/Set方法</strong>, 没有逻辑在对象中<br><strong>充血模型</strong>: <strong>将数据和行为封装在一起</strong>, 并与现实世界的业务对象相映射. 各类具备明确的职责划分, 使得逻辑分散到合适对象中. (领域模型)</p>
<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><strong>微服务架构必须解决这三个问题</strong><br><strong>拆分领域模型</strong>、<strong>事务</strong>、<strong>查询</strong></p>
<h2 id="拆分领域模型"><a href="#拆分领域模型" class="headerlink" title="拆分领域模型"></a>拆分领域模型</h2><p>遵循Single Responsibility(单一职责)<br><strong>Aggregate</strong>(聚合): </p>
<ul>
<li>聚合通过id（例如主键）来引用而不是通过对象引用</li>
<li>聚合必须遵循一个事务只能对一个聚合进行创建或更新</li>
<li>聚合应该尽量细</li>
</ul>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>由于采用了微服务拥有各自的私人数据库, 只能通过API访问, 不可避免出现了分布式跨数据库事务问题. </p>
<h3 id="ACID-vs-BASE"><a href="#ACID-vs-BASE" class="headerlink" title="ACID vs BASE"></a>ACID vs BASE</h3><p>传统事务 <strong>ACID</strong>: </p>
<ul>
<li>Atomicity（原子性）: 一个事务中的操作是原子的, 其中任何一步失败, 系统都能够完全回到事务前的状态</li>
<li>Consistency（一致性）: 数据库的状态始终保持一致</li>
<li>Isolation（隔离性）: 多个并发执行的事务不会互相影响</li>
<li>Durability（持久性）: 事务处理结束后, 对数据的修改是永久的</li>
</ul>
<p>微服务下依靠分布式事务（如2PC）保证实时一致性（强一致性）, 性能底下, 牺牲了可用性, 已不适用于现代的微服务架构. </p>
<p><strong>BASE</strong>模型: </p>
<ul>
<li>Basically Available（基本可用）: 系统在出现不可预知的故障的时候, 允许损失部分可用性, 但不等于系统不可用</li>
<li>Soft State（软状态）: 允许系统中的数据存在中间状态, 并认为该中间状态的存在不会影响系统的整体可用性</li>
<li>Eventually Consistent（最终一致性）: 系统保证最终数据能够达到一致</li>
</ul>
<p>微服务倡导每个微服务拥有私有的数据库, 且其他服务不能直接与访问该数据库, 只能通过该服务暴露的API进行交互. </p>
<h3 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h3><p>业务层面的2PC, 需要实现<code>Try</code>、<code>Comfirm</code>、<code>Cancel</code><br><em><a href="https://github.com/search?l=Java&amp;o=desc&amp;q=tcc&amp;s=stars&amp;type=Repositories&amp;utf8=%E2%9C%93" rel="external nofollow noopener noreferrer" target="_blank">GitHub中TCC实现框架</a></em></p>
<h3 id="基于可靠消息达到最终一致性"><a href="#基于可靠消息达到最终一致性" class="headerlink" title="基于可靠消息达到最终一致性"></a>基于可靠消息达到最终一致性</h3><p>缺点是应用程序不能够立即读取到自己刚刚的写入（滞后性）. </p>
<h4 id="使用本地事务"><a href="#使用本地事务" class="headerlink" title="使用本地事务"></a>使用本地事务</h4><p>对资源的操作与发布时间捆绑在同一事务中.<br>优点: 使用了本地数据库的事务, 如果Event没有插入或发布成功, 那么订单也不会被创建.<br>缺点: 需要单独处理Event发布在业务逻辑中, 繁琐容易忘记；Event发送有些滞后. </p>
<h4 id="使用数据库特有的MySQL-Binlog跟踪"><a href="#使用数据库特有的MySQL-Binlog跟踪" class="headerlink" title="使用数据库特有的MySQL Binlog跟踪"></a>使用数据库特有的MySQL Binlog跟踪</h4><p>订阅binlog发送event<br>优点: 提高了性能<br>缺点: 不同的数据库, 日志格式不一样, 而且同一数据库, 不同版本格式也可能不一样, 决策的时候请慎重. </p>
<h3 id="Event-Sourcing"><a href="#Event-Sourcing" class="headerlink" title="Event Sourcing"></a>Event Sourcing</h3><p>颠覆传统存储概念, 不持久化对象数据, 而是持久化对象变更的Event, 通过溯源, 遍历事件拿到对象的最新状态. 在我看来, 类似文件系统的概念, 一个操作是一层, 删除并不是减掉一层, 而是添加一层删除操作（类似Git中的版本, 可回滚, 有记录追踪）. </p>
<h3 id="阿里云GTS全局事务"><a href="#阿里云GTS全局事务" class="headerlink" title="阿里云GTS全局事务"></a>阿里云GTS全局事务</h3><p><strong><em><a href="https://help.aliyun.com/document_detail/48726.html" rel="external nofollow noopener noreferrer" target="_blank">GTS（Global Transaction Service）官方文档</a></em></strong>（需要捆绑Ali全家桶. . . ）</p>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>实践微服务之后, 除了事务之外, 查询是又是另外一个挑战. 在传统架构中, 我们可以JOIN多个表进行查询, 但在微服务当中, 数据库已经分开, 如果是通过Event Sourcing实现的架构就更加困难了（因为存储的是事件）. </p>
<p>解决之道: <strong>CQRS</strong></p>
<h1 id="Extend"><a href="#Extend" class="headerlink" title="Extend"></a>Extend</h1><h2 id="Event-driven"><a href="#Event-driven" class="headerlink" title="Event-driven"></a>Event-driven</h2><p><code>Sync</code>（请求/响应）: 串行架构</p>
<p><img src="https://cdn.yangbingdong.com/img/micro-service/register-sync.jpg" alt><br>优点: 个人认为, 只有一个优点, 可以偷懒<br>缺点: 中心控制点承担了太多的职责, 入侵式强耦合代码, 如果此时多加一个业务例如创建用户团队, 那就必须在原来代码基础上继续入侵代码, 而且修改一行代码有可能影响到下文. </p>
<p><code>Async</code>（基于事件）: 并行/异步架构</p>
<p><img src="https://cdn.yangbingdong.com/img/micro-service/register-async.jpg" alt><br>优点: 客户端发起的不是一个请求, 而是<strong>发布一个事件</strong>, 然后其他协作者接收到该事件, 并知道该怎么做. 我们从来不会告知任何人去做任何事, 基于事件的系统天生就是<strong>异步</strong>的. 整个系统都很聪明, 业务逻辑并非存在某个核心大脑, 而是分布在不同的协作者中. 基于事件的协作方式耦合性很低, 这意味着你可以在<strong>不改变客户端代码</strong>的情况下, 对该事件<strong>添加新的订阅者来完成新增的功能需求</strong>. </p>
<h2 id="Spring-Cloud-Framework"><a href="#Spring-Cloud-Framework" class="headerlink" title="Spring Cloud Framework"></a>Spring Cloud Framework</h2><h3 id="Spring-Cloud-Netflix"><a href="#Spring-Cloud-Netflix" class="headerlink" title="Spring Cloud Netflix"></a>Spring Cloud Netflix</h3><p>这可是个大boss, 地位仅次于老大, 老大各项服务依赖与它, 与各种Netflix OSS组件集成, 组成微服务的核心, 它的小弟主要有Eureka, Hystrix, Zuul, Archaius… 太多了</p>
<p><strong>Netflix Eureka</strong></p>
<p>服务中心, 云端服务发现, 一个基于 REST 的服务, 用于定位服务, 以实现云端中间层服务发现和故障转移. 这个可是springcloud最牛鼻的小弟, 服务中心, 任何小弟需要其它小弟支持什么都需要从这里来拿, 同样的你有什么独门武功的都赶紧过报道, 方便以后其它小弟来调用；它的好处是你不需要直接找各种什么小弟支持, 只需要到服务中心来领取, 也不需要知道提供支持的其它小弟在哪里, 还是几个小弟来支持的, 反正拿来用就行, 服务中心来保证稳定性和质量. </p>
<p><strong>Netflix Hystrix</strong></p>
<p>熔断器, 容错管理工具, 旨在通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力. 比如突然某个小弟生病了, 但是你还需要它的支持, 然后调用之后它半天没有响应, 你却不知道, 一直在等等这个响应；有可能别的小弟也正在调用你的武功绝技, 那么当请求多之后, 就会发生严重的阻塞影响老大的整体计划. 这个时候Hystrix就派上用场了, 当Hystrix发现某个小弟不在状态不稳定立马马上让它下线, 让其它小弟来顶上来, 或者给你说不用等了这个小弟今天肯定不行, 该干嘛赶紧干嘛去别在这排队了. </p>
<p><strong>Netflix Zuul</strong></p>
<p>Zuul 是在云平台上提供动态路由,监控,弹性,安全等边缘服务的框架. Zuul 相当于是设备和 Netflix 流应用的 Web 网站后端所有请求的前门. 当其它门派来找大哥办事的时候一定要先经过zuul,看下有没有带刀子什么的给拦截回去, 或者是需要找那个小弟的直接给带过去. </p>
<p><strong>Netflix Archaius</strong></p>
<p>配置管理API, 包含一系列配置管理API, 提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能. 可以实现动态获取配置, 原理是每隔60s（默认, 可配置）从配置源读取一次内容, 这样修改了配置文件后不需要重启服务就可以使修改后的内容生效, 前提使用archaius的API来读取. </p>
<h3 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h3><p>俗称的配置中心, 配置管理工具包, 让你可以把配置放到远程服务器, 集中化管理集群配置, 目前支持本地存储、Git以及Subversion. 就是以后大家武器、枪火什么的东西都集中放到一起, 别随便自己带, 方便以后统一管理、升级装备. </p>
<h3 id="Spring-Cloud-Bus"><a href="#Spring-Cloud-Bus" class="headerlink" title="Spring Cloud Bus"></a>Spring Cloud Bus</h3><p>事件、消息总线, 用于在集群（例如, 配置变化事件）中传播状态变化, 可与Spring Cloud Config联合实现热部署. 相当于水浒传中日行八百里的神行太保戴宗, 确保各个小弟之间消息保持畅通. </p>
<h3 id="Spring-Cloud-for-Cloud-Foundry"><a href="#Spring-Cloud-for-Cloud-Foundry" class="headerlink" title="Spring Cloud for Cloud Foundry"></a>Spring Cloud for Cloud Foundry</h3><p>Cloud Foundry是VMware推出的业界第一个开源PaaS云平台, 它支持多种框架、语言、运行时环境、云平台及应用服务, 使开发人员能够在几秒钟内进行应用程序的部署和扩展, 无需担心任何基础架构的问题</p>
<p>其实就是与CloudFoundry进行集成的一套解决方案, 抱了Cloud Foundry的大腿. </p>
<h3 id="Spring-Cloud-Cluster"><a href="#Spring-Cloud-Cluster" class="headerlink" title="Spring Cloud Cluster"></a>Spring Cloud Cluster</h3><p>Spring Cloud Cluster将取代Spring Integration. 提供在分布式系统中的集群所需要的基础功能支持, 如: 选举、集群的状态一致性、全局锁、tokens等常见状态模式的抽象和实现. </p>
<p>如果把不同的帮派组织成统一的整体, Spring Cloud Cluster已经帮你提供了很多方便组织成统一的工具. </p>
<h3 id="Spring-Cloud-Consul"><a href="#Spring-Cloud-Consul" class="headerlink" title="Spring Cloud Consul"></a>Spring Cloud Consul</h3><p>Consul 是一个支持多数据中心分布式高可用的服务发现和配置共享的服务软件,由 HashiCorp 公司用 Go 语言开发, 基于 Mozilla Public License 2.0 的协议进行开源. Consul 支持健康检查,并允许 HTTP 和 DNS 协议调用 API 存储键值对.</p>
<p>Spring Cloud Consul 封装了Consul操作, consul是一个服务发现与配置工具, 与Docker容器可以无缝集成. </p>
<h3 id="其它小弟"><a href="#其它小弟" class="headerlink" title="其它小弟"></a>其它小弟</h3><p><strong>Spring Cloud Security</strong></p>
<p>基于spring security的安全工具包, 为你的应用程序添加安全控制. 这个小弟很牛鼻专门负责整个帮派的安全问题, 设置不同的门派访问特定的资源, 不能把秘籍葵花宝典泄漏了. </p>
<p><strong>Spring Cloud Sleuth</strong></p>
<p>日志收集工具包, 封装了Dapper和log-based追踪以及Zipkin和HTrace操作, 为SpringCloud应用实现了一种分布式追踪解决方案. </p>
<p><strong>Spring Cloud Data Flow</strong></p>
<ul>
<li>Data flow 是一个用于开发和执行大范围数据处理其模式包括ETL, 批量运算和持续运算的统一编程模型和托管服务. </li>
<li>对于在现代运行环境中可组合的微服务程序来说, Spring Cloud data flow是一个原生云可编配的服务. 使用Spring Cloud data flow, 开发者可以为像数据抽取, 实时分析, 和数据导入/导出这种常见用例创建和编配数据通道 （data pipelines）. </li>
<li>Spring Cloud data flow 是基于原生云对 spring XD的重新设计, 该项目目标是简化大数据应用的开发. Spring XD 的流处理和批处理模块的重构分别是基于 Spring Boot的stream 和 task/batch 的微服务程序. 这些程序现在都是自动部署单元而且他们原生的支持像 Cloud Foundry、Apache YARN、Apache Mesos和Kubernetes 等现代运行环境. </li>
<li>Spring Cloud data flow 为基于微服务的分布式流处理和批处理数据通道提供了一系列模型和最佳实践. </li>
</ul>
<p><strong>Spring Cloud Stream</strong></p>
<p>Spring Cloud Stream是创建消息驱动微服务应用的框架. Spring Cloud Stream是基于Spring Boot创建, 用来建立单独的／工业级spring应用, 使用spring integration提供与消息代理之间的连接. 数据流操作开发包, 封装了与Redis,Rabbit、Kafka等发送接收消息. </p>
<p>一个业务会牵扯到多个任务, 任务之间是通过事件触发的, 这就是Spring Cloud stream要干的事了</p>
<p><strong>Spring Cloud Task</strong></p>
<p>Spring Cloud Task 主要解决短命微服务的任务管理, 任务调度的工作, 比如说某些定时任务晚上就跑一次, 或者某项数据分析临时就跑几次. </p>
<p><strong>Spring Cloud Zookeeper</strong></p>
<p>ZooKeeper是一个分布式的, 开放源码的分布式应用程序协调服务, 是Google的Chubby一个开源的实现, 是Hadoop和Hbase的重要组件. 它是一个为分布式应用提供一致性服务的软件, 提供的功能包括: 配置维护、域名服务、分布式同步、组服务等. ZooKeeper的目标就是封装好复杂易出错的关键服务, 将简单易用的接口和性能高效、功能稳定的系统提供给用户. </p>
<p>操作Zookeeper的工具包, 用于使用zookeeper方式的服务发现和配置管理, 抱了Zookeeper的大腿. </p>
<p><strong>Spring Cloud Connectors</strong></p>
<p>Spring Cloud Connectors 简化了连接到服务的过程和从云平台获取操作的过程, 有很强的扩展性, 可以利用Spring Cloud Connectors来构建你自己的云平台. </p>
<p>便于云端应用程序在各种PaaS平台连接到后端, 如: 数据库和消息代理服务. </p>
<p><strong>Spring Cloud Starters</strong></p>
<p>Spring Boot式的启动项目, 为Spring Cloud提供开箱即用的依赖管理. </p>
<p><strong>Spring Cloud CLI</strong></p>
<p>基于 Spring Boot CLI, 可以让你以命令行方式快速建立云组件. </p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p><em><a href="https://github.com/JoeCao/OrderEventDrivenDemo" rel="external nofollow noopener noreferrer" target="_blank">基于事件驱动+事件溯源+Saga的微服务示例</a></em></p>
<p><em><a href="https://github.com/chaokunyang/microservices-event-sourcing" rel="external nofollow noopener noreferrer" target="_blank">一个微服务架构的在线购物网站（CQRS+Event Sourcing）</a></em></p>
<p><em><a href="https://github.com/kbastani/spring-cloud-event-sourcing-example" rel="external nofollow noopener noreferrer" target="_blank">spring-cloud-event-sourcing-example</a></em></p>
<p><em><a href="https://github.com/AxonFramework/AxonFramework" rel="external nofollow noopener noreferrer" target="_blank">CQRS实现框架AxonFramework</a></em></p>
<p><em><a href="https://github.com/eventuate-local/eventuate-local" rel="external nofollow noopener noreferrer" target="_blank">溯源实现框架Eventuate Local</a></em></p>
]]></content><categories><category>Programming</category><category>Java</category></categories><tags><tag>Java</tag></tags></entry><entry><title>MySQL杂记</title><url>/2018/mysql-related-learning/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/mysql-related-learning/MySQL.png" alt></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><blockquote>
<p>MySQL是什么就多说了. . . </p>
</blockquote>
<a id="more"></a>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="传统安装"><a href="#传统安装" class="headerlink" title="传统安装"></a>传统安装</h2><p>请见<a href="/2017/ubuntu-dev-environment-to-build/#%E5%AE%89%E8%A3%85MySQL%E4%BB%A5%E5%8F%8AGUI%E5%B7%A5%E5%85%B7"><em>之前写的的一篇开发环境配置</em></a></p>
<h2 id="Docker版安装"><a href="#Docker版安装" class="headerlink" title="Docker版安装"></a>Docker版安装</h2><p>直接贴出<code>docker-compose.yml</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.5'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"3306:3306"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">../data:/var/lib/mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">../conf:/etc/mysql/conf.d</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=root</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">backend:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>配置文件（<code>config-file.cnf</code>, 放在上面<code>volumes</code>中提到的<code>../conf</code>里）: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"></span><br><span class="line">sql_mode = STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION</span><br><span class="line">lower_case_table_names = 1</span><br><span class="line">character-set-server = utf8mb4</span><br><span class="line">collation-server = utf8mb4_unicode_ci</span><br></pre></td></tr></table></figure>
<h2 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h2><h3 id="配置文件权限"><a href="#配置文件权限" class="headerlink" title="配置文件权限"></a>配置文件权限</h3><p>虽然启动成功, 但发现MySQL实例是关闭的, 在启动日志中发现这一条信息</p>
<p><img src="https://cdn.yangbingdong.com/img/mysql-related-learning/mysql-warning.png" alt></p>
<p>大概意思是<strong>权限全局可写</strong>, 任何一个用户都可以写. MySQL担心这种文件<strong>被其他用户恶意修改</strong>, 所以<strong>忽略</strong>掉这个配置文件. </p>
<p>结论: <strong>配置文件权限过大, 会影响实例不能启动, 或者不能关闭, 需要修改为 644</strong></p>
<p>问题得以解决~！</p>
<h3 id="Docker时区"><a href="#Docker时区" class="headerlink" title="Docker时区"></a>Docker时区</h3><p>通过Docker启动的MySql, 默认读取的是Docker中的时区UTC, 只要在docker compose文件中指定时区就行了:</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">    environment:</span><br><span class="line">      - MYSQL_ROOT_PASSWORD=root</span><br><span class="line"><span class="addition">+     - TZ=Asia/Shanghai</span></span><br></pre></td></tr></table></figure>
<p>或者在MySql配置文件中加入:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">...</span><br><span class="line">default-time-zone=&apos;+8:00&apos;</span><br></pre></td></tr></table></figure>
<h3 id="连接不上"><a href="#连接不上" class="headerlink" title="连接不上"></a>连接不上</h3><p>若抛出酱紫的错误:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR 2002 (HY000): Can&apos;t connect to local MySQL server through socket &apos;/var/run/mysqld/mysqld.sock&apos; (2)</span><br></pre></td></tr></table></figure>
<p>那么你可能使用了 <code>localhost</code> 链接, 改为 <code>127.0.0.1</code> 或内网地址则OK.</p>
<h1 id="客户端以及GUI"><a href="#客户端以及GUI" class="headerlink" title="客户端以及GUI"></a>客户端以及GUI</h1><h2 id="传统终端客户端"><a href="#传统终端客户端" class="headerlink" title="传统终端客户端"></a>传统终端客户端</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mysql-client</span><br><span class="line"></span><br><span class="line">// 链接</span><br><span class="line">mysql -h 127.0.0.1 -P 3306 -u root -p</span><br></pre></td></tr></table></figure>
<h2 id="智能补全命令客户端"><a href="#智能补全命令客户端" class="headerlink" title="智能补全命令客户端"></a>智能补全命令客户端</h2><p>这个一个智能补全并且高亮语法的终端客户端 <strong><em><a href="https://github.com/dbcli/mycli" rel="external nofollow noopener noreferrer" target="_blank">mycli</a></em></strong></p>
<p><img src="https://cdn.yangbingdong.com/img/mysql-related-learning/mycli.gif" alt></p>
<p>安装: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install mycli</span><br></pre></td></tr></table></figure>
<p><code>mycli --help</code> 查看使用方法.</p>
<h2 id="Navicat-Premium"><a href="#Navicat-Premium" class="headerlink" title="Navicat Premium"></a>Navicat Premium</h2><p>安装以及破解在<strong><em><a href="/2017/ubuntu-dev-environment-to-build/#Navicat-Premium">另一篇博文</a></em></strong>里面. </p>
<p><img src="https://cdn.yangbingdong.com/img/javaDevEnv/navicat12.png" alt></p>
<h2 id="Workbench"><a href="#Workbench" class="headerlink" title="Workbench"></a>Workbench</h2><p>MySQL官方开源GUI</p>
<p>下载地址: <strong><em><a href="https://dev.mysql.com/downloads/workbench/" rel="external nofollow noopener noreferrer" target="_blank">https://dev.mysql.com/downloads/workbench/</a></em></strong></p>
<p><img src="https://cdn.yangbingdong.com/img/mysql-related-learning/MySQL%20Workbench_001.png" alt></p>
<h1 id="索引相关"><a href="#索引相关" class="headerlink" title="索引相关"></a>索引相关</h1><h2 id="科普"><a href="#科普" class="headerlink" title="科普"></a>科普</h2><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+ Tree"></a>B+ Tree</h3><p>Innodb 采用 B+ Tree 结构, 索引也是.</p>
<p>B+ Tree 的几个特征:</p>
<ul>
<li>最底层的节点叫作叶子节点, 用来存放数据</li>
<li>其他上层节点叫作非叶子节点, 仅用来存放目录项, 作为索引</li>
<li>非叶子节点分为不同层次, 通过分层来降低每一层的搜索量</li>
<li>所有节点<strong>按照索引键大小排序</strong>, 构成一个双向链表, 加速范围查找</li>
</ul>
<p><img src="https://cdn.yangbingdong.com/img/mysql-related-learning/mysql-b-plus-tree.png" alt></p>
<p>B+ 树, 既可以保存实际数据, 也可以加速数据搜索, 这就是聚簇索引.由于数据在物理上只会保存一份, <strong>所以包含实际数据的聚簇索引只能有一个</strong>.</p>
<h3 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h3><p>为了实现非主键字段的快速搜索, 就引出了二级索引, 也叫作<strong>非聚簇索引</strong>或者辅助索引. 二级索引的叶子节点中保存的不是实际数据, 而是主键, 获得主键值后去聚簇索引中获得数据行, 这个过程就叫作<strong>回表</strong>。</p>
<h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><p>如果我们需要查询的是索引列索引或联合索引能覆盖的数据, 那么查询索引本身已经  “覆盖” 了需要的数据不再需要回表查询.</p>
<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>索引下推优化(index condition pushdown)是在 MySQL 5.6 引入的: 可以在索引遍历过程中, 对索引中包含的字段先做判断, 直接过滤掉不满足条件的记录, 减少回表次数.</p>
<h2 id="如何判断数据库索引是否生效"><a href="#如何判断数据库索引是否生效" class="headerlink" title="如何判断数据库索引是否生效"></a>如何判断数据库索引是否生效</h2><p>使用<code>explain ... \G</code>分析语句 (使用<code>\G</code>可格式化结果)</p>
<p>表结构: </p>
<p><img src="https://cdn.yangbingdong.com/img/mysql-related-learning/idx-explain01.png" alt></p>
<p>不使用索引: </p>
<p><img src="https://cdn.yangbingdong.com/img/mysql-related-learning/idx-explain02.png" alt></p>
<p>使用索引: </p>
<p><img src="https://cdn.yangbingdong.com/img/mysql-related-learning/idx-explain03.png" alt></p>
<p>可以看到, 使用<code>explain</code>显示了很多列, 各个关键字的含义如下: </p>
<ul>
<li><p><code>table</code>: 顾名思义, 显示这一行的数据是关于哪张表的；</p>
</li>
<li><p><code>type</code>: 这是重要的列, 显示连接使用了何种类型. 从<strong>最好到最差</strong>的连接类型为: <code>const</code>、<code>eq_reg</code>、<code>ref</code>、<code>range</code>、<code>indexhe</code>和<code>ALL</code>（详情: <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain-join-types" rel="external nofollow noopener noreferrer" target="_blank"><em>https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain-join-types</em></a>）；</p>
</li>
<li><p><code>possible_keys</code>: 显示可能应用在这张表中的索引. 如果为空, 没有可能的索引. 可以为相关的域从<code>where</code>语句中选择一个合适的语句；</p>
</li>
<li><p><code>key</code>: 实际使用的索引. 如果为<code>NULL</code>, 则没有使用索引. 很少的情况下, MySQL会选择优化不足的索引. 这种情况下, 可以在<code>Select</code>语句中使用<code>USE INDEX（indexname）</code>来强制使用一个索引或者用<code>IGNORE INDEX（indexname）</code>来强制MySQL忽略索引；</p>
</li>
<li><p><code>key_len</code>: 使用的索引的长度. 在不损失精确性的情况下, 长度越短越好；</p>
</li>
<li><p><code>ref</code>: 显示索引的哪一列被使用了, 如果可能的话, 是一个常数；</p>
</li>
<li><p><code>rows</code>: MySQL认为必须检查的用来返回请求数据的行数；</p>
</li>
<li><p><code>Extra</code>: 关于MySQL如何解析查询的额外信息. </p>
<p>  以下是<code>Extra</code>返回含义: </p>
<p>  <code>Distinct</code>:一旦MYSQL找到了与行相联合匹配的行, 就不再搜索了</p>
<p>  <code>Not exists</code>: MYSQL优化了<code>LEFT JOIN</code>, 一旦它找到了匹配<code>LEFT JOIN</code>标准的行, 就不再搜索了</p>
<p>  <code>Range checked for each Record（index map:#）</code>:没有找到理想的索引, 因此对于从前面表中来的每一个行组合, MYSQL检查使用哪个索引, 并用它来从表中返回行. 这是使用索引的最慢的连接之一</p>
<p>  <code>Using filesort</code>: 看到这个的时候, 查询就需要优化了. MYSQL需要进行额外的步骤来发现如何对返回的行排序. 它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行</p>
<p>  <code>Using index</code>: 列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的, 这发生在对表的全部的请求列都是同一个索引的部分的时候</p>
<p>  <code>Using temporary</code> 看到这个的时候, 查询需要优化了. 这里, MYSQL需要创建一个临时表来存储结果, 这通常发生在对不同的列集进行<code>ORDER BY</code>上, 而不是<code>GROUP BY</code>上</p>
<p>  <code>Where used</code> 使用了<code>WHERE</code>从句来限制哪些行将与下一张表匹配或者是返回给用户. 如果不想返回表中的全部行, 并且连接类型<code>ALL</code>或<code>index</code>, 这就会发生, 或者是查询有问题不同连接类型的解释（按照效率高低的顺序排序）</p>
<p>  <code>system</code> 表只有一行: <code>system</code>表. 这是<code>const</code>连接类型的特殊情况</p>
<p>  <code>const</code>:表中的一个记录的最大值能够匹配这个查询（索引可以是主键或惟一索引）. 因为只有一行, 这个值实际就是常数, 因为MYSQL先读这个值然后把它当做常数来对待</p>
<p>  <code>eq_ref</code>:在连接中, MYSQL在查询时, 从前面的表中, 对每一个记录的联合都从表中读取一个记录, 它在查询使用了索引为主键或惟一键的全部时使用</p>
<p>  <code>ref</code>:这个连接类型只有在查询使用了不是惟一或主键的键或者是这些类型的部分（比如, 利用最左边前缀）时发生. 对于之前的表的每一个行联合, 全部记录都将从表中读出. 这个类型严重依赖于根据索引匹配的记录多少—越少越好</p>
<p>  <code>range</code>:这个连接类型使用索引返回一个范围中的行, 比如使用&gt;或&lt;查找东西时发生的情况</p>
<p>  <code>index</code>: 这个连接类型对前面的表中的每一个记录联合进行完全扫描（比ALL更好, 因为索引一般小于表数据）</p>
<p>  <code>ALL</code>:这个连接类型对于前面的每一个记录联合进行完全扫描, 这一般比较糟糕, 应该尽量避免</p>
</li>
</ul>
<p>具体的各个列所能表示的值以及含义可以参考MySQL官方文档介绍, 地址: <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html" rel="external nofollow noopener noreferrer" target="_blank"><em>https://dev.mysql.com/doc/refman/5.7/en/explain-output.html</em></a></p>
<h2 id="哪些场景会造成索引失效"><a href="#哪些场景会造成索引失效" class="headerlink" title="哪些场景会造成索引失效"></a>哪些场景会造成索引失效</h2><ol>
<li><p>应尽量避免在 <code>where</code> 子句中使用 <code>!=</code> 或 <code>&lt;&gt;</code> 操作符, 否则引擎将放弃使用索引而进行全表扫描</p>
</li>
<li><p>尽量避免在 <code>where</code> 子句中使用 <code>or</code> 来连接条件, 否则将<strong>导致引擎放弃使用索引而进行全表扫描</strong>, 即使其中有条件带索引也不会使用, 这也是为什么尽量少用 <code>or</code> 的原因</p>
</li>
<li><p>对于<strong>多列索引</strong>, <strong>不是使用的第一部分</strong>, 则不会使用索引</p>
</li>
<li><p>隐式转换, 比如列类型是<strong>字符串</strong>, 那一定要在条件中将数据使用<strong>引号</strong>引用起来, 否则不会使用索引</p>
<p><img src="https://cdn.yangbingdong.com/img/mysql-related-learning/idx-explain04.png" alt></p>
</li>
<li><p>可能由于字符集导致的索引失败, 连表查询中, 两个关联字段的字符集不一样会导致索引失效, 因为字符集不一样 MySQL 或使用函数将字符集改成一样的</p>
</li>
<li><p><code>like</code>的模糊查询以 <code>%</code> 开头, 索引失效, 索引 B+ 树中行数据<strong>按照索引值排序</strong>, 只能根据前缀进行比较.</p>
</li>
<li><p>应尽量<strong>避免</strong>在 <code>where</code> 子句中对字段进行<strong>表达式操作</strong>, 这将导致引擎放弃使用索引而进行全表扫描</p>
<p>如: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select id from t where num/2 = 100 1</span><br></pre></td></tr></table></figure>
<p>应改为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select id from t where num = 100*2；1</span><br></pre></td></tr></table></figure>
</li>
<li><p>应尽量<strong>避免</strong>在 where 子句中对字段进行<strong>函数操作</strong>, 这将导致引擎放弃使用索引而进行全表扫描, 同样的原因, 索引保存的是索引列的原始值, 而不是经过函数计算后的值</p>
<p>例如: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select id from t where substring(name,1,3) = &apos;abc&apos; – name;1</span><br></pre></td></tr></table></figure>
<p>以abc开头的, 应改成: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select id from t where name like ‘abc%’ 1</span><br></pre></td></tr></table></figure>
<p>例如: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select id from t where datediff(day, createdate, &apos;2005-11-30&apos;) = 0 – &apos;2005-11-30&apos;;1</span><br></pre></td></tr></table></figure>
<p>应改为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select id from t where createdate &gt;= &apos;2005-11-30&apos; and createdate &lt; &apos;2005-12-1&apos;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不要在 <code>where</code> 子句中的 <code>=</code> 左边进行函数、算术运算或其他表达式运算, 否则系统将可能无法正确使用索引</p>
</li>
<li><p>如果MySQL估计使用全表扫描要比使用索引快, 则不使用索引</p>
</li>
<li><p>不适合键值较少的列（重复数据较多的列）</p>
<blockquote>
<p>假如索引列TYPE有5个键值, 如果有1万条数据, 那么 WHERE TYPE = 1将访问表中的2000个数据块. 再加上访问索引块, 一共要访问大于2000个的数据块. 如果全表扫描, 假设10条数据一个数据块, 那么只需访问1000个数据块, 既然全表扫描访问的数据块少一些, 肯定就不会利用索引了. </p>
</blockquote>
</li>
</ol>
<blockquote>
<p>参考: <em><a href="http://blog.csdn.net/xlgen157387/article/details/79572598" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/xlgen157387/article/details/79572598</a></em></p>
</blockquote>
<h1 id="JSON相关"><a href="#JSON相关" class="headerlink" title="JSON相关"></a>JSON相关</h1><h2 id="JSON支持"><a href="#JSON支持" class="headerlink" title="JSON支持"></a>JSON支持</h2><ul>
<li>在MySQL 5.7.8中, MySQL支持由RFC 7159定义的本地JSON数据类型, 它支持对JSON(JavaScript对象标记)文档中的数据进行有效访问.</li>
<li>MySQL会对DML JSON数据自动验证. 无效的DML JSON数据操作会产生错误.</li>
<li>优化的存储格式. 存储在JSON列中的JSON文档转换为一种内部格式, 允许对Json元素进行快速读取访问.</li>
<li>MySQL Json类型支持通过虚拟列方式建立索引, 从而增加查询性能提升.</li>
</ul>
<h3 id="函数语法"><a href="#函数语法" class="headerlink" title="函数语法"></a>函数语法</h3><p>mysql在json类型中增加了一些json相关的函数 可以参考如下</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-modification-functions.html#function_json-append" rel="external nofollow noopener noreferrer" target="_blank"><code>JSON_APPEND()</code></a> (deprecated 5.7.9)</td>
<td>Append data to JSON document</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-creation-functions.html#function_json-array" rel="external nofollow noopener noreferrer" target="_blank"><code>JSON_ARRAY()</code></a></td>
<td>Create JSON array</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-modification-functions.html#function_json-array-append" rel="external nofollow noopener noreferrer" target="_blank"><code>JSON_ARRAY_APPEND()</code></a></td>
<td>Append data to JSON document</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-modification-functions.html#function_json-array-insert" rel="external nofollow noopener noreferrer" target="_blank"><code>JSON_ARRAY_INSERT()</code></a></td>
<td>Insert into JSON array</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-search-functions.html#operator_json-column-path" rel="external nofollow noopener noreferrer" target="_blank"><code>-&gt;</code></a></td>
<td>Return value from JSON column after evaluating path; equivalent to JSON_EXTRACT().</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-search-functions.html#function_json-contains" rel="external nofollow noopener noreferrer" target="_blank"><code>JSON_CONTAINS()</code></a></td>
<td>Whether JSON document contains specific object at path</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-search-functions.html#function_json-contains-path" rel="external nofollow noopener noreferrer" target="_blank"><code>JSON_CONTAINS_PATH()</code></a></td>
<td>Whether JSON document contains any data at path</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-attribute-functions.html#function_json-depth" rel="external nofollow noopener noreferrer" target="_blank"><code>JSON_DEPTH()</code></a></td>
<td>Maximum depth of JSON document</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-search-functions.html#function_json-extract" rel="external nofollow noopener noreferrer" target="_blank"><code>JSON_EXTRACT()</code></a></td>
<td>Return data from JSON document</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-search-functions.html#operator_json-inline-path" rel="external nofollow noopener noreferrer" target="_blank"><code>-&gt;&gt;</code></a></td>
<td>Return value from JSON column after evaluating path and unquoting the result; equivalent to JSON_UNQUOTE(JSON_EXTRACT()).</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-modification-functions.html#function_json-insert" rel="external nofollow noopener noreferrer" target="_blank"><code>JSON_INSERT()</code></a></td>
<td>Insert data into JSON document</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-search-functions.html#function_json-keys" rel="external nofollow noopener noreferrer" target="_blank"><code>JSON_KEYS()</code></a></td>
<td>Array of keys from JSON document</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-attribute-functions.html#function_json-length" rel="external nofollow noopener noreferrer" target="_blank"><code>JSON_LENGTH()</code></a></td>
<td>Number of elements in JSON document</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-modification-functions.html#function_json-merge" rel="external nofollow noopener noreferrer" target="_blank"><code>JSON_MERGE()</code></a> (deprecated 5.7.22)</td>
<td>Merge JSON documents, preserving duplicate keys. Deprecated synonym for JSON_MERGE_PRESERVE()</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-modification-functions.html#function_json-merge-patch" rel="external nofollow noopener noreferrer" target="_blank"><code>JSON_MERGE_PATCH()</code></a></td>
<td>Merge JSON documents, replacing values of duplicate keys</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-modification-functions.html#function_json-merge-preserve" rel="external nofollow noopener noreferrer" target="_blank"><code>JSON_MERGE_PRESERVE()</code></a></td>
<td>Merge JSON documents, preserving duplicate keys</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-creation-functions.html#function_json-object" rel="external nofollow noopener noreferrer" target="_blank"><code>JSON_OBJECT()</code></a></td>
<td>Create JSON object</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-utility-functions.html#function_json-pretty" rel="external nofollow noopener noreferrer" target="_blank"><code>JSON_PRETTY()</code></a></td>
<td>Prints a JSON document in human-readable format, with each array element or object member printed on a new line, indented two spaces with respect to its parent.</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-creation-functions.html#function_json-quote" rel="external nofollow noopener noreferrer" target="_blank"><code>JSON_QUOTE()</code></a></td>
<td>Quote JSON document</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-modification-functions.html#function_json-remove" rel="external nofollow noopener noreferrer" target="_blank"><code>JSON_REMOVE()</code></a></td>
<td>Remove data from JSON document</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-modification-functions.html#function_json-replace" rel="external nofollow noopener noreferrer" target="_blank"><code>JSON_REPLACE()</code></a></td>
<td>Replace values in JSON document</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-search-functions.html#function_json-search" rel="external nofollow noopener noreferrer" target="_blank"><code>JSON_SEARCH()</code></a></td>
<td>Path to value within JSON document</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-modification-functions.html#function_json-set" rel="external nofollow noopener noreferrer" target="_blank"><code>JSON_SET()</code></a></td>
<td>Insert data into JSON document</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-utility-functions.html#function_json-storage-size" rel="external nofollow noopener noreferrer" target="_blank"><code>JSON_STORAGE_SIZE()</code></a></td>
<td>Space used for storage of binary representation of a JSON document; for a JSON column, the space used when the document was inserted, prior to any partial updates</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-attribute-functions.html#function_json-type" rel="external nofollow noopener noreferrer" target="_blank"><code>JSON_TYPE()</code></a></td>
<td>Type of JSON value</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-modification-functions.html#function_json-unquote" rel="external nofollow noopener noreferrer" target="_blank"><code>JSON_UNQUOTE()</code></a></td>
<td>Unquote JSON value</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-attribute-functions.html#function_json-valid" rel="external nofollow noopener noreferrer" target="_blank"><code>JSON_VALID()</code></a></td>
<td>Whether JSON value is valid</td>
</tr>
</tbody>
</table>
<p>常见的就是<code>JSON_EXTRACT()等</code></p>
<h3 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h3><p><img src="https://cdn.yangbingdong.com/img/mysql-related-learning/idx-explain05.png" alt></p>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO `user_json` VALUES (1, &apos;&#123;\&quot;name\&quot;: \&quot;yang\&quot;, \&quot;address\&quot;: \&quot;shenyang\&quot;&#125;&apos;);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.yangbingdong.com/img/mysql-related-learning/idx-explain07.png" alt></p>
<p><strong>JSON校验</strong>: </p>
<p><img src="https://cdn.yangbingdong.com/img/mysql-related-learning/idx-explain06.png" alt></p>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from user_json where json_extract(data,&apos;$.name&apos;)=&apos;yang&apos;;</span><br><span class="line">select json_extract(data,&apos;$.name&apos;) from user_json where json_extract(data,&apos;$.name&apos;)=&apos;yang&apos;;</span><br><span class="line">select data-&gt;&apos;$.name&apos; from user_json where data-&gt;&apos;$.name&apos;=&apos;yang&apos;;</span><br></pre></td></tr></table></figure>
<p>发现结果集是带有双引号的: </p>
<p><img src="https://cdn.yangbingdong.com/img/mysql-related-learning/idx-explain08.png" alt></p>
<p>如果想要去除双引号一般来说我们这样:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select JSON_UNQUOTE(json_extract(data,&apos;$.name&apos;))from user_json where json_extract(data,&apos;$.name&apos;)=&apos;yang&apos;;</span><br><span class="line">select  data-&gt;&gt;&apos;$.name&apos; from user_json where data-&gt;&apos;$.name&apos;=&apos;yang&apos;;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.yangbingdong.com/img/mysql-related-learning/idx-explain09.png" alt></p>
<h2 id="JSON如何建立索引"><a href="#JSON如何建立索引" class="headerlink" title="JSON如何建立索引"></a>JSON如何建立索引</h2><p>json类型并不能建立索引, 但我们可以通过<strong>虚拟列</strong>来建立索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALTER TABLE user_json ADD COLUMN `virtual_name` varchar(20) GENERATED ALWAYS AS (data-&gt;&gt;&apos;$.name&apos;) VIRTUAL NULL AFTER `data`;</span><br><span class="line"></span><br><span class="line">ALTER TABLE user_json ADD KEY (virtual_name);</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.yangbingdong.com/img/mysql-related-learning/idx-explain10.png" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/mysql-related-learning/idx-explain11.png" alt></p>
<p>可以看到索引起作用了~</p>
<p>像时间这些要把周一到周日建索引也是可以的: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`dayofweek` tinyint(4) GENERATED ALWAYS AS (dayofweek(SomeDate)) VIRTUAL,</span><br></pre></td></tr></table></figure>
<p>或者某些很麻烦的条件: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table ApiLog add verb_url_hash varbinary(16) GENERATED ALWAYS AS (unhex(md5(CONCAT(verb, &apos; - &apos;, replace(url,&apos;.xml&apos;,&apos;&apos;))))) VIRTUAL;</span><br><span class="line">alter table ApiLog add key (verb_url_hash);</span><br></pre></td></tr></table></figure>
<h1 id="MySQL存储引擎MyISAM与InnoDB区别"><a href="#MySQL存储引擎MyISAM与InnoDB区别" class="headerlink" title="MySQL存储引擎MyISAM与InnoDB区别"></a>MySQL存储引擎MyISAM与InnoDB区别</h1><h2 id="MySQL默认存储引擎的变迁"><a href="#MySQL默认存储引擎的变迁" class="headerlink" title="MySQL默认存储引擎的变迁"></a>MySQL默认存储引擎的变迁</h2><p>在MySQL 5.1之前的版本中, 默认的搜索引擎是MyISAM, 从MySQL 5.5之后的版本中, 默认的搜索引擎变更为InnoDB. </p>
<h2 id="MyISAM与InnoDB存储引擎的主要特点"><a href="#MyISAM与InnoDB存储引擎的主要特点" class="headerlink" title="MyISAM与InnoDB存储引擎的主要特点"></a>MyISAM与InnoDB存储引擎的主要特点</h2><p>MyISAM存储引擎的特点是: <strong>表级锁</strong>、<strong>不支持事务和全文索引</strong>, 适合一些CMS内容管理系统作为后台数据库使用, 但是使用大并发、重负荷生产系统上, <strong>表锁结构的特性就显得力不从心</strong>；</p>
<p>以下是MySQL 5.7 MyISAM存储引擎的版本特性: </p>
<p><img src="https://cdn.yangbingdong.com/img/mysql-related-learning/mysql-engine01.png" alt></p>
<p>InnoDB存储引擎的特点是: <strong>行级锁</strong>、<strong>事务安全（ACID兼容）</strong>、<strong>支持外键</strong>、不支持FULLTEXT类型的索引(5.6.4以后版本开始支持FULLTEXT类型的索引). InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全存储引擎. InnoDB是<strong>为处理巨大量时拥有最大性能而设计的</strong>. 它的CPU效率可能是任何其他基于磁盘的关系数据库引擎所不能匹敌的. </p>
<p>以下是MySQL 5.7 InnoDB存储引擎的版本特性: </p>
<p><img src="https://cdn.yangbingdong.com/img/mysql-related-learning/mysql-engine02.png" alt></p>
<p><em>注意: </em><br>InnoDB表的行锁也不是绝对的, 假如在执行一个SQL语句时MySQL不能确定要扫描的范围, InnoDB表同样会锁全表, 例如<code>update table set num=1 where name like “a%”</code>. </p>
<p>两种类型最主要的差别就是InnoDB支持事务处理与外键和行级锁. 而MyISAM不支持. 所以MyISAM往往就容易被人认为只适合在小项目中使用. </p>
<h2 id="MyISAM与InnoDB性能测试"><a href="#MyISAM与InnoDB性能测试" class="headerlink" title="MyISAM与InnoDB性能测试"></a>MyISAM与InnoDB性能测试</h2><p>下边两张图是官方提供的MyISAM与InnoDB的压力测试结果</p>
<p><img src="https://cdn.yangbingdong.com/img/mysql-related-learning/mysql-engine03.png" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/mysql-related-learning/mysql-engine04.png" alt></p>
<p>可以看出, <strong>随着CPU核数的增加</strong>, <strong>InnoDB的吞吐量反而越好</strong>, 而MyISAM, 其吞吐量几乎没有什么变化, 显然, MyISAM的表锁定机制降低了读和写的吞吐量. </p>
<h2 id="事务支持与否"><a href="#事务支持与否" class="headerlink" title="事务支持与否"></a>事务支持与否</h2><p>MyISAM是一种非事务性的引擎, 使得MyISAM引擎的MySQL可以提供高速存储和检索, 以及全文搜索能力, 适合数据仓库等查询频繁的应用；</p>
<p>InnoDB是事务安全的；</p>
<p>事务是一种高级的处理方式, 如在一些列增删改中只要哪个出错还可以回滚还原, 而MyISAM就不可以了. </p>
<h2 id="MyISAM与InnoDB构成上的区别"><a href="#MyISAM与InnoDB构成上的区别" class="headerlink" title="MyISAM与InnoDB构成上的区别"></a>MyISAM与InnoDB构成上的区别</h2><p>（1）每个MyISAM在磁盘上存储成三个文件: </p>
<blockquote>
<p>第一个文件的名字以表的名字开始, 扩展名指出文件类型, .frm文件存储表定义.<br>第二个文件是数据文件, 其扩展名为.MYD (MYData).<br>第三个文件是索引文件, 其扩展名是.MYI (MYIndex). </p>
</blockquote>
<p>（2）基于磁盘的资源是InnoDB表空间数据文件和它的日志文件, InnoDB 表的 大小只受限于操作系统文件的大小, 一般为 2GB. </p>
<h2 id="MyISAM与InnoDB表锁和行锁的解释"><a href="#MyISAM与InnoDB表锁和行锁的解释" class="headerlink" title="MyISAM与InnoDB表锁和行锁的解释"></a>MyISAM与InnoDB表锁和行锁的解释</h2><p>MySQL表级锁有两种模式: 表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）. 什么意思呢, 就是说对MyISAM表进行读操作时, 它不会阻塞其他用户对同一表的读请求, 但会阻塞对同一表的写操作；而对MyISAM表的写操作, 则会阻塞其他用户对同一表的读和写操作. </p>
<p>InnoDB行锁是通过给索引项加锁来实现的, 即<strong>只有通过索引条件检索数据</strong>, <strong>InnoDB才使用行级锁</strong>, <strong>否则将使用表锁</strong>！行级锁在每次获取锁和释放锁的操作需要消耗比表锁更多的资源. 在InnoDB两个事务发生死锁的时候, 会计算出每个事务影响的行数, 然后回滚行数少的那个事务. 当锁定的场景中不涉及Innodb的时候, InnoDB是检测不到的. 只能依靠锁定超时来解决. </p>
<h2 id="是否保存数据库表中表的具体行数"><a href="#是否保存数据库表中表的具体行数" class="headerlink" title="是否保存数据库表中表的具体行数"></a>是否保存数据库表中表的具体行数</h2><p>InnoDB 中不保存表的具体行数, 也就是说, 执行<code>select count(*) from table</code> 时, InnoDB要扫描一遍整个表来计算有多少行, 但是MyISAM只要简单的读出保存好的行数即可. </p>
<p>注意的是, 当<code>count(*)</code>语句包含<code>where</code>条件时, 两种表的操作是一样的. 也就是 上述“6”中介绍到的InnoDB使用表锁的一种情况. </p>
<h2 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h2><p>MyISAM适合:<br>（1）做很多count 的计算；<br>（2）插入不频繁, 查询非常频繁, 如果执行大量的SELECT, MyISAM是更好的选择；<br>（3）没有事务. </p>
<p>InnoDB适合:<br>（1）可靠性要求比较高, 或者要求事务；<br>（2）表更新和查询都相当的频繁, 并且表锁定的机会比较大的情况指定数据引擎的创建；<br>（3）如果你的数据执行大量的INSERT或UPDATE, 出于性能方面的考虑, 应该使用InnoDB表；<br>（4）DELETE FROM table时, InnoDB不会重新建立表, 而是一行一行的 删除；<br>（5）LOAD TABLE FROM MASTER操作对InnoDB是不起作用的, 解决方法是首先把InnoDB表改成MyISAM表, 导入数据后再改成InnoDB表, 但是对于使用的额外的InnoDB特性（例如外键）的表不适用. </p>
<p>要注意, 创建每个表格的代码是相同的, 除了最后的 TYPE参数, 这一参数用来指定数据引擎. </p>
<h2 id="其他区别"><a href="#其他区别" class="headerlink" title="其他区别"></a>其他区别</h2><p>1、对于AUTO_INCREMENT类型的字段, InnoDB中必须包含只有该字段的索引, 但是在MyISAM表中, 可以和其他字段一起建立联合索引. </p>
<p>2、DELETE FROM table时, InnoDB不会重新建立表, 而是一行一行的删除. </p>
<p>3、LOAD TABLE FROMMASTER操作对InnoDB是不起作用的, 解决方法是首先把InnoDB表改成MyISAM表, 导入数据后再改成InnoDB表, 但是对于使用的额外的InnoDB特性(例如外键)的表不适用. </p>
<p>4、 InnoDB存储引擎被完全与MySQL服务器整合, InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池. </p>
<p>5、对于自增长的字段, InnoDB中必须包含只有该字段的索引, 但是在MyISAM表中可以和其他字段一起建立联合索引. </p>
<p>6、清空整个表时, InnoDB是一行一行的删除, 效率非常慢. MyISAM则会重建表. </p>
<h1 id="通过SQL查看表信息"><a href="#通过SQL查看表信息" class="headerlink" title="通过SQL查看表信息"></a>通过SQL查看表信息</h1><h2 id="查看创建表"><a href="#查看创建表" class="headerlink" title="查看创建表"></a>查看创建表</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_table;</span><br></pre></td></tr></table></figure>
<h2 id="查看表信息"><a href="#查看表信息" class="headerlink" title="查看表信息"></a>查看表信息</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> <span class="keyword">STATUS</span> <span class="keyword">WHERE</span> <span class="keyword">NAME</span> <span class="keyword">IN</span>(<span class="string">'test_table'</span>, <span class="string">'person'</span>);</span><br></pre></td></tr></table></figure>
<p>更详细信息:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> information_schema.tables <span class="keyword">WHERE</span> table_schema=<span class="string">'test_db'</span> <span class="keyword">AND</span> table_name=<span class="string">'test_table'</span>;</span><br></pre></td></tr></table></figure>
<h2 id="查看字段信息"><a href="#查看字段信息" class="headerlink" title="查看字段信息"></a>查看字段信息</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">FULL</span> <span class="keyword">FIELDS</span> <span class="keyword">FROM</span> <span class="string">`test_table`</span>;</span><br></pre></td></tr></table></figure>
<p>更详细信息:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> information_schema.COLUMNS <span class="keyword">WHERE</span> table_schema=<span class="string">'test_db'</span> <span class="keyword">AND</span> table_name=<span class="string">'test_table'</span>;</span><br></pre></td></tr></table></figure>
<h2 id="查看表索引"><a href="#查看表索引" class="headerlink" title="查看表索引"></a>查看表索引</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> test_table;</span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">KEYS</span> <span class="keyword">from</span> test_table;</span><br></pre></td></tr></table></figure>
<h1 id="备份数据与恢复"><a href="#备份数据与恢复" class="headerlink" title="备份数据与恢复"></a>备份数据与恢复</h1><p>从Navicat中导入导出数据是比较慢的, 我们可以通过 <code>mysqldump</code> (安装 <code>mysql-client</code> 后自带)备份.</p>
<h2 id="mysqldump-备份"><a href="#mysqldump-备份" class="headerlink" title="mysqldump 备份"></a>mysqldump 备份</h2><p>备份一个数据库:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump -u [uname] -p[pass] db_name &gt; db_backup.sql</span><br></pre></td></tr></table></figure>
<p>备份所有数据库:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump -u [uname] -p[pass] --all-databases &gt; all_db_backup.sql</span><br></pre></td></tr></table></figure>
<p>备份特定的表:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump -u [uname] -p[pass] db_name table1 table2 &gt; table_backup.sql</span><br></pre></td></tr></table></figure>
<p>导出压缩一步到位:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump -u [uname] -p[pass] db_name | gzip &gt; db_backup.sql.gz</span><br></pre></td></tr></table></figure>
<p>远程数据库:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump -P 3306 -h [ip_address] -u [uname] -p[pass] db_name &gt; db_backup.sql</span><br></pre></td></tr></table></figure>
<p>遇到 <code>mysqldump: Got error: 1044: Access denied for user</code> 解决办法:</p>
<p>加上 <code>--single-transaction</code> 即可, 网上有人说使用 <code>--skip-lock-tables</code>, 这个会影响数据的一致性(可能比丢数据还要遭糕)，故不推荐使用这个方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump --single-transaction -P 3306 -h [ip_address] -u [uname] -p[pass] db_name &gt; db_backup.sql</span><br></pre></td></tr></table></figure>
<h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><p>恢复一个数据库:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -h [host] -P [port] -u [uname] -p[pass] db_name &lt; db_backup.sql</span><br></pre></td></tr></table></figure>
<p>恢复全部数据库:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -h [host] -P [port] -u [uname] -p[pass] &lt; db_backup_all.sql</span><br></pre></td></tr></table></figure>
<h1 id="死锁排查"><a href="#死锁排查" class="headerlink" title="死锁排查"></a>死锁排查</h1><p><strong><em><a href="https://mp.weixin.qq.com/s/HT1tWfEPnigBO9fhML6y0w" rel="external nofollow noopener noreferrer" target="_blank">解决死锁之路（终结篇）- 再见死锁</a></em></strong></p>
<h1 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h1><p>看到一片美团技术团队的博文非常好: <strong><em><a href="https://tech.meituan.com/mysql-index.html" rel="external nofollow noopener noreferrer" target="_blank">https://tech.meituan.com/mysql-index.html</a></em></strong></p>
]]></content><categories><category>MySQL</category></categories><tags><tag>MySQL</tag></tags></entry><entry><title>Spring5新特征与WebFlux反应式编程</title><url>/2017/new-in-spring-framework-5/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/spring-framework-5/spring-framework-5.png" alt></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><blockquote>
<p>Spring 5 于 2017 年 9 月发布了通用版本 (<code>GA</code>), 它标志着自 2013 年 12 月以来第一个主要 Spring Framework 版本. 它提供了一些人们期待已久的改进, 还采用了一种全新的编程范例, 以<strong><em><a href="http://www.reactivemanifesto.org/" rel="external nofollow noopener noreferrer" target="_blank">反应式宣言</a></em></strong>中陈述的反应式原则为基础. </p>
<p>这个版本是很长时间以来最令人兴奋的 Spring Framework 版本. Spring 5 兼容 <code>Java™8</code> 和 <code>JDK 9</code>, 它集成了<strong>反应式流</strong>, 以便提供一种颠覆性方法来实现端点和 Web 应用程序开发. </p>
<p>诚然, 反应式编程不仅是此版本的主题, 还是令许多开发人员激动不已的重大特性. 人们对能够针对负载波动进行无缝扩展的灾备和响应式服务的需求在不断增加, Spring 5 很好地满足了这一需求. </p>
<p>本文将全面介绍 Spring 5. 我将介绍 Java SE 8 和 Java EE 7 API 的基准升级、Spring 5 的新反应式编程模型、<a href="https://www.ibm.com/developerworks/library/wa-http2-under-the-hood/index.html" rel="external nofollow noopener noreferrer" target="_blank">HTTP/2</a> 支持, 以及 Spring 通过 <code>Kotlin</code> 对函数式编程的全面支持. 我还会简要介绍测试和性能增强, 最后介绍对 Spring 核心和容器的一般性修订. </p>
</blockquote>
<a id="more"></a>
<h1 id="Spring-Framework-5-中的新特性"><a href="#Spring-Framework-5-中的新特性" class="headerlink" title="Spring Framework 5 中的新特性"></a>Spring Framework 5 中的新特性</h1><h2 id="升级到-Java-SE-8-和-Java-EE-7"><a href="#升级到-Java-SE-8-和-Java-EE-7" class="headerlink" title="升级到 Java SE 8 和 Java EE 7"></a>升级到 Java SE 8 和 Java EE 7</h2><p>直到现在, Spring Framework 仍支持一些弃用的 Java 版本, 但 Spring 5 已从旧包袱中解放出来. 为了充分利用 Java 8 特性, 它的代码库已进行了改进, 而且该框架要求将 Java 8 作为<strong>最低的 JDK 版本</strong>. </p>
<p>Spring 5 在类路径（和模块路径）上完全兼容 Java 9, 而且它通过了 JDK 9 测试套件的测试. 对 Java 9 爱好者而言, 这是一条好消息, 因为在 Java 9 发布后, Spring 能立即使用它. </p>
<p>在 <code>API</code> 级别上, Spring 5 兼容 Java EE 8 技术, 满足对 <code>Servlet 4.0</code>、<code>Bean Validation 2.0</code> 和全新的 <code>JSON Binding API</code> 的需求. 对 Java EE API 的最低要求为 <code>V7</code>, 该版本引入了针对 <code>Servlet</code>、<code>JPA</code> 和 <code>Bean Validation API</code> 的次要版本. </p>
<h2 id="反应式编程模型"><a href="#反应式编程模型" class="headerlink" title="反应式编程模型"></a>反应式编程模型</h2><p>Spring 5 最令人兴奋的新特性是它的<strong>反应式编程模型</strong>. Spring 5 Framework 基于一种反应式基础而构建, 而且是<strong>完全异步和非阻塞的</strong>. 只需少量的线程, 新的事件循环执行模型就可以垂直扩展. </p>
<p>该框架采用反应式流来提供在反应式组件中传播负压的机制. <strong>负压</strong>是一个<strong>确保来自多个生产者的数据不会让使用者不堪重负的概念</strong>. </p>
<p><code>Spring WebFlux</code> 是 Spring 5 的反应式核心, 它为开发人员提供了两种为 Spring Web 编程而设计的编程模型: 一种基于<strong>注解的模型</strong>和 <strong>Functional Web Framework</strong> (<code>WebFlux.fn</code>). </p>
<p>基于注解的模型是 Spring WebMVC 的现代替代方案, 该模型基于反应式基础而构建, 而 Functional Web Framework 是基于<code>@Controller</code> 注解的编程模型的替代方案. 这些模型都通过同一种反应式基础来运行, 后者调整非阻塞 HTTP 来适应反应式流 API. </p>
<h2 id="使用注解进行编程"><a href="#使用注解进行编程" class="headerlink" title="使用注解进行编程"></a>使用注解进行编程</h2><p>WebMVC 程序员应该对 Spring 5 的基于注解的编程模型非常熟悉. Spring 5 调整了 WebMVC 的 <code>@Controller</code> 编程模型, 采用了相同的注解. </p>
<p>在清单 1 中, <code>BookController</code> 类提供了两个方法, 分别响应针对某个图书列表的 HTTP 请求, 以及针对具有给定 <code>id</code> 的图书的 HTTP 请求. 请注意 resource 方法返回的对象（<code>Mono</code> 和 <code>Flux</code>）. 这些对象是实现<strong><em><a href="http://www.reactive-streams.org/" rel="external nofollow noopener noreferrer" target="_blank">反应式流</a></em></strong>规范中的 <code>Publisher</code> 接口的反应式类型. 它们的职责是处理数据流. <code>Mono</code> 对象处理一个<strong>仅含 1 个元素的流</strong>, 而 <code>Flux</code> 表示一个<strong>包含 N 个元素的流</strong>. </p>
<p><strong>清单 1. 反应式控制器</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class BookController &#123;</span><br><span class="line"> </span><br><span class="line">    @GetMapping(&quot;/book&quot;)</span><br><span class="line">    Flux&lt;Book&gt; list() &#123;</span><br><span class="line">        return this.repository.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @GetMapping(&quot;/book/&#123;id&#125;&quot;)</span><br><span class="line">    Mono&lt;Book&gt; findById(@PathVariable String id) &#123;</span><br><span class="line">        return this.repository.findOne(id);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // Plumbing code omitted for brevity</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是针对 Spring Web 编程的注解. 现在我们使用函数式 Web 框架来解决同一个问题. </p>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>Spring 5 的新函数式方法将请求委托给处理函数, 这些函数接受一个服务器请求实例并返回一种反应式类型. 清单 2 演示了这一过程, 其中 <code>listBook</code> 和 <code>getBook</code> 方法类似于清单 1 中的功能. </p>
<p><strong>清单 2. 清单 2.BookHandler 函数类</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BookHandler &#123;</span><br><span class="line"> </span><br><span class="line">    public Mono&lt;ServerResponse&gt; listBooks(ServerRequest request) &#123;</span><br><span class="line">        return ServerResponse.ok()</span><br><span class="line">            .contentType(APPLICATION_JSON)</span><br><span class="line">            .body(repository.allPeople(), Book.class);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public Mono&lt;ServerResponse&gt; getBook(ServerRequest request) &#123;</span><br><span class="line">        return repository.getBook(request.pathVariable(&quot;id&quot;))</span><br><span class="line">            .then(book -&gt; ServerResponse.ok()</span><br><span class="line">            .contentType(APPLICATION_JSON)</span><br><span class="line">            .body(fromObject(book)))</span><br><span class="line">            .otherwiseIfEmpty(ServerResponse.notFound().build());</span><br><span class="line">    &#125;</span><br><span class="line">    // Plumbing code omitted for brevity</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过路由函数来匹配 HTTP 请求谓词与媒体类型, 将客户端请求路由到处理函数. 清单 3 展示了图书资源端点 URI 将调用委托给合适的处理函数: </p>
<p><strong>清单 3. Router 函数</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BookHandler handler = new BookHandler();</span><br><span class="line"> </span><br><span class="line">RouterFunction&lt;ServerResponse&gt; personRoute =</span><br><span class="line">    route(</span><br><span class="line">        GET(&quot;/books/&#123;id&#125;&quot;)</span><br><span class="line">        .and(accept(APPLICATION_JSON)), handler::getBook)</span><br><span class="line">        .andRoute(</span><br><span class="line">    GET(&quot;/books&quot;)</span><br><span class="line">        .and(accept(APPLICATION_JSON)), handler::listBooks);</span><br></pre></td></tr></table></figure></p>
<p>这些示例背后的数据存储库也支持完整的反应式体验, 该体验是通过 Spring Data 对反应式 <code>Couchbase</code>、<code>Reactive MongoDB</code> 和 <code>Cassandra</code> 的支持来实现的. </p>
<h2 id="使用-REST-端点执行反应式编程"><a href="#使用-REST-端点执行反应式编程" class="headerlink" title="使用 REST 端点执行反应式编程"></a>使用 REST 端点执行反应式编程</h2><p>新的编程模型脱离了传统的 Spring WebMVC 模型, 引入了一些很不错的新特性. </p>
<p>举例来说, WebFlux 模块为 <code>RestTemplate</code> 提供了一种完全非阻塞、反应式的替代方案, 名为 <code>WebClient</code>. 清单 4 创建了一个 <code>WebClient</code>, 并调用 <code>books</code> 端点来请求一本给定 <code>id</code> 为 <code>1234</code> 的图书. </p>
<p><strong>清单 4. 通过 WebClient 调用 REST 端点</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mono&lt;Book&gt; book = WebClient.create(&quot;http://localhost:8080&quot;)</span><br><span class="line">      .get()</span><br><span class="line">      .url(&quot;/books/&#123;id&#125;&quot;, 1234)</span><br><span class="line">      .accept(APPLICATION_JSON)</span><br><span class="line">      .exchange(request)</span><br><span class="line">      .then(response -&gt; response.bodyToMono(Book.class));</span><br></pre></td></tr></table></figure></p>
<h2 id="HTTP-2-支持"><a href="#HTTP-2-支持" class="headerlink" title="HTTP/2 支持"></a>HTTP/2 支持</h2><p><strong>HTTP/2 幕后原理: </strong>要了解 HTTP/2 如何提高传输性能, 减少延迟, 并帮助提高应用程序吞吐量, 从而提供经过改进的丰富 Web 体验, 请查阅<em><a href="https://www.ibm.com/developerworks/cn/web/wa-http2-under-the-hood/index.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.ibm.com/developerworks/cn/web/wa-http2-under-the-hood/index.html</a></em>. </p>
<p>Spring Framework 5.0 将提供专门的 <em><a href="https://www.ibm.com/developerworks/cn/web/wa-http2-under-the-hood/index.html" rel="external nofollow noopener noreferrer" target="_blank">HTTP/2 特性</a></em> 支持, 还支持人们期望出现在 JDK 9 中的新 HTTP 客户端. 尽管 HTTP/2 的服务器推送功能已通过 Jetty servlet 引擎的 <code>ServerPushFilter</code> 类向 Spring 开发人员公开了很长一段时间, 但如果发现 Spring 5 中开箱即用地提供了 <em><a href="https://www.ibm.com/developerworks/cn/web/wa-http2-under-the-hood/index.html" rel="external nofollow noopener noreferrer" target="_blank">HTTP/2</a></em> 性能增强, Web 优化者们一定会为此欢呼雀跃. </p>
<p>Java EE Servlet 规范预计将于 2017 年第 4 季度发布, Servlet 4.0 支持将在 Spring 5.1 中提供. 到那时, <em><a href="https://www.ibm.com/developerworks/cn/web/wa-http2-under-the-hood/index.html" rel="external nofollow noopener noreferrer" target="_blank">HTTP/2 特性</a></em> 将由 Tomcat 9.0、Jetty 9.3 和 Undertow 1.4 原生提供. </p>
<p>Kotlin 和 Spring WebFlux</p>
<p><code>Kotlin</code> 是一种来自 <em><a href="https://blog.jetbrains.com/kotlin/" rel="external nofollow noopener noreferrer" target="_blank">JetBrains</a></em> 的面向对象的语言, 它支持函数式编程. 它的主要优势之一是与 Java 有非常高的互操作性. 通过引入对 <code>Kotlin</code> 的专门支持, Spring 在 V5 中全面吸纳了这一优势. 它的函数式编程风格与 Spring WebFlux 模块完美匹配, 它的新路由 DSL 利用了函数式 Web 框架以及干净且符合语言习惯的代码. 可以像清单 5 中这样简单地表达端点路由: </p>
<p><strong>清单 5. Kotlin 的用于定义端点的路由 DSL</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">fun apiRouter() = router &#123;</span><br><span class="line">    (accept(APPLICATION_JSON) and &quot;/api&quot;).nest &#123;</span><br><span class="line">        &quot;/book&quot;.nest &#123;</span><br><span class="line">            GET(&quot;/&quot;, bookHandler::findAll)</span><br><span class="line">            GET(&quot;/&#123;id&#125;&quot;, bookHandler::findOne)</span><br><span class="line">        &#125;</span><br><span class="line">        &quot;/video&quot;.nest &#123;</span><br><span class="line">            GET(&quot;/&quot;, videoHandler::findAll)</span><br><span class="line">            GET(&quot;/&#123;genre&#125;&quot;, videoHandler::findByGenre)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>Kotlin 1.1.4+</code> 时, 还添加了对 Kotlin 的不可变类的支持（通过带默认值的可选参数）, 以及对完全支持 <code>null</code> 的 API 的支持. </p>
<h2 id="使用-Lambda-表达式注册-bean"><a href="#使用-Lambda-表达式注册-bean" class="headerlink" title="使用 Lambda 表达式注册 bean"></a>使用 Lambda 表达式注册 bean</h2><p>作为传统 XML 和 JavaConfig 的替代方案, 现在可以使用 lambda 表达式注册 Spring bean, 使 bean 可以实际注册为提供者. 清单 6 使用 lambda 表达式注册了一个 <code>Book</code> bean. </p>
<p><strong>清单 6. 将 Bean 注册为提供者</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GenericApplicationContext context = new GenericApplicationContext();</span><br><span class="line">context.registerBean(Book.class, () -&gt; new </span><br><span class="line">              Book(context.getBean(Author.class))</span><br><span class="line">        );</span><br></pre></td></tr></table></figure></p>
<h2 id="Spring-WebMVC-支持最新的-API"><a href="#Spring-WebMVC-支持最新的-API" class="headerlink" title="Spring WebMVC 支持最新的 API"></a>Spring WebMVC 支持最新的 API</h2><p>全新的 WebFlux 模块提供了许多新的、令人兴奋的功能, 但 Spring 5 也迎合了愿意继续使用 Spring MVC 的开发人员的需求. Spring 5 中更新了模型-视图-控制器框架, 以兼容 WebFlux 和最新版的 <em><a href="https://github.com/FasterXML/jackson/wiki/Jackson-Release-2.9" rel="external nofollow noopener noreferrer" target="_blank">Jackson 2.9</a></em> 和 <em><a href="https://github.com/google/protobuf/releases?after=v3.0.0-alpha-3" rel="external nofollow noopener noreferrer" target="_blank">Protobuf 3.0</a></em>, 甚至包括对新的 <em><a href="http://json-b.net/" rel="external nofollow noopener noreferrer" target="_blank">Java EE 8 JSON-Binding API</a></em> 的支持. </p>
<p>除了 <em><a href="https://www.ibm.com/developerworks/cn/web/wa-http2-under-the-hood/index.html" rel="external nofollow noopener noreferrer" target="_blank">HTTP/2 特性</a></em> 的基础服务器实现之外, Spring WebMVC 还通过 MVC 控制器方法的一个参数来支持 Servlet 4.0 的 <code>PushBuilder</code>. 最后, WebMVC 全面支持 Reactor 3.1 的 <code>Flux</code> 和 <code>Mono</code> 对象, 以及 <a href="https://github.com/ReactiveX/RxJava/wiki" rel="external nofollow noopener noreferrer" target="_blank">RxJava</a> 1.3 和 2.1, 它们被视为来自 MVC 控制器方法的返回值. 这项支持的最终目的是支持 Spring Data 中的新的反应式 <code>WebClient</code> 和反应式存储库. </p>
<h2 id="使用-JUnit-5-执行条件和并发测试"><a href="#使用-JUnit-5-执行条件和并发测试" class="headerlink" title="使用 JUnit 5 执行条件和并发测试"></a>使用 JUnit 5 执行条件和并发测试</h2><p><strong>JUnit 和 Spring 5</strong>: Spring 5 全面接纳了函数式范例, 并支持 JUnit 5 及其新的函数式测试风格. 还提供了对 JUnit 4 的向后兼容性, 以确保不会破坏旧代码. </p>
<p>Spring 5 的测试套件通过多种方式得到了增强, 但最明显的是它对 <em><a href="http://junit.org/junit5/" rel="external nofollow noopener noreferrer" target="_blank">JUnit 5</a></em> 的支持. 现在可以在您的单元测试中利用 Java 8 中提供的函数式编程特性. 清单 7 演示了这一支持: </p>
<p><strong>清单 7.JUnit 5 全面接纳了 Java 8 流和 lambda 表达式</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">void givenStreamOfInts_SumShouldBeMoreThanFive() &#123;</span><br><span class="line">    assertTrue(Stream.of(20, 40, 50)</span><br><span class="line">      .stream()</span><br><span class="line">      .mapToInt(i -&gt; i)</span><br><span class="line">      .sum() &gt; 110, () -&gt; &quot;Total should be more than 100&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>迁移到 JUnit 5: </strong>如果您对升级到 JUnit 5 持观望态度, Steve Perry 的<em><a href="https://www.ibm.com/developerworks/cn/views/global/libraryview.jsp?sort_by=&amp;show_abstract=true&amp;show_all=&amp;search_flag=&amp;contentarea_by=%E6%89%80%E6%9C%89%E4%B8%93%E5%8C%BA&amp;search_by=JUnit+5+%E7%AE%80%E4%BB%8B&amp;product_by=-1&amp;topic_by=-1&amp;type_by=%E6%89%80%E6%9C%89%E7%B1%BB%E5%88%AB&amp;ibm-search=%E6%90%9C%E7%B4%A2" rel="external nofollow noopener noreferrer" target="_blank">分两部分的深入剖析教程</a></em> 将说服您冒险尝试. </p>
<p>Spring 5 继承了 <em><a href="https://www.ibm.com/developerworks/cn/java/j-introducing-junit5-part1-jupiter-api/index.html" rel="external nofollow noopener noreferrer" target="_blank">JUnit 5</a></em> 在 Spring TestContext Framework 内实现多个扩展 API 的灵活性. 举例而言, 开发人员可以使用 JUnit 5 的条件测试执行注解 <code>@EnabledIf</code> 和 <code>@DisabledIf</code> 来自动计算一个 <em><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html" rel="external nofollow noopener noreferrer" target="_blank">SpEL</a></em> (Spring Expression Language) 表达式, 并适当地启用或禁用测试. 借助这些注解, Spring 5 支持以前很难实现的复杂的条件测试方案. Spring TextContext Framework 现在能够并发执行测试. </p>
<h2 id="使用-Spring-WebFlux-执行集成测试"><a href="#使用-Spring-WebFlux-执行集成测试" class="headerlink" title="使用 Spring WebFlux 执行集成测试"></a>使用 Spring WebFlux 执行集成测试</h2><p>Spring Test 现在包含一个 <code>WebTestClient</code>, 后者支持对 Spring WebFlux 服务器端点执行集成测试. <code>WebTestClient</code> 使用模拟请求和响应来避免耗尽服务器资源, 并能直接绑定到 WebFlux 服务器基础架构. </p>
<p><code>WebTestClient</code> 可绑定到真实的服务器, 或者使用控制器或函数. 在清单 8 中, <code>WebTestClient</code> 被绑定到 localhost: </p>
<p><strong>清单 8. 绑定到 localhost 的 <code>WebTestClient</code></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WebTestClient testClient = WebTestClient</span><br><span class="line">  .bindToServer()</span><br><span class="line">  .baseUrl(&quot;http://localhost:8080&quot;)</span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure>
<p><strong>清单 9. 将 <code>WebTestClient</code> 绑定到 <code>RouterFunction</code></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RouterFunction bookRouter = RouterFunctions.route(</span><br><span class="line">  RequestPredicates.GET(&quot;/books&quot;),</span><br><span class="line">  request -&gt; ServerResponse.ok().build()</span><br><span class="line">);</span><br><span class="line">  </span><br><span class="line">WebTestClient</span><br><span class="line">  .bindToRouterFunction(bookRouter)</span><br><span class="line">  .build().get().uri(&quot;/books&quot;)</span><br><span class="line">  .exchange()</span><br><span class="line">  .expectStatus().isOk()</span><br><span class="line">  .expectBody().isEmpty();</span><br></pre></td></tr></table></figure>
<h2 id="包清理和弃用"><a href="#包清理和弃用" class="headerlink" title="包清理和弃用"></a>包清理和弃用</h2><p>Spring 5 中止了对一些过时 API 的支持. 遭此厄运的还有 Hibernate 3 和 4, 为了支持 Hibernate 5, 它们遭到了弃用. 另外, 对 Portlet、Velocity、JasperReports、XMLBeans、JDO 和 Guava 的支持也已中止. </p>
<p>包级别上的清理工作仍在继续: Spring 5 不再支持 <code>beans.factory.access</code>、<code>jdbc.support.nativejdbc</code>、<code>mock.staticmock</code>（来自 spring-aspects 模块）或 <code>web.view.tiles2M</code>. Tiles 3 现在是 Spring 的最低要求. </p>
<h2 id="对-Spring-核心和容器的一般更新"><a href="#对-Spring-核心和容器的一般更新" class="headerlink" title="对 Spring 核心和容器的一般更新"></a>对 Spring 核心和容器的一般更新</h2><p>Spring Framework 5 改进了扫描和识别组件的方法, 使大型项目的性能得到提升. 目前, 扫描是在编译时执行的, 而且向 <em><a href="https://jira.spring.io/browse/SPR-11890" rel="external nofollow noopener noreferrer" target="_blank">META-INF/spring.components</a></em> 文件中的索引文件添加了组件坐标. 该索引是通过一个为项目定义的特定于平台的应用程序构建任务来生成的. </p>
<p>标有来自 <em><a href="https://docs.oracle.com/javase/8/docs/api/overview-summary.html" rel="external nofollow noopener noreferrer" target="_blank">javax 包</a></em> 的注解的组件会添加到索引中, 任何带 <code>@Index</code> 注解的类或接口都会添加到索引中. Spring 的传统类路径扫描方式没有删除, 而是保留为一种后备选择. 有许多针对大型代码库的明显性能优势, 而托管许多 Spring 项目的服务器也会缩短启动时间. </p>
<p>Spring 5 还添加了对 <code>@Nullable</code> 的支持, 后者可用于指示可选的注入点. 使用者现在必须准备接受 null 值. 此外, 还可以使用此注解来标记可以为 null 的参数、字段和返回值. <code>@Nullable</code> 主要用于 IntelliJ IDEA 等 IDE, 但也可用于 Eclipse 和 FindBugs, 它使得在编译时处理 null 值变得更方便, 而无需在运行时发送 <code>NullPointerExceptions</code>. </p>
<p>Spring Logging 还提升了性能, 自带开箱即用的 Commons Logging 桥接器. 现在已通过<code>资源抽象</code>支持防御性编程, 为 <code>getFile</code>访问提供了 <code>isFile</code> 指示器. </p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Spring 5 的首要特性是新的反应式编程模型, 这代表着对提供可无缝扩展、基于 Spring 的响应式服务的重大保障. 随着人们对 Spring 5 的采用, 开发人员有望看到反应式编程将会成为使用 Java 语言的 Web 和企业应用程序开发的未来发展道路. </p>
<p>未来的 Spring Framework 版本将继续反映这一承诺, 因为 Spring Security、Spring Data 和 Spring Integration 有望采用反应式编程的特征和优势. </p>
<p>总之, Spring 5 代表着一次大受 Spring 开发人员欢迎的范例转变, 同时也为其他框架指出了一条发展之路. </p>
<h1 id="使用-Spring-5-的-WebFlux-开发反应式-Web-应用"><a href="#使用-Spring-5-的-WebFlux-开发反应式-Web-应用" class="headerlink" title="使用 Spring 5 的 WebFlux 开发反应式 Web 应用"></a>使用 Spring 5 的 WebFlux 开发反应式 Web 应用</h1><p><img src="https://cdn.yangbingdong.com/img/spring-framework-5/spring-webflux-reactive-mongodb-rest-api-example.png" alt></p>
<h2 id="WebFlux-简介"><a href="#WebFlux-简介" class="headerlink" title="WebFlux 简介"></a>WebFlux 简介</h2><p>WebFlux 模块的名称是 <code>spring-webflux</code>, 名称中的 <code>Flux</code> 来源于 <code>Reactor</code> 中的类 <code>Flux</code>. 该模块中包含了对<strong>反应式 HTTP</strong>、<strong>服务器推送事件</strong>和 <strong><code>WebSocket</code> 的客户端和服务器端的支持</strong>. 对于开发人员来说, 比较重要的是服务器端的开发, 这也是本文的重点. 在服务器端, WebFlux 支持<strong>两种</strong>不同的编程模型: 第一种是 Spring MVC 中使用的<strong>基于 Java 注解的方式</strong>；第二种是基于 Java 8 的 lambda 表达式的<strong>函数式编程模型</strong>. 这两种编程模型<strong>只是在代码编写方式上存在不同</strong>. 它们运行在同样的反应式底层架构之上, 因此在<strong>运行时是相同的</strong>. WebFlux 需要底层提供运行时的支持, WebFlux 可以运行在支持 Servlet 3.1 非阻塞 IO API 的 Servlet 容器上, 或是其他异步运行时环境, 如 <code>Netty</code> 和 <code>Undertow</code>. </p>
<p>最方便的创建 WebFlux 应用的方式是使用 Spring Boot 提供的<strong>应用模板</strong>. 直接访问 Spring Initializ 网站（<em><a href="http://start.spring.io/" rel="external nofollow noopener noreferrer" target="_blank">http://start.spring.io/</a></em> ）, 选择创建一个 Maven 或 Gradle 项目. Spring Boot 的版本选择 <code>2.0.0 M2</code>（或更高）. 在添加的依赖中, 选择 <code>Reactive Web</code>. 最后输入应用所在的分组和名称, 点击进行下载即可. 需要注意的是, 只有在选择了 <code>Spring Boot 2.0.0 M2</code> 之后, 依赖中才可以选择 <code>Reactive Web</code>. 下载完成之后可以导入到 IDE 中进行编辑. </p>
<p>本文从三个方面对 WebFlux 进行介绍. 首先是使用经典的基于 Java 注解的编程模型来进行开发, 其次是使用 WebFlux 新增的函数式编程模型来进行开发, 最后介绍 WebFlux 应用的测试. 通过这样循序渐进的方式让读者了解 WebFlux 应用开发的细节. </p>
<h2 id="Java-注解编程模型"><a href="#Java-注解编程模型" class="headerlink" title="Java 注解编程模型"></a>Java 注解编程模型</h2><p>基于 Java 注解的编程模型, 对于使用过 Spring MVC 的开发人员来说是再熟悉不过的. 在 WebFlux 应用中使用同样的模式, 容易理解和上手. 我们先从最经典的 Hello World 的示例开始说明. 代码清单 1 中的 <code>BasicController</code> 是 REST API 的控制器, 通过<code>@RestController</code> 注解来声明. 在 <code>BasicController</code> 中声明了一个 URI 为<code>/hello_world</code> 的映射. 其对应的方法 <code>sayHelloWorld()</code>的返回值是 <code>Mono&lt;String&gt;</code>类型, 其中包含的字符串<code>&quot;Hello World&quot;</code>会作为 HTTP 的响应内容. </p>
<p><strong>清单 1. Hello World 示例</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class BasicController &#123;</span><br><span class="line">    @GetMapping(&quot;/hello_world&quot;)</span><br><span class="line">    public Mono&lt;String&gt; sayHelloWorld() &#123;</span><br><span class="line">        return Mono.just(&quot;Hello World&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从代码清单 1 中可以看到, 使用 WebFlux 与 Spring MVC 的<strong>不同在于</strong>, WebFlux 所使用的类型是与反应式编程相关的 <code>Flux</code> 和 <code>Mono</code> 等, 而<strong>不是简单的对象</strong>. 对于简单的 Hello World 示例来说, 这两者之间并没有什么太大的差别. <strong>对于复杂的应用来说, 反应式编程和负压的优势会体现出来, 可以带来整体的性能的提升</strong>. </p>
<h3 id="REST-API"><a href="#REST-API" class="headerlink" title="REST API"></a>REST API</h3><p>简单的 Hello World 示例并不足以说明 WebFlux 的用法. 在下面的小节中, 本文将介绍其他具体的实例. 先从 REST API 开始说起. REST API 在 Web 服务器端应用中占据了很大的一部分. 我们通过一个具体的实例来说明如何使用 WebFlux 来开发 REST API. </p>
<p>该 REST API 用来对用户数据进行基本的 <code>CRUD</code> 操作. 作为<strong>领域对象</strong>的 User 类中包含了 id、name 和 email 等三个基本的属性. 为了对 User 类进行操作, 我们需要提供服务类 <code>UserService</code>, 如代码清单 2 所示. 类 <code>UserService</code> 使用一个 <code>Map</code> 来<strong>保存</strong>所有用户的信息, 并不是一个持久化的实现. 这对于示例应用来说已经足够了. 类 <code>UserService</code> 中的方法都以 <code>Flux</code> 或 <code>Mono</code> 对象作为返回值, 这也是 <strong>WebFlux 应用的特征</strong>. 在方法 <code>getById()</code>中, 如果找不到 ID 对应的 User 对象, 会返回一个包含了 <code>ResourceNotFoundException</code> 异常通知的 <code>Mono</code> 对象. 方法 <code>getById()</code>和 <code>createOrUpdate()</code>都可以接受 <code>String</code> 或 <code>Flux</code> 类型的参数. <code>Flux</code> 类型的参数表示的是有多个对象需要处理. 这里使用 <code>doOnNext()</code>来对其中的每个对象进行处理. </p>
<p><strong>清单 2. UserService</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">class UserService &#123;</span><br><span class="line">    private final Map&lt;String, User&gt; data = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    Flux&lt;User&gt; list() &#123;</span><br><span class="line">        return Flux.fromIterable(this.data.values());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Flux&lt;User&gt; getById(final Flux&lt;String&gt; ids) &#123;</span><br><span class="line">        return ids.flatMap(id -&gt; Mono.justOrEmpty(this.data.get(id)));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Mono&lt;User&gt; getById(final String id) &#123;</span><br><span class="line">        return Mono.justOrEmpty(this.data.get(id))</span><br><span class="line">                .switchIfEmpty(Mono.error(new ResourceNotFoundException()));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Flux&lt;User&gt; createOrUpdate(final Flux&lt;User&gt; users) &#123;</span><br><span class="line">        return users.doOnNext(user -&gt; this.data.put(user.getId(), user));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Mono&lt;User&gt; createOrUpdate(final User user) &#123;</span><br><span class="line">        this.data.put(user.getId(), user);</span><br><span class="line">        return Mono.just(user);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Mono&lt;User&gt; delete(final String id) &#123;</span><br><span class="line">        return Mono.justOrEmpty(this.data.remove(id));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码清单 3 中的类 <code>UserController</code> 是具体的 Spring MVC 控制器类. 它使用类 <code>UserService</code> 来完成具体的功能. 类 <code>UserController</code> 中使用了注解<code>@ExceptionHandler</code> 来添加了 <code>ResourceNotFoundException</code> 异常的处理方法, 并返回 <code>404</code> 错误. 类 <code>UserController</code> 中的方法都很简单, 只是简单地代理给 <code>UserService</code> 中的对应方法. </p>
<p><strong>清单 3. UserController</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/user&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    private final UserService userService;</span><br><span class="line"> </span><br><span class="line">    @Autowired</span><br><span class="line">    public UserController(final UserService userService) &#123;</span><br><span class="line">        this.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @ResponseStatus(value = HttpStatus.NOT_FOUND, reason = &quot;Resource not found&quot;)</span><br><span class="line">    @ExceptionHandler(ResourceNotFoundException.class)</span><br><span class="line">    public void notFound() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @GetMapping(&quot;&quot;)</span><br><span class="line">    public Flux&lt;User&gt; list() &#123;</span><br><span class="line">        return this.userService.list();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public Mono&lt;User&gt;getById(@PathVariable(&quot;id&quot;) final String id) &#123;</span><br><span class="line">        return this.userService.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @PostMapping(&quot;&quot;)</span><br><span class="line">    public Flux&lt;User&gt; create(@RequestBody final Flux&lt;User&gt;  users) &#123;</span><br><span class="line">        return this.userService.createOrUpdate(users);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @PutMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public Mono&lt;User&gt;  update(@PathVariable(&quot;id&quot;) final String id, @RequestBody final User user) &#123;</span><br><span class="line">        Objects.requireNonNull(user);</span><br><span class="line">        user.setId(id);</span><br><span class="line">        return this.userService.createOrUpdate(user);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public Mono&lt;User&gt;  delete(@PathVariable(&quot;id&quot;) final String id) &#123;</span><br><span class="line">        return this.userService.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="服务器推送事件"><a href="#服务器推送事件" class="headerlink" title="服务器推送事件"></a>服务器推送事件</h3><p>服务器推送事件（Server-Sent Events, SSE）允许服务器端不断地推送数据到客户端. 相对于 WebSocket 而言, 服务器推送事件<strong>只支持服务器端到客户端的单向数据传递</strong>. 虽然功能较弱, 但优势在于 SSE 在已有的 HTTP 协议上使用简单易懂的文本格式来表示传输的数据. 作为 W3C 的推荐规范, SSE 在浏览器端的支持也比较广泛, 除了 IE 之外的其他浏览器都提供了支持. 在 IE 上也可以使用 polyfill 库来提供支持. 在服务器端来说, SSE 是一个不断产生新数据的流, 非常适合于用反应式流来表示. 在 WebFlux 中创建 SSE 的服务器端是非常简单的. 只需要返回的对象的类型是 <code>Flux&lt;ServerSentEvent&gt;</code>, 就会被自动按照 SSE 规范要求的格式来发送响应. </p>
<p>代码清单 4 中的 <code>SseController</code> 是一个使用 SSE 的控制器的示例. 其中的方法 <code>randomNumbers()</code>表示的是每隔一秒产生一个随机数的 SSE 端点. 我们可以使用类 <code>ServerSentEvent.Builder</code> 来创建 <code>ServerSentEvent</code> 对象. 这里我们指定了事件名称 <code>random</code>, 以及每个事件的标识符和数据. 事件的标识符是一个递增的整数, 而数据则是产生的随机数. </p>
<p><strong>清单 4. 服务器推送事件示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/sse&quot;)</span><br><span class="line">public class SseController &#123;</span><br><span class="line">    @GetMapping(&quot;/randomNumbers&quot;)</span><br><span class="line">    public Flux&lt;ServerSentEvent&lt;Integer&gt;&gt; randomNumbers() &#123;</span><br><span class="line">        return Flux.interval(Duration.ofSeconds(1))</span><br><span class="line">                .map(seq -&gt; Tuples.of(seq, ThreadLocalRandom.current().nextInt()))</span><br><span class="line">                .map(data -&gt; ServerSentEvent.&lt;Integer&gt;builder()</span><br><span class="line">                        .event(&quot;random&quot;)</span><br><span class="line">                        .id(Long.toString(data.getT1()))</span><br><span class="line">                        .data(data.getT2())</span><br><span class="line">                        .build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在测试 SSE 时, 我们只需要使用 curl 来访问即可. 代码清单 5 给出了调用 curl <a href="http://localhost:8080/sse/randomNumbers" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8080/sse/randomNumbers</a> 的结果. </p>
<p><strong>清单 5. SSE 服务器端发送的响应</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id:0</span><br><span class="line">event:random</span><br><span class="line">data:751025203</span><br><span class="line"> </span><br><span class="line">id:1</span><br><span class="line">event:random</span><br><span class="line">data:-1591883873</span><br><span class="line"> </span><br><span class="line">id:2</span><br><span class="line">event:random</span><br><span class="line">data:-1899224227</span><br></pre></td></tr></table></figure>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>WebSocket 支持客户端与服务器端的双向通讯. 当客户端与服务器端之间的交互方式比较复杂时, 可以使用 WebSocket. WebSocket 在主流的浏览器上都得到了支持. WebFlux 也对创建 WebSocket 服务器端提供了支持. 在服务器端, 我们需要实现接口 <code>org.springframework.web.reactive.socket.WebSocketHandler</code> 来处理 WebSocket 通讯. 接口 <code>WebSocketHandler</code> 的方法 <code>handle</code> 的参数是接口 <code>WebSocketSession</code> 的对象, 可以用来获取客户端信息、接送消息和发送消息. 代码清单 6 中的 <code>EchoHandler</code> 对于每个接收的消息, 会发送一个添加了”<code>ECHO -&gt;</code> “前缀的响应消息. <code>WebSocketSession</code> 的 <code>receive</code> 方法的返回值是一个 <code>Flux&lt;WebSocketMessage&gt;</code>对象, 表示的是接收到的消息流. 而 <code>send</code> 方法的参数是一个 <code>Publisher&lt;WebSocketMessage&gt;</code>对象, 表示要发送的消息流. 在 <code>handle</code> 方法, 使用 <code>map</code> 操作对 <code>receive</code> 方法得到的 <code>Flux&lt;WebSocketMessage&gt;</code>中包含的消息继续处理, 然后直接由 <code>send</code> 方法来发送. </p>
<p><strong>清单 6. WebSocket 的 EchoHandler 示例</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class EchoHandler implements WebSocketHandler &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Mono&lt;Void&gt; handle(final WebSocketSession session) &#123;</span><br><span class="line">        return session.send(</span><br><span class="line">                session.receive()</span><br><span class="line">                        .map(msg -&gt; session.textMessage(&quot;ECHO -&gt; &quot; + msg.getPayloadAsText())));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在创建了 WebSocket 的处理器 <code>EchoHandler</code> 之后, 下一步需要把它注册到 WebFlux 中. 我们首先需要创建一个类 <code>WebSocketHandlerAdapter</code> 的对象, 该对象负责把 <code>WebSocketHandler</code> 关联到 WebFlux 中. 代码清单 7 中给出了相应的 Spring 配置. 其中的 <code>HandlerMapping</code> 类型的 bean 把 <code>EchoHandler</code> 映射到路径 <code>/echo</code>. </p>
<p><strong>清单 7. 注册 EchoHandler</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class WebSocketConfiguration &#123;</span><br><span class="line"> </span><br><span class="line">    @Autowired</span><br><span class="line">    @Bean</span><br><span class="line">    public HandlerMapping webSocketMapping(final EchoHandler echoHandler) &#123;</span><br><span class="line">        final Map&lt;String, WebSocketHandler&gt; map = new HashMap&lt;&gt;(1);</span><br><span class="line">        map.put(&quot;/echo&quot;, echoHandler);</span><br><span class="line"> </span><br><span class="line">        final SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();</span><br><span class="line">        mapping.setOrder(Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">        mapping.setUrlMap(map);</span><br><span class="line">        return mapping;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Bean</span><br><span class="line">    public WebSocketHandlerAdapter handlerAdapter() &#123;</span><br><span class="line">        return new WebSocketHandlerAdapter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行应用之后, 可以使用工具来测试该 WebSocket 服务. 打开工具页面 <em><a href="https://www.websocket.org/echo.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.websocket.org/echo.html</a></em>, 然后连接到 <em>ws://localhost:8080/echo</em>, 可以发送消息并查看服务器端返回的结果. </p>
<h2 id="函数式编程模型"><a href="#函数式编程模型" class="headerlink" title="函数式编程模型"></a>函数式编程模型</h2><p>在上节中介绍了基于 Java 注解的编程模型, WebFlux 还支持基于 lambda 表达式的函数式编程模型. 与基于 Java 注解的编程模型相比, 函数式编程模型的抽象层次更低, 代码编写更灵活, 可以满足一些对动态性要求更高的场景. 不过在编写时的代码复杂度也较高, 学习曲线也较陡. 开发人员可以根据实际的需要来选择合适的编程模型. 目前 Spring Boot 不支持在一个应用中同时使用两种不同的编程模式. </p>
<p>为了说明函数式编程模型的用法, 我们使用 <code>Spring Initializ</code> 来创建一个新的 WebFlux 项目. 在函数式编程模型中, 每个请求是由一个函数来处理的, 通过接口 <code>org.springframework.web.reactive.function.server.HandlerFunction</code> 来表示. <code>HandlerFunction</code> 是一个函数式接口, 其中只有一个方法 <code>Mono&lt;T extends ServerResponse&gt; handle(ServerRequest request)</code>, 因此可以用 labmda 表达式来实现该接口. 接口 <code>ServerRequest</code> 表示的是一个 HTTP 请求. 通过该接口可以获取到请求的相关信息, 如请求路径、HTTP 头、查询参数和请求内容等. 方法 <code>handle</code> 的返回值是一个 <code>Mono&lt;T extends ServerResponse&gt;</code>对象. 接口 <code>ServerResponse</code> 用来表示 HTTP 响应. <code>ServerResponse</code> 中包含了很多静态方法来创建不同 HTTP 状态码的响应对象. 本节中通过一个简单的计算器来展示函数式编程模型的用法. 代码清单 8 中给出了处理不同请求的类 <code>CalculatorHandler</code>, 其中包含的方法 <code>add</code>、<code>subtract</code>、<code>multiply</code> 和 <code>divide</code> 都是接口 <code>HandlerFunction</code> 的实现. 这些方法分别对应加、减、乘、除四种运算. 每种运算都是从 HTTP 请求中获取到两个作为操作数的整数, 再把运算的结果返回. </p>
<p><strong>清单 8. 处理请求的类 CalculatorHandler</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class CalculatorHandler &#123;</span><br><span class="line"> </span><br><span class="line">    public Mono&lt;ServerResponse&gt; add(final ServerRequest request) &#123;</span><br><span class="line">        return calculate(request, (v1, v2) -&gt; v1 + v2);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Mono&lt;ServerResponse&gt; subtract(final ServerRequest request) &#123;</span><br><span class="line">        return calculate(request, (v1, v2) -&gt; v1 - v2);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Mono&lt;ServerResponse&gt;  multiply(final ServerRequest request) &#123;</span><br><span class="line">        return calculate(request, (v1, v2) -&gt; v1 * v2);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Mono&lt;ServerResponse&gt; divide(final ServerRequest request) &#123;</span><br><span class="line">        return calculate(request, (v1, v2) -&gt; v1 / v2);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private Mono&lt;ServerResponse&gt; calculate(final ServerRequest request,</span><br><span class="line">                                           final BiFunction&lt;Integer, Integer, Integer&gt; calculateFunc) &#123;</span><br><span class="line">        final Tuple2&lt;Integer, Integer&gt; operands = extractOperands(request);</span><br><span class="line">        return ServerResponse</span><br><span class="line">                .ok()</span><br><span class="line">                .body(Mono.just(calculateFunc.apply(operands.getT1(), operands.getT2())), Integer.class);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private Tuple2&lt;Integer, Integer&gt; extractOperands(final ServerRequest request) &#123;</span><br><span class="line">        return Tuples.of(parseOperand(request, &quot;v1&quot;), parseOperand(request, &quot;v2&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private int parseOperand(final ServerRequest request, final String param) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return Integer.parseInt(request.queryParam(param).orElse(&quot;0&quot;));</span><br><span class="line">        &#125; catch (final NumberFormatException e) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在创建了处理请求的 <code>HandlerFunction</code> 之后, 下一步是为这些 <code>HandlerFunction</code> 提供路由信息, 也就是这些 <code>HandlerFunction</code> 被调用的条件. 这是通过函数式接口 <code>org.springframework.web.reactive.function.server.RouterFunction</code> 来完成的. 接口 <code>RouterFunction</code> 的方法 <code>Mono&lt;HandlerFunction&lt;T extends ServerResponse&gt;&gt; route(ServerRequest request)</code>对每个 <code>ServerRequest</code>, 都返回对应的 0 个或 1 个 <code>HandlerFunction</code> 对象, 以 <code>Mono&lt;HandlerFunction&gt;</code>来表示. 当找到对应的 <code>HandlerFunction</code> 时, 该 <code>HandlerFunction</code> 被调用来处理该 <code>ServerRequest</code>, 并把得到的 <code>ServerResponse</code> 返回. 在使用 WebFlux 的 Spring Boot 应用中, 只需要创建 <code>RouterFunction</code> 类型的 <code>bean</code>, 就会被自动注册来处理请求并调用相应的 <code>HandlerFunction</code>. </p>
<p>代码清单 9 给了示例相关的配置类 <code>Config</code>. 方法 <code>RouterFunctions.route</code> 用来根据 <code>Predicate</code> 是否匹配来确定 <code>HandlerFunction</code> 是否被应用. <code>RequestPredicates</code> 中包含了很多静态方法来创建常用的基于不同匹配规则的 <code>Predicate</code>. 如 <code>RequestPredicates.path</code> 用来根据 HTTP 请求的路径来进行匹配. 此处我们检查请求的路径是<code>/calculator</code>. 在清单 9 中, 我们首先使用 <code>ServerRequest</code> 的 <code>queryParam</code> 方法来获取到查询参数 <code>operator</code> 的值, 然后通过反射 API 在类 <code>CalculatorHandler</code> 中找到与查询参数 <code>operator</code> 的值名称相同的方法来确定要调用的 <code>HandlerFunction</code> 的实现, 最后调用查找到的方法来处理该请求. 如果找不到查询参数 <code>operator</code> 或是 <code>operator</code> 的值不在识别的列表中, 服务器端返回 <code>400</code> 错误；如果反射 API 的方法调用中出现错误, 服务器端返回 <code>500</code> 错误. </p>
<p><strong>清单 9. 注册 RouterFunction</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class Config &#123;</span><br><span class="line"> </span><br><span class="line">    @Bean</span><br><span class="line">    @Autowired</span><br><span class="line">    public RouterFunction&lt;ServerResponse&gt;routerFunction(final CalculatorHandler calculatorHandler) &#123;</span><br><span class="line">        return RouterFunctions.route(RequestPredicates.path(&quot;/calculator&quot;), request -&gt;</span><br><span class="line">                request.queryParam(&quot;operator&quot;).map(operator -&gt;</span><br><span class="line">                        Mono.justOrEmpty(ReflectionUtils.findMethod(CalculatorHandler.class, operator, ServerRequest.class))</span><br><span class="line">                                .flatMap(method -&gt; (Mono&lt;ServerResponse&gt;) ReflectionUtils.invokeMethod(method, calculatorHandler, request))</span><br><span class="line">                                .switchIfEmpty(ServerResponse.badRequest().build())</span><br><span class="line">                                .onErrorResume(ex -&gt; ServerResponse.status(HttpStatus.INTERNAL_SERVER_ERROR).build()))</span><br><span class="line">                        .orElse(ServerResponse.badRequest().build()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>除了服务器端实现之外, WebFlux 也提供了反应式客户端, 可以访问 HTTP、SSE 和 WebSocket 服务器端. </p>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>对于 HTTP 和 SSE, 可以使用 WebFlux 模块中的类 o<code>rg.springframework.web.reactive.function.client.WebClient</code>. 代码清单 10 中的 <code>RESTClient</code> 用来访问前面小节中创建的 REST API. 首先使用 <code>WebClient.create</code> 方法来创建一个新的 <code>WebClient</code> 对象, 然后使用方法 <code>post</code> 来创建一个 <code>POST</code> 请求, 并使用方法 <code>body</code> 来设置 <code>POST</code> 请求的内容. 方法 <code>exchange</code> 的作用是发送请求并得到以 <code>Mono&lt;ServerResponse&gt;</code>表示的 HTTP 响应. 最后对得到的响应进行处理并输出结果. <code>ServerResponse</code> 的 <code>bodyToMono</code> 方法把响应内容转换成类 <code>User</code> 的对象, 最终得到的结果是 <code>Mono&lt;User&gt;</code>对象. 调用 <code>createdUser.block</code> 方法的作用是等待请求完成并得到所产生的类 User 的对象. </p>
<p><strong>清单 10. 使用 WebClient 访问 REST API</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RESTClient &#123;</span><br><span class="line">    public static void main(final String[] args) &#123;</span><br><span class="line">        final User user = new User();</span><br><span class="line">        user.setName(&quot;Test&quot;);</span><br><span class="line">        user.setEmail(&quot;test@example.org&quot;);</span><br><span class="line">        final WebClient client = WebClient.create(&quot;http://localhost:8080/user&quot;);</span><br><span class="line">        final Monol&lt;User&gt; createdUser = client.post()</span><br><span class="line">                .uri(&quot;&quot;)</span><br><span class="line">                .accept(MediaType.APPLICATION_JSON)</span><br><span class="line">                .body(Mono.just(user), User.class)</span><br><span class="line">                .exchange()</span><br><span class="line">                .flatMap(response -&gt; response.bodyToMono(User.class));</span><br><span class="line">        System.out.println(createdUser.block());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SSE"><a href="#SSE" class="headerlink" title="SSE"></a>SSE</h3><p><code>WebClient</code> 还可以用同样的方式来访问 SSE 服务, 如代码清单 11 所示. 这里我们访问的是在之前的小节中创建的生成随机数的 SSE 服务. 使用 <code>WebClient</code> 访问 SSE 在发送请求部分与访问 REST API 是相同的, 所不同的地方在于对 HTTP 响应的处理. 由于 SSE 服务的响应是一个消息流, 我们需要使用 <code>flatMapMany</code> 把 <code>Mono&lt;ServerResponse&gt;</code>转换成一个 <code>Flux&lt;ServerSentEvent&gt;</code>对象, 这是通过方法 <code>BodyExtractors.toFlux</code> 来完成的, 其中的参数 <code>new ParameterizedTypeReference&lt;ServerSentEvent&lt;String&gt;&gt;() {}</code>表明了响应消息流中的内容是 <code>ServerSentEvent</code> 对象. 由于 SSE 服务器会不断地发送消息, 这里我们只是通过 <code>buffer</code> 方法来获取前 10 条消息并输出. </p>
<p><strong>清单 11. 使用 WebClient 访问 SSE 服务</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SSEClient &#123;</span><br><span class="line">    public static void main(final String[] args) &#123;</span><br><span class="line">        final WebClient client = WebClient.create();</span><br><span class="line">        client.get()</span><br><span class="line">                .uri(&quot;http://localhost:8080/sse/randomNumbers&quot;)</span><br><span class="line">                .accept(MediaType.TEXT_EVENT_STREAM)</span><br><span class="line">                .exchange()</span><br><span class="line">                .flatMapMany(response -&gt; response.body(BodyExtractors.toFlux(new ParameterizedTypeReference&lt;ServerSentEvent&lt;String&gt;&gt;() &#123;</span><br><span class="line">                &#125;)))</span><br><span class="line">                .filter(sse -&gt; Objects.nonNull(sse.data()))</span><br><span class="line">                .map(ServerSentEvent::data)</span><br><span class="line">                .buffer(10)</span><br><span class="line">                .doOnNext(System.out::println)</span><br><span class="line">                .blockFirst();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="WebSocket-1"><a href="#WebSocket-1" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>访问 WebSocket 不能使用 <code>WebClient</code>, 而应该使用<strong>专门</strong>的 <code>WebSocketClient</code> 客户端. Spring Boot 的 WebFlux 模板中默认使用的是 <code>Reactor Netty</code> 库. <code>Reactor Netty</code> 库提供了 <code>WebSocketClient</code> 的实现. 在代码清单 12 中, 我们访问的是上面小节中创建的 WebSocket 服务. <code>WebSocketClient</code> 的 <code>execute</code> 方法与 WebSocket 服务器建立连接, 并执行给定的 <code>WebSocketHandler</code> 对象. 该 <code>WebSocketHandler</code> 对象与代码清单 6 中的作用是一样的, 只不过它是工<strong>作于客户端</strong>, 而不是服务器端. 在 <code>WebSocketHandler</code> 的实现中, 首先通过 <code>WebSocketSession</code> 的 <code>send</code> 方法来发送字符串 <code>Hello</code> 到服务器端, 然后通过 <code>receive</code> 方法来等待服务器端的响应并输出. 方法 <code>take(1)</code>的作用是表明客户端只获取服务器端发送的第一条消息. </p>
<p><strong>清单 12. 使用 WebSocketClient 访问 WebSocket</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class WSClient &#123;</span><br><span class="line">    public static void main(final String[] args) &#123;</span><br><span class="line">        final WebSocketClient client = new ReactorNettyWebSocketClient();</span><br><span class="line">        client.execute(URI.create(&quot;ws://localhost:8080/echo&quot;), session -&gt;</span><br><span class="line">                session.send(Flux.just(session.textMessage(&quot;Hello&quot;)))</span><br><span class="line">                        .thenMany(session.receive().take(1).map(WebSocketMessage::getPayloadAsText))</span><br><span class="line">                        .doOnNext(System.out::println)</span><br><span class="line">                        .then())</span><br><span class="line">                .block(Duration.ofMillis(5000));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在 <code>spring-test</code> 模块中也添加了对 WebFlux 的支持. 通过类 <code>org.springframework.test.web.reactive.server.WebTestClient</code> 可以测试 WebFlux 服务器. 进行测试时既可以通过 <code>mock</code> 的方式来进行, 也可以对实际运行的服务器进行集成测试. 代码清单 13 通过一个集成测试来测试 <code>UserController</code> 中的创建用户的功能. 方法 <code>WebTestClient.bindToServer</code> 绑定到一个运行的服务器并设置了基础 URL. 发送 HTTP 请求的方式与代码清单 10 相同, 不同的是 <code>exchange</code> 方法的返回值是 <code>ResponseSpec</code> 对象, 其中包含了 <code>expectStatus</code> 和 <code>expectBody</code> 等方法来<strong>验证</strong> <code>HTTP</code> 响应的状态码和内容. 方法 <code>jsonPath</code> 可以根据 JSON 对象中的路径来进行验证. </p>
<p><strong>清单 13. 测试 UserController</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class UserControllerTest &#123;</span><br><span class="line">    private final WebTestClient client = WebTestClient.bindToServer().baseUrl(&quot;http://localhost:8080&quot;).build();</span><br><span class="line"> </span><br><span class="line">    @Test</span><br><span class="line">    public void testCreateUser() throws Exception &#123;</span><br><span class="line">        final User user = new User();</span><br><span class="line">        user.setName(&quot;Test&quot;);</span><br><span class="line">        user.setEmail(&quot;test@example.org&quot;);</span><br><span class="line">        client.post().uri(&quot;/user&quot;)</span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">                .body(Mono.just(user), User.class)</span><br><span class="line">                .exchange()</span><br><span class="line">                .expectStatus().isOk()</span><br><span class="line">                .expectBody().jsonPath(&quot;name&quot;).isEqualTo(&quot;Test&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>反应式编程范式为开发高性能 Web 应用带来了新的机会和挑战. Spring 5 中的 WebFlux 模块可以作为开发反应式 Web 应用的基础. 由于 Spring 框架的流行, WebFlux 会成为开发 Web 应用的重要趋势之一. 本文对 Spring 5 中的 WebFlux 模块进行了详细的介绍, 包括如何用 WebFlux 开发 HTTP、SSE 和 WebSocket 服务器端应用, 以及作为客户端来访问 HTTP、SSE 和 WebSocket 服务. 对于 WebFlux 的基于 Java 注解和函数式编程等两种模型都进行了介绍. 最后介绍了如何测试 WebFlux 应用. </p>
<h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><blockquote>
<p>原文链接: </p>
<p><strong><em><a href="https://www.ibm.com/developerworks/cn/java/spring5-webflux-reactive/index.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.ibm.com/developerworks/cn/java/spring5-webflux-reactive/index.html</a></em></strong></p>
<p><strong><em><a href="https://www.ibm.com/developerworks/cn/java/j-whats-new-in-spring-framework-5-theedom/index.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.ibm.com/developerworks/cn/java/j-whats-new-in-spring-framework-5-theedom/index.html</a></em></strong></p>
</blockquote>
]]></content><categories><category>Programming</category><category>Java</category></categories><tags><tag>Java</tag><tag>Spring5</tag></tags></entry><entry><title>Nexus搭建与Maven配置</title><url>/2019/nexus3-by-docker/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/docker-nexus3/nexus-logo.png" alt></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><blockquote>
<p>一般每个企业里面都有属于自己的Nexus服务器作为自己的私服（代理），私服好处众多，例如加速构建、稳定，节省带宽、节省中央<code>maven</code>仓库的带宽，控制和审计，可以建立本地内部仓库、可以建立公共仓库等等。<code>Docker</code> 可以大大简化服务器的部署，并且Nexus3已经支持<code>Docker Image</code>啦～爽歪歪</p>
</blockquote>
<a id="more"></a>
<h1 id="Get-Image"><a href="#Get-Image" class="headerlink" title="Get Image"></a>Get Image</h1><h2 id="直接拉取镜像"><a href="#直接拉取镜像" class="headerlink" title="直接拉取镜像"></a>直接拉取镜像</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull sonatype/nexus3</span><br></pre></td></tr></table></figure>
<p>如果没有代理导致下载很慢可以尝试下面方式二</p>
<h2 id="通过Dockerfile构建"><a href="#通过Dockerfile构建" class="headerlink" title="通过Dockerfile构建"></a>通过Dockerfile构建</h2><p>通过官方的<code>Dockerfile</code>构建：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/sonatype/docker-nexus3.git</span><br><span class="line">cd docker-nexus3</span><br><span class="line">docker build --rm=true --tag=sonatype/nexus3 .</span><br></pre></td></tr></table></figure>
<p><code>--rm=true</code> 表示成功编译后删除中间的容器，至于<code>tag</code>随便起</p>
<h1 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h1><p>官方有两种方式：</p>
<ul>
<li>使用 docker 的 <code>data volume</code> （推荐）</li>
<li>使用本地目录作为 container 的 <code>volume</code></li>
</ul>
<p>使用<code>data volume</code>可以获取更高的灵活性。</p>
<p>使用 <code>data volume</code>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker volume create --name nexus-data</span><br></pre></td></tr></table></figure></p>
<p>使用本地目录：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir /some/dir/nexus-data &amp;&amp; chown -R 200 /some/dir/nexus-data</span><br></pre></td></tr></table></figure></p>
<p>其中 <code>chown -R 200</code> 表示更改该文件夹的拥有者为 UID 为 200 的用户，这里应该是为了尽量不要在本机被当前用户或其他用户修改该文件夹，该文件夹只允许我们后面运行的 docker container 来使用。（个人认为，首先通过命令<code>id 200</code> 检查一下该 <code>id</code> 是否有用户，如果没有就用该 <code>id</code>，如果有则换一个新的 <code>id</code>。）</p>
<h1 id="Enviroment"><a href="#Enviroment" class="headerlink" title="Enviroment"></a>Enviroment</h1><p>可通过 <code>INSTALL4J_ADD_VM_PARAMS</code> 环境变量配置 JVM 参数.</p>
<p>默认是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xms1200m -Xmx1200m -XX:MaxDirectMemorySize=2g -Djava.util.prefs.userRoot=$&#123;NEXUS_DATA&#125;/javaprefs</span><br></pre></td></tr></table></figure>
<p>ex:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8081:8081 --name nexus -e INSTALL4J_ADD_VM_PARAMS=&quot;-Xms2g -Xmx2g -XX:MaxDirectMemorySize=3g  -Djava.util.prefs.userRoot=/some-other-dir&quot; sonatype/nexus3</span><br></pre></td></tr></table></figure>
<h1 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h1><p>使用 <code>data volume</code>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --restart=always -d -p 8090:8081 --name nexus -v nexus-data:/nexus-data sonatype/nexus3</span><br></pre></td></tr></table></figure></p>
<p>使用本地目录：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --restart=always -d -p 8090:8081 --name nexus -v /some/dir/nexus-data:/nexus-data sonatype/nexus3</span><br></pre></td></tr></table></figure></p>
<p>通过<code>docker logs nexus</code> 可以查看启动日志。</p>
<p>启动过程需要稍等几分钟，之后可以访问<code>localhost:8090</code>，默认的 用户名／密码是admin／admin123，需要自己修改密码。</p>
<h1 id="Password"><a href="#Password" class="headerlink" title="Password"></a>Password</h1><p>最新版的默认密码是随机生成的, 在 <code>/nexus-data/admin.password</code> 中, <strong>首次登录</strong>需要输入里面的密码, 再重新设置密码.</p>
<h1 id="Repositories"><a href="#Repositories" class="headerlink" title="Repositories"></a>Repositories</h1><p><img src="https://cdn.yangbingdong.com/img/docker-nexus3/nexus-repo.png" alt></p>
<p>有几个默认仓库分别是：</p>
<ol>
<li><code>maven-central</code>：maven中央库，默认从<a href="https://repo1.maven.org/maven2/" rel="external nofollow noopener noreferrer" target="_blank">https://repo1.maven.org/maven2/</a>拉取jar</li>
<li><code>maven-releases</code>：私库发行版jar，初次安装请将<code>Deployment policy</code>设置为<code>Allow redeploy</code></li>
<li><code>maven-snapshots</code>：私库快照（调试版本）<code>jar</code></li>
<li><code>maven-public</code>：仓库分组，把上面三个仓库组合在一起对外提供服务，在本地maven基础配置<code>settings.xml</code>中使用。</li>
</ol>
<p>Nexus默认的仓库类型有以下四种：</p>
<ol>
<li><code>group</code>(仓库组类型)：又叫组仓库，用于方便开发人员自己设定的仓库</li>
<li><code>hosted</code>(宿主类型)：内部项目的发布仓库（内部开发人员，发布上去存放的仓库</li>
<li><code>proxy</code>(代理类型)：从远程中央仓库中寻找数据的仓库（可以点击对应的仓库的<code>Configuration</code>页签下<code>Remote Storage</code>属性的值即被代理的远程仓库的路径</li>
<li><code>virtual</code>(虚拟类型)：虚拟仓库（这个基本用不到，重点关注上面三个仓库的使用）</li>
</ol>
<h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><p>由于访问中央仓库有时候会比较慢，我们可以配置代理加快速度。</p>
<h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><p>默认的<code>maven-central</code> 使用的是 <em><a href="https://repo1.maven.org/maven2/" rel="external nofollow noopener noreferrer" target="_blank">https://repo1.maven.org/maven2/</a></em> 地址，速度上没有UK 的快，所以修改为 <em><a href="http://uk.maven.org/maven2/" rel="external nofollow noopener noreferrer" target="_blank">http://uk.maven.org/maven2/</a></em> 或者阿里的镜像 <em><a href="http://maven.aliyun.com/nexus/content/groups/public/" rel="external nofollow noopener noreferrer" target="_blank">http://maven.aliyun.com/nexus/content/groups/public/</a></em> 或 <em><a href="https://maven.aliyun.com/repository/public" rel="external nofollow noopener noreferrer" target="_blank">https://maven.aliyun.com/repository/public</a></em></p>
<p><img src="https://cdn.yangbingdong.com/img/docker-nexus3/proxy-url.png" alt></p>
<h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>添加一个阿里云的代理仓库，然后优先级放到默认中央库之前：</p>
<p><img src="https://cdn.yangbingdong.com/img/docker-nexus3/nexus-proxy1.png" alt></p>
<p>然后再public组里面讲这个<code>aliyun-proxy</code>仓库加入，排在<code>maven-central</code>之前即可。</p>
<p><img src="https://cdn.yangbingdong.com/img/docker-nexus3/nexus-proxy2.png" alt></p>
<p><strong>Nexus仓库分类的概念</strong></p>
<p>1）Maven可直接从宿主仓库下载构件,也可以从代理仓库下载构件,而代理仓库间接的从远程仓库下载并缓存构件</p>
<p>2）为了方便,Maven可以从仓库组下载构件,而仓库组并没有时间的内容(下图中用虚线表示,它会转向包含的宿主仓库或者代理仓库获得实际构件的内容)</p>
<p><img src="https://cdn.yangbingdong.com/img/docker-nexus3/nexus-proxy3.png" alt></p>
<h1 id="允许多次push"><a href="#允许多次push" class="headerlink" title="允许多次push"></a>允许多次push</h1><p><img src="https://cdn.yangbingdong.com/img/docker-nexus3/nexus-repush.png" alt></p>
<h1 id="Backup-amp-Recovery"><a href="#Backup-amp-Recovery" class="headerlink" title="Backup &amp; Recovery"></a>Backup &amp; Recovery</h1><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --rm -v nexus-data:/backup-data -v $(pwd):/backup ubuntu:latest tar cvf /backup/nexus-data.tar /backup-data</span><br><span class="line"></span><br><span class="line"># or</span><br><span class="line">docker run --rm -v nexus-data:/backup-data -v $(pwd):/backup ubuntu:latest tar zcvf /backup/nexus-data.tar.gz /backup-data</span><br></pre></td></tr></table></figure>
<h2 id="还原"><a href="#还原" class="headerlink" title="还原"></a>还原</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker volume create --name nexus-data1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --rm -v nexus-data1:/vdata -v $(pwd):/backup ubuntu:latest tar xvf /backup/nexus-data.tar -C /vdata --strip-components=1</span><br><span class="line"></span><br><span class="line"># or</span><br><span class="line">docker run --rm -v nexus-data1:/vdata -v $(pwd):/backup ubuntu:latest tar zxvf /backup/nexus-data.tar.gz -C /vdata --strip-components=1</span><br></pre></td></tr></table></figure>
<p><code>--strip-components=1</code>是为了不要解压出来的最外层文件夹</p>
<h1 id="Maven-配置"><a href="#Maven-配置" class="headerlink" title="Maven 配置"></a>Maven 配置</h1><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p><code>setting.xml</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置自己的maven本地仓库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>/home/ybd/data/application/maven/maven-repo-local<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin123<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin123<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-public<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>central repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://127.0.0.1:9091/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus Release Snapshot Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://127.0.0.1:9091/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://127.0.0.1:9091/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus Release Snapshot Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://127.0.0.1:9091/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://127.0.0.1:9091/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p>下载<code>jar</code>包源码可以在配置文件或IDEA中配置</p>
<h3 id="通过配置文件添加"><a href="#通过配置文件添加" class="headerlink" title="通过配置文件添加"></a>通过配置文件添加</h3><p>在maven的<code>settings.xml</code>配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>downloadSources<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">downloadSources</span>&gt;</span>true<span class="tag">&lt;/<span class="name">downloadSources</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">downloadJavadocs</span>&gt;</span>true<span class="tag">&lt;/<span class="name">downloadJavadocs</span>&gt;</span>             </span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>downloadSources<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">activeProfiles</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="IDEA配置"><a href="#IDEA配置" class="headerlink" title="IDEA配置"></a>IDEA配置</h3><p><img src="https://cdn.yangbingdong.com/img/docker-nexus3/download-source.png" alt></p>
<p>然后重新<code>import</code>就ok了</p>
<h2 id="发布项目"><a href="#发布项目" class="headerlink" title="发布项目"></a>发布项目</h2><p>在 <code>pom.xml</code> 中配置:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 两个ID必须与 setting.xml中的&lt;server&gt;&lt;id&gt;nexus-releases&lt;/id&gt;&lt;/server&gt;保持一致--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus Release Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://127.0.0.1:9091/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus Snapshot Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://127.0.0.1:9091/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="仓库优先级"><a href="#仓库优先级" class="headerlink" title="仓库优先级"></a>仓库优先级</h1><p>本地仓库 &gt; 私服 （profile）&gt; 远程仓库（repository）和 镜像 （mirror） &gt; 中央仓库 （central）</p>
<h1 id="附录-阿里代理的仓库列表"><a href="#附录-阿里代理的仓库列表" class="headerlink" title="附录: 阿里代理的仓库列表"></a>附录: 阿里代理的仓库列表</h1><table>
<thead>
<tr>
<th style="text-align:left">仓库名称</th>
<th style="text-align:left">代理源地址</th>
<th style="text-align:left">使用地址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">central</td>
<td style="text-align:left"><a href="https://repo1.maven.org/maven2/" rel="external nofollow noopener noreferrer" target="_blank">https://repo1.maven.org/maven2/</a></td>
<td style="text-align:left"><a href="https://maven.aliyun.com/repository/central" rel="external nofollow noopener noreferrer" target="_blank">https://maven.aliyun.com/repository/central</a> 或 <a href="https://maven.aliyun.com/nexus/content/repositories/central" rel="external nofollow noopener noreferrer" target="_blank">https://maven.aliyun.com/nexus/content/repositories/central</a></td>
</tr>
<tr>
<td style="text-align:left">jcenter</td>
<td style="text-align:left"><a href="http://jcenter.bintray.com/" rel="external nofollow noopener noreferrer" target="_blank">http://jcenter.bintray.com/</a></td>
<td style="text-align:left"><a href="https://maven.aliyun.com/repository/jcenter" rel="external nofollow noopener noreferrer" target="_blank">https://maven.aliyun.com/repository/jcenter</a> 或 <a href="https://maven.aliyun.com/nexus/content/repositories/jcenter" rel="external nofollow noopener noreferrer" target="_blank">https://maven.aliyun.com/nexus/content/repositories/jcenter</a></td>
</tr>
<tr>
<td style="text-align:left">public</td>
<td style="text-align:left">central仓和jcenter仓的聚合仓</td>
<td style="text-align:left"><a href="https://maven.aliyun.com/repository/public" rel="external nofollow noopener noreferrer" target="_blank">https://maven.aliyun.com/repository/public</a> 或<a href="https://maven.aliyun.com/nexus/content/groups/public" rel="external nofollow noopener noreferrer" target="_blank">https://maven.aliyun.com/nexus/content/groups/public</a></td>
</tr>
<tr>
<td style="text-align:left">google</td>
<td style="text-align:left"><a href="https://maven.google.com/" rel="external nofollow noopener noreferrer" target="_blank">https://maven.google.com/</a></td>
<td style="text-align:left"><a href="https://maven.aliyun.com/repository/google" rel="external nofollow noopener noreferrer" target="_blank">https://maven.aliyun.com/repository/google</a> 或 <a href="https://maven.aliyun.com/nexus/content/repositories/google" rel="external nofollow noopener noreferrer" target="_blank">https://maven.aliyun.com/nexus/content/repositories/google</a></td>
</tr>
<tr>
<td style="text-align:left">gradle-plugin</td>
<td style="text-align:left"><a href="https://plugins.gradle.org/m2/" rel="external nofollow noopener noreferrer" target="_blank">https://plugins.gradle.org/m2/</a></td>
<td style="text-align:left"><a href="https://maven.aliyun.com/repository/gradle-plugin" rel="external nofollow noopener noreferrer" target="_blank">https://maven.aliyun.com/repository/gradle-plugin</a> 或 <a href="https://maven.aliyun.com/nexus/content/repositories/gradle-plugin" rel="external nofollow noopener noreferrer" target="_blank">https://maven.aliyun.com/nexus/content/repositories/gradle-plugin</a></td>
</tr>
<tr>
<td style="text-align:left">spring</td>
<td style="text-align:left"><a href="http://repo.spring.io/libs-milestone/" rel="external nofollow noopener noreferrer" target="_blank">http://repo.spring.io/libs-milestone/</a></td>
<td style="text-align:left"><a href="https://maven.aliyun.com/repository/spring" rel="external nofollow noopener noreferrer" target="_blank">https://maven.aliyun.com/repository/spring</a> 或 <a href="https://maven.aliyun.com/nexus/content/repositories/spring" rel="external nofollow noopener noreferrer" target="_blank">https://maven.aliyun.com/nexus/content/repositories/spring</a></td>
</tr>
<tr>
<td style="text-align:left">spring-plugin</td>
<td style="text-align:left"><a href="http://repo.spring.io/plugins-release/" rel="external nofollow noopener noreferrer" target="_blank">http://repo.spring.io/plugins-release/</a></td>
<td style="text-align:left"><a href="https://maven.aliyun.com/repository/spring-plugin" rel="external nofollow noopener noreferrer" target="_blank">https://maven.aliyun.com/repository/spring-plugin</a> 或 <a href="https://maven.aliyun.com/nexus/content/repositories/spring-plugin" rel="external nofollow noopener noreferrer" target="_blank">https://maven.aliyun.com/nexus/content/repositories/spring-plugin</a></td>
</tr>
<tr>
<td style="text-align:left">grails-core</td>
<td style="text-align:left"><a href="https://repo.grails.org/grails/core" rel="external nofollow noopener noreferrer" target="_blank">https://repo.grails.org/grails/core</a></td>
<td style="text-align:left"><a href="https://maven.aliyun.com/repository/grails-core" rel="external nofollow noopener noreferrer" target="_blank">https://maven.aliyun.com/repository/grails-core</a> 或 <a href="https://maven.aliyun.com/nexus/content/repositories/grails-core" rel="external nofollow noopener noreferrer" target="_blank">https://maven.aliyun.com/nexus/content/repositories/grails-core</a></td>
</tr>
<tr>
<td style="text-align:left">apache snapshots</td>
<td style="text-align:left"><a href="https://repository.apache.org/snapshots/" rel="external nofollow noopener noreferrer" target="_blank">https://repository.apache.org/snapshots/</a></td>
<td style="text-align:left"><a href="https://maven.aliyun.com/repository/apache-snapshots" rel="external nofollow noopener noreferrer" target="_blank">https://maven.aliyun.com/repository/apache-snapshots</a> 或 <a href="https://maven.aliyun.com/nexus/content/repositories/apache-snapshots" rel="external nofollow noopener noreferrer" target="_blank">https://maven.aliyun.com/nexus/content/repositories/apache-snapshots</a></td>
</tr>
</tbody>
</table>
<p>使用:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>阿里云公共仓库<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果想使用其它代理仓库,可在<code>&lt;repositories&gt;&lt;/repositories&gt;</code>节点中加入对应的仓库使用地址。以使用spring代理仓为例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/spring<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><blockquote>
<p>参考： <strong><em><a href="https://hub.docker.com/r/sonatype/nexus3/" rel="external nofollow noopener noreferrer" target="_blank">https://hub.docker.com/r/sonatype/nexus3/</a></em></strong></p>
</blockquote>
]]></content><categories><category>Maven</category></categories><tags><tag>Maven</tag></tags></entry><entry><title>NGINX初学指南(安装与简单配置)</title><url>/2017/nginx-noob-guide/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/NGINX.png" alt></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>走上了VPS这条<del>不归路</del>, 就意味着需要会维护以及运营自己的服务器. 那么这一章记录一下学习Nginx的一些东西…<br>本文绝大部分内容来自NGINX 网站的官方手册:<br><strong><em><a href="https://www.nginx.com/resources/admin-guide/installing-nginx-open-source/" rel="external nofollow noopener noreferrer" target="_blank">https://www.nginx.com/resources/admin-guide/installing-nginx-open-source/</a></em></strong><br><strong><em><a href="http://nginx.org/en/docs/beginners_guide.html" rel="external nofollow noopener noreferrer" target="_blank">http://nginx.org/en/docs/beginners_guide.html</a></em></strong></p>
</blockquote>
<a id="more"></a>
<h1 id="安装NGINX部分"><a href="#安装NGINX部分" class="headerlink" title="安装NGINX部分"></a>安装NGINX部分</h1><h2 id="主干版本VS稳定版本"><a href="#主干版本VS稳定版本" class="headerlink" title="主干版本VS稳定版本"></a>主干版本VS稳定版本</h2><p>NGINX 有两个有效版本: </p>
<ul>
<li>主干版本. 这个版本中包含了最新的功能和 BUG 修复, 并且总是最新的版本. 这个版本很可靠, 但是也包含了一些实验性质的模块和一定数量的新 BUG. </li>
<li>稳定版本. 这个版本没有最新的功能, 但是包含了关键 BUG 的修复. 在生产服务器中推荐使用稳定版本. </li>
</ul>
<h2 id="预编译包VS源码编译"><a href="#预编译包VS源码编译" class="headerlink" title="预编译包VS源码编译"></a>预编译包VS源码编译</h2><p>NGINX 的主干版本和稳定版本都可以以下两种方式安装: </p>
<ul>
<li>预编译包安装. 这是一种快捷的安装方式. 预编译包中含有几乎所有 NGINX 官方模块并且适用于大多数主流的操作系统. </li>
<li>通过源码编译安装. 这种方式更加灵活: 你可以添加包括第三方模块在内的特殊模块以及最新的安全补丁. </li>
</ul>
<h2 id="通过源码编译和安装"><a href="#通过源码编译和安装" class="headerlink" title="通过源码编译和安装"></a>通过源码编译和安装</h2><blockquote>
<p>通过源码编译 NGINX 带给你更多的灵活性: 你可以添加包括第三方模块在内的特殊模块以及最新的安全补丁. </p>
</blockquote>
<p>先安装一些编译依赖:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install -y build-essential libtool</span><br></pre></td></tr></table></figure></p>
<h3 id="安装-NGINX-依赖"><a href="#安装-NGINX-依赖" class="headerlink" title="安装 NGINX 依赖"></a>安装 NGINX 依赖</h3><p>1、<strong><em><a href="http://pcre.org/" rel="external nofollow noopener noreferrer" target="_blank">PCRC</a></em></strong> 库: 被 NGINX <strong><em><a href="https://nginx.org/en/docs/ngx_core_module.html?_ga=2.65941421.2064822644.1493181926-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">Core</a></em></strong> 和 <strong><em><a href="https://nginx.org/en/docs/http/ngx_http_rewrite_module.html?_ga=2.65941421.2064822644.1493181926-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">Rewrite</a></em></strong> 模块需求, 并且提供正则表达式支持:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/src &amp;&amp; wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.40.tar.gz &amp;&amp; tar -zxf pcre-8.40.tar.gz &amp;&amp; cd pcre-8.40 &amp;&amp; ./configure &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p>
<p>2、<strong><em><a href="http://www.zlib.net/" rel="external nofollow noopener noreferrer" target="_blank">zlib</a></em></strong> 库: 为了头部压缩被 NGINX <strong><em><a href="https://nginx.org/en/docs/http/ngx_http_gzip_module.html?_ga=2.65941421.2064822644.1493181926-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">Gzip</a></em></strong> 模块需求:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/src &amp;&amp; wget http://zlib.net/zlib-1.2.11.tar.gz &amp;&amp; tar -zxf zlib-1.2.11.tar.gz &amp;&amp; cd zlib-1.2.11 &amp;&amp; ./configure &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p>
<p>3、<strong><em><a href="https://www.openssl.org/" rel="external nofollow noopener noreferrer" target="_blank">OpenSSL</a></em></strong> 库: 被 NGINX SSL 模块需求用以支持 HTTPS 协议: </p>
<blockquote>
<p>这里博主并不选择源码安装=.=, 而是通过apt安装: </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get upgrade</span><br><span class="line">apt-get install -y libssl-dev openssl</span><br></pre></td></tr></table></figure>
<h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><p>NGINX 同时提供了稳定版本和主干版本的源码文件. 源码文件可以从 NGINX Open Source 下载页面下载:<br><a id="download" href="http://www.nginx.org/en/download.html" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-download"></i><span>Redirect Download Page</span><br></a><br>下载并解压最新的主干版本源码文件, 在命令行中输入下面的命令:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/src &amp;&amp; wget http://nginx.org/download/nginx-1.12.0.tar.gz &amp;&amp; tar -zxvf nginx-1.12.0.tar.gz &amp;&amp; cd nginx-1.12.0</span><br></pre></td></tr></table></figure></p>
<h3 id="配置构建选项"><a href="#配置构建选项" class="headerlink" title="配置构建选项"></a>配置构建选项</h3><p>配置选项要使用 <code>./configure</code> 脚本来设置各种 NGINX 的参数, 其中包括源码和配置文件路径、编译器选项, 连接处理方法以及模块列表. 脚本最终创建了用于编译代码和安装 NGINX 的 Makefile 文件.<br>例如:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure --sbin-path=/usr/local/nginx/nginx --conf-path=/usr/local/nginx/nginx.conf --pid-path=/usr/local/nginx/nginx.pid --with-pcre=../pcre-8.40 --with-zlib=../zlib-1.2.11 --with-http_ssl_module --with-stream --with-http_stub_status_module</span><br></pre></td></tr></table></figure></p>
<h4 id="配置-NGINX-路径"><a href="#配置-NGINX-路径" class="headerlink" title="配置 NGINX 路径"></a>配置 NGINX 路径</h4><p>配置脚本允许你设置 NGINX 二进制文件和配置文件的路径以及依赖库 （PCRC 或 SSL）的路径, 以便静态链接到 NGINX 二进制文件中. </p>
<p><code>–prefix=path</code>:<br>定义保存 NGINX 文件的目录. 目录也将被用于所有通过 <code>./configure</code> 设置的相对路径和 nginx.conf 配置文件的路径. 默认这个路径被设置为 <code>/usr/local/nginx</code>. </p>
<p><code>–sbin-path=path</code>:<br>设置 NGINX 可执行文件的名称. 这个名称仅在安装期间使用. 该文件默认的被命名为 <code>prefix/sbin/nginx</code>. </p>
<p><code>–conf-path=path</code>:<br>设置 NGINX 配置文件名称. 该文件默认的被命名为 <code>prefix/conf/nginx.conf</code>. </p>
<p>注意: 无论这个选项是什么, 你都可以在命令行中通过 -c 选项来指定使用不同的配置文件启动 NGINX. </p>
<p><code>–pid-path=path</code>:<br>设置存储主进程的进程 id 的 <code>nginx.pid</code> 文件名. 在安装以后, 文件名的路径总是可以在 <code>nginx.conf</code> 文件中被修改, 通过使用 pid 指令. 默认该文件被命名为 <code>prefix/logs/nginx.pid</code></p>
<p><code>–error-log-path=path</code>:<br>设置主要的错误, 警告和诊断文件的名字. 安装之后, 文件名总是可以在 <code>nginx.conf</code> 文件中使用 <code>error_log</code> 指令修改. 该文件默认被命名为 <code>prefix/logs/access.log</code>. </p>
<p><code>–user=name</code>:<br>设置凭据将被用于 NGINX worker 进程的非特权用户的名称. 在安装后, 这个名称可以通过使用 user 指令在 <code>nginx.conf</code> 文件中修改. 默认的名字是 nobody. </p>
<p><code>–group=name</code>:<br>设置凭据将被用于 NGINX worker 进程的用户组名. 在安装以后, 这个名称可以通过使用 user 指令在 <code>nginx.conf</code> 文件中修改. 默认地, 用户组名被设置为非特权用户的名字. </p>
<p><code>–with-pcre=path</code>:<br>设置 PCRE 库的源码的路径. 这个库在 <strong><em><a href="https://nginx.org/en/docs/http/ngx_http_core_module.html?&amp;_ga=2.225233945.2064822644.1493181926-708921149.1492677721#location" rel="external nofollow noopener noreferrer" target="_blank">location</a></em></strong> 指令和 <strong><em><a href="https://nginx.org/en/docs/http/ngx_http_rewrite_module.html?_ga=2.225233945.2064822644.1493181926-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">ngx_http_rewrite_module</a></em></strong> 模块中被用于支持正则表达式. </p>
<p><code>–with-pcre-jit</code>:<br>使用 “just-in-time compilation” 支持（<strong><em><a href="https://nginx.org/en/docs/ngx_core_module.html?&amp;_ga=2.225233945.2064822644.1493181926-708921149.1492677721#pcre_jit" rel="external nofollow noopener noreferrer" target="_blank">pcre_jit</a></em></strong> 指令）来构建 PCRE 库. </p>
<p><code>–with-zlib=path</code>:<br>设置 zlib 库的源码的路径. 这个库被用于 <strong><em><a href="https://nginx.org/en/docs/http/ngx_http_gzip_module.html?_ga=2.252710794.2064822644.1493181926-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">ngx_http_gzip_module</a></em></strong> 模块中. </p>
<h4 id="配置-NGINX-GCC-选项"><a href="#配置-NGINX-GCC-选项" class="headerlink" title="配置 NGINX GCC 选项"></a>配置 NGINX GCC 选项</h4><p>在配置脚本中你也可以指定编译器关联选项:<br><code>–with-cc-opt=parameters</code>:<br>设置添加到 CFLAGS 变量中的附加参数. 在 FreeBSD 系统下, 当使用系统 PCRE 库的时候, <code>–with-cc-opt=-I/usr/local/include</code> 必须被指定. </p>
<p>如果被select支持的文件数量需要增加, 那么也可以像这下面这样指定: <code>–with-cc-opt=-D/FD_SETSIZE=2048</code>. </p>
<p><code>–with-ld-opt=parameters</code>:<br>设置将用于链接时的附加参数. 当在 FreeBSD 下使用系统 PCRE 库时, <code>–with-cc-opt=-L/usr/local/lib</code> 必须被指定. </p>
<h4 id="指定-NGINX-连接处理方法"><a href="#指定-NGINX-连接处理方法" class="headerlink" title="指定 NGINX 连接处理方法"></a>指定 NGINX 连接处理方法</h4><p>在配置脚本中, 你可以重新定义基于事件的轮询方法. 查看 <strong><em><a href="https://nginx.org/en/docs/events.html?_ga=2.221072283.2064822644.1493181926-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">Connection Processing Methods</a></em></strong> 了解更多内容.<br><code>–with-select_module</code>,<code>–without-select_module</code>:<br>启用或禁用构建允许 NGINX 使用 select 方法工作的模块. 如果平台没有明确支持想 kqueue,epoll,/dev/poll这样更加合适的方法, 该模块将被自动构建. </p>
<p><code>–with-poll_module</code>,<code>–without-poll-module</code>:<br>启用或禁用构建允许 NGINX 使用 poll() 方法工作的模块. 如果该平台没有明确支持像 kqueue,epoll,/dev/poll 这样更加更是的方法, 该模块将被自动构建. </p>
<h4 id="NGINX-模块"><a href="#NGINX-模块" class="headerlink" title="NGINX 模块"></a>NGINX 模块</h4><p>模块的 NGINX 常量. 模块的设置就如其他构建选项一样被配置在 <code>./configure</code> 脚本中.<br>有一些模块被自动构建——他们不需要在配置脚本中指定. 然而, 一些默认的模块可以被排除在 NGINX 二进制文件之外, 通过在配置脚本中使用 <code>-without-</code> 配置选项.<br>模块默认不包含第三方模块, 必须在配置脚本中使用其他的构建选项明确指定才行. 这些模块可以被链接到 NGINX 二进制文件, 以静态的方式在每次启动 NGINX 被加载, 或者如果他们在配置文件中被指定则以动态的方式被加载. </p>
<h4 id="默认的模块构建"><a href="#默认的模块构建" class="headerlink" title="默认的模块构建"></a>默认的模块构建</h4><p>如果你不需要一个默认的构建模块, 你可以通过使用 <code>–without-</code> 前缀的模块名来禁用它:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure --sbin-path=/usr/local/nginx/nginx --conf-path=/usr/local/nginx/nginx.conf --pid-path=/usr/local/nginx/nginx.pid --with-http_ssl_module --with-stream --with-pcre=../pcre-8.40 --with-zlib=../zlib-1.2.11 --without-http_empty_gif_module</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>模块名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://nginx.org/en/docs/http/ngx_http_charset_module.html?_ga=2.81192606.806275146.1493177927-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank"><strong><em>http_charset_module</em></strong></a></td>
<td>向 Content-Type 响应 header 域添加指定的字符集, 能够覆盖数据从一种编码到另外一种.</td>
</tr>
<tr>
<td><strong><em><a href="https://nginx.org/en/docs/http/ngx_http_gzip_module.html?_ga=2.263596489.438601762.1493179575-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">http_gzip_module</a></em></strong></td>
<td>使用 gzip 方法压缩响应, 有助于将传输的数据减少至少一半.</td>
</tr>
<tr>
<td><strong><em><a href="https://nginx.org/en/docs/http/ngx_http_ssi_module.html?_ga=2.258467593.2064822644.1493181926-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">http_ssi_module</a></em></strong></td>
<td>通过它在响应中处理 SSI (Server Side Includes) 命令.</td>
</tr>
<tr>
<td><strong><em><a href="https://nginx.org/en/docs/http/ngx_http_userid_module.html?_ga=2.258467593.2064822644.1493181926-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">http_userid_module</a></em></strong></td>
<td>为客户端鉴定设置 cookies 适配.</td>
</tr>
<tr>
<td><strong><em><a href="https://nginx.org/en/docs/http/ngx_http_access_module.html?_ga=2.258467593.2064822644.1493181926-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">http_access_module</a></em></strong></td>
<td>限制对特定客户端地址的访问</td>
</tr>
<tr>
<td><strong><em><a href="https://nginx.org/en/docs/http/ngx_http_auth_basic_module.html?_ga=2.258467593.2064822644.1493181926-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">http_auth_basic_module</a></em></strong></td>
<td>通过使用 HTTP Basic Authentication 协议验证用户名和密码来限制访问资源.</td>
</tr>
<tr>
<td><strong><em><a href="https://nginx.org/en/docs/http/ngx_http_autoindex_module.html?_ga=2.195961647.2064822644.1493181926-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">http_autoindex_module</a></em></strong></td>
<td>处理以斜线（/）结束的请求并产生一个目录列表.</td>
</tr>
<tr>
<td><strong><em><a href="https://nginx.org/en/docs/http/ngx_http_geo_module.html?_ga=2.195961647.2064822644.1493181926-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">http_geo_module</a></em></strong></td>
<td>创建依赖客户端 IP 地址值的变量.</td>
</tr>
<tr>
<td><strong><em><a href="https://nginx.org/en/docs/http/ngx_http_map_module.html?_ga=2.195961647.2064822644.1493181926-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">http_map_module</a></em></strong></td>
<td>创建依赖其他变量值的变量.</td>
</tr>
<tr>
<td><strong><em><a href="https://nginx.org/en/docs/http/ngx_http_split_clients_module.html?_ga=2.195961647.2064822644.1493181926-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">http_split_clients_module</a></em></strong></td>
<td>创建适配 AB 测试的变量, 也被称为分隔测试.</td>
</tr>
<tr>
<td><strong><em><a href="https://nginx.org/en/docs/http/ngx_http_referer_module.html?_ga=2.195961647.2064822644.1493181926-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">http_referer_module</a></em></strong></td>
<td>如果请求的 header 域中的 Referer 使用了无效值, 阻止其访问站点.</td>
</tr>
<tr>
<td><strong><em><a href="https://nginx.org/en/docs/http/ngx_http_rewrite_module.html?_ga=2.65405741.2064822644.1493181926-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">http_rewrite_module</a></em></strong></td>
<td>使用正则表达式改变请求的 URI 并重定向. 有条件的选择. 需要 PCRE 库支持.</td>
</tr>
<tr>
<td><strong><em><a href="https://nginx.org/en/docs/http/ngx_http_proxy_module.html?_ga=2.65405741.2064822644.1493181926-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">http_proxy_module</a></em></strong></td>
<td>传递请求到其他服务器.</td>
</tr>
<tr>
<td><strong><em><a href="https://nginx.org/en/docs/http/ngx_http_fastcgi_module.html?_ga=2.65405741.2064822644.1493181926-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">http_fastcgi_module</a></em></strong></td>
<td>传递请求到 FastCGI 服务器.</td>
</tr>
<tr>
<td><strong><em><a href="https://nginx.org/en/docs/http/ngx_http_uwsgi_module.html?_ga=2.65405741.2064822644.1493181926-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">http_uwsgi_module</a></em></strong></td>
<td>传递请求到 uwsgi 服务器.</td>
</tr>
<tr>
<td><strong><em><a href="https://nginx.org/en/docs/http/ngx_http_scgi_module.html?_ga=2.65405741.2064822644.1493181926-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">http_scgi_module</a></em></strong></td>
<td>传递请求到 SCGI 服务器.</td>
</tr>
<tr>
<td><strong><em><a href="https://nginx.org/en/docs/http/ngx_http_memcached_module.html?_ga=2.65405741.2064822644.1493181926-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">http_memcached_module</a></em></strong></td>
<td>从 memcached 服务器中获取响应.</td>
</tr>
<tr>
<td><strong><em><a href="https://nginx.org/en/docs/http/ngx_http_limit_conn_module.html?_ga=2.65405741.2064822644.1493181926-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">http_limit_conn_module</a></em></strong></td>
<td>限制每个定义的 key 的连接数量, 特别是来自单一 IP 地址的连接数量.</td>
</tr>
<tr>
<td><strong><em><a href="https://nginx.org/en/docs/http/ngx_http_limit_req_module.html?_ga=2.65405741.2064822644.1493181926-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">http_limit_req_module</a></em></strong></td>
<td>限制每个定义的 key 的请求处理率, 特别是来自单一 IP 地址的处理率.</td>
</tr>
<tr>
<td><strong><em><a href="https://nginx.org/en/docs/http/ngx_http_empty_gif_module.html?_ga=2.60746670.2064822644.1493181926-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">http_empty_gif_module</a></em></strong></td>
<td>发出单像素透明 GIF.</td>
</tr>
<tr>
<td><strong><em><a href="https://nginx.org/en/docs/http/ngx_http_browser_module.html?_ga=2.60746670.2064822644.1493181926-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">http_browser_module</a></em></strong></td>
<td>创建依赖请求 header 域中的 “User-Agent” 值的变量.</td>
</tr>
<tr>
<td><strong><em><a href="https://nginx.org/en/docs/http/ngx_http_upstream_module.html?&amp;_ga=2.60746670.2064822644.1493181926-708921149.1492677721#hash" rel="external nofollow noopener noreferrer" target="_blank">http_upstream_hash_module</a></em></strong></td>
<td>开启 hash 负载均衡方法.</td>
</tr>
<tr>
<td><strong><em><a href="https://nginx.org/en/docs/http/ngx_http_upstream_module.html?&amp;_ga=2.60746670.2064822644.1493181926-708921149.1492677721#ip_hash" rel="external nofollow noopener noreferrer" target="_blank">http_upstream_ip_hash_module</a></em></strong></td>
<td>开启 IP hash 负载均衡方法.</td>
</tr>
<tr>
<td><strong><em><a href="https://nginx.org/en/docs/http/ngx_http_upstream_module.html?&amp;_ga=2.60746670.2064822644.1493181926-708921149.1492677721#least_conn" rel="external nofollow noopener noreferrer" target="_blank">http_upstream_least_conn_module</a></em></strong></td>
<td>开启 least_conn 负载均衡方法.</td>
</tr>
<tr>
<td><strong><em><a href="https://nginx.org/en/docs/http/ngx_http_upstream_module.html?&amp;_ga=2.60746670.2064822644.1493181926-708921149.1492677721#keepalive" rel="external nofollow noopener noreferrer" target="_blank">http_upstream_keepalive_module</a></em></strong></td>
<td>开启持续连接.</td>
</tr>
<tr>
<td><strong><em><a href="https://nginx.org/en/docs/http/ngx_http_upstream_module.html?&amp;_ga=2.60746670.2064822644.1493181926-708921149.1492677721#zone" rel="external nofollow noopener noreferrer" target="_blank">http_upstream_zone_module</a></em></strong></td>
<td>开启共享内存区.</td>
</tr>
</tbody>
</table>
<h4 id="非默认构建的模块"><a href="#非默认构建的模块" class="headerlink" title="非默认构建的模块"></a>非默认构建的模块</h4><p>一些 NGINX 模块<strong>不是默认构建</strong>的. 你需要通过添加到 <code>./configure</code> 命令去手动启用他们. <a href="https://nginx.org/en/docs/mail/ngx_mail_core_module.html?_ga=2.225839129.2064822644.1493181926-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">mail</a>,<a href="https://nginx.org/en/docs/stream/ngx_stream_core_module.html?_ga=2.225839129.2064822644.1493181926-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">stream</a>,<a href="https://nginx.org/en/docs/http/ngx_http_geoip_module.html?_ga=2.225839129.2064822644.1493181926-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">geoip</a>,<a href="https://nginx.org/en/docs/http/ngx_http_image_filter_module.html?_ga=2.225839129.2064822644.1493181926-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">image_filter</a>,<a href="https://nginx.org/en/docs/http/ngx_http_perl_module.html?_ga=2.225839129.2064822644.1493181926-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">perl</a>和<a href="https://nginx.org/en/docs/http/ngx_http_xslt_module.html?_ga=2.230180639.2064822644.1493181926-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">xslt</a> 模块可以被动态编译. 查看 <strong><em><a href="https://www.nginx.com/resources/admin-guide/installing-nginx-open-source/#modules_dynamic" rel="external nofollow noopener noreferrer" target="_blank">Dynamic Modules</a></em></strong> 来了解更多内容. </p>
<p>例如, <code>./configure</code> 命令包含了这些模块:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure --sbin-path=/usr/local/nginx/nginx --conf-path=/usr/local/nginx/nginx.conf --pid-path=/usr/local/nginx/nginx.pid --with-pcre=../pcre-8.40 --with-zlib=../zlib-1.2.11 --with-http_ssl_module --with-stream --with-mail</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>–with-threads</td>
<td>允许 NGINX 使用线程池. 查看详情: <strong><em> <a href="https://www.nginx.com/blog/thread-pools-boost-performance-9x/" rel="external nofollow noopener noreferrer" target="_blank">Thread Pools in NGINX Boost Performance 9x!</a></em></strong></td>
</tr>
<tr>
<td>–with-file-aio</td>
<td>启用异步 I/O.</td>
</tr>
<tr>
<td>–with-ipv6</td>
<td>启用 IPv6 支持.</td>
</tr>
<tr>
<td>–with-http_ssl_module</td>
<td>提供 HTTPS 支持. 需要 SSL 库, 如 <strong><em><a href="https://www.openssl.org/" rel="external nofollow noopener noreferrer" target="_blank">OpenSSL</a></em></strong>. 配置参考: <strong><em><a href="https://nginx.org/en/docs/http/ngx_http_ssl_module.html?_ga=2.115793734.1190757652.1493193149-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">ngx_http_ssl_module</a></em></strong></td>
</tr>
<tr>
<td>–with-http_v2_module</td>
<td>提供 HTTP/2 支持. 配置参考: <strong><em><a href="https://nginx.org/en/docs/http/ngx_http_v2_module.html?_ga=2.69656016.1190757652.1493193149-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">ngx_http_v2_module</a></em></strong>, 更多信息: <strong><em><a href="https://www.nginx.com/blog/http2-module-nginx/" rel="external nofollow noopener noreferrer" target="_blank">HTTP/2 Module in NGINX</a></em></strong></td>
</tr>
<tr>
<td>–with-http_realip_module</td>
<td>修改客户端地址为在指定 header 域中的发送地址. 参考配置: <strong><em><a href="https://nginx.org/en/docs/http/ngx_http_realip_module.html?_ga=2.114613063.1190757652.1493193149-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">ngx_http_realip_module</a></em></strong></td>
</tr>
<tr>
<td>–with-http_addition_module</td>
<td>在响应的前后添加文本. 配置参考: <strong><em><a href="https://nginx.org/en/docs/http/ngx_http_addition_module.html?_ga=2.114613063.1190757652.1493193149-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">ngx_http_addition_module</a></em></strong></td>
</tr>
<tr>
<td>–with-http_xslt_module 或 –with-http_xslt_module=dynamic</td>
<td>使用一种或多种 XSLT 样式表来转换 XML 响应. 该模块需要 <a href="http://xmlsoft.org/" rel="external nofollow noopener noreferrer" target="_blank">Libxml2</a> 和 <a href="http://xmlsoft.org/XSLT/" rel="external nofollow noopener noreferrer" target="_blank">XSLT</a> 库. 配置参考: <strong><em><a href="https://nginx.org/en/docs/http/ngx_http_xslt_module.html?_ga=2.107494082.1190757652.1493193149-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">ngx_http_xslt_module</a></em></strong></td>
</tr>
<tr>
<td>–with-http_image_filter_module 或 –with-http_image_filter_module=dynamic</td>
<td>将图片在 JPEG、GIF 和 PNG 中转换格式. 该模块需要 LibGD 库. 配置参考: <strong><em><a href="https://nginx.org/en/docs/http/ngx_http_image_filter_module.html?_ga=2.107494082.1190757652.1493193149-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">ngx_http_image_filter_module</a></em></strong></td>
</tr>
<tr>
<td>–with-http_geoip_module 或 –with-http_geoip_module=dynamic</td>
<td>允许创建依赖客户端 IP 地址值的变量. 该模块使用了 <a href="http://www.maxmind.com/" rel="external nofollow noopener noreferrer" target="_blank">MaxMind</a> GeoIP 数据库. 配置参考: <strong><em><a href="https://nginx.org/en/docs/http/ngx_http_geoip_module.html?_ga=2.114618951.1190757652.1493193149-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">ngx_http_geoip_module</a></em></strong></td>
</tr>
<tr>
<td>–with-http_sub_module</td>
<td>通过使用其他的字符串替换指定字符串修改响应. 配置参考: <strong><em><a href="https://nginx.org/en/docs/http/ngx_http_sub_module.html?_ga=2.114618951.1190757652.1493193149-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">ngx_http_sub_module</a></em></strong></td>
</tr>
<tr>
<td>–with-http_dav_module</td>
<td>用于通过 WebDAV 协议的文件管理自动化. 配置参考: <strong><em><a href="https://nginx.org/en/docs/http/ngx_http_dav_module.html?_ga=2.114618951.1190757652.1493193149-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">ngx_http_dav_module</a></em></strong></td>
</tr>
<tr>
<td>–with-http_flv_module</td>
<td>为 Flash Video (FLV) 文件提供伪流服务器端支持. 配置参考: ngx <strong><em><a href="https://nginx.org/en/docs/http/ngx_http_flv_module.html?_ga=2.114618951.1190757652.1493193149-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">http_flv_module</a></em></strong></td>
</tr>
<tr>
<td>–with-mp4_module</td>
<td>为 MP4 文件提供伪流服务器端支持. 配置参考: <strong><em><a href="https://nginx.org/en/docs/http/ngx_http_mp4_module.html?_ga=2.114618951.1190757652.1493193149-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">ngx_http_mp4_module</a></em></strong></td>
</tr>
<tr>
<td>–with-http_gunzip_module</td>
<td>使用 Content-Encoding 解压响应: gzip 用于不支持 zip 编码方法的客户端. 配置参考: <strong><em><a href="https://nginx.org/en/docs/http/ngx_http_gunzip_module.html?_ga=2.177683941.1190757652.1493193149-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">ngx_http_gunzip_module</a></em></strong></td>
</tr>
<tr>
<td>–with-http_gzip_static_module</td>
<td>允许发送使用 <code>*.gz</code> 文件扩展名而不是常规的预压缩文件. 配置参考: <strong><em><a href="https://nginx.org/en/docs/http/ngx_http_gzip_static_module.html?_ga=2.177683941.1190757652.1493193149-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">ngx_http_gzip_static_module</a></em></strong></td>
</tr>
<tr>
<td>–with-http_auth_request_module</td>
<td>基于子请求实施客户端授权. 配置参考: <strong><em><a href="https://nginx.org/en/docs/http/ngx_http_auth_request_module.html?_ga=2.177683941.1190757652.1493193149-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">http_auth_request_module</a></em></strong></td>
</tr>
<tr>
<td>–with-http_random_index_module</td>
<td>处理使用斜杠 (/) 结尾的请求, 并且从一个目录取出一个随机文件来作为首页. 配置参考: <strong><em><a href="https://nginx.org/en/docs/http/ngx_http_random_index_module.html?_ga=2.177683941.1190757652.1493193149-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">ngx_http_random_index_module</a></em></strong></td>
</tr>
<tr>
<td>–with-http_secure_link_module</td>
<td>用于插件被请求链接的授权, 保护资源不被未授权访问或者限制链接的生命周期. 配置参考: <strong><em><a href="https://nginx.org/en/docs/http/ngx_http_secure_link_module.html?_ga=2.177683941.1190757652.1493193149-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">ngx_http_secure_link_module</a></em></strong></td>
</tr>
<tr>
<td>–with-http_slice_module</td>
<td>允许将请求分隔为子请求, 每个请求返回确定的响应范围. 提供更多大型文件的有效缓存. 查看 ngx_http_slice_module 相关的指令列表. 配置参考: <strong><em><a href="https://nginx.org/en/docs/http/ngx_http_slice_module.html?_ga=2.177683941.1190757652.1493193149-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">ngx_http_slice_module</a></em></strong></td>
</tr>
<tr>
<td>–with-http_degradation_module</td>
<td>当内存超出默认值的时候, 允许返回错误信息</td>
</tr>
<tr>
<td>–with-http_stub_status_module</td>
<td>提供访问基本状态信息. 配置参考: <strong><em><a href="https://nginx.org/en/docs/http/ngx_http_stub_status_module.html?_ga=2.207099347.1190757652.1493193149-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">ngx_http_stub__status_module</a></em></strong>. 注意 NGINX Plus 用户不需要这个模块, 因为已经为他们提供了扩展状态的面板.</td>
</tr>
<tr>
<td>–with-http_perl_module 或 –with-http_perl_module=dynamic</td>
<td>用于在 Perl 中实现位置和变量句柄, 并且将 Perl 调用插入到 SSI 中. 需要 <a href="https://www.perl.org/get.html" rel="external nofollow noopener noreferrer" target="_blank">PERL</a> 库. 配置参考: <strong><em><a href="https://nginx.org/en/docs/http/ngx_http_perl_module.html?_ga=2.207099347.1190757652.1493193149-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">ngx_http_perl_module</a></em></strong> . 该模块也可以被动态编译.</td>
</tr>
<tr>
<td>–with-mail 或 –with-mail=dynamic</td>
<td>启用邮件代理功能. 配置参考: <strong><em><a href="https://nginx.org/en/docs/mail/ngx_mail_core_module.html?_ga=2.207099347.1190757652.1493193149-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">ngx_mail_core_module</a></em></strong> . 该模块也可以被动态编译.</td>
</tr>
<tr>
<td>–with-mail_ssl_module</td>
<td>为使用 SSL/TLS 协议工作的邮件代理服务器提供支持. 需要想 <a href="https://www.openssl.org/" rel="external nofollow noopener noreferrer" target="_blank">OpenSSL</a> 这样的 SSL 库. 配置参考: <strong><em><a href="https://nginx.org/en/docs/mail/ngx_mail_ssl_module.html?_ga=2.174071266.1190757652.1493193149-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">ngx_mail_ssl_module</a></em></strong></td>
</tr>
<tr>
<td>–with-stream 或 –with-stream=dynamic</td>
<td>开启 TCP 代理功能. 配置参考: <strong><em><a href="https://nginx.org/en/docs/stream/ngx_stream_core_module.html?_ga=2.174071266.1190757652.1493193149-708921149.1492677721" rel="external nofollow noopener noreferrer" target="_blank">ngx_stream_code_module</a> </em></strong>. 该模块可以被动态编译.</td>
</tr>
<tr>
<td>–with-google_perftools_module</td>
<td>允许使用 Google Performance 工具库.</td>
</tr>
<tr>
<td>–with-cpp_test_module 或 –with-debug</td>
<td>开启<strong><em><a href="https://www.nginx.com/resources/admin-guide/debugging-nginx" rel="external nofollow noopener noreferrer" target="_blank">调试日志</a></em></strong>.</td>
</tr>
</tbody>
</table>
<h4 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h4><p>你可以使用你自己的模块或者第三方模块扩展 NGINX 的功能通过编译 NGINX 源码. 一些第三方模块被列举在 <a href="https://nginx.com/resources/wiki/modules/" rel="external nofollow noopener noreferrer" target="_blank">https://nginx.com/resources/wiki/modules/</a> 页面中. 使用第三方模块的你将要承担稳定性无法保证的风险. </p>
<p><strong>静态链接模块</strong><br>被构建在 NGINX 源码中的大多数模块是被静态链接的: 他们在编译的时候被构建在 NGINX 源码中, 然后被静态的了链接到 NGINX 二进制文件中. 这些模块只能在 NGINX 重新编译之后才能禁用.<br>要使用静态链接的第三方模块去编译 NGINX 源码, 在配置脚本中要指定 <code>–add-module=option</code> 并且输入模块的路径:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">  ./configure ... --add-module=/usr/build/nginx-rtmp-module</span></span><br></pre></td></tr></table></figure></p>
<p><strong>动态链接模块</strong><br>NGINX 模块也可以被编译为一个共享对象（<em>.so 文件）, 然后在运行时动态的加载到 NGINX 中. 这样提供了更多的灵活性, 作为模块可以在任何时候被加载或反加载通过在 NGINX 配置文件中使用 **</em><a href="https://nginx.org/en/docs/ngx_core_module.html?&amp;_ga=2.111565380.1190757652.1493193149-708921149.1492677721#load_module" rel="external nofollow noopener noreferrer" target="_blank">load_module</a>*** 指令指定. 注意: 这种模块必须支持动态链接.<br>要使用动态加载第三方模块编译 NGINX 源码, 在配置脚本中要指定 <code>–add-dynamic-module=</code>配置选项和模块的路径.<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">  ./configure ... --add-dynamic-module=/path/to/module</span></span><br></pre></td></tr></table></figure></p>
<p>动态模块的结果文件 .so 在编译结束后在 <code>prefix/modules/</code> 目录中被找到, prefix 是保存服务器文件的目录, 如: <code>/usr/local/nginx/modules</code>. 要想加载动态模块, 在 NGINX 安装完成后使用 <strong><em><a href="https://nginx.org/en/docs/ngx_core_module.html?&amp;_ga=2.136254193.1190757652.1493193149-708921149.1492677721#load_module" rel="external nofollow noopener noreferrer" target="_blank">local_module</a></em></strong> 指令.<br>查看 <strong><em><a href="https://www.nginx.com/blog/dynamic-modules-nginx-1-9-11/" rel="external nofollow noopener noreferrer" target="_blank">Introducing Dynamic Modules in NGINX 1.9.11</a></em></strong> 和 <strong><em><a href="https://www.nginx.com/resources/wiki/extending/" rel="external nofollow noopener noreferrer" target="_blank">Extending NGINX</a> </em></strong>来了解更多内容. </p>
<h3 id="完成安装"><a href="#完成安装" class="headerlink" title="完成安装"></a>完成安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/usr/local/nginx --with-pcre=../pcre-8.40 --with-zlib=../zlib-1.2.11 --with-http_stub_status_module --with-http_ssl_module</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>到此NGINX已经安装完成, 但是, 此时直接敲<code>nginx</code>可能会显示没有找到命令, 因为<strong>还没有配置环境变量</strong>:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch /etc/profile.d/nginx.sh</span><br><span class="line">echo "PATH=$PATH:/usr/local/nginx/sbin" &gt;&gt; /etc/profile.d/nginx.sh</span><br><span class="line">echo "export PATH" &gt;&gt; /etc/profile.d/nginx.sh</span><br><span class="line">source /etc/profile.d/nginx.sh</span><br></pre></td></tr></table></figure></p>
<p>完成！查看NGINX:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx -v</span><br></pre></td></tr></table></figure></p>
<h2 id="预编译包安装"><a href="#预编译包安装" class="headerlink" title="预编译包安装"></a>预编译包安装</h2><blockquote>
<p>博主用的就是这种方式, <strong>简单粗暴</strong>！当然上面的方式也是过, 但毕竟只是个业余的, 手动一个个模块配置上去的话, 小白表示搞不定. </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install curl gnupg2 ca-certificates lsb-release</span><br><span class="line">echo &quot;deb http://nginx.org/packages/ubuntu `lsb_release -cs` nginx&quot; | sudo tee /etc/apt/sources.list.d/nginx.list</span><br><span class="line">curl -fsSL https://nginx.org/keys/nginx_signing.key | sudo apt-key add -</span><br><span class="line">sudo apt update &amp;&amp; sudo apt install -y nginx openssl</span><br></pre></td></tr></table></figure>
<p>查看版本:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx -V</span><br></pre></td></tr></table></figure>
<p>启动:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable nginx</span><br><span class="line">sudo systemctl start nginx</span><br><span class="line"></span><br><span class="line"># sudo systemctl stop | start | restart | reload | disable | enable nginx</span><br></pre></td></tr></table></figure>
<h1 id="NGINX初学"><a href="#NGINX初学" class="headerlink" title="NGINX初学"></a>NGINX初学</h1><h2 id="校验-启动-停止和重新加载配置"><a href="#校验-启动-停止和重新加载配置" class="headerlink" title="校验, 启动, 停止和重新加载配置"></a>校验, 启动, 停止和重新加载配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 校验</span></span><br><span class="line">nginx -t </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止、退出、重新加载配置、重启</span></span><br><span class="line">nginx -s stop|quit|reload|reopen</span><br></pre></td></tr></table></figure>
<p>也可以是这样:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kill -s QUIT 1888 #1888是nginx的PID</span><br></pre></td></tr></table></figure></p>
<p>要获取全部正在运行中的 nginx 进程列表, 可以使用 ps 工具, 就像下面这样:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ax | grep nginx</span><br></pre></td></tr></table></figure></p>
<p>如果要了解更多的有关信号发送的信息, 请查看<strong><em><a href="http://nginx.org/en/docs/control.html" rel="external nofollow noopener noreferrer" target="_blank">控制nginx</a></em></strong>. </p>
<h2 id="配置文件的结构"><a href="#配置文件的结构" class="headerlink" title="配置文件的结构"></a>配置文件的结构</h2><p>nginx 由被配置文件指定的指令控制的模块组成. 指令被分为简单指令和块指令. 简单指令有名称和参数组成, 通过空格来分隔开, 以 <code>;</code> 号来结束. 块指令拥有和简单指令一样的结构, 但是不用 <code>;</code> 结束而是使用一组被 <code>{}</code> 环绕的额外指令. 如果一个块指令在其内部包含了其他指令, 则被称为上下文（context）, 比如: <strong><em><a href="http://nginx.org/en/docs/ngx_core_module.html#events" rel="external nofollow noopener noreferrer" target="_blank">events</a></em></strong>,<strong><em><a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#http" rel="external nofollow noopener noreferrer" target="_blank">http</a></em></strong>,<strong><em><a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#server" rel="external nofollow noopener noreferrer" target="_blank">server</a></em></strong> 和<strong><em><a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#location" rel="external nofollow noopener noreferrer" target="_blank">location</a></em></strong>. </p>
<p>被放置在配置文件中却不在任何上下文中的指令被认为是在主上下文之内的. <code>events</code> 和 <code>http</code> 指令就属于主上下文, <code>server</code> 在 <code>http</code> 之内, <code>location</code> 在 <code>server</code> 之内. </p>
<p>单行之中在 <code>#</code> 号之后的剩余内容被认为是注释. </p>
<h2 id="静态内容服务"><a href="#静态内容服务" class="headerlink" title="静态内容服务"></a>静态内容服务</h2><p>一个重要的 web 服务器任务就是提供文件（比如图片或者静态 HTML 页面）. 你将会实现一个例子, 依赖于 request 请求, 文件将被从不同的本地目录（/data/www 和 /data/images）中提供. 这需要编辑配置文件并在 <code>http</code> 块之内使用两个 <code>location</code> 块来设置一个 <code>server</code> 块. </p>
<p>首先, 创建 <code>/data/www</code> 目录并且将一个名为 <code>index.html</code> 文件放进去, 然后在创建一个 <code>/data/images</code> 目录并放置一些图片在里面. </p>
<p>接下来, 打开配置文件. 默认的配置文件已经包含了一些 <code>server</code> 块的例子, 通常都被注释掉了. 那么现在, 注释掉全部块并且编写一个新的 <code>server</code>块吧: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常地, 配置文件可能包含了一些 <code>server</code> 块, 通过<strong><em><a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#listen" rel="external nofollow noopener noreferrer" target="_blank">监听</a></em></strong>端口和<strong><em><a href="http://nginx.org/en/docs/http/server_names.html" rel="external nofollow noopener noreferrer" target="_blank">服务器名字</a></em></strong>来<strong><em><a href="http://nginx.org/en/docs/http/request_processing.html" rel="external nofollow noopener noreferrer" target="_blank">区分</a></em></strong>. 一旦 nginx 决定哪个服务处理请求, 将会试着添加以下 <code>location</code> 块到 <code>server</code> 块中: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root /data/www;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 <code>location</code> 块说明了 <code>/</code> 前缀和请求中的 URI 进行比较. 对于匹配的请求, URI 将会被添加到被 <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#root" rel="external nofollow noopener noreferrer" target="_blank">root</a> 指令说明的路径中去, 就是到 <code>/data/www</code> 中, 形成一个在本地文件系统中的请求文件路径. 如果有多个匹配了 <code>location</code> 的块, nginx 会<strong>选择前缀最长的那个</strong>. 上面的那个 <code>location</code> 块是最短的前缀, 长度只有 1, 所以只有其他 <code>location</code> 块匹配都失败了, 这个块才会被使用. </p>
<p>接下来, 添加第二个 <code>location</code> 块: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location /images/ &#123;</span><br><span class="line">    root /data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这将匹配以 <code>/images/</code> 开始的请求（location / 也会匹配这个请求, 但他的前缀最短）. </p>
<p>最终 <code>server</code> 块的配置看起来是像下面这样的: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root /data/www ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /iamges/ &#123;</span><br><span class="line">        root /data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置一个监听标准 80 端口并且可在本机访问的服务器的工作就是这样了. 在响应使用以 <code>/images/</code> 为开头的 URI 的请求中, 服务器会从 <code>/data/images</code> 目录中中发送文件. 例如, 在响应 <code>http://localhost/images/example.png</code> 的请求中, nginx 会发送 <code>/data/images/exmaple.png</code> 文件. 如果这个文件不存在, nginx 会发送一个  404 错误的响应. URI 不以 <code>/images/</code> 开头的请求将被映射到 <code>/data/www</code> 目录中. 例如, 在响应 <code>http://localhost/some/example.html</code> 的请求中, nginx 将发送 <code>/data/www/some/example.html</code> 文件. </p>
<p>要想应用新的配置, 请启动 nginx（如果还没启动的话）或者发送 <code>reload</code> 信号到 nginx 主进程, 通过执行如下命令: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>
<blockquote>
<p>本例中, 有些不会像期望中的那样工作, 你可以在 <code>access.log</code> 和 <code>error.log</code> 文件中尝试找到原因, 这些文件的位置在 <code>/usr/local/nginx/logs</code> 或 <code>/var/log/nginx</code> 中. </p>
</blockquote>
<h2 id="设置一个简单的代理服务器"><a href="#设置一个简单的代理服务器" class="headerlink" title="设置一个简单的代理服务器"></a>设置一个简单的代理服务器</h2><p>nginx 的一个频繁的用法是被设置作为代理服务器, 这意味着接收请求的服务器, 通过他们到被代理的服务器, 再通过他们取回相应, 并且通过他们发送给客户端. </p>
<p>下面我们来配置一个基本的代理服务器, 来为本地图片请求提供服务并将其他请求转到被代理的服务器上. 本例中, 两个服务器将被定义在一个 nginx 实例中. </p>
<p>首先, 通过增加一个 <code>server</code> 块到 nginx 配置文件的方式定义被代理的服务, 配置内容如下: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line">    root /data/up1;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个监听 8080 端口并且映射全部请求到本地 <code>/data/up1</code> 目录的简单服务器. 创建这个目录并放一个 <code>index.html</code> 在里面. 注意, <code>root</code> 指令被放置在 <code>server</code> 上下文中, 这样的 <code>root</code> 指令被用在当 <code>location</code> 块被选中提供服务的时候. </p>
<p>接下来, 使用上一节的服务器配置并修改为一个代理服务器的配置. 在第一 <code>location</code> 块中, 放入使用由协议, 名字以及被代理服务器的端口描述的参数的 <code>proxy_pass</code> 指令（在我们的例子中, 就是 <a href="http://localhost:8080）" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8080）</a>: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    localtion / &#123;</span><br><span class="line">        proxy_pass http://localhost:8080;</span><br><span class="line">    &#125;</span><br><span class="line">    localtion /images/ &#123;</span><br><span class="line">        root /data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将修改第二个 <code>location</code> 块, 它当前使用 <code>/images/</code> 前缀来映射请求到 <code>/data/images/</code> 下的文件, 我们现在想要让他匹配一些典型的图片类型扩展名的请求. 修改后的 <code>localtion</code> 块看起来像这样的: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">localtion ~ \.(gif|jpg|png)$ &#123;</span><br><span class="line">    root /data/images;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数是匹配了全部以 <code>.gif</code> <code>.jpg</code> <code>.png</code> 结尾的 URI 的正则表达式. 一个正则表达式应被 <code>~</code> 开始. 这样, 相关的请求就会被映射到 <code>/data/images/</code> 目录中了. </p>
<p>当 nginx 选取一个 <code>localtion</code> 块来为请求提供服务的时候, 首先要检查 <code>location</code> 指令说明的前缀, <strong>记住最长前缀</strong>的 <code>location</code>, <strong>然后再检查正则表达式</strong>. 如果匹配了一个正则表达式, nginx 挑出这个 <code>localtion</code>, 否则, 它就会挑选之前被记录的. </p>
<p>代理服务器的配置结果看起来将会是下面这样: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://localhost:8080/;</span><br><span class="line">    &#125;</span><br><span class="line">    localtion ~ \.(gif|jpg|png)$ &#123;</span><br><span class="line">        root /data/images;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个服务器将过滤以 <code>.gif</code> <code>.jpg</code> <code>.png</code> 结尾的请求, 并映射他们到 <code>/data/images</code> 目录（通过添加 URI 到 <code>root</code> 指令的参数）, 还会传递其他请求到被之前配置的被代理服务器上. </p>
<p>要应用新配置, 要像前面章节提到的发送 <code>reload</code> 信号给 nginx. </p>
<p>这里有<strong><em><a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html" rel="external nofollow noopener noreferrer" target="_blank">更多</a></em></strong>的可能更加有用的配置代理连接的指令. </p>
<h2 id="快速查看配置文件的方法"><a href="#快速查看配置文件的方法" class="headerlink" title="快速查看配置文件的方法"></a>快速查看配置文件的方法</h2><p>nginx的配置放在nginx.conf文件中, 一般我们可以使用以下命令查看服务器中存在的nginx.conf文件. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">locate nginx.conf</span><br><span class="line">/usr/local/etc/nginx/nginx.conf</span><br><span class="line">/usr/local/etc/nginx/nginx.conf.default</span><br><span class="line">...1234</span><br></pre></td></tr></table></figure>
<p>如果服务器中存在多个nginx.conf文件, 我们并不知道实际上调用的是哪个配置文件, 因此我们<strong>必须找到实际调用的配置文件</strong>才能进行修改. </p>
<h2 id="查看NGINX实际调用的配置文件"><a href="#查看NGINX实际调用的配置文件" class="headerlink" title="查看NGINX实际调用的配置文件"></a>查看NGINX实际调用的配置文件</h2><h3 id="1-查看NGINX路径"><a href="#1-查看NGINX路径" class="headerlink" title="1.查看NGINX路径"></a>1.查看NGINX路径</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps aux|grep nginx</span><br><span class="line">root              352   0.0  0.0  2468624    924   ??  S    10:43上午   0:00.08 nginx: worker process  </span><br><span class="line">root              232   0.0  0.0  2459408    532   ??  S    10:43上午   0:00.02 nginx: master process /usr/local/opt/nginx/bin/nginx -g daemon off;  </span><br><span class="line">root             2345   0.0  0.0  2432772    640 s000  S+    1:01下午   0:00.00 grep nginx1234</span><br></pre></td></tr></table></figure>
<p>NGINX的路径为: <code>/usr/local/opt/nginx/bin/nginx</code> </p>
<h3 id="2-查看NGINX配置文件路径"><a href="#2-查看NGINX配置文件路径" class="headerlink" title="2.查看NGINX配置文件路径"></a>2.查看NGINX配置文件路径</h3><p>使用NGINX的 <code>-t</code> 参数进行配置检查, 即可知道实际调用的配置文件路径及是否调用有效. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/usr/local/opt/nginx/bin/nginx -t</span><br><span class="line">nginx: the configuration file /usr/local/etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /usr/local/etc/nginx/nginx.conf test is successful123</span><br></pre></td></tr></table></figure>
<p>测试可知, NGINX的配置文件路径为: <code>/usr/local/etc/nginx/nginx.conf</code> 且调用有效. </p>
<h2 id="拒绝或允许指定IP"><a href="#拒绝或允许指定IP" class="headerlink" title="拒绝或允许指定IP"></a>拒绝或允许指定IP</h2><p>NGINX拒绝或允许指定IP,是使用模块HTTP访问控制模块（HTTP Access）.<br>控制规则按照声明的顺序进行检查, 首条匹配IP的访问规则将被启用.<br>如下例: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  deny    192.168.1.1;</span><br><span class="line">  allow   192.168.1.0/24;</span><br><span class="line">  allow   10.1.1.0/16;</span><br><span class="line">  deny    all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子中仅允许192.168.1.0/24和10.1.1.0/16网络段访问这个<code>location</code>字段, 但192.168.1.1是个例外.<br>注意规则的匹配顺序, 如果你使用过Apache你可能会认为你可以随意控制规则的顺序并且他们能够正常的工作, 但实际上不行, 下面的这个例子将拒绝掉所有的连接: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  #这里将永远输出403错误. </span><br><span class="line">  deny all;</span><br><span class="line">  #这些指令不会被启用, 因为到达的连接在第一条已经被拒绝</span><br><span class="line">  deny    192.168.1.1;</span><br><span class="line">  allow   192.168.1.0/24;</span><br><span class="line">  allow   10.1.1.0/1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><blockquote>
<p>参考:<br><strong><em><a href="https://www.nginx.com/resources/admin-guide/installing-nginx-open-source/" rel="external nofollow noopener noreferrer" target="_blank">Installing NGINX Open Source</a></em></strong><br><strong><em><a href="https://www.crazy-code.tech/index.php/2016/11/11/nginx-beginner-guide/" rel="external nofollow noopener noreferrer" target="_blank">Nginx 初学者指南</a></em></strong><br><strong><em><a href="https://mp.weixin.qq.com/s/OrpOil-AKjdf8tDfDdc-RA" rel="external nofollow noopener noreferrer" target="_blank">超实用的 Nginx 极简教程，覆盖了常用场景</a></em></strong></p>
</blockquote>
<p>顺便写了个安装脚本:<br><strong><em><a href="https://github.com/masteranthoneyd/about-shell/blob/master/nginx-by-source.sh" rel="external nofollow noopener noreferrer" target="_blank">源码版</a></em></strong><br><strong><em><a href="https://github.com/masteranthoneyd/about-shell/blob/master/nginx-by-pre-built-package.sh" rel="external nofollow noopener noreferrer" target="_blank">预编译版</a></em></strong></p>
]]></content><categories><category>Nginx</category></categories><tags><tag>VPS</tag><tag>Nginx</tag></tags></entry><entry><title>Git学习笔记</title><url>/2017/note-of-learning-git/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/git/git-operations.png" alt></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>What is Git?<br>Git是目前世界上最先进的分布式版本控制系统（没有之一）, 而且是一款免费、开源的分布式版本控制系统, 用于敏捷高效地处理任何或小或大的项目<br>一直以来, 博主开发项目用的版本管理系用都是SVN<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="集中式版本管理系统之一
">[1]</span></a></sup>, 其实早就听闻过Git, 一直没用过, 后来接触Github和Hexo博客框架, 才真正意义上开始接触Git, 感受就是高端大气上档次！</p>
<a id="more"></a>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Git是Linux系统的开发者Linus在2005年的时候, BitKeeper<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="一个商业的版本控制系统">[2]</span></a></sup>的东家BitMover公司回收了Linux社区的免费使用权的情况下, 在仅仅的两周内Linus用C写出了一个分布式版本控制系统, 这就是Git（超级牛X）！从此, Linux系统的源码已经由Git管理了. 逐渐地, Git迅速成为最流行的分布式版本控制系统, 尤其是在Github上线之后, 无数开源项目开始迁移至GitHub, 包括jQuery, PHP, Ruby等等</p>
<h1 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h1><p>在<strong>Debian</strong>或者<strong>Ubuntu Linux</strong>下的Git安装非常简单, 直接一条命令搞定<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure></p>
<p><strong>Windows</strong>下的模拟环境安装起来比较复杂, 那么可以用牛人封装好的模拟环境加Git, 叫<strong>msysgit</strong>, 只需要下载一个exe然后双击安装<br>可从<em><a href="https://git-for-windows.github.io/" rel="external nofollow noopener noreferrer" target="_blank">https://git-for-windows.github.io/</a></em> 下载, 或者从<em><a href="https://pan.baidu.com/s/1kU5OCOB#list/path=%2Fpub%2Fgit" rel="external nofollow noopener noreferrer" target="_blank">廖雪峰老师的镜像</a></em> 下载, 然后按默认选项安装<br>安装完成后, 在开始菜单里找到“Git”-&gt;“Git Bash”, 蹦出一个类似命令行窗口的东西, 就说明Git安装成功</p>
<p>成功安装之后, 还需要配置一下全局个人信息:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure></p>
<p>每次提交, 都会记录这两个值, <code>--global</code> 参数, 表示你这台机器上所有的Git仓库都会使用这个配置<br>可使用 <code>git config -l</code> 查看全局配置信息</p>
<h1 id="运行前配置"><a href="#运行前配置" class="headerlink" title="运行前配置"></a>运行前配置</h1><p>一般在新的系统上, 我们都需要先配置下自己的 Git 工作环境. 配置工作只需一次, 以后升级时还会沿用现在的配置. </p>
<h2 id="配置文件如何生效"><a href="#配置文件如何生效" class="headerlink" title="配置文件如何生效"></a>配置文件如何生效</h2><p>对于 Git 来说, 配置文件的权重是<strong>仓库&gt;全局&gt;系统</strong>. Git 会使用这一系列的配置文件来存储你定义的偏好, 它首先会查找 <code>/etc/gitconfig</code> 文件（系统级）, 该文件含有对系统上所有用户及他们所拥有的仓库都生效的配置值. 接下来 Git 会查找每个用户的 <code>~/.gitconfig</code> 文件（全局级）. 最后 Git 会查找由用户定义的各个库中Git目录下的配置文件 <code>.git/config</code>（仓库级）, 该文件中的值只对当前所属仓库有效. 以上阐述的三 层配置从一般到特殊层层推进, 如果定义的值有冲突, 以后面层中定义的为准, 例如: <code>.git/config</code> 和 <code>/etc/gitconfig</code> 的较量中, <code>.git/config</code> 取得了胜利. </p>
<h2 id="查看配置"><a href="#查看配置" class="headerlink" title="查看配置"></a>查看配置</h2><p>格式: <code>git config [--local|--global|--system] -l</code></p>
<p>example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看当前生效的配置</span><br><span class="line">git config -l</span><br><span class="line"></span><br><span class="line"># 查看仓库级的配置</span><br><span class="line">git config --local -l</span><br><span class="line"></span><br><span class="line"># 查看全局级的配置</span><br><span class="line">git config --global -l</span><br><span class="line"></span><br><span class="line"># 查看系统级的配置</span><br><span class="line">git config --system -l</span><br></pre></td></tr></table></figure>
<h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>格式: <code>git config [--local|--global|--system] key value</code></p>
<p>example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name ybd</span><br><span class="line">git config --global user.email yangbingdong1994@gmail.com</span><br></pre></td></tr></table></figure>
<h1 id="创建仓库（Repository）"><a href="#创建仓库（Repository）" class="headerlink" title="创建仓库（Repository）"></a>创建仓库（Repository）</h1><p>创建一个目录并进入, 进行初始化仓库<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir repo</span><br><span class="line">cd repo</span><br><span class="line">git init</span><br></pre></td></tr></table></figure></p>
<p>目录下会多一个 <code>.git</code> 的隐藏文件, 现在要创建一个文件并提交到仓库<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch read</span><br><span class="line">vi read</span><br><span class="line"> # 按a进入编辑</span><br><span class="line"> # 输入Git is a distributed version control system</span><br><span class="line"> # 按下Esc, 并输入 &quot;:wq&quot; 保存退出</span><br><span class="line">git add README.md  #添加文件到缓存区</span><br><span class="line">git commit -m &quot;first commit&quot;  #将缓存区的文件提交到本地仓库</span><br></pre></td></tr></table></figure></p>
<p>多个文件提交可用 <code>git add -A</code> 然后再 commit<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  repo git:(master) ✗ git commit -m &quot;first commit&quot;</span><br><span class="line">[master （根提交） 20717f5] first commit</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 read</span><br></pre></td></tr></table></figure></p>
<h1 id="操作的自由穿越"><a href="#操作的自由穿越" class="headerlink" title="操作的自由穿越"></a>操作的自由穿越</h1><p>要随时掌握工作区的状态: <code>git status</code><br>查看修改内容: <code>git diff read</code><br>查看版本历史信息 <code>got log</code> 或 <code>git log --pretty=oneline</code></p>
<h2 id="版本穿越"><a href="#版本穿越" class="headerlink" title="版本穿越"></a>版本穿越</h2><p>退到上一个版本:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure></p>
<p>上上一个版本就是 <code>HEAD^^</code>, 当然往上100个版本写100个^比较容易数不过来, 所以写成 <code>HEAD~100</code><br>要重返未来, 查看命令历史: <code>git reflog</code></p>
<h2 id="修改管理"><a href="#修改管理" class="headerlink" title="修改管理"></a>修改管理</h2><p>添加文件到缓存区: <code>git add read</code> 或 <code>git add -A</code><br>然后提交: <code>git commit -m &quot;msg&quot;</code><br>查看状态: <code>git status</code><br><strong>每次修改, 如果不add到暂存区, 那就不会加入到commit中</strong></p>
<h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p>当你发现工作区的修改有错误的时候, 可丢弃工作区的修改:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -- read</span><br></pre></td></tr></table></figure></p>
<p>命令 <code>git checkout -- read</code> 意思就是, 把 <code>read</code> 文件在工作区的修改全部撤销, 这里有两种情况: </p>
<p>一种是 <code>read</code> 自修改后还没有被放到暂存区, 现在, 撤销修改就回到和版本库一模一样的状态</p>
<p>一种是 <code>read</code> 已经添加到暂存区后, 又作了修改, 现在, 撤销修改就回到添加到暂存区后的状态</p>
<p><strong>总之, 就是让这个文件回到最近一次 <code>git commit</code> 或 <code>git add</code> 时的状态</strong><br><strong>注意！ <code>git checkout -- file</code> 命令中的 <code>--</code> 很重要, 没有 <code>--</code> 就变成了切换分支了</strong></p>
<p>当你发现该文件修改错误并且已经提交到了缓存区, 这个时候可以把暂存区的修改撤销掉（unstage）, 重新放回工作区:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset HEAD read</span><br></pre></td></tr></table></figure></p>
<p>然后再丢弃工作区中的修改:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -- read</span><br></pre></td></tr></table></figure></p>
<p><code>git reset</code>命令既可以回退版本, 也可以把暂存区的修改回退到工作区. 当我们用HEAD时, 表示最新的版本</p>
<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>如果把工作区中的文件删除了, 那么工作区和版本库就不一致, <code>git status</code> 命令会立刻告诉你哪些文件被删除了<br>现在有两个选择</p>
<ul>
<li><p>一是确实要从版本库中删除该文件, 那就用命令删掉, 并且提交: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rm read</span><br><span class="line">git commit -m &quot;delete&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>另一种情况是删错了, 因为版本库里还有呢, 所以可以很轻松地把误删的文件恢复到最新版本: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -- read</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>git checkout</code> 其实是用版本库里的版本替换工作区的版本, 无论工作区是修改还是删除, 都可以“一键还原”</p>
<h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><p>那么学会了Git的基本操作之后, 对于分布式管理我们还需要有一个远程仓库供大家一起共同开发, 好在有一个全世界最大最神奇的同性交友网—— <em><a href="https://github.com/" rel="external nofollow noopener noreferrer" target="_blank">Github</a></em><br>那么在使用Github之前呢, 我们需要设置一下与Github的SSH通讯:<br>1. 创建SSH Key（已有.ssh目录的可以略过）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure></p>
<p>你需要把邮件地址换成你自己的邮件地址, 然后一路回车, 使用默认值即可, 由于这个Key也不是用于军事目的, 所以也无需设置密码<br>如果一切顺利的话, 可以在用户主目录里找到 <code>.ssh</code> 目录, 里面有 <code>id_rsa</code> 和 <code>id_rsa.pub</code> 两个文件, 这两个就是SSH Key的秘钥对, <code>id_rsa</code> 是私钥, 不能泄露出去, <code>id_rsa.pub</code> 是公钥, 可以放心地告诉任何人</p>
<p>2. 登陆GitHub, 打开“Account settings”, “SSH Keys”页面, 然后, 点“Add SSH Key”, 填上任意Title, 在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容, 最后点“Add Key”</p>
<h2 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h2><p>首先到Github创建一个仓库<br>然后与本地关联:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:your-name/repo-name.git</span><br></pre></td></tr></table></figure></p>
<p>远程库的名字就是<code>origin</code>, 这是Git默认的叫法, 也可以改成别的, 但是<code>origin</code>这个名字一看就知道是远程库</p>
<p>下一步, 就可以把本地库的所有内容推送到远程库上:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></p>
<p>把本地库的内容推送到远程, 用 <code>git push</code> 命令, 实际上是把当前分支 <code>master</code> 推送到远程<br>由于远程库是空的, 我们第一次推送 <code>master</code> 分支时, 加上了 <code>-u</code> 参数, Git不但会把本地的 <code>master</code> 分支内容推送的远程新的 <code>master</code> 分支, 还会把本地的 <code>master</code> 分支和远程的 <code>master</code> 分支关联起来, 在以后的推送或者拉取时就可以简化命令</p>
<p>此后的推送都可以使用:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure></p>
<h2 id="从远程仓库克隆"><a href="#从远程仓库克隆" class="headerlink" title="从远程仓库克隆"></a>从远程仓库克隆</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git git@github.com:your-name/repo-name.git</span><br></pre></td></tr></table></figure>
<h1 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h1><h2 id="查看tag"><a href="#查看tag" class="headerlink" title="查看tag"></a>查看tag</h2><p>列出所有tag:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure></p>
<p>这样列出的tag是按字母排序的, 和创建时间没关系. 如果只是想查看某些tag的话, 可以加限定:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag -l v1.*</span><br></pre></td></tr></table></figure></p>
<p>这样就只会列出1.几的版本. </p>
<h2 id="创建tag"><a href="#创建tag" class="headerlink" title="创建tag"></a>创建tag</h2><p>创建轻量级<code>tag</code>:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag 1.0.1</span><br></pre></td></tr></table></figure></p>
<p>这样创建的<code>tag</code>没有附带其他信息, 与之相应的是带信息的<code>tag</code>,<code>-m</code>后面带的就是注释信息, 这样在日后查看的时候会很有用, 这种是普通<code>tag</code>, 还有一种有签名的<code>tag</code>:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag -a 1.0.1 -m &apos;first version&apos;</span><br></pre></td></tr></table></figure></p>
<p>除了可以为当前的进度添加<code>tag</code>, 我们还可以为以前的<code>commit</code>添加<code>tag</code>:<br>首先查看以前的<code>commit</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --oneline</span><br></pre></td></tr></table></figure></p>
<p>假如有这样一个<code>commit</code>: 8a5cbc2 updated readme<br>这样为他添加<code>tag</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag -a v1.1 8a5cbc2</span><br></pre></td></tr></table></figure></p>
<h2 id="删除tag"><a href="#删除tag" class="headerlink" title="删除tag"></a>删除tag</h2><p>很简单, 知道<code>tag</code>名称后:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git tag -d v1.0</span><br></pre></td></tr></table></figure></p>
<p>删除远程分支:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin --delete tag &lt;tagname&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="共享tag"><a href="#共享tag" class="headerlink" title="共享tag"></a>共享tag</h2><p>我们在执行<code>git push</code>的时候, <code>tag</code>是不会上传到服务器的, 比如现在的<code>github</code>, 创建<code>tag</code>后<code>git push</code>, 在<code>github</code>网页上是看不到<code>tag</code>的, 为了共享这些<code>tag</code>, 你必须这样:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure></p>
<h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><p>分支相当与平行宇宙, 互不干扰, 哪天合并了就拥有了所有平行宇宙的特性<br><img src="https://cdn.yangbingdong.com/img/git/gitBranch.png" alt></p>
<h2 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h2><ul>
<li>每次提交, Git都把它们串成一条时间线, 这条时间线就是一个分支. 截止到目前, 只有一条时间线, 在Git里, 这个分支叫主分支, 即 <code>master</code> 分支</li>
<li>一开始的时候, <code>master</code> 分支是一条线, Git用 <code>master</code> 指向最新的提交, 再用 <code>HEAD</code> 指向 <code>master</code> , 就能确定当前分支, 以及当前分支的提交点</li>
<li>当我们创建新的分支, 例如 <code>dev</code> 时, Git新建了一个指针叫 <code>dev</code> , 指向 <code>master</code> 相同的提交, 再把 <code>HEAD</code> 指向 <code>dev</code> , 就表示当前分支在 <code>dev</code> 上</li>
<li>Git创建一个分支很快, 因为除了增加一个 <code>dev</code> 指针, 改改 <code>HEAD</code> 的指向, 工作区的文件都没有任何变化</li>
<li>当 <code>HEAD</code> 指向 <code>dev</code> , 对工作区的修改和提交就是针对 <code>dev</code> 分支了, 比如新提交一次后, <code>dev</code> 指针往前移动一步, 而 <code>master</code> 指针不变<br><img src="https://cdn.yangbingdong.com/img/git/gitBranch01.png" alt></li>
</ul>
<p>查看分支: <code>git branch</code><br>创建分支: <code>git branch &lt;name&gt;</code><br>切换分支: <code>git checkout &lt;name&gt;</code><br>创建+切换分支: <code>git checkout -b &lt;name&gt;</code><br>合并某分支到当前分支: <code>git merge &lt;name&gt;</code><br>删除分支: <code>git branch -d &lt;name&gt;</code></p>
<h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>合并分支并不是每次都不会出问题, 如不同的分支对同一个文件同一行都被修改过, 就会出现以下情况<br><img src="https://cdn.yangbingdong.com/img/git/gitConflict.png" alt><br>那么再次合并有可能会冲突<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  repo git:(master) git merge feature1 </span><br><span class="line">自动合并 read</span><br><span class="line">冲突（内容）: 合并冲突于 read</span><br><span class="line">自动合并失败, 修正冲突然后提交修正的结果. </span><br><span class="line">➜  repo git:(master) ✗ git status </span><br><span class="line">位于分支 master</span><br><span class="line">您有尚未合并的路径. </span><br><span class="line">  （解决冲突并运行 &quot;git commit&quot;）</span><br><span class="line"></span><br><span class="line">未合并的路径: </span><br><span class="line">  （使用 &quot;git add &lt;文件&gt;...&quot; 标记解决方案）</span><br><span class="line"></span><br><span class="line">	双方修改:   read</span><br><span class="line"></span><br><span class="line">修改尚未加入提交（使用 &quot;git add&quot; 和/或 &quot;git commit -a&quot;）</span><br></pre></td></tr></table></figure></p>
<p>这种情况必须手动解决然后再次 <code>git add .</code>, <code>git commit -m &quot;commit&quot;</code>, 打开文件可看到<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Git is a version control</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure></p>
<p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>, <code>=======</code>, <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容, 那么经过合意, 不好意思, 大师兄说了, 在座的各位都是垃圾, 于是改成<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Git,too fast too simple</span><br></pre></td></tr></table></figure></p>
<p>再提交<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  repo git:(master) ✗ git add read </span><br><span class="line">➜  repo git:(master) ✗ git commit -m &quot;conflict fixed&quot;</span><br><span class="line">[master 8933f88] conflict fixed</span><br><span class="line">➜  repo git:(master)</span><br></pre></td></tr></table></figure></p>
<p>ok了, 再次 <code>add</code> 和 <code>commit</code> , 现在 <code>master</code> 分支和<code>feature1</code>分支变成了这样<br><img src="https://cdn.yangbingdong.com/img/git/gitFixConflict.png" alt></p>
<h2 id="多PC协同开发"><a href="#多PC协同开发" class="headerlink" title="多PC协同开发"></a>多PC协同开发</h2><p>当你从远程仓库克隆时, 实际上Git自动把本地的 <code>master</code> 分支和远程的 <code>master</code> 分支对应起来了, 并且, 远程仓库的默认名称是 <code>origin</code> </p>
<p>查看远程库的信息:<br>查看简单信息: <code>git remote</code><br>查看详细信息: <code>git remote -v</code><br>查看远程仓库分支: <code>git branch -r</code><br>查看本地分支与远程分支的对应关系: <code>git branch -vv</code></p>
<p>推送分支<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin &lt;branch&gt; </span><br><span class="line"></span><br><span class="line">git push -u origin &lt;branch&gt; # 第一次推送加-u可以把当前分支与远程分支关联起来</span><br></pre></td></tr></table></figure></p>
<p>克隆分支并关联<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:youName/program.git # 默认克隆master分支到当前目录（包含分支文件目录）</span><br><span class="line"></span><br><span class="line">git clone -b &lt;branch&gt; git@github.com:youName/program.git ./</span><br><span class="line"># 克隆指定分支到指定文件目录下（不包含分支文件目录）</span><br></pre></td></tr></table></figure></p>
<p>创建远程 <code>origin</code> 的 <code>dev</code> 分支到本地<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b &lt;branch&gt; origin/&lt;branch&gt;</span><br></pre></td></tr></table></figure></p>
<p>关联本地分支与远程仓库分支<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch --set-upstream &lt;branch&gt; origin/&lt;branch&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="Commit-带上-emoji-表情"><a href="#Commit-带上-emoji-表情" class="headerlink" title="Commit 带上 emoji 表情"></a>Commit 带上 emoji 表情</h1><blockquote>
<p>执行 <code>git commit</code> 时使用 emoji 为本次提交打上一个 “标签”, 使得此次 commit 的主要工作得以凸现, 也能够使得其在整个提交历史中易于区分与查找.</p>
</blockquote>
<p><img src="https://cdn.yangbingdong.com/img/git/git-emoji.png" alt></p>
<p>只需要加上 emoji 标签即可:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">":tada: Initialize Repo"</span></span><br></pre></td></tr></table></figure>
<p>常用的标签:</p>
<table>
<thead>
<tr>
<th>emoji</th>
<th>emoji 代码</th>
<th>commit 说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>:art: (调色板)</td>
<td><code>:art:</code></td>
<td>改进代码结构/代码格式</td>
</tr>
<tr>
<td>:zap: (闪电):racehorse: (赛马)</td>
<td><code>:zap:“:racehorse:</code></td>
<td>提升性能</td>
</tr>
<tr>
<td>:fire: (火焰)</td>
<td><code>:fire:</code></td>
<td>移除代码或文件</td>
</tr>
<tr>
<td>:bug: (bug)</td>
<td><code>:bug:</code></td>
<td>修复 bug</td>
</tr>
<tr>
<td>:ambulance: (急救车)</td>
<td><code>:ambulance:</code></td>
<td>重要补丁</td>
</tr>
<tr>
<td>:sparkles: (火花)</td>
<td><code>:sparkles:</code></td>
<td>引入新功能</td>
</tr>
<tr>
<td>:memo: (备忘录)</td>
<td><code>:memo:</code></td>
<td>撰写文档</td>
</tr>
<tr>
<td>:rocket: (火箭)</td>
<td><code>:rocket:</code></td>
<td>部署功能</td>
</tr>
<tr>
<td>:lipstick: (口红)</td>
<td><code>:lipstick:</code></td>
<td>更新 UI 和样式文件</td>
</tr>
<tr>
<td>:tada: (庆祝)</td>
<td><code>:tada:</code></td>
<td>初次提交</td>
</tr>
<tr>
<td>:white_check_mark: (白色复选框)</td>
<td><code>:white_check_mark:</code></td>
<td>增加测试</td>
</tr>
<tr>
<td>:lock: (锁)</td>
<td><code>:lock:</code></td>
<td>修复安全问题</td>
</tr>
<tr>
<td>:apple: (苹果)</td>
<td><code>:apple:</code></td>
<td>修复 macOS 下的问题</td>
</tr>
<tr>
<td>:penguin: (企鹅)</td>
<td><code>:penguin:</code></td>
<td>修复 Linux 下的问题</td>
</tr>
<tr>
<td>:checkered_flag: (旗帜)</td>
<td><code>:checked_flag:</code></td>
<td>修复 Windows 下的问题</td>
</tr>
<tr>
<td>:bookmark: (书签)</td>
<td><code>:bookmark:</code></td>
<td>发行/版本标签</td>
</tr>
<tr>
<td>:rotating_light: (警车灯)</td>
<td><code>:rotating_light:</code></td>
<td>移除 linter 警告</td>
</tr>
<tr>
<td>:construction: (施工)</td>
<td><code>:construction:</code></td>
<td>工作进行中</td>
</tr>
<tr>
<td>:green_heart: (绿心)</td>
<td><code>:green_heart:</code></td>
<td>修复 CI 构建问题</td>
</tr>
<tr>
<td>:arrow_down: (下降箭头)</td>
<td><code>:arrow_down:</code></td>
<td>降级依赖</td>
</tr>
<tr>
<td>:arrow_up: (上升箭头)</td>
<td><code>:arrow_up:</code></td>
<td>升级依赖</td>
</tr>
<tr>
<td>:construction_worker: (工人)</td>
<td><code>:construction_worker:</code></td>
<td>添加 CI 构建系统</td>
</tr>
<tr>
<td>:chart_with_upwards_trend: (上升趋势图)</td>
<td><code>:chart_with_upwards_trend:</code></td>
<td>添加分析或跟踪代码</td>
</tr>
<tr>
<td>:hammer: (锤子)</td>
<td><code>:hammer:</code></td>
<td>重大重构</td>
</tr>
<tr>
<td>:heavy_minus_sign: (减号)</td>
<td><code>:heavy_minus_sign:</code></td>
<td>减少一个依赖</td>
</tr>
<tr>
<td>:whale: (鲸鱼)</td>
<td><code>:whale:</code></td>
<td>Docker 相关工作</td>
</tr>
<tr>
<td>:heavy_plus_sign: (加号)</td>
<td><code>:heavy_plug_sign:</code></td>
<td>增加一个依赖</td>
</tr>
<tr>
<td>:wrench: (扳手)</td>
<td><code>:wrench:</code></td>
<td>修改配置文件</td>
</tr>
<tr>
<td>:globe_with_meridians: (地球)</td>
<td><code>:globe_with_meridians:</code></td>
<td>国际化与本地化</td>
</tr>
<tr>
<td>:pencil2: (铅笔)</td>
<td><code>:pencil2:</code></td>
<td>修复 typo</td>
</tr>
</tbody>
</table>
<p>更多标签参考:</p>
<p><strong><em><a href="https://gitmoji.carloscuesta.me/" rel="external nofollow noopener noreferrer" target="_blank">https://gitmoji.carloscuesta.me/</a></em></strong></p>
<p><strong><em><a href="https://www.webfx.com/tools/emoji-cheat-sheet/" rel="external nofollow noopener noreferrer" target="_blank">https://www.webfx.com/tools/emoji-cheat-sheet/</a></em></strong></p>
<h1 id="美化你的-README"><a href="#美化你的-README" class="headerlink" title="美化你的 README"></a>美化你的 README</h1><p><strong><em><a href="https://github.com/kefranabg/readme-md-generator" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/kefranabg/readme-md-generator</a></em></strong></p>
<p><strong><em><a href="https://github.com/anuraghazra/github-readme-stats" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/anuraghazra/github-readme-stats</a></em></strong></p>
<h1 id="同步更新Github-Fork的项目"><a href="#同步更新Github-Fork的项目" class="headerlink" title="同步更新Github Fork的项目"></a>同步更新Github Fork的项目</h1><p>1、<code>fork</code>项目并<code>clone</code>到本地</p>
<p>2、进入项目根目录</p>
<p>3、添加<code>remote</code>指向<strong>上游仓库</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git</span><br></pre></td></tr></table></figure>
<p>4、把上游项目<code>fetch</code>下来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch upstream</span><br></pre></td></tr></table></figure>
<p>5、<code>merge</code>到<code>master</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge upstream/master</span><br></pre></td></tr></table></figure>
<p>6、<code>push</code>到自己的远程仓库, 搞定～</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="Git-pull-时每次都要输入用户名和密码的解决办法"><a href="#Git-pull-时每次都要输入用户名和密码的解决办法" class="headerlink" title="Git pull 时每次都要输入用户名和密码的解决办法"></a>Git pull 时每次都要输入用户名和密码的解决办法</h2><p>如果我们git clone的下载代码的时候是连接的https://而不是git@git (ssh)的形式，当我们操作git pull/push到远程的时候，总是提示我们输入账号和密码才能操作成功，频繁的输入账号和密码会很麻烦。</p>
<p><code>git bash</code>进入你的项目目录，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure>
<p>然后你会在你本地生成一个文本，上边记录你的账号和密码。当然这些你可以不用关心。然后你使用上述的命令配置好之后，再操作一次git pull，然后它会提示你输入账号密码，这一次之后就不需要再次输入密码了。</p>
<h1 id="Git-多平台统一换行符"><a href="#Git-多平台统一换行符" class="headerlink" title="Git 多平台统一换行符"></a>Git 多平台统一换行符</h1><h3 id="设置-git-全局参数"><a href="#设置-git-全局参数" class="headerlink" title="设置 git 全局参数"></a>设置 git 全局参数</h3><p>git 中有三个参数于换行符有关:</p>
<ul>
<li><code>eol</code>: 设置工作目录中文件的换行符, 有三个值 lf, crlf 和 native(默认, 同操作系统)</li>
<li><code>autocrlf</code> :<ul>
<li><code>true</code> 表示检出是转换CRLF, 提交时转换为 LF</li>
<li><code>input</code> 表示检出是不转换, 提交时转换为 LF</li>
<li><code>false</code> 表示不做转换</li>
</ul>
</li>
<li><code>safecrlf</code> :<ul>
<li><code>true</code> 表示不允许提交时包含不同换行符</li>
<li><code>warn</code> 则只在有不同换行符时警告</li>
<li><code>false</code> 则允许提价时有不同换行符存在</li>
</ul>
</li>
</ul>
<p>配置方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--统一换行符为 lf--&gt;</span><br><span class="line">git config --global core.eol lf</span><br><span class="line">&lt;!--将自动转换关闭,避免转换失败不能不同进行提交--&gt;</span><br><span class="line">git config --global core.autocrlf false</span><br><span class="line">&lt;!--禁止混用 lf 和 crlf 两种换行符--&gt;</span><br><span class="line">git config --global core.safecrlf true</span><br></pre></td></tr></table></figure>
<h3 id="增加配置文件-gitattributes"><a href="#增加配置文件-gitattributes" class="headerlink" title="增加配置文件 .gitattributes"></a>增加配置文件 .gitattributes</h3><p>虽然通过设置了 git 全局参数解决了问题, 但是作为团队协作的话, 并不能保证所有人都正确配好了. git 提供了 <code>.gitattributes</code> 文件解决了这个问题, 在项目根目录新建 <code>.gitattributes</code> 文件, 添加一下内容:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Set the default behavior, in case people don&apos;t have core.autocrlf set.</span><br><span class="line">* text eol=lf</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>通过这种方式避免有人没有设置 <code>core.autocrlf</code> 参数, 并且将该文件加入版本控制中.</p>
<p>另外根据需要 <code>.gitattributes</code> 文件可以在项目不同目录中创建, 而一些非文本文件可以设置为二进制文件, 不用考虑换行符问题.</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>Git真的异常强大, 但命令繁多, 需多加练习</p>
<blockquote>
<p><strong><em>参考: <a href="http://www.liaoxuefeng.com/" rel="external nofollow noopener noreferrer" target="_blank">廖雪峰老师的教程</a></em></strong></p>
</blockquote>
<p>附命令图一张:<br><img src="https://cdn.yangbingdong.com/img/git/gitCommand.png" alt></p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">集中式版本管理系统之一<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">一个商业的版本控制系统<a href="#fnref:2" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content><categories><category>Git/Github</category></categories><tags><tag>Github</tag><tag>Git</tag></tags></entry><entry><title>Ubuntu 常用命令</title><url>/2017/note-of-linux-command/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/node-of-ubuntu-command/ubuntu-logo.png" alt></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><blockquote>
<p>=.= 这里只记录一些个人比较常用到的<a href="https://www.ubuntu.com" rel="external nofollow noopener noreferrer" target="_blank"><em>Ubuntu</em></a>命令</p>
</blockquote>
<a id="more"></a>
<h1 id="SSH相关"><a href="#SSH相关" class="headerlink" title="SSH相关"></a>SSH相关</h1><h2 id="安装SSH"><a href="#安装SSH" class="headerlink" title="安装SSH"></a>安装SSH</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install ssh</span><br><span class="line">sudo apt install openssh-server</span><br></pre></td></tr></table></figure>
<p>查看启动成功: <code>ps -e|grep ssh</code>, 如果看到<code>sshd</code>那代表成功了, 如果没有, 执行: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo/etc/init.d/ssh start</span><br></pre></td></tr></table></figure>
<p>ssh的配置文件位于<code>/etc/ssh/sshd_config</code>, 修改后需要重启ssh: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/sshresart</span><br></pre></td></tr></table></figure>
<h2 id="保持长连接"><a href="#保持长连接" class="headerlink" title="保持长连接"></a>保持长连接</h2><p>只需要在<code>ssh</code>命令后加上发送心跳即可:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -o ServerAliveInterval=30 root@123.456.88 -p 2333</span><br></pre></td></tr></table></figure></p>
<h2 id="生成SSH密钥和公钥"><a href="#生成SSH密钥和公钥" class="headerlink" title="生成SSH密钥和公钥"></a>生成SSH密钥和公钥</h2><p>打开终端, 使用下面的<code>ssh-keygen</code>来生成<code>RSA</code>密钥和公钥. <code>-t</code>表示type, 就是说要生成<code>RSA</code>加密的钥匙:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C "your_email@youremail.com"</span><br></pre></td></tr></table></figure></p>
<p><code>RSA</code>也是默认的加密类型, 所以你也可以只输入<code>ssh-keygen</code>, 默认的<code>RSA</code>长度是2048位, 如果你非常注重安全, 那么可以指定4096位的长度:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -b 4096 -t rsa -C "your_email@youremail.com"</span><br></pre></td></tr></table></figure></p>
<p>生成SSH Key的过程中会要求你指定一个文件来保存密钥, 按<code>Enter</code>键使用默认的文件就行了, 然后需要输入一个密码来加密你的SSH Key, 密码至少要20位长度, SSH密钥会保存在<code>home</code>目录下的<code>.ssh/id_rsa</code>文件中, SSH公钥保存在<code>.ssh/id_rsa.pub</code>文件中.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/home/matrix/.ssh/id_rsa): 　#按Enter键</span><br><span class="line">Enter passphrase (empty for no passphrase): 　　#输入一个密码</span><br><span class="line">Enter same passphrase again: 　　#再次输入密码</span><br><span class="line">Your identification has been saved in /home/matrix/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /home/matrix/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">e1:dc:ab:ae:b6:19:b0:19:74:d5:fe:57:3f:32:b4:d0 matrix@vivid</span><br><span class="line">The key&apos;s randomart image is:</span><br><span class="line">+---[RSA 4096]----+</span><br><span class="line">| .. |</span><br><span class="line">| . . |</span><br><span class="line">| . . .. . |</span><br><span class="line">| . . o o.. E .|</span><br><span class="line">| o S ..o ...|</span><br><span class="line">| = ..+...|</span><br><span class="line">| o . . .o .|</span><br><span class="line">| .o . |</span><br><span class="line">| .++o |</span><br><span class="line">+-----------------+</span><br></pre></td></tr></table></figure></p>
<h2 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h2><p>姿势:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 传输单个文件</span><br><span class="line">scp -P &lt;端口&gt; &lt;源文件&gt; &lt;目标文件&gt;</span><br><span class="line"></span><br><span class="line"># 传输文件夹</span><br><span class="line">scp -P &lt;端口&gt; -r &lt;源文件夹&gt; &lt;目标文件夹&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong><code>-P</code>要在前面<br>例如把本地的file复制到远程服务器:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -P 2333 /home/ybd/file root@123.456.78:/root/file</span><br></pre></td></tr></table></figure></p>
<h2 id="SSH-与-SCP-使用代理"><a href="#SSH-与-SCP-使用代理" class="headerlink" title="SSH 与 SCP 使用代理"></a>SSH 与 SCP 使用代理</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -o ProxyCommand=&quot;nc -X 5 -x proxy.net:1080 %h %p&quot; user@server.net</span><br></pre></td></tr></table></figure>
<p>常用参数：</p>
<ul>
<li><p>-X 指定代理协议</p>
<ul>
<li><code>4</code> SOCKS v.4</li>
<li><code>5</code> SOCKS v.5<strong>（默认）</strong></li>
<li><code>connect</code> HTTPS proxy</li>
</ul>
</li>
<li><p>-x 代理地址[:端口]</p>
<p>如果没有指定端口，采用协议常用端口，如：</p>
<ul>
<li>SOCKETS 使用 1080</li>
<li>HTTPS 使用 3128</li>
</ul>
</li>
</ul>
<h2 id="免密码登录远程服务器"><a href="#免密码登录远程服务器" class="headerlink" title="免密码登录远程服务器"></a>免密码登录远程服务器</h2><h3 id="姿势一"><a href="#姿势一" class="headerlink" title="姿势一"></a>姿势一</h3><p>使用上述<code>scp</code>把公钥<strong>上传</strong>到服务器, 然后:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure></p>
<h3 id="姿势二"><a href="#姿势二" class="headerlink" title="姿势二"></a>姿势二</h3><p>可以使用<code>ssh-copy-id</code>命令来完成:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-copy-id &lt;用户名&gt;@&lt;服务器ip&gt; -p &lt;端口&gt;</span><br></pre></td></tr></table></figure></p>
<p>输入远程用户的密码后, SSH公钥就会自动上传了, SSH公钥保存在远程Linux服务器的<code>.ssh/authorized_keys</code>文件中. </p>
<h1 id="别名alias简化命令"><a href="#别名alias简化命令" class="headerlink" title="别名alias简化命令"></a>别名alias简化命令</h1><p>只需要在当前用户目录加上别名命令, 但博主用的是<code>zsh</code>, 所有配置在<code>.zshrc</code>而不是<code>.bashrc</code><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "alias vps='ssh -o ServerAliveInterval=30 root@172.104.65.190 -p 2333'" &gt;&gt; ~/.zshrc</span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure></p>
<p>然后直接输入<code>vps</code>就可以登陆远程服务器了. </p>
<h1 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h1><p>使用<code>su</code>命令切换用户, ex:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su - ybd</span><br></pre></td></tr></table></figure></p>
<p>这样就切换到了ybd用户<br><code>su -</code>就是<code>su -l</code>(l为login的意思), <code>l</code>可以省略, 所以一般写成<code>su -</code>…..(<del>坑爹</del>)<br>如果不加用户名, 默认是 <code>su root</code>切换<code>root</code>用户.<br><strong>注意</strong>: <code>su</code> 和 <code>su -</code>的区别</p>
<ul>
<li>前者是直接切换, 还<strong>保留了当前位置以及变量</strong></li>
<li>而后者不单单切换了用户, 而且还<strong>切换到了用户目录</strong>, 并且之前用户的<strong>环境变量没有了</strong>！</li>
</ul>
<blockquote>
<p>因为这个原因, 写<code>Dockerfile</code>困扰了好一段时间…囧</p>
</blockquote>
<p>还有<code>su</code>也可以使用某个用户的身份执行一些命令, ex:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 执行单个命令</span><br><span class="line">su - $&#123;USER_NAME&#125; -c &quot;npm install -g hexo-cli&quot;</span><br><span class="line"># 执行shell脚本</span><br><span class="line">su - $&#123;USER_NAME&#125; -s /bin/bash shell.sh</span><br></pre></td></tr></table></figure></p>
<p>执行完之后还是保持当前用户.<br>可以通过<code>exit</code>退出当前用户. </p>
<h1 id="ufw防火墙"><a href="#ufw防火墙" class="headerlink" title="ufw防火墙"></a>ufw防火墙</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Ubuntu自带ufw, 没有可以直接安装: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo get install ufw</span><br></pre></td></tr></table></figure>
<h2 id="查看端口是否开启"><a href="#查看端口是否开启" class="headerlink" title="查看端口是否开启"></a>查看端口是否开启</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">telnet 192.168.1.103 80</span><br></pre></td></tr></table></figure>
<h2 id="设置默认规则"><a href="#设置默认规则" class="headerlink" title="设置默认规则"></a>设置默认规则</h2><p>大多数系统只需要打开少量的端口接受传入连接, 并且关闭所有剩余的端口. 从一个简单的规则基础开始, <code>ufw default</code>命令可以用于设置对传入和传出连接的默认响应动作. 要拒绝所有传入并允许所有传出连接, 那么运行: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ufw default allow outgoing</span><br><span class="line">sudo ufw default deny incoming</span><br></pre></td></tr></table></figure>
<h2 id="查看本地的端口开启情况"><a href="#查看本地的端口开启情况" class="headerlink" title="查看本地的端口开启情况"></a>查看本地的端口开启情况</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ufw status</span><br></pre></td></tr></table></figure>
<h2 id="打开80端口"><a href="#打开80端口" class="headerlink" title="打开80端口"></a>打开80端口</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ufw allow 80</span><br></pre></td></tr></table></figure>
<h2 id="允许从一个-IP-地址连接"><a href="#允许从一个-IP-地址连接" class="headerlink" title="允许从一个 IP 地址连接"></a>允许从一个 IP 地址连接</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ufw allow from 123.45.67.89</span><br></pre></td></tr></table></figure>
<h2 id="允许特定子网的连接"><a href="#允许特定子网的连接" class="headerlink" title="允许特定子网的连接"></a>允许特定子网的连接</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ufw allow from 123.45.67.89/24</span><br></pre></td></tr></table></figure>
<h2 id="允许特定-IP-端口的组合"><a href="#允许特定-IP-端口的组合" class="headerlink" title="允许特定 IP/ 端口的组合"></a>允许特定 IP/ 端口的组合</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ufw allow from 123.45.67.89 to any port 22 proto tcp</span><br></pre></td></tr></table></figure>
<h2 id="防火墙开启-禁用"><a href="#防火墙开启-禁用" class="headerlink" title="防火墙开启/禁用"></a>防火墙开启/禁用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 开启</span><br><span class="line">sudo ufw enable</span><br><span class="line"># 禁用</span><br><span class="line">sudo ufw disable</span><br></pre></td></tr></table></figure>
<h2 id="防火墙重启"><a href="#防火墙重启" class="headerlink" title="防火墙重启:"></a>防火墙重启:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ufw reload</span><br></pre></td></tr></table></figure>
<h1 id="用户与用户组相关"><a href="#用户与用户组相关" class="headerlink" title="用户与用户组相关"></a>用户与用户组相关</h1><h2 id="添加用户useradd"><a href="#添加用户useradd" class="headerlink" title="添加用户useradd"></a>添加用户useradd</h2><p><img src="https://cdn.yangbingdong.com/img/node-of-ubuntu-command/command-useradd.png" alt></p>
<p>ex:<br>创建<code>ybd</code>用户并且加入<code>ybd</code>用户组并且创建用户目录: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd -g ybd -m ybd</span><br><span class="line"># 或者</span><br><span class="line">user add -m -U ybd</span><br></pre></td></tr></table></figure>
<h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">passwd ybd</span><br></pre></td></tr></table></figure>
<h2 id="修改用户usermod"><a href="#修改用户usermod" class="headerlink" title="修改用户usermod"></a>修改用户usermod</h2><p><img src="https://cdn.yangbingdong.com/img/node-of-ubuntu-command/command-usermod.png" alt></p>
<h2 id="添加用户组groupadd"><a href="#添加用户组groupadd" class="headerlink" title="添加用户组groupadd"></a>添加用户组groupadd</h2><p><img src="https://cdn.yangbingdong.com/img/node-of-ubuntu-command/command-groupadd.png" alt></p>
<h2 id="修改用户组"><a href="#修改用户组" class="headerlink" title="修改用户组"></a>修改用户组</h2><p><img src="https://cdn.yangbingdong.com/img/node-of-ubuntu-command/command-groupmod.png" alt></p>
<p>ex:将test组的名子改成test2<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groupmod -n test2 test</span><br></pre></td></tr></table></figure></p>
<p>删除组test2<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groupdel test2</span><br></pre></td></tr></table></figure></p>
<h2 id="查看组"><a href="#查看组" class="headerlink" title="查看组"></a>查看组</h2><p>查看当前登录用户所在的组:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groups</span><br></pre></td></tr></table></figure></p>
<p>查看用户test所在组:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groups test</span><br></pre></td></tr></table></figure></p>
<p>查看所有组:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /etc/group</span><br></pre></td></tr></table></figure></p>
<h2 id="修改用户名"><a href="#修改用户名" class="headerlink" title="修改用户名"></a>修改用户名</h2><blockquote>
<p><code>usermod</code>不允许你改变正在线上的使用者帐号名称. 当<code>usermod</code>用来改变<code>userID</code>, 必须确认这名<code>user</code>没在电脑上执行任何程序, 否则会报“<code>usermod: user xxx is currently logged in</code>”错误. <strong>因此必须<code>root</code>用户登录或者其他用户登录然后切换到<code>root</code>身份, 而不能在当前用户下切换至<code>root</code>进行修改. </strong></p>
</blockquote>
<p>1、<strong>以root身份登录</strong></p>
<p>2、<strong>usermod -l hadoop seed</strong><br>该命令相当于做了两件事: </p>
<ul>
<li>将<code>/etc/passwd</code>下的用户名栏从<code>seed</code>修改为<code>hadoop</code>, 其他部分不变</li>
<li>将<code>/etc/shadow</code>下的用户名栏从<code>seed</code>修改为<code>hadoop</code>, 其他部分不变</li>
</ul>
<p>3、<strong>usermod -c hadoop hadoop</strong></p>
<ul>
<li>相当于将<code>/etc/passwd</code>下的注解栏修改为<code>hadoop</code>, 其他部分不变</li>
</ul>
<p>4、<strong>groupmod -n hadoop seed</strong></p>
<ul>
<li>将原来的用户组<code>seed</code>修改为<code>hadoop</code>, 只修改组名, 组标识号不变, 相当于修改了文件<code>/etc/group</code>和<code>/etc/gshadow</code></li>
</ul>
<p>5、<strong>usermod -md /home/hadoop hadoop</strong><br>相当于做了两件事: </p>
<ul>
<li>将~下的登入目录栏修改为<code>/home/hadoop</code>, 其他部分不变</li>
<li>将原来的用户目录<code>/home/seed</code>修改为新的用户目录<code>/home/hadoop</code></li>
</ul>
<h1 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h1><h2 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h2><blockquote>
<p>来自: <strong><em><a href="https://itbilu.com/linux/man/4yZ9qH_7X.html" rel="external nofollow noopener noreferrer" target="_blank">https://itbilu.com/linux/man/4yZ9qH_7X.html</a></em></strong></p>
<p><code>curl</code>是一个开源的用于数据传输的命令行工具与库，它使用<code>URL</code>语法格式，支持众多传输协议，包括：HTTP、HTTPS、FTP、FTPS、GOPHER、TFTP、SCP、SFTP、SMB、TELNET、DICT、LDAP、LDAPS、FILE、IMAP、SMTP、POP3、RTSP和RTMP。<code>curl</code>库提供了很多强大的功能，你可以利用它来进行HTTP/HTTPS请求、上传/下载文件等，且支持Cookie、认证、代理、限速等。</p>
</blockquote>
<p><strong>直接访问</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curlyangbingdong.com</span><br></pre></td></tr></table></figure>
<p><strong>重定向跟踪</strong></p>
<p>页面使用了重定向，这时我们可以添加<code>-L</code>参数来跟踪URL重定向：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -L https://git.io/vokNn</span><br></pre></td></tr></table></figure>
<p><strong>页面保存</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -o [文件名] https://git.io/vokNn</span><br></pre></td></tr></table></figure>
<p><strong>查看头信息</strong></p>
<p>如果需要查看访问页面的可以添加<code>-i</code>或<code>--include</code>参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -i yangbingdong.com</span><br></pre></td></tr></table></figure>
<p>添加<code>-i</code>参数后，页面响应头会和页面源码（响应体）一块返回。如果只想查看响应头，可以使用<code>-I</code>或<code>--head</code>参数.</p>
<p><strong>POST数据提交</strong></p>
<p><code>curl</code>使用<code>POST</code>提交表单数据时，除了<code>-X</code>参数指定请求方法外，还要使用<code>--data</code>参数添加提交数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X POST --data &apos;keyword=linux&apos; itbilu.com</span><br></pre></td></tr></table></figure>
<p><strong>添加请求头</strong></p>
<p>有时在进行HTTP请求时，需要自定义请求头。在<code>curl</code>中，可以通过<code>-H</code>或<code>--header</code>参数来指定请求头。多次使用<code>-H</code>或<code>--header</code>参数可指定多个请求头。</p>
<p>如，指定<code>Content-Type</code>及<code>Authorization</code>请求头：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -H &apos;Content-Type:application/json&apos; -H &apos;Authorization: bearer eyJhbGciOiJIUzI1NiJ9&apos; itbilu.com</span><br></pre></td></tr></table></figure>
<p><strong>Cookie支持</strong></p>
<p><code>Cookie</code>是一种常用的保持服务端会话信息的方法，<code>crul</code>也支持使用<code>Cookie</code>。</p>
<p>可以通过<code>--cookie</code>参数指定发送请求时的<code>Cookie</code>值，也可以通过<code>-b [文件名]</code>来指定一个存储了<code>Cookie</code>值的本地文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -b stored_cookies_in_file itbilu.com</span><br></pre></td></tr></table></figure>
<p><code>Cookie</code>值可能会被服务器所返回的值所修改，并应用于下次HTTP请求。这时，可以能过<code>-c</code>参数指定存储服务器返回<code>Cookie</code>值的存储文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -b cookies.txt -c newcookies.txt itbilu.com</span><br></pre></td></tr></table></figure>
<h2 id="递归下载抓取整个网站内容"><a href="#递归下载抓取整个网站内容" class="headerlink" title="递归下载抓取整个网站内容"></a>递归下载抓取整个网站内容</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -r -p -k -np &lt;URL&gt;</span><br></pre></td></tr></table></figure>
<p>参数说明:<br><code>-r</code>:  递归下载<br><code>-p</code>:  下载所有用于显示 HTML 页面的图片之类的元素<br><code>-k</code>:   在转换文件 X 前先将它备份为 <code>X.orig</code><br><code>-np</code>:   不追溯至父目录</p>
<h1 id="跟踪日志输出"><a href="#跟踪日志输出" class="headerlink" title="跟踪日志输出"></a>跟踪日志输出</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail -f &lt;log&gt;</span><br><span class="line"></span><br><span class="line"># 输出最后1000行</span><br><span class="line">tail -1000 &lt;log&gt;</span><br></pre></td></tr></table></figure>
<h1 id="统计文件夹大小"><a href="#统计文件夹大小" class="headerlink" title="统计文件夹大小"></a>统计文件夹大小</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">du -hs `ls -al |awk &apos;&#123;print $9&#125;&apos;`</span><br></pre></td></tr></table></figure>
<p>上面命令可以统计文件夹中所有的文件夹和文件的大小, 并且包括隐藏目录. 缺点是连上级目录也会统计. </p>
<p>如果不需要列出上级目录, 则把ls命令的-a换成-A, 就不会列出点文件了.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">du -hs `ls -Al |awk &apos;&#123;print $9&#125;&apos;`</span><br></pre></td></tr></table></figure></p>
<p>如果不需要列出文件, 只需文件夹, 则在ls中增加-d参数即可<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">du -hs `ls -Adl |awk &apos;&#123;print $9&#125;&apos;`</span><br><span class="line">或</span><br><span class="line">du -hs `ls -Al |grep ^d|awk &apos;&#123;print $9&#125;&apos;`</span><br></pre></td></tr></table></figure></p>
<h1 id="压缩和解压缩"><a href="#压缩和解压缩" class="headerlink" title="压缩和解压缩"></a>压缩和解压缩</h1><p>打包但是不压缩(<code>tar</code>): <code>tar -cf &lt;压缩包文件名&gt; &lt;要打包的目录&gt;</code><br>打包并压缩(<code>tar.gz</code>): <code>tar -zcf &lt;压缩包文件名&gt; &lt;要打包的目录&gt;</code></p>
<p>解压缩<code>tar</code>文件: <code>tar -xvf &lt;压缩包文件&gt;</code><br>解压缩<code>tar.gz</code>文件: <code>tar -zxvf &lt;压缩包文件&gt;</code></p>
<h1 id="目录与文件"><a href="#目录与文件" class="headerlink" title="目录与文件"></a>目录与文件</h1><blockquote>
<p>以下转载于<strong><em><a href="http://blog.csdn.net/wzzfeitian/article/details/40985549" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/wzzfeitian/article/details/40985549</a></em></strong></p>
</blockquote>
<h2 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a><strong>find命令</strong></h2><p>find &lt; path &gt; &lt; expression &gt; &lt; cmd &gt;</p>
<ul>
<li>path: 所要搜索的目录及其所有子目录. 默认为当前目录. </li>
<li>expression: 所要搜索的文件的特征. </li>
<li>cmd: 对搜索结果进行特定的处理. </li>
</ul>
<p>如果什么参数也不加, find默认搜索当前目录及其子目录, 并且不过滤任何结果（也就是返回所有文件）, 将它们全都显示在屏幕上. </p>
<h3 id="find命令常用选项及实例"><a href="#find命令常用选项及实例" class="headerlink" title="find命令常用选项及实例"></a><strong>find命令常用选项及实例</strong></h3><p><code>-name</code> 按照文件名查找文件.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find /dir -name filename  在/dir目录及其子目录下面查找名字为filename的文件</span><br><span class="line">find . -name &quot;*.c&quot; 在当前目录及其子目录（用“.”表示）中查找任何扩展名为“c”的文件</span><br></pre></td></tr></table></figure></p>
<p><code>-perm</code> 按照文件权限来查找文件.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find . -perm 755 –print 在当前目录下查找文件权限位为755的文件, 即文件属主可以读、写、执行, 其他用户可以读、执行的文件</span><br></pre></td></tr></table></figure></p>
<p><code>-prune</code> 使用这一选项可以使<code>find</code>命令不在当前指定的目录中查找, 如果同时使用<code>-depth</code>选项, 那么<code>-prune</code>将被<code>find</code>命令忽略. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find /apps -path &quot;/apps/bin&quot; -prune -o –print 在/apps目录下查找文件, 但不希望在/apps/bin目录下查找</span><br><span class="line">find /usr/sam -path &quot;/usr/sam/dir1&quot; -prune -o –print 在/usr/sam目录下查找不在dir1子目录之内的所有文件</span><br></pre></td></tr></table></figure>
<p><code>-depth</code>: 在查找文件时, 首先查找当前目录中的文件, 然后再在其子目录中查找. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find / -name &quot;CON.FILE&quot; -depth –print 它将首先匹配所有的文件然后再进入子目录中查找</span><br></pre></td></tr></table></figure>
<p><code>-user</code> 按照文件属主来查找文件. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find ~ -user sam –print 在$HOME目录中查找文件属主为sam的文件</span><br></pre></td></tr></table></figure>
<p><code>-group</code> 按照文件所属的组来查找文件. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find /apps -group gem –print 在/apps目录下查找属于gem用户组的文件</span><br></pre></td></tr></table></figure>
<p><code>-mtime -n +n</code> 按照文件的更改时间来查找文件, -n表示文件更改时间距现在n天以内, +n表示文件更改时间距现在n天以前. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find / -mtime -5 –print 在系统根目录下查找更改时间在5日以内的文件</span><br><span class="line">find /var/adm -mtime +3 –print 在/var/adm目录下查找更改时间在3日以前的文件</span><br></pre></td></tr></table></figure>
<p><code>-nogroup</code> 查找无有效所属组的文件, 即该文件所属的组在<code>/etc/groups</code>中不存在. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find / –nogroup -print</span><br></pre></td></tr></table></figure>
<p><code>-nouser</code> 查找无有效属主的文件, 即该文件的属主在<code>/etc/passwd</code>中不存在. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find /home -nouser –print</span><br></pre></td></tr></table></figure>
<p><code>-newer file1 ! file2</code> 查找更改时间比文件file1新但比文件file2旧的文件. </p>
<p><code>-type</code> 查找某一类型的文件, </p>
<p>诸如: </p>
<ul>
<li>b - 块设备文件. </li>
<li>d - 目录. </li>
<li>c - 字符设备文件. </li>
<li>p - 管道文件. </li>
<li>l - 符号链接文件. </li>
<li>f - 普通文件. <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find /etc -type d –print 在/etc目录下查找所有的目录</span><br><span class="line">find . ! -type d –print 在当前目录下查找除目录以外的所有类型的文件</span><br><span class="line">find /etc -type l –print 在/etc目录下查找所有的符号链接文件</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>-size n[c]</code> 查找文件长度为n块的文件, 带有c时表示文件长度以字节计.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find . -size +1000000c –print 在当前目录下查找文件长度大于1 M字节的文件</span><br><span class="line">find /home/apache -size 100c –print 在/home/apache目录下查找文件长度恰好为100字节的文件</span><br><span class="line">find . -size +10 –print 在当前目录下查找长度超过10块的文件（一块等于512字节）</span><br></pre></td></tr></table></figure></p>
<p><code>-mount</code> 在查找文件时不跨越文件系统mount点.<br>  <code>find . -name “*.XC” -mount –print</code> 从当前目录开始查找位于本文件系统中文件名以XC结尾的文件（不进入其他文件系统）</p>
<p><code>-follow</code> 如果find命令遇到符号链接文件, 就跟踪至链接所指向的文件</p>
<p><code>-exec</code> find命令对匹配的文件执行该参数所给出的shell命令. 相应命令的形式为<code>command {} \</code>, 注意<code>{}</code>和<code>\</code>;之间的空格</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find ./ -size 0 -exec rm &#123;&#125; \; 删除文件大小为零的文件</span><br><span class="line">$ rm -i `find ./ -size 0`  </span><br><span class="line">$ find ./ -size 0 | xargs rm -f &amp;</span><br><span class="line"></span><br><span class="line">为了用ls -l命令列出所匹配到的文件, 可以把ls -l命令放在find命令的-exec选项中: </span><br><span class="line">$ find . -type f -exec ls -l &#123;&#125; \;</span><br><span class="line">在/logs目录中查找更改时间在5日以前的文件并删除它们: </span><br><span class="line">find /logs -type f -mtime +5 -exec rm &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<p><code>-ok</code>, 和<code>-exec</code>的作用相同, 只不过以一种更为安全的模式来执行该参数所给出的shell命令, 在执行每一个命令之前, 都会给出提示, 让用户来确定是否执行. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find . -name &quot;*.conf&quot;  -mtime +5 -ok rm &#123;&#125; \; 在当前目录中查找所有文件名以.LOG结尾、更改时间在5日以上的文件, 并删除它们, 只不过在删除之前先给出提示</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>: 如果你要寻找一个档案的话, 那么使用 find 会是一个不错的主意. 不过, 由于 find 在寻找数据的时候相当的耗硬盘, 所以没事情不要使用 find 啦！有更棒的指令可以取代呦, 那就是 <code>whereis</code> 与 <code>locate</code> 咯~</p>
<h3 id="一些常用命令"><a href="#一些常用命令" class="headerlink" title="一些常用命令"></a><strong>一些常用命令</strong></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. find . -type f -exec ls -l &#123;&#125; \;</span><br><span class="line">查找当前路径下的所有普通文件, 并把它们列出来. </span><br><span class="line"></span><br><span class="line">2. find logs -type f -mtime +5 -exec rm &#123;&#125; \;</span><br><span class="line">删除logs目录下更新时间为5日以上的文件. </span><br><span class="line"></span><br><span class="line">3.find . -name &quot;*.log&quot; -mtime +5 -ok rm &#123;&#125; \;</span><br><span class="line">删除当前路径下以. log结尾的五日以上的文件, 删除之前要确认. </span><br><span class="line"></span><br><span class="line">4. find ~ -type f -perm 4755 -print</span><br><span class="line">查找$HOME目录下suid位被设置, 文件属性为755的文件打印出来. </span><br><span class="line">说明: find在有点系统中会一次性得到将匹配到的文件都传给exec, 但是有的系统对exec的命令长度做限制, 就会报: ”参数列太长“, 这就需要使用xargs. xargs是部分取传来的文件. </span><br><span class="line"></span><br><span class="line">5. find / -type f -print |xargs file</span><br><span class="line">xargs测试文件分类</span><br><span class="line"></span><br><span class="line">6. find . -name &quot;core*&quot; -print|xargs echo &quot; &quot;&gt;/tmp/core.log</span><br><span class="line">将core文件信息查询结果报存到core. log日志. </span><br><span class="line"></span><br><span class="line">7. find / -type f -print | xargs chmod o -w</span><br><span class="line"></span><br><span class="line">8. find . -name * -print |xargs grep &quot;DBO&quot;</span><br></pre></td></tr></table></figure>
<h2 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a><strong>grep命令</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep [选项] pattern [文件名]</span><br></pre></td></tr></table></figure>
<p>命令中的选项为: </p>
<ul>
<li>-? 同时显示匹配行上下的？行, 如: <code>grep -2 pattern filename</code> 同时显示匹配行的上下2行. </li>
<li>-b, —byte-offset 打印匹配行前面打印该行所在的块号码. </li>
<li>-c,—count 只打印匹配的行数, 不显示匹配的内容. </li>
<li>-f File, —file=File 从文件中提取模板. 空文件中包含0个模板, 所以什么都不匹配. </li>
<li>-h, —no-filename 当搜索多个文件时, 不显示匹配文件名前缀. </li>
<li>-i, —ignore-case 忽略大小写差别. </li>
<li>-q, —quiet 取消显示, 只返回退出状态. 0则表示找到了匹配的行. </li>
<li>-l, —files-with-matches 打印匹配模板的文件清单. </li>
<li>-L, —files-without-match 打印不匹配模板的文件清单. </li>
<li>-n, —line-number 在匹配的行前面打印行号. </li>
<li>-s, —silent 不显示关于不存在或者无法读取文件的错误信息. </li>
<li>-v, —revert-match 反检索, 只显示不匹配的行. </li>
<li>-w, —word-regexp 如果被\&lt;和&gt;引用, 就把表达式做为一个单词搜索. </li>
<li>-V, —version 显示软件版本信息. </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -l | grep &apos;^a&apos; 通过管道过滤ls -l输出的内容, 只显示以a开头的行. </span><br><span class="line">grep &apos;test&apos; d* 显示所有以d开头的文件中包含test的行. </span><br><span class="line">grep &apos;test&apos; aa bb cc 显示在aa, bb, cc文件中匹配test的行. </span><br><span class="line">grep &apos;[a-z]&apos; aa 显示所有包含每个字符串至少有5个连续小写字符的字符串的行. </span><br><span class="line">grep &apos;w(es)t.*&apos; aa 如果west被匹配, 则es就被存储到内存中, 并标记为1, 然后搜索任意个字符(.*), 这些字符后面紧跟着另外一个es(), 找到就显示该行. 如果用egrep或grep -E, 就不用&quot;&quot;号进行转义, 直接写成&apos;w(es)t.*&apos;就可以了. </span><br><span class="line">grep -i pattern files : 不区分大小写地搜索. 默认情况区分大小写</span><br><span class="line">grep -l pattern files : 只列出匹配的文件名, </span><br><span class="line">grep -L pattern files : 列出不匹配的文件名, </span><br><span class="line">grep -w pattern files : 只匹配整个单词, 而不是字符串的一部分(如匹配‘magic’, 而不是‘magical’), </span><br><span class="line">grep -C number pattern files : 匹配的上下文分别显示[number]行, </span><br><span class="line">grep pattern1 | pattern2 files : 显示匹配 pattern1 或 pattern2 的行, </span><br><span class="line">grep pattern1 files | grep pattern2 : 显示既匹配 pattern1 又匹配 pattern2 的行.</span><br></pre></td></tr></table></figure>
<p>pattern为所要匹配的字符串, 可使用下列模式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">. 匹配任意一个字符</span><br><span class="line">* 匹配0 个或多个*前的字符</span><br><span class="line">^ 匹配行开头</span><br><span class="line">$ 匹配行结尾</span><br><span class="line">[] 匹配[ ]中的任意一个字符, []中可用 - 表示范围, </span><br><span class="line">例如[a-z]表示字母a 至z 中的任意一个</span><br><span class="line">\ 转意字符</span><br></pre></td></tr></table></figure></p>
<h2 id="xargs命令"><a href="#xargs命令" class="headerlink" title="xargs命令"></a><strong>xargs命令</strong></h2><p>【xargs定位参数位置 | xargs控制参数位置 | 如何定位控制xargs参数位置】<br><strong>背景</strong>:<br>管道 + xargs用于把上游输出转换为下游参数输入.<br>例如 <code>ls *.bak | xargs rm -f</code></p>
<p><strong>问题</strong>:<br>xargs默认把输入作为参数放到命令的最后, 但是很多命令需要自己定位参数的位置, 比如拷贝命令<code>cp {上游结果} destFolder</code></p>
<p><strong>解决方法</strong>:<br>xargs 使用大写字母i 定义参数指示符 <strong>-I &lt;指示符&gt;</strong>, 然后用这个参数指示符定位参数插入的位置, 例如: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls *.bak | xargs -I % cp % /tmp/test</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注释: 这里使用%作为指示符, 第一个%可以理解为声明, 第二个%可以理解为调用. 你也<strong>可以用其他字符</strong>, 比如 <code>ls *.bak | xargs -I {} cp {} /tmp/test</code></p>
</blockquote>
<p><strong>简介</strong><br>之所以能用到xargs这个命令, 关键是由于很多命令不支持|管道来传递参数, 而日常工作中有有这个必要, 所以就有了xargs命令, 例如: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find /sbin -perm +700 | ls -l       这个命令是错误的</span><br><span class="line">find /sbin -perm +700 | xargs ls -l   这样才是正确的</span><br></pre></td></tr></table></figure>
<p>xargs 可以读入 stdin 的资料, 并且以<strong>空白字元或断行字元</strong>作为分辨, 将 stdin 的资料分隔成为 arguments . 因为是以空白字元作为分隔, 所以, 如果有一些档名或者是其他意义的名词内含有空白字元的时候, xargs 可能就会误判了～<br><strong>选项解释</strong><br>-0 当sdtin含有特殊字元时候, 将其当成一般字符, 像/ ‘ 空格等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@localhost:~/test#echo &quot;//&quot;|xargs  echo</span><br><span class="line">root@localhost:~/test#echo &quot;//&quot;|xargs -0 echo</span><br><span class="line">/</span><br></pre></td></tr></table></figure>
<p>-a file 从文件中读入作为sdtin</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@localhost:~/test#cat test#!/bin/shecho &quot;hello world/n&quot;</span><br><span class="line">root@localhost:~/test#xargs -a test echo#!/bin/sh echo hello world/n</span><br><span class="line">root@localhost:~/test#</span><br></pre></td></tr></table></figure>
<ul>
<li>-e flag , 注意有的时候可能会是-E, flag必须是一个以空格分隔的标志, 当xargs分析到含有flag这个标志的时候就停止. </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@localhost:~/test#cat txt</span><br><span class="line">/bin tao shou kun</span><br><span class="line">root@localhost:~/test#cat txt|xargs -E &apos;shou&apos; echo</span><br><span class="line">/bin tao</span><br></pre></td></tr></table></figure>
<ul>
<li>-p 当每次执行一个argument的时候询问一次用户. </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@localhost:~/test#cat txt|xargs -p echoecho /bin tao shou kun ff ?...y</span><br><span class="line">/bin tao shou kun ff</span><br></pre></td></tr></table></figure>
<ul>
<li>-n num 后面加次数, 表示命令在执行的时候一次用的argument的个数, 默认是用所有的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@localhost:~/test#cat txt|xargs -n1 echo</span><br><span class="line">/bin</span><br><span class="line">tao</span><br><span class="line">shou</span><br><span class="line">kun</span><br><span class="line">root@localhost:~/test3#cat txt|xargs  echo</span><br><span class="line">/bin tao shou ku</span><br></pre></td></tr></table></figure>
<ul>
<li>-t 表示先打印命令, 然后再执行. </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@localhost:~/test#cat txt|xargs -t echoecho /bin tao shou kun</span><br><span class="line">/bin tao shou kun</span><br></pre></td></tr></table></figure>
<ul>
<li>-i 或者是-I, 这得看linux支持了, 将xargs的每项名称, 一般是一行一行赋值给{}, 可以用{}代替. </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls | xargs -t -i mv &#123;&#125; &#123;&#125;.bak</span><br></pre></td></tr></table></figure>
<ul>
<li>-r no-run-if-empty 当xargs的输入为空的时候则停止xargs, 不用再去执行了. </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@localhost:~/test#echo &quot;&quot;|xargs -t -r  mv</span><br><span class="line">root@localhost:~/test#</span><br></pre></td></tr></table></figure>
<ul>
<li>-s num 命令行的最大字符数, 指的是xargs后面那个命令的最大命令行字符数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@localhost:~/test#cat test |xargs -i -x  -s 14 echo &quot;&#123;&#125;&quot;</span><br><span class="line">exp1</span><br><span class="line">exp5</span><br><span class="line">file</span><br><span class="line">xargs: argument line too long</span><br><span class="line">linux-2</span><br><span class="line">root@localhost:~/test#</span><br></pre></td></tr></table></figure>
<ul>
<li><p>-L num Use at most max-lines nonblank input lines per command line.-s是含有空格的. </p>
</li>
<li><p>-l 同-L</p>
</li>
<li><p>-d delim 分隔符, <strong>默认的xargs分隔符是回车</strong>, <strong>argument的分隔符是空格</strong>, 这里修改的是xargs的分隔符</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@localhost:~/test#cat txt |xargs -i -p echo &#123;&#125;echo /bin tao shou kun ?...y</span><br><span class="line">root@localhost:~/test#cat txt |xargs -i -p -d &quot; &quot; echo &#123;&#125;echo /bin ?...y</span><br><span class="line">echo tao ?.../bin</span><br><span class="line">y</span><br><span class="line">echo shou ?...tao</span><br><span class="line">再如: </span><br><span class="line">root@localhost:~/test#cat test |xargs -i -p -d &quot; &quot; echo &#123;&#125;echo exp1</span><br><span class="line">exp5</span><br><span class="line">file</span><br><span class="line">linux-2</span><br><span class="line">ngis_post</span><br><span class="line">tao</span><br><span class="line">test</span><br><span class="line">txt</span><br><span class="line">xen-3</span><br><span class="line">?...y</span><br><span class="line">root@localhost:~/test#cat test |xargs -i -p echo &#123;&#125;echo exp1 ?...y</span><br><span class="line">echo exp5 ?...exp1</span><br><span class="line">y</span><br><span class="line">echo file ?...exp5</span><br><span class="line">y</span><br></pre></td></tr></table></figure>
<ul>
<li><p>-x exit的意思, 主要是配合-s使用. </p>
</li>
<li><p>-P 修改最大的进程数, 默认是1, 为0时候为as many as it can</p>
</li>
</ul>
<h2 id="其他查找命令"><a href="#其他查找命令" class="headerlink" title="其他查找命令"></a><strong>其他查找命令</strong></h2><h3 id="1-locate命令"><a href="#1-locate命令" class="headerlink" title="1. locate命令"></a><strong>1. locate命令</strong></h3><p>locate命令其实是“find -name”的另一种写法, 但是要比后者快得多, 原因在于它不搜索具体目录, 而是搜索一个数据库（/var/lib/locatedb）, 这个数据库中含有本地所有文件信息. Linux系统自动创建这个数据库, 并且每天自动更新一次, 所以使用locate命令查不到最新变动过的文件. 为了避免这种情况, 可以在使用locate之前, 先使用updatedb命令, 手动更新数据库. </p>
<p><strong>locate命令的使用实例: </strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ locate /etc/sh</span><br><span class="line">搜索etc目录下所有以sh开头的文件. </span><br><span class="line">$ locate -i ~/m</span><br><span class="line">搜索用户主目录下, 所有以m开头的文件, 并且忽略大小写.</span><br></pre></td></tr></table></figure>
<h3 id="2-whereis命令"><a href="#2-whereis命令" class="headerlink" title="2. whereis命令"></a><strong>2. whereis命令</strong></h3><p>whereis命令只能用于程序名的搜索, 而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）. 如果省略参数, 则返回所有信息. </p>
<p><strong>whereis命令的使用实例: </strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ whereis grep</span><br><span class="line">grep: /bin/grep /usr/share/man/man1p/grep.1p.gz /usr/share/man/man1/grep.1.gz</span><br></pre></td></tr></table></figure>
<h3 id="3-which命令"><a href="#3-which命令" class="headerlink" title="3. which命令"></a><strong>3. which命令</strong></h3><p>which命令的作用是, 在PATH变量指定的路径中, 搜索某个系统命令的位置, 并且返回第一个搜索结果. 也就是说, 使用which命令, 就可以看到某个系统命令是否存在, 以及执行的到底是哪一个位置的命令. </p>
<p><strong>which命令的使用实例: </strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ which grep</span><br><span class="line">/bin/grep</span><br></pre></td></tr></table></figure>
<h2 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h2><blockquote>
<p>sed是stream editor的简称，也就是流编辑器。它一次处理一行内容，处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。</p>
</blockquote>
<p>sed命令常用的使用方法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed [option] &apos;command&apos; input_file</span><br></pre></td></tr></table></figure>
<p>常见的option选项：</p>
<p><code>-n</code> 使用安静(silent)模式（想不通为什么不是-s）。在一般sed的用法中，所有来自stdin的内容一般都会被列出到屏幕上。但如果加上-n参数后，则只有经过sed特殊处理的那一行(或者动作)才会被列出来；<br><code>-e</code> 直接在指令列模式上进行 sed 的动作编辑；<br><code>-f</code> 直接将 sed 的动作写在一个文件内， <code>-f filename</code> 则可以执行filename内的sed命令；<br><code>-r</code> 让sed命令支持扩展的正则表达式(默认是基础正则表达式)；<br><code>-i</code> 直接修改读取的文件内容，而不是由屏幕输出。</p>
<p>常用的命令：</p>
<p><code>a\</code>： append即追加字符串， a \的后面跟上字符串s(多行字符串可以用\n分隔)，则会在当前选择的行的后面都加上字符串s；</p>
<p><code>c\</code>： 取代/替换字符串，c \后面跟上字符串s(多行字符串可以用\n分隔)，则会将当前选中的行替换成字符串s；</p>
<p><code>d</code>： delete即删除，该命令会将当前选中的行删除；</p>
<p><code>i\</code>： insert即插入字符串，i \后面跟上字符串s(多行字符串可以用\n分隔)，则会在当前选中的行的前面都插入字符串s；</p>
<p><code>p</code>： print即打印，该命令会打印当前选择的行到屏幕上；</p>
<p><code>s</code>： 替换，通常s命令的用法是这样的：<code>1，2s/old/new/g</code>，将old字符串替换成new字符串；其中的g 表示global全局替换，如果没有global的话，只会替换每一行中的第一个匹配的内容；</p>
<p><code>=</code>： 显示文件行号 </p>
<p>在sed 命令中的定位问题：</p>
<p>定址用于决定对哪些行进行编辑。地址的形式可以是数字、正则表达式、或二者的结合。如果没有指定地址，sed将处理输入文件的所有行。</p>
<p>如： 3，表示第3行， 1,5 表示第1-5行， $ 表示最后一行；</p>
<p>/sb/ 表示包含sb的行， /sb/, /2b/ 表示包含 sb至包含 2b的行；</p>
<p>/^ha.*day$/  表示以ha开头，以day结尾的行</p>
<p><code>s/\(.*\)line$/\1/g</code>  表示：<code>\(\)</code>包裹的内容表示正则表达式的第n部分，序号从1开始计算。本例中只有一个<code>\(\)</code>所以<code>\(.*\)</code>表示正则表达式的第一部分，这部分匹配任意字符串，所以<code>\(.*\)line$</code>匹配的就是以line结尾的任何行。用<code>\1</code>表示匹配到的第一部分，同样<code>\2</code>表示第二部分，<code>\3</code>表示第三部分，可以依次这样引用。 所以，它的意思是把每一行的line删除掉。</p>
<h1 id="系统监控"><a href="#系统监控" class="headerlink" title="系统监控"></a>系统监控</h1><h2 id="查看磁盘空间"><a href="#查看磁盘空间" class="headerlink" title="查看磁盘空间"></a>查看磁盘空间</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df -hl</span><br></pre></td></tr></table></figure>
<p>显示格式为: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">文件系统              容量 已用 可用 已用% 挂载点　</span><br><span class="line"></span><br><span class="line">Filesystem            Size Used Avail Use% Mounted on</span><br></pre></td></tr></table></figure>
<p><code>df -hl</code> 查看磁盘剩余空间</p>
<p><code>df -h</code> 查看每个根路径的分区大小</p>
<p><code>du -sh</code> [目录名] 返回该目录的大小</p>
<p><code>du -sm</code> [文件夹] 返回该文件夹总M数</p>
<h2 id="查看内存使用情况"><a href="#查看内存使用情况" class="headerlink" title="查看内存使用情况"></a>查看内存使用情况</h2><p><code>free</code>: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@localhost:~# free -h</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           989M        121M         87M        7.0M        781M        662M</span><br><span class="line">Swap:          255M         14M        241M</span><br></pre></td></tr></table></figure>
<h2 id="查看CPU信息"><a href="#查看CPU信息" class="headerlink" title="查看CPU信息"></a>查看CPU信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo</span><br></pre></td></tr></table></figure>
<h2 id="查看内核所能打开的线程数"><a href="#查看内核所能打开的线程数" class="headerlink" title="查看内核所能打开的线程数"></a>查看内核所能打开的线程数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /proc/sys/kernel/threads-max</span><br></pre></td></tr></table></figure>
<h2 id="查看当前进程打开的文件"><a href="#查看当前进程打开的文件" class="headerlink" title="查看当前进程打开的文件"></a>查看当前进程打开的文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 这里显示的数字需要减一, 因为第一行为头部标题信息</span><br><span class="line">lsof -p $&#123;PID&#125; | wc -l</span><br></pre></td></tr></table></figure>
<h2 id="查看文件描述符"><a href="#查看文件描述符" class="headerlink" title="查看文件描述符"></a>查看文件描述符</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls /proc/$&#123;PID&#125;/fd |wc -l</span><br></pre></td></tr></table></figure>
<h1 id="挂载新硬盘并格式化硬盘"><a href="#挂载新硬盘并格式化硬盘" class="headerlink" title="挂载新硬盘并格式化硬盘"></a>挂载新硬盘并格式化硬盘</h1><h2 id="查看硬盘"><a href="#查看硬盘" class="headerlink" title="查看硬盘"></a>查看硬盘</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll -h /dev/sd*</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brw-rw---- 1 root disk 8,  0 10月 11 09:20 /dev/sda</span><br><span class="line">brw-rw---- 1 root disk 8,  1 10月 11 09:20 /dev/sda1</span><br><span class="line">brw-rw---- 1 root disk 8,  2 10月 11 09:20 /dev/sda2</span><br><span class="line">brw-rw---- 1 root disk 8,  5 10月 11 09:20 /dev/sda5</span><br><span class="line">brw-rw---- 1 root disk 8, 16 10月 11 09:20 /dev/sdb</span><br></pre></td></tr></table></figure>
<p>通过<code>sudo fdisk -l</code>也可以查看</p>
<h2 id="新建分区"><a href="#新建分区" class="headerlink" title="新建分区"></a>新建分区</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo fdisk /dev/sdb</span><br></pre></td></tr></table></figure>
<p>之后进入command状态，大概是这么操作的：</p>
<ul>
<li>输入 m 查看帮助</li>
<li>输入 p 查看 /dev/sdb 分区的状态</li>
<li>输入 n 创建sdb这块硬盘的分区</li>
<li>选 p primary =&gt;输入　p</li>
<li>Partition number =&gt;分一个区所以输入　1</li>
<li>其他的默认回车即可</li>
<li>最后输入 w 保存并退出 Command 状态。</li>
</ul>
<p>操作示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Command (m for help): n</span><br><span class="line"># n创建分区</span><br><span class="line">Partition type</span><br><span class="line">   p   primary (0 primary, 0 extended, 4 free)</span><br><span class="line">   e   extended (container for logical partitions)</span><br><span class="line">Select (default p): p</span><br><span class="line"># p(primary主分区） e(extended拓展分区)</span><br><span class="line">Partition number (1-4, default 1): 1</span><br><span class="line"># 分区号</span><br><span class="line">First sector (2048-83886079, default 2048): </span><br><span class="line"># 默认</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G,T,P&#125; (2048-83886079, default 83886079): </span><br><span class="line"># 大小，可自定义，保持默认</span><br><span class="line">Created a new partition 1 of type &apos;Linux&apos; and of size 40 GiB.</span><br><span class="line"></span><br><span class="line">Command (m for help): p</span><br><span class="line"># 查看分区情况</span><br><span class="line">Disk /dev/sdb: 40 GiB, 42949672960 bytes, 83886080 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: dos</span><br><span class="line">Disk identifier: 0xbb6c1792</span><br><span class="line"></span><br><span class="line">Device     Boot Start      End  Sectors Size Id Type</span><br><span class="line">/dev/sdb1        2048 83886079 83884032  40G 83 Linux</span><br><span class="line"></span><br><span class="line">Command (m for help): w</span><br><span class="line"># 保存</span><br><span class="line">The partition table has been altered.</span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line">Syncing disks.</span><br></pre></td></tr></table></figure>
<p>在通过查看命令即可查看，新增的硬盘.</p>
<h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><p>ext4为分区格式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mkfs.ext4 /dev/sdb1</span><br></pre></td></tr></table></figure>
<h2 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mkdir /home/ybd/data</span><br><span class="line">sudo mount /dev/sdb1 /home/ybd/data</span><br></pre></td></tr></table></figure>
<h3 id="开机自动挂载"><a href="#开机自动挂载" class="headerlink" title="开机自动挂载"></a>开机自动挂载</h3><p>查看sdb1的UUID:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo blkid</span><br></pre></td></tr></table></figure>
<p>添加UUID到<code>/etc/fstab</code> 添加<code>UUID=63295b70-daec-4253-b659-821f51200be9 /home/data ext4 defaults,errors=remount-ro 0 1</code>到<code>/etc/fstab</code> 其中UUID后面跟sdb1的UUID 重启.</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>如果涉及新硬盘的权限问题，可以通过chown，chmod命令调整权限.</p>
<h1 id="letsencrypt-自动脚本"><a href="#letsencrypt-自动脚本" class="headerlink" title="letsencrypt 自动脚本"></a>letsencrypt 自动脚本</h1><p><strong><em><a href="https://github.com/Neilpang/acme.sh" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/Neilpang/acme.sh</a></em></strong></p>
<h1 id="Extend"><a href="#Extend" class="headerlink" title="Extend"></a>Extend</h1><h2 id="使用systemd设置开机启动"><a href="#使用systemd设置开机启动" class="headerlink" title="使用systemd设置开机启动"></a>使用systemd设置开机启动</h2><blockquote>
<p><a href="https://www.centos.bz/category/other-system/ubuntu/" rel="external nofollow noopener noreferrer" target="_blank">ubuntu</a>从16.04开始不再使用initd管理系统, 改用<a href="https://www.centos.bz/tag/systemd/" rel="external nofollow noopener noreferrer" target="_blank">systemd</a></p>
</blockquote>
<p><strong>为了像以前一样, 在<code>/etc/rc.local</code>中设置开机启动程序, 需要以下几步: </strong></p>
<p><strong>1、systemd默认读取<code>/etc/systemd/system</code>下的配置文件, 该目录下的文件会链接<code>/lib/systemd/system/</code>下的文件. 一般系统安装完<code>/lib/systemd/system/</code>下会有<code>rc-local.service</code>文件, 即我们需要的配置文件. </strong></p>
<p>链接过来: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -fs /lib/systemd/system/rc-local.service /etc/systemd/system/rc-local.service</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /etc/systemd/system/</span><br><span class="line">vim rc-local.service</span><br></pre></td></tr></table></figure>
<p><code>rc-local.service</code>内容: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#  This file is part of systemd.</span><br><span class="line">#</span><br><span class="line">#  systemd is free software; you can redistribute it and/or modify it</span><br><span class="line">#  under the terms of the GNU Lesser General Public License as published by</span><br><span class="line">#  the Free Software Foundation; either version 2.1 of the License, or</span><br><span class="line">#  (at your option) any later version.</span><br><span class="line"></span><br><span class="line"># This unit gets pulled automatically into multi-user.target by</span><br><span class="line"># systemd-rc-local-generator if /etc/rc.local is executable.</span><br><span class="line">[Unit]</span><br><span class="line">Description=/etc/rc.local Compatibility</span><br><span class="line">ConditionFileIsExecutable=/etc/rc.local</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/etc/rc.local start</span><br><span class="line">TimeoutSec=0</span><br><span class="line">RemainAfterExit=yes</span><br><span class="line">GuessMainPID=no</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">Alias=rc-local.service</span><br></pre></td></tr></table></figure>
<p><strong>2、创建/etc/rc.local文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch /etc/rc.local</span><br></pre></td></tr></table></figure>
<p><strong>3、赋可执行权限</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 755 /etc/rc.local</span><br></pre></td></tr></table></figure>
<p><strong>4、编辑rc.local, 添加需要开机启动的任务</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">echo &quot;test test &quot; &gt; /var/test_boot_up.log</span><br></pre></td></tr></table></figure>
<p><strong>5、执行reboot重启系统验证OK. </strong></p>
<p>最后, 说一下<code>/etc/systemd/system/</code>下的配置文件（<code>XXXX.service</code>）,<br>其中有三个配置项, <code>[Unit]</code> / <code>[Service]</code> / <code>[Install]</code></p>
<ul>
<li><code>[Unit]</code> 区块: 启动顺序与依赖关系. </li>
<li><code>[Service]</code> 区块: 启动行为,如何启动, 启动类型. </li>
<li><code>[Install]</code> 区块, 定义如何安装这个配置文件, 即怎样做到开机启动. </li>
</ul>
<h2 id="apt-get-update无法下载"><a href="#apt-get-update无法下载" class="headerlink" title="apt-get update无法下载"></a>apt-get update无法下载</h2><p><img src="https://cdn.yangbingdong.com/img/node-of-ubuntu-command/apt-get-update-fail.png" alt></p>
<p>出现类似情况, 可以找到<code>/etc/apt/sources.list.d</code>目录, 删除对应的<code>.list</code>文件即可.</p>
<h2 id="printf进制转换"><a href="#printf进制转换" class="headerlink" title="printf进制转换"></a>printf进制转换</h2><blockquote>
<p>二进制:binanry number</p>
<p>八进制:otcal number</p>
<p>十进制:decimal number</p>
<p>十六进制: hexadecimal number</p>
<p>一般使用jstack查找线程时候用到</p>
</blockquote>
<p>十进制转16进制:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">printf &quot;%x\n&quot; 666</span><br></pre></td></tr></table></figure>
<p>输出的是<code>29a</code>, 一般16进制前面会加个<code>0x</code>表示, 所以可以这样: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">printf &quot;0x%x\n&quot; 666</span><br></pre></td></tr></table></figure>
<p>16进制转十进制:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">printf &quot;%d\n&quot; 0x29a</span><br></pre></td></tr></table></figure>
<h2 id="Shell自动交互"><a href="#Shell自动交互" class="headerlink" title="Shell自动交互"></a>Shell自动交互</h2><h3 id="输入重定向Here-Document"><a href="#输入重定向Here-Document" class="headerlink" title="输入重定向Here Document"></a>输入重定向Here Document</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">ftp -i -n 192.168.167.187 &lt;&lt; EOF</span><br><span class="line">user hzc 123456</span><br><span class="line">pwd</span><br><span class="line">cd test</span><br><span class="line">pwd</span><br><span class="line">close</span><br><span class="line">bye</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<h3 id="管道，echo-sleep"><a href="#管道，echo-sleep" class="headerlink" title="管道，echo + sleep + |"></a>管道，echo + sleep + |</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">(echo &quot;curpassword&quot;</span><br><span class="line">sleep 1</span><br><span class="line">echo &quot;newpassword&quot;</span><br><span class="line">sleep 1</span><br><span class="line">echo &quot;newpassword&quot;)|passwd</span><br></pre></td></tr></table></figure>
<h3 id="expect"><a href="#expect" class="headerlink" title="expect"></a>expect</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install expect</span><br></pre></td></tr></table></figure>
<h2 id="Shell脚本加密"><a href="#Shell脚本加密" class="headerlink" title="Shell脚本加密"></a>Shell脚本加密</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install -y shc</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shc -e &quot;01/12/2019&quot; -m &quot;Script expired, pleace contact yangbingdong1994@gmail.com&quot; -v -r -T -f shell.sh</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-e</code>: 过期时间</li>
<li><code>-m</code>: 过期消息</li>
<li><code>-f</code>: 需要加密的脚本</li>
</ul>
<h2 id="写入文件或追加"><a href="#写入文件或追加" class="headerlink" title="写入文件或追加"></a>写入文件或追加</h2><p>有时候简单的东西不想通过 vi 编辑文件, 或者在脚本中需要写入或追加文字到文件中, 我们可以通过以下方式实现.</p>
<ol>
<li><p>单行通过 <code>echo</code> 实现:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 覆盖写入</span><br><span class="line">echo &quot;hello&quot; &gt; test.txt</span><br><span class="line"></span><br><span class="line"># 追加</span><br><span class="line">echo &quot;hello&quot; &gt;&gt; test.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>多行可以通过 <code>cat</code> 实现:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 覆盖写入</span><br><span class="line">cat &lt;&lt;- EOF &gt; test.txt</span><br><span class="line">hello1</span><br><span class="line">hello2</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"># 追加</span><br><span class="line">cat &lt;&lt;- EOF &gt;&gt; test.txt</span><br><span class="line">hello1</span><br><span class="line">hello2</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
</li>
<li><p>当文件需要权限时, 可使用 <code>tee</code> 命令实现:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 覆盖写入</span><br><span class="line">echo &quot;%sudo   ALL=(ALL:ALL) NOPASSWD:ALL&quot; | sudo tee /etc/sudoers.d/sudoers</span><br><span class="line"></span><br><span class="line"># 追加</span><br><span class="line">echo &quot;forward-socks5 / 127.0.0.1:1080 .&quot; | sudo tee -a /etc/privoxy/config</span><br></pre></td></tr></table></figure>
<p>当然也可以多行输入:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;- EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;$&#123;DOCKER_MIRRORS&#125;&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h1><p>附上 Linux 命令行的艺术: <strong><em><a href="https://github.com/jlevy/the-art-of-command-line" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/jlevy/the-art-of-command-line</a></em></strong></p>
]]></content><categories><category>OperatingSystem</category><category>Ubuntu</category></categories><tags><tag>Ubuntu</tag></tags></entry><entry><title>Ubuntu下使用IntelliJ IDEA的正确姿势</title><url>/2017/note-of-learning-idea-under-ubuntu/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/idea2.png" alt></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><blockquote>
<p>公司里的大牛们用的IDE基本都是IDEA<del>近墨者黑</del>, 早就听闻IntelliJ IDEA这个大名, 只不过当初比较菜鸟还不会用(…虽然现在也还是个菜鸟=.=), 再不用就要被OUT了<br>此篇把在Ubuntu下使用IDEA的学习经验记录下来(网上还是比较少资料解决Ubuntu下IDEA的问题Orz), 以便老了记性不好可以看一看…</p>
</blockquote>
<a id="more"></a>
<h1 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h1><p>博主采用<strong><em><a href="https://www.jetbrains.com/toolbox/app/" rel="external nofollow noopener noreferrer" target="_blank">Toolbox App</a></em></strong> 方式安装.<br>这样的好处是我们不用关心更新问题, 每次有新版本它都会提示, 我们是需要点一下<code>Install</code>就可以了, 不需要关心升级后的配置.<br>还有一个好处是可以管理其他的IntelliJ软件（虽然博主只用他们的IDEA = =）…<br>安装的时候注意<strong>配置安装路径</strong>:<br><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/idea-setting-path.png" alt></p>
<h1 id="License"><a href="#License" class="headerlink" title="License"></a>License</h1><blockquote>
<p>可参考 <strong><em><a href="http://idea.lanyus.com/" rel="external nofollow noopener noreferrer" target="_blank">http://idea.lanyus.com/</a></em></strong></p>
</blockquote>
<h2 id="2018-1-5以前版本"><a href="#2018-1-5以前版本" class="headerlink" title="2018.1.5以前版本"></a>2018.1.5以前版本</h2><p>注册码可以自己读娘, 或者使用授权服务器 </p>
<p>博主用的是基于docker的授权服务器: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull ilanyu/golang-reverseproxy</span><br><span class="line">docker run -d -p 6666:8888 ilanyu/golang-reverseproxy</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/license-server.png" alt></p>
<p>也可以自己搭建一个基于docker的服务 = =</p>
<p><a href="https://github.com/masteranthoneyd/docker-jetlicense" rel="external nofollow noopener noreferrer" target="_blank"><strong><em>https://github.com/masteranthoneyd/docker-jetlicense</em></strong></a></p>
<p>部署到VPS上, nginx反向代理: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;  </span><br><span class="line">    listen 80;  </span><br><span class="line">    server_name 域名;  </span><br><span class="line"></span><br><span class="line">    location / &#123;  </span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;  </span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  </span><br><span class="line">        proxy_set_header Host $http_host;  </span><br><span class="line">        proxy_set_header X-NginX-Proxy true;  </span><br><span class="line">        proxy_pass http://127.0.0.1:端口/;  </span><br><span class="line">        proxy_redirect off;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重启nginx: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>
<h1 id="Personal-Setting"><a href="#Personal-Setting" class="headerlink" title="Personal Setting"></a>Personal Setting</h1><p>博主的常用配置:<br>一般会选择打开项目时最外层的窗口打开<code>setting</code>, 对全局生效.<br><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/idea-setting.png" alt></p>
<h2 id="文件修改后-设置左边目录出现颜色变化"><a href="#文件修改后-设置左边目录出现颜色变化" class="headerlink" title="文件修改后, 设置左边目录出现颜色变化"></a>文件修改后, 设置左边目录出现颜色变化</h2><p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/version-control-change.png" alt></p>
<h2 id="如果只有一行方法的代码默认要展开-去掉这个勾"><a href="#如果只有一行方法的代码默认要展开-去掉这个勾" class="headerlink" title="如果只有一行方法的代码默认要展开, 去掉这个勾"></a>如果只有一行方法的代码默认要展开, 去掉这个勾</h2><p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/one-line-methods.png" alt></p>
<h2 id="修改字体和字号"><a href="#修改字体和字号" class="headerlink" title="修改字体和字号"></a>修改字体和字号</h2><p>Ubuntu下默认的字体还是让人看了有点<del>不爽</del>, 而且使用Ubuntu默认的字体工具栏可能会出现乱码.<br>下面三个地方, 分别是窗口字体, 代码字体和控制台字体:<br><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/idea-font.png" alt></p>
<h2 id="修改VM参数"><a href="#修改VM参数" class="headerlink" title="修改VM参数"></a>修改VM参数</h2><p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/idea-vm-setting.png" alt><br>通过<code>Toolbox</code>可以简单地设置VM参数, 博主16G内存的主机的VM参数设置为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xms512m</span><br><span class="line">-Xmx1500m</span><br><span class="line">-XX:ReservedCodeCacheSize=500m</span><br></pre></td></tr></table></figure></p>
<h2 id="设置代码不区分大小写"><a href="#设置代码不区分大小写" class="headerlink" title="设置代码不区分大小写"></a>设置代码不区分大小写</h2><p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/code-comlpetion.png" alt></p>
<h2 id="禁止-import"><a href="#禁止-import" class="headerlink" title="禁止 import *"></a>禁止 import *</h2><p>IDEA默认检测到有5个相同包就会自动<code>import *</code>, 其实没必要, 需要哪个就<code>import</code>哪个.<br><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/import-optimizing.png" alt></p>
<h2 id="设置不自动打开上一次最后关闭的项目"><a href="#设置不自动打开上一次最后关闭的项目" class="headerlink" title="设置不自动打开上一次最后关闭的项目"></a>设置不自动打开上一次最后关闭的项目</h2><p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/system-setting01.png" alt></p>
<h2 id="Postfix-Completion"><a href="#Postfix-Completion" class="headerlink" title="Postfix Completion"></a>Postfix Completion</h2><p>这个本来就是默认开启的<br><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/postfix-completion.png" alt></p>
<h2 id="可生成SreializableID"><a href="#可生成SreializableID" class="headerlink" title="可生成SreializableID"></a>可生成SreializableID</h2><p>在 <code>setting&gt;Editor&gt;Inspections&gt;Java&gt;Serializtion Issues&gt;</code>:<br><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/ger-serializtion.png" alt><br>钩上之后在需要生成的类上<code>Alt+Enter</code>就会出现了. </p>
<h2 id="关闭代码拖拽功能"><a href="#关闭代码拖拽功能" class="headerlink" title="关闭代码拖拽功能"></a>关闭代码拖拽功能</h2><p>一不小心手抖就改了代码…禁用！<br><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/dorp-function.png" alt></p>
<h2 id="显示内存使用情况"><a href="#显示内存使用情况" class="headerlink" title="显示内存使用情况"></a>显示内存使用情况</h2><p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/show-memory.png" alt><br>点击内存信息展示的那个条可以进行部分的内存回收<br><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/menory.png" alt></p>
<h2 id="优化-Java-注释"><a href="#优化-Java-注释" class="headerlink" title="优化 Java 注释"></a>优化 Java 注释</h2><p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/code-optimize.png" alt></p>
<h2 id="优化方法链"><a href="#优化方法链" class="headerlink" title="优化方法链"></a>优化方法链</h2><p>在Java8中特别是使用Stream API, ex:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.stream().filter(func).distinct().skip(num).limit(num).map(func).peek(func).collect(func);</span><br></pre></td></tr></table></figure></p>
<p>写成一行太长了！！<br>勾上这个选项idea将自动帮我们优化:<br><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/code-style-method-chain.png" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/method-chain.png" alt></p>
<blockquote>
<p>钩上 <code>Align when multiline</code> 可对其方法链</p>
</blockquote>
<p>会变成这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list = list.stream()</span><br><span class="line">		   .filter(func)</span><br><span class="line">		   .distinct()</span><br><span class="line">		   .....</span><br></pre></td></tr></table></figure>
<h2 id="多线程自动编译"><a href="#多线程自动编译" class="headerlink" title="多线程自动编译"></a>多线程自动编译</h2><p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/auto-compile.png" alt></p>
<h2 id="设置统一编译JDK版本（关闭module-JDK）"><a href="#设置统一编译JDK版本（关闭module-JDK）" class="headerlink" title="设置统一编译JDK版本（关闭module JDK）"></a>设置统一编译JDK版本（关闭module JDK）</h2><p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/idea-close-module-jdk.png" alt></p>
<h2 id="Tab-键改为4个空格"><a href="#Tab-键改为4个空格" class="headerlink" title="Tab 键改为4个空格"></a>Tab 键改为4个空格</h2><blockquote>
<p>代码规范会要求编程时使用4个空格缩进而不是tab, 因为不同编辑器下4个空格的宽度看起来是一致的, 而tab则长短可能会不一致。</p>
</blockquote>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/tab-setting.png" alt></p>
<h2 id="Maven-自动下载源码"><a href="#Maven-自动下载源码" class="headerlink" title="Maven 自动下载源码"></a>Maven 自动下载源码</h2><p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/maven-auto-download-source.png" alt></p>
<h2 id="自定义代码颜色"><a href="#自定义代码颜色" class="headerlink" title="自定义代码颜色"></a>自定义代码颜色</h2><h3 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h3><p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/idea-change-prameter-color.png" alt></p>
<h3 id="选择变量显示使用地方"><a href="#选择变量显示使用地方" class="headerlink" title="选择变量显示使用地方"></a>选择变量显示使用地方</h3><p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/idea-change-select-color.png" alt></p>
<h3 id="选中代码块的背景颜色"><a href="#选中代码块的背景颜色" class="headerlink" title="选中代码块的背景颜色"></a>选中代码块的背景颜色</h3><p>Selection background:</p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/selection-background-color.png" alt></p>
<h2 id="修改快捷键"><a href="#修改快捷键" class="headerlink" title="修改快捷键"></a>修改快捷键</h2><h3 id="Fix-doc-comment"><a href="#Fix-doc-comment" class="headerlink" title="Fix doc comment"></a>Fix doc comment</h3><p>打开 Setting, Keymap -&gt; Other -&gt; Fix doc comment</p>
<h2 id="统一代码风格"><a href="#统一代码风格" class="headerlink" title="统一代码风格"></a>统一代码风格</h2><h3 id="导入-Google-Code-Style"><a href="#导入-Google-Code-Style" class="headerlink" title="导入 Google Code Style"></a>导入 Google Code Style</h3><p>查看并下载: <em><a href="https://github.com/ningg/styleguide/blob/gh-pages/intellij-java-google-style.xml" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/ningg/styleguide/blob/gh-pages/intellij-java-google-style.xml</a></em></p>
<p>导入:</p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/set-code-style.png" alt></p>
<h3 id="使用-editorconfig-与-gitattributes"><a href="#使用-editorconfig-与-gitattributes" class="headerlink" title="使用 editorconfig 与 gitattributes"></a>使用 editorconfig 与 gitattributes</h3><p>在项目根目录中加入 <code>.editorconfig</code> :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># http://editorconfig.org</span><br><span class="line">root = true</span><br><span class="line"></span><br><span class="line"># 空格替代Tab缩进在各种编辑工具下效果一致</span><br><span class="line">[*]</span><br><span class="line">indent_style = space</span><br><span class="line">indent_size = 4</span><br><span class="line">charset = utf-8</span><br><span class="line">end_of_line = lf</span><br><span class="line">trim_trailing_whitespace = true</span><br><span class="line">insert_final_newline = true</span><br><span class="line"></span><br><span class="line">[*.java]</span><br><span class="line">indent_style = tab</span><br><span class="line"></span><br><span class="line">[*.&#123;json,yml&#125;]</span><br><span class="line">indent_size = 2</span><br><span class="line"></span><br><span class="line">[*.md]</span><br><span class="line">insert_final_newline = false</span><br><span class="line">trim_trailing_whitespace = false</span><br></pre></td></tr></table></figure>
<p>在项目根目录中加入 <code>.gitattributes</code> :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># All text files should have the &quot;lf&quot; (Unix) line endings</span><br><span class="line">* text eol=lf</span><br><span class="line"># windows cmd shoud have the &quot;crlf&quot; (Win32) line endings</span><br><span class="line">*.cmd eol=crlf</span><br><span class="line"></span><br><span class="line"># Explicitly declare text files you want to always be normalized and converted</span><br><span class="line"># to native line endings on checkout.</span><br><span class="line">*.java text</span><br><span class="line">*.js text</span><br><span class="line">*.css text</span><br><span class="line">*.html text</span><br><span class="line">*.properties text</span><br><span class="line">*.xml text</span><br><span class="line">*.yml text</span><br><span class="line"></span><br><span class="line"># Denote all files that are truly binary and should not be modified.</span><br><span class="line">*.png binary</span><br><span class="line">*.jpg binary</span><br><span class="line">*.jar binary</span><br><span class="line">*.ttf binary</span><br></pre></td></tr></table></figure>
<h1 id="Keyboard-shortcuts"><a href="#Keyboard-shortcuts" class="headerlink" title="Keyboard shortcuts"></a>Keyboard shortcuts</h1><blockquote>
<p>JetBrains官方快捷键手册: <em><a href="https://resources.jetbrains.com/storage/products/intellij-idea/docs/IntelliJIDEA_ReferenceCard.pdf" rel="external nofollow noopener noreferrer" target="_blank">https://resources.jetbrains.com/storage/products/intellij-idea/docs/IntelliJIDEA_ReferenceCard.pdf</a></em></p>
</blockquote>
<p>个人感觉Ubuntu下使用IDEA最大的一个不爽就是<strong>快捷键</strong>了, <del>想屎的感觉有木有</del>, 各种没反应, 原来是快捷键冲突, 本来想改成Eclipse的风格, 但想了想好像不太合适.<br>快捷键风格可以在<code>setting</code> -&gt; <code>Keymap</code> 里面这是, 博主使用安装时候idea默认配置的<code>Default for XWin</code>.<br>先来大致分各类（纯属个人看法= =）: </p>
<h2 id="导航（一般都可以在Navigate里面找到）"><a href="#导航（一般都可以在Navigate里面找到）" class="headerlink" title="导航（一般都可以在Navigate里面找到）"></a>导航（一般都可以在Navigate里面找到）</h2><table>
<thead>
<tr>
<th style="text-align:left">Keyboard shortcut</th>
<th style="text-align:left">Declaration</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>Ctrl+N</strong></td>
<td style="text-align:left">查找Java类</td>
</tr>
<tr>
<td style="text-align:left"><strong>Ctrl+Shift+N</strong></td>
<td style="text-align:left">查找非Java文件</td>
</tr>
<tr>
<td style="text-align:left"><strong>Ctrl+Shift+Alt+N</strong></td>
<td style="text-align:left">查找<strong>mvc接口</strong>、类中的方法或变量</td>
</tr>
<tr>
<td style="text-align:left"><strong>Double Shift</strong></td>
<td style="text-align:left">查找所有</td>
</tr>
<tr>
<td style="text-align:left"><strong>Ctrl+Alt+Left/Right</strong></td>
<td style="text-align:left">跳到光标的上/下一个位置</td>
</tr>
<tr>
<td style="text-align:left"><strong>F2/Shift+F2</strong></td>
<td style="text-align:left">光标移动到下/上一个错误</td>
</tr>
<tr>
<td style="text-align:left"><strong>Ctrl+Shift+Backspace</strong></td>
<td style="text-align:left">跳到上一个编辑处</td>
</tr>
<tr>
<td style="text-align:left"><strong>Ctrl+Alt+B</strong></td>
<td style="text-align:left">跳到实现类/方法</td>
</tr>
<tr>
<td style="text-align:left"><strong>Ctrl+U</strong></td>
<td style="text-align:left">跳到父类/方法</td>
</tr>
<tr>
<td style="text-align:left"><strong>Alt+Up/Down</strong></td>
<td style="text-align:left">光标移动到上/下一个方法</td>
</tr>
<tr>
<td style="text-align:left"><strong>Ctrl+F12</strong></td>
<td style="text-align:left">搜索当前文件方法</td>
</tr>
<tr>
<td style="text-align:left"><strong>Ctrl+H/Ctrl+Shift+H</strong></td>
<td style="text-align:left">显示类/方法层级</td>
</tr>
<tr>
<td style="text-align:left"><strong>F11/Shift+F11</strong></td>
<td style="text-align:left">当前行设置书签/显示所有书签</td>
</tr>
<tr>
<td style="text-align:left"><strong>Ctrl+G</strong></td>
<td style="text-align:left">跳到指定行</td>
</tr>
</tbody>
</table>
<h2 id="查找-替换（一般在Edit的find里面）"><a href="#查找-替换（一般在Edit的find里面）" class="headerlink" title="查找/替换（一般在Edit的find里面）"></a>查找/替换（一般在Edit的find里面）</h2><table>
<thead>
<tr>
<th style="text-align:left">Keyboard shortcut</th>
<th style="text-align:left">Declaration</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>Ctrl+F</strong></td>
<td style="text-align:left">文件内查找</td>
</tr>
<tr>
<td style="text-align:left"><strong>Ctrl+R</strong></td>
<td style="text-align:left">文件内替换</td>
</tr>
<tr>
<td style="text-align:left"><strong>F3/Shift+F3</strong></td>
<td style="text-align:left">查找下/上一个</td>
</tr>
<tr>
<td style="text-align:left"><strong>Ctrl+Shift+F</strong></td>
<td style="text-align:left">目录内查找</td>
</tr>
<tr>
<td style="text-align:left"><strong>Ctrl+Shift+R</strong></td>
<td style="text-align:left">目录内替换</td>
</tr>
<tr>
<td style="text-align:left"><strong>Ctrl+F7</strong></td>
<td style="text-align:left">查找当前文件中的使用处</td>
</tr>
<tr>
<td style="text-align:left"><strong>Alt+F7</strong></td>
<td style="text-align:left">查找被使用处</td>
</tr>
<tr>
<td style="text-align:left"><strong>Ctrl+Alt+F7</strong></td>
<td style="text-align:left">显示被使用处</td>
</tr>
</tbody>
</table>
<h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><table>
<thead>
<tr>
<th>Keyboard shortcut</th>
<th>Declaration</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Ctrl+D</strong></td>
<td>重复代码,未选择代码时重复当前行</td>
</tr>
<tr>
<td><strong>Ctrl+Y</strong></td>
<td>删除当前行</td>
</tr>
<tr>
<td><strong>Ctrl+Shift+Enter</strong></td>
<td>补全语句</td>
</tr>
<tr>
<td><strong>Ctrl+P</strong></td>
<td>显示方法参数</td>
</tr>
<tr>
<td><strong>Ctrl+Q</strong></td>
<td>显示注释文档</td>
</tr>
<tr>
<td><strong>Alt+Insert</strong></td>
<td>生成代码,生成 Getter、Setter、构造器等</td>
</tr>
<tr>
<td><strong>Ctrl+O/Ctrl+I</strong></td>
<td>重写父类方法/实现接口方法</td>
</tr>
<tr>
<td><strong>Ctrl+W</strong></td>
<td>选择代码块,连续按会增加选择外层的代码块</td>
</tr>
<tr>
<td><strong>Ctrl+Shift+W</strong></td>
<td>与“Ctrl+W”相反,减少选择代码块</td>
</tr>
<tr>
<td><strong>Ctrl+Alt+L</strong></td>
<td>格式化代码</td>
</tr>
<tr>
<td><strong>Ctrl+Alt+O</strong></td>
<td>优化 Imports</td>
</tr>
<tr>
<td><strong>Ctrl+Shift+J</strong></td>
<td>合并多行为一行</td>
</tr>
<tr>
<td><strong>Ctrl+Shift+U</strong></td>
<td>对选中内容进行大小写切换</td>
</tr>
<tr>
<td><strong>Ctrl+Shift+]/[</strong></td>
<td>选中到代码块的开始/结束</td>
</tr>
<tr>
<td><strong>Ctrl+Delete/Ctrl+Backspace</strong></td>
<td>删除从光标所在位置到单词结束/开头处</td>
</tr>
<tr>
<td><strong>Ctrl+F4</strong></td>
<td>关闭当前编辑页</td>
</tr>
<tr>
<td><strong>Alt+J/Ctrl+Alt+Shift+J</strong></td>
<td>匹配下一个/全部与当前选中相同的代码</td>
</tr>
<tr>
<td><strong>Alt+Shift+J</strong></td>
<td>“Alt+J”的反选</td>
</tr>
<tr>
<td><strong>Alt+Shift+Insert,然后Shift+Up/Down</strong></td>
<td>同时编辑多行(退出此<code>Column</code>模式也是“Alt+Shift+Insert”)</td>
</tr>
</tbody>
</table>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><table>
<thead>
<tr>
<th>Keyboard shortcut</th>
<th>Declaration</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>F8/F7</strong></td>
<td>单步调试,不进入函数内部/进入函数内部</td>
</tr>
<tr>
<td><strong>Shift+F8</strong></td>
<td>跳出函数</td>
</tr>
<tr>
<td><strong>Alt+F9</strong></td>
<td>运行到断点</td>
</tr>
<tr>
<td><strong>Alt+F8</strong></td>
<td>执行表达式查看结果</td>
</tr>
<tr>
<td><strong>F9</strong></td>
<td>继续执行,进入下一个断点或执行完程序</td>
</tr>
<tr>
<td><strong>Ctrl+Shift+F8</strong></td>
<td>查看断点</td>
</tr>
</tbody>
</table>
<h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><table>
<thead>
<tr>
<th>Keyboard shortcut</th>
<th>Declaration</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>F6</strong></td>
<td>移动类</td>
</tr>
<tr>
<td><strong>Alt+Delete</strong></td>
<td>安全删除,删除前会提示调用处</td>
</tr>
<tr>
<td><strong>Shift+F6</strong></td>
<td>重命名</td>
</tr>
<tr>
<td><strong>Ctrl+F6</strong></td>
<td>重构方法参数、Exception 等</td>
</tr>
<tr>
<td><strong>Ctrl+Alt+M</strong></td>
<td>提取为新方法</td>
</tr>
<tr>
<td><strong>Ctrl+Alt+V</strong></td>
<td>提取为新变量</td>
</tr>
<tr>
<td><strong>Ctrl+Alt+F</strong></td>
<td>提取为对象新属性</td>
</tr>
<tr>
<td><strong>Ctrl+Alt+C</strong></td>
<td>提取为新静态常量</td>
</tr>
<tr>
<td><strong>Ctrl+Alt+P</strong></td>
<td>提取为方法参数</td>
</tr>
<tr>
<td><strong>Ctrl+Shift+Alt+P</strong></td>
<td>提取为函数式参数</td>
</tr>
<tr>
<td><strong>Ctrl+Alt+Shift+T</strong></td>
<td>重构一切</td>
</tr>
</tbody>
</table>
<h1 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h1><h2 id="IDE-Features-Trainer"><a href="#IDE-Features-Trainer" class="headerlink" title="IDE Features Trainer"></a>IDE Features Trainer</h2><p>IDEA 使用教程, 安装后在左上角会出现 Learn 的栏目, 可在其中进行学习.</p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/plugin-learn.png" alt></p>
<h2 id="RestfulToolkit"><a href="#RestfulToolkit" class="headerlink" title="RestfulToolkit"></a>RestfulToolkit</h2><p>提供 Restful 开发工具箱, 可通过 <code>Ctrl + Alt + N</code> 搜索 url 方法</p>
<h2 id="Codota"><a href="#Codota" class="headerlink" title="Codota"></a>Codota</h2><p><em><a href="https://www.codota.com/" rel="external nofollow noopener noreferrer" target="_blank">Codota</a></em> 这个插件用于智能代码补全, 它基于数百万Java程序, 能够根据程序上下文提示补全代码</p>
<h2 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h2><p>1.首先在IDEA里面安装使用lombok编写简略风格代码的插件,<br>打开IDEA的Settings面板, 并选择Plugins选项, 然后点击 “Browse repositories..”<br><img src="https://cdn.yangbingdong.com/img/lombok/installLombok01.png" alt><br>在输入框输入”lombok”, 得到搜索结果, 选择第二个, 点击安装, 然后安装提示重启IDEA, 安装成功;<br><img src="https://cdn.yangbingdong.com/img/lombok/installLombok02.png" alt></p>
<p> 还需要在IDEA中开启支持: </p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/annotation-support.png" alt></p>
<p>2.在自己的项目里添加lombok的编译支持(maven项目),在pom文件里面添加如下<br>indenpence</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>3.然后就可以尽情在自己项目里面编写简略风格的Java代码咯<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lombok;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.EqualsAndHashCode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span>(callSuper = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> sex;</span><br><span class="line">    Integer age;</span><br><span class="line">    String address;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; books;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用Student类对象</span></span><br><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line">student.setName(name);</span><br><span class="line">student.setAge(age);</span><br><span class="line">student.setAddress(address);</span><br><span class="line">student.setBooks(Arrays.asList(books));</span><br></pre></td></tr></table></figure></p>
<p>4.常用注解</p>
<ul>
<li><p><code>@Getter</code> and <code>@Setter</code>: 生成<code>getter</code> / <code>setter</code>方法, 默认生成的方法是public的, 如果要修改方法修饰符可以设置<strong>AccessLevel</strong>的值, 例如: <code>@Getter(access = AccessLevel.PROTECTED)</code></p>
</li>
<li><p><code>@ToString</code>: 生成toString()方法, 可以这样设置不包含哪些字段<code>@ToString(exclude = &quot;id&quot;)</code> / <code>@ToString(exclude = {&quot;id&quot;,&quot;name&quot;})</code>, 如果继承的有父类的话, 可以设置<strong>callSuper</strong> 让其调用父类的toString()方法, 例如: <code>@ToString(callSuper = true)</code></p>
</li>
<li><p><code>@NoArgsConstructor</code>, <code>@RequiredArgsConstructor</code>, <code>@AllArgsConstructor</code>: <code>@NoArgsConstructor</code>生成一个无参构造方法. 当类中有final字段没有被初始化时, 编译器会报错, 此时可用<code>@NoArgsConstructor(force = true)</code>, 然后就会为没有初始化的<code>final</code>字段设置默认值 <code>0</code> / <code>false</code> / <code>null</code>. 对于具有约束的字段（例如<code>@NonNul</code>l字段）, 不会生成检查或分配, 因此请注意, 正确初始化这些字段之前, 这些约束无效. <code>@RequiredArgsConstructor</code>会生成构造方法（可能带参数也可能不带参数）, 如果带参数, 这参数只能是以final修饰的未经初始化的字段, 或者是以<code>@NonNull</code>注解的未经初始化的字段<code>@RequiredArgsConstructor(staticName = &quot;of&quot;)</code>会生成一个<code>of()</code>的静态方法, 并把构造方法设置为私有. <code>@AllArgsConstructor</code> 生成一个全参数的构造方法. </p>
</li>
<li><p><code>@Data</code>: <code>@Data</code> 包含了<code>@ToString</code>, <code>@EqualsAndHashCode</code>, <code>@Getter</code> / <code>@Setter</code>和<code>@RequiredArgsConstructor</code>的功能. </p>
</li>
<li><p><code>@Accessors</code>: 主要用于控制生成的<code>getter</code>和<code>setter</code>, 此注解有三个参数: <code>fluent boolean</code>值, 默认为<code>false</code>. 此字段主要为控制生成的<code>getter</code>和<code>setter</code>方法前面是否带<code>get/set</code>；<code>chain boolean</code>值, 默认<code>false</code>. 如果设置为<code>true</code>, <code>setter</code>返回的是此对象, 方便链式调用方法<code>prefix</code> 设置前缀 例如: <code>@Accessors(prefix = &quot;abc&quot;) private String abcAge</code>  当生成<code>get</code>/<code>set</code>方法时, 会把此前缀去掉. </p>
</li>
<li><p><code>@Synchronized</code>: 给方法加上同步锁. </p>
</li>
<li><p><code>@Builder</code>: <code>@Builder</code>注释为你的类生成复杂的构建器<code>API</code>: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person.builder().name(&quot;Adam Savage&quot;).city(&quot;San Francisco&quot;).job(&quot;Mythbusters&quot;).job(&quot;Unchained Reaction&quot;).build();</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>@NonNull</code>: 如其名, 不能为空, 否则抛出<code>NullPointException</code></p>
</li>
<li><p><code>Log</code>类: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CommonsLog</span></span><br><span class="line">Creates <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog(LogExample<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="meta">@JBossLog</span></span><br><span class="line">Creates <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.jboss.logging.Logger log = org.jboss.logging.Logger.getLogger(LogExample<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="meta">@Log</span></span><br><span class="line">Creates <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.util.logging.Logger log = java.util.logging.Logger.getLogger(LogExample<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"><span class="meta">@Log</span>4j</span><br><span class="line">Creates <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(LogExample<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line">Creates <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.apache.logging.log4j.Logger log = org.apache.logging.log4j.LogManager.getLogger(LogExample<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line">Creates <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LogExample<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="meta">@XSlf</span>4j</span><br><span class="line">Creates <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.slf4j.ext.XLogger log = org.slf4j.ext.XLoggerFactory.getXLogger(LogExample<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><code>@SneakyThrows</code>: 将 Checked Exception 转换成 <code>RuntimeException</code></li>
</ul>
<p><code>Lombok</code>的功能不仅如此, 更详细请看<strong><em><a href="https://projectlombok.org/features/all" rel="external nofollow noopener noreferrer" target="_blank">features</a></em></strong></p>
<h2 id="Docker-Integration"><a href="#Docker-Integration" class="headerlink" title="Docker Integration"></a>Docker Integration</h2><p>可以通过IDEA链接Docker API, 前提是开启了Docker API</p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/docker-integration01.png" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/docker-integration02.png" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/docker-integration03.png" alt></p>
<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><p>Zookeeper UI, 支持删除操作</p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/zookeeper-plugin1.png" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/zookeeper-plugin2.png" alt></p>
<h2 id="K8s工具：Kubernetes"><a href="#K8s工具：Kubernetes" class="headerlink" title="K8s工具：Kubernetes"></a>K8s工具：Kubernetes</h2><p>参考 <em><a href="https://plugins.jetbrains.com/plugin/10485-kubernetes" rel="external nofollow noopener noreferrer" target="_blank">https://plugins.jetbrains.com/plugin/10485-kubernetes</a></em> 支持编辑 Kubernetes 资源文件, 如下： 可以比较方便的查看yaml中的各项 placeholder 的默认值, 且可以方便的链接到value位置。</p>
<h2 id="GsonFormat"><a href="#GsonFormat" class="headerlink" title="GsonFormat"></a>GsonFormat</h2><p>复制一段JSON格式字符串</p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/gson-format01.png" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/gson-format02.png" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/gson-format03.png" alt></p>
<h2 id="POJO-to-JSON"><a href="#POJO-to-JSON" class="headerlink" title="POJO to JSON"></a>POJO to JSON</h2><p>为了测试需要, 我们需要将简单 Java 领域对象转成 JSON 字符串方便用 postman 或者 curl 模拟数据。详细使用文档, 参考：<em><a href="https://plugins.jetbrains.com/plugin/9686-pojo-to-json" rel="external nofollow noopener noreferrer" target="_blank">https://plugins.jetbrains.com/plugin/9686-pojo-to-json</a></em></p>
<h2 id="CamelCase"><a href="#CamelCase" class="headerlink" title="CamelCase"></a>CamelCase</h2><p>下划线转驼峰插件, 安装好之后可通过快捷键 <code>Shift+Alt+U</code> 更换驼峰.</p>
<h2 id="Grep-Console"><a href="#Grep-Console" class="headerlink" title="Grep Console"></a>Grep Console</h2><p>参考：<em><a href="https://plugins.jetbrains.com/plugin/7125-grep-console" rel="external nofollow noopener noreferrer" target="_blank">https://plugins.jetbrains.com/plugin/7125-grep-console</a></em></p>
<h2 id="Free-Mybatis-Plugin"><a href="#Free-Mybatis-Plugin" class="headerlink" title="Free Mybatis Plugin"></a>Free Mybatis Plugin</h2><p>可以直接从Mapper文件跳转到xml: </p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/free-mybatis.png" alt></p>
<h2 id="MyBatisCodeHelper-Pro"><a href="#MyBatisCodeHelper-Pro" class="headerlink" title="MyBatisCodeHelper-Pro"></a>MyBatisCodeHelper-Pro</h2><p>插件地址: <strong><em><a href="https://github.com/gejun123456/MyBatisCodeHelper-Pro" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/gejun123456/MyBatisCodeHelper-Pro</a></em></strong></p>
<p>Crack: <strong><em><a href="https://github.com/pengzhile/MyBatisCodeHelper-Pro-Crack" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/pengzhile/MyBatisCodeHelper-Pro-Crack</a></em></strong></p>
<h2 id="Ali规约插件-P3C"><a href="#Ali规约插件-P3C" class="headerlink" title="Ali规约插件 P3C"></a>Ali规约插件 P3C</h2><p>插件地址: <strong><em><a href="https://github.com/alibaba/p3c" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/alibaba/p3c</a></em></strong><br>文档: <strong><em><a href="https://github.com/alibaba/p3c/blob/master/idea-plugin/README_cn.md" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/alibaba/p3c/blob/master/idea-plugin/README_cn.md</a></em></strong></p>
<h2 id="FindBugs"><a href="#FindBugs" class="headerlink" title="FindBugs"></a>FindBugs</h2><p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/find-bug.png" alt><br>装完之后右键最下面会多出一个<code>FindBugs</code>的选项</p>
<h2 id="Maven-Helper"><a href="#Maven-Helper" class="headerlink" title="Maven Helper"></a>Maven Helper</h2><p>这个主要可以分析maven依赖冲突. </p>
<p>安装之后, 打开<code>pom.xml</code>文件, 会看到多了一个Dependency Analyzer的面板, 点击可以进入分析面板: </p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/maven-helper01.png" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/maven-helper02.png" alt></p>
<p>另外, 右键项目也会多两个Maven的bar: </p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/maven-helper03.png" alt></p>
<h2 id="Statistic"><a href="#Statistic" class="headerlink" title="Statistic"></a>Statistic</h2><p>这个插件可以统计代码数量: </p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/maven-helper04.png" alt></p>
<h2 id="Stackoverflow"><a href="#Stackoverflow" class="headerlink" title="Stackoverflow"></a>Stackoverflow</h2><p>看名字就知道这个是干嘛的啦, 在plugin repostories直接搜索stackoverflow就找得到</p>
<p>重启后随便选中内容右键就可以看到</p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/idea-stackoverflow.png" alt></p>
<h2 id="Background-Image-Plus"><a href="#Background-Image-Plus" class="headerlink" title="Background Image Plus"></a>Background Image Plus</h2><p>这是一个设置背景图的插件</p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/background-image-plus.png" alt></p>
<p><strong>在 2020+ 版本中已经自带设置背景功能</strong>:</p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/setting-background-image.png" alt></p>
<h2 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h2><p>详细使用文档, 参考：<strong><em><a href="https://github.com/YiiGuxing/TranslationPlugin" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/YiiGuxing/TranslationPlugin</a></em></strong></p>
<p>有道智云: <strong><em><a href="https://ai.youdao.com/" rel="external nofollow noopener noreferrer" target="_blank">https://ai.youdao.com/</a></em></strong></p>
<p>快捷键:</p>
<ul>
<li>翻译: <code>Ctrl</code> + <code>Shift</code> + <code>Y</code></li>
<li>翻译并替换: <code>Ctrl</code> + <code>Shift</code> + <code>X</code></li>
</ul>
<h2 id="Enso"><a href="#Enso" class="headerlink" title="Enso"></a>Enso</h2><p>它可以将测试名转化成一个句子, 一目了然地显示测试的内容. 这意味着当你在注视任何类的时候, Enso 都会展示其说明文档. </p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/plugin-enso.png" alt></p>
<h2 id="Rainbow-Brackets"><a href="#Rainbow-Brackets" class="headerlink" title="Rainbow Brackets"></a>Rainbow Brackets</h2><blockquote>
<p><strong><em><a href="https://github.com/izhangzhihao/intellij-rainbow-brackets" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/izhangzhihao/intellij-rainbow-brackets</a></em></strong></p>
</blockquote>
<p>这个可以实现配对括号相同颜色, 并且实现选中区域代码高亮的功能, 对增强写代码的有趣性和排错等都有一些帮助。</p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/with-material-theme-ui.png" alt></p>
<p>高亮效果:  Ctrl+鼠标右键单击</p>
<p>选中部分外暗淡效果: Alt+鼠标右键单击</p>
<h2 id="Checkstyle"><a href="#Checkstyle" class="headerlink" title="Checkstyle"></a>Checkstyle</h2><p><code>checks.xml</code>: <em><a href="https://github.com/ningg/checkstyle/blob/master/src/main/resources/google_checks.xml" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/ningg/checkstyle/blob/master/src/main/resources/google_checks.xml</a></em></p>
<p>安装完以后在 Other Settings 中配置 Checkstyle:</p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/check-style-config-2-configure.png" alt></p>
<p>利用 Checkstyle 进行 check: (3 种, 可以使用一种)</p>
<ul>
<li><code>Check Current file</code></li>
<li><code>Check All Modified file</code></li>
<li><code>Check Project</code></li>
</ul>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/check-style-config-3-usage.png" alt></p>
<h2 id="Jclasslib"><a href="#Jclasslib" class="headerlink" title="Jclasslib"></a>Jclasslib</h2><blockquote>
<p>这是一个查看Java字节码的插件</p>
</blockquote>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/idea-plugin-jclasslib.png" alt></p>
<h2 id="JOL"><a href="#JOL" class="headerlink" title="JOL"></a>JOL</h2><blockquote>
<p>Java Object Layout, 查看Java对象大小的插件</p>
</blockquote>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/idea-plugin-jol.png" alt></p>
<h1 id="Theme"><a href="#Theme" class="headerlink" title="Theme"></a>Theme</h1><h2 id="Cyan-Light-Theme"><a href="#Cyan-Light-Theme" class="headerlink" title="Cyan Light Theme"></a>Cyan Light Theme</h2><p><strong><em><a href="https://plugins.jetbrains.com/plugin/12102-cyan-light-theme" rel="external nofollow noopener noreferrer" target="_blank">https://plugins.jetbrains.com/plugin/12102-cyan-light-theme</a></em></strong> </p>
<p>个人觉得比较舒适的主题, 清新, 没有多余的花里胡哨.</p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/theme-cyan.png" alt></p>
<h2 id="Material-Theme"><a href="#Material-Theme" class="headerlink" title="Material Theme"></a>Material Theme</h2><p>漂亮的主题插件, 内置了多种主题, 主题浏览: <strong><em><a href="https://www.material-theme.com/" rel="external nofollow noopener noreferrer" target="_blank">https://www.material-theme.com/</a></em></strong></p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/theme-material-oceanic.png" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/theme-material-github.png" alt></p>
<p>配置说明: <strong><em><a href="https://blog.csdn.net/zyx1260168395/article/details/102928172" rel="external nofollow noopener noreferrer" target="_blank">Material Theme UI详解</a></em></strong></p>
<h1 id="Icons"><a href="#Icons" class="headerlink" title="Icons"></a>Icons</h1><h2 id="Atom-Material-Icons"><a href="#Atom-Material-Icons" class="headerlink" title="Atom Material Icons"></a>Atom Material Icons</h2><p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/atom-material-icons.png" alt></p>
<h1 id="Skills"><a href="#Skills" class="headerlink" title="Skills"></a>Skills</h1><h2 id="演出模式"><a href="#演出模式" class="headerlink" title="演出模式"></a>演出模式</h2><p>此模式将<code>IDEA</code>弄到最大, 可以让你只关注一个类里面的代码, 进行毫无干扰的<code>coding</code>. </p>
<p>可以使用<code>Alt+V</code>快捷键, 弹出<code>View</code>视图, 然后选择<code>Enter Presentation Mode</code></p>
<p>若<code>Alt+V</code>没有设置快捷键, 可在<code>Keymap</code>中设置: </p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/keymap-view.png" alt></p>
<p>退出: 使用<code>ALT+V</code>弹出view视图, 然后选择<code>Exit Presentation Mode</code> 即可. </p>
<h2 id="Inject-language-编辑JSON"><a href="#Inject-language-编辑JSON" class="headerlink" title="Inject language 编辑JSON"></a>Inject language 编辑JSON</h2><p>如果使用<code>IDEA</code>在编写<code>JSON</code>字符串的时候, 然后要一个一个<code>\</code>去转义双引号的话, 就实在太不应该了, 又烦又容易出错. 在<code>IDEA</code>可以使用<code>Inject language</code>帮我们自动转义双引号. </p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/inject-language.png" alt></p>
<p>然后搜索<code>json</code>: </p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/inject-language-json.png" alt></p>
<p>选择完后. 鼠标焦点自动会定位在双引号里面, 这个时候你再次使用<code>alt+enter</code>就可以看到 :</p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/inject-language-json-edit-new.png" alt></p>
<p>选中<code>Edit JSON Fragment</code>并回车, 就可以看到编辑<code>JSON</code>文件的视图了:</p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/inject-language-json-edit-result.png" alt></p>
<h2 id="使用快捷键移动分割线"><a href="#使用快捷键移动分割线" class="headerlink" title="使用快捷键移动分割线"></a>使用快捷键移动分割线</h2><p>有时候想要拖拉项目视图的分割线: </p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/project-view-hide.png" alt></p>
<p>可以先<code>alt+1</code>把鼠标焦点定位到<code>project</code>视图里, 然后直接使用<code>ctrl+shift+左右箭头</code>来移动分割线. </p>
<p>再按<code>esc</code>返回代码. </p>
<h2 id="把鼠标定位到project视图里"><a href="#把鼠标定位到project视图里" class="headerlink" title="把鼠标定位到project视图里"></a>把鼠标定位到project视图里</h2><p>使用<code>alt+F1</code>, 弹出<code>Select in</code>视图, 然后选择<code>Project View</code>中的<code>Project</code>, 回车, 就可以立刻定位到类的位置了. </p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/locate-project.png" alt></p>
<p>使用<code>esc</code>或者<code>F4</code>跳回代码. </p>
<h2 id="自动生成not-null判断语句"><a href="#自动生成not-null判断语句" class="headerlink" title="自动生成not null判断语句"></a>自动生成not null判断语句</h2><p>变量后输入<code>.not</code>或者<code>.nn</code>: </p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/edit-notnull.png" alt></p>
<p>更多模板可查看设置中的<code>Postfix Completion</code>. </p>
<h2 id="生成-Try-Catch"><a href="#生成-Try-Catch" class="headerlink" title="生成 Try Catch"></a>生成 Try Catch</h2><p>使用<code>Ctrl + w</code>选中区域后按下<code>Ctrl + Shift + t</code>:</p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/try-catch.png" alt></p>
<h1 id="VM-Options"><a href="#VM-Options" class="headerlink" title="VM Options"></a>VM Options</h1><p>可以通过ToolBox或IDEA选项里面设置</p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/vmoption1.jpg" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/vmoption2.jpg" alt></p>
<p>优化参数(32G内存): </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-server</span><br><span class="line">-Xms2048m</span><br><span class="line">-Xmx4096m</span><br><span class="line">-Xmn1024m</span><br><span class="line">-XX:MetaspaceSize=256m</span><br><span class="line">-XX:MaxMetaspaceSize=2048m</span><br><span class="line">-XX:ReservedCodeCacheSize=512m</span><br><span class="line">-XX:+UseG1GC</span><br><span class="line">-XX:-UseConcMarkSweepGC</span><br><span class="line">-XX:SoftRefLRUPolicyMSPerMB=200</span><br><span class="line">-XX:+UseCompressedOops</span><br><span class="line">-ea</span><br><span class="line">-Dsun.io.useCanonCaches=false</span><br><span class="line">-Djava.net.preferIPv4Stack=true</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:-OmitStackTraceInFastThrow</span><br><span class="line">-Dsun.awt.keepWorkingSetOnMinimize=true</span><br><span class="line">-Dide.no.platform.update=true</span><br><span class="line">-Djdk.http.auth.tunneling.disabledSchemes=&quot;&quot;</span><br><span class="line">-javaagent:/home/ybd/data/application/jetbrains/JetbrainsCrack.jar</span><br><span class="line">-XX:MaxJavaStackTraceDepth=10000</span><br></pre></td></tr></table></figure>
<p><strong>部分参数说明</strong>: </p>
<p><code>-Xms2048m</code>: 初始时内存大小, 至少为<code>Xmx</code>的二分之一</p>
<p><code>-Xmx2048m</code>: 最大内存大小, 若总内存小于2GB, 至少为总内存的四分之一；若总内存大于2GB, 设为1-4GB</p>
<p><code>-XX:+UseG1GC -XX:-UseParNewGC -XX:-UseConcMarkSweepGC</code>: 设置使用G1垃圾收集器 </p>
<p><code>-server</code>: JVM以server的方式运行, 启动速度慢, 运行速度快</p>
<p><code>-Dsun.awt.keepWorkingSetOnMinimize=true</code>: 让IDEA最小化后阻止JVM对其进行修剪</p>
<h1 id="Conflict-of-keyboard-shortcuts"><a href="#Conflict-of-keyboard-shortcuts" class="headerlink" title="Conflict of keyboard shortcuts"></a>Conflict of keyboard shortcuts</h1><p>快捷键有冲突, 创建脚本并执行:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash  </span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings toggle-shaded <span class="string">"[]"</span> </span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.settings-daemon.plugins.media-keys screencast <span class="string">"[]"</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings switch-to-workspace-left <span class="string">"[]"</span> </span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings switch-to-workspace-right <span class="string">"[]"</span></span><br><span class="line">gsettings <span class="built_in">set</span> org.gnome.desktop.wm.keybindings begin-move <span class="string">"[]"</span></span><br></pre></td></tr></table></figure></p>
<p>如果是习惯Windows下的快捷键, 那么可以<strong>禁用TTY</strong>（IDEA Ctrl+Alt+F1-6冲突）: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FILE_NAME=/usr/share/X11/xorg.conf.d/50-novtswitch.conf &amp;&amp;\</span><br><span class="line">sudo touch $&#123;FILE_NAME&#125; &amp;&amp; \</span><br><span class="line">sudo tee $&#123;FILE_NAME&#125; &lt;&lt; EOF</span><br><span class="line"> Section &quot;ServerFlags&quot;</span><br><span class="line">Option &quot;DontVTSwitch&quot; &quot;true&quot;</span><br><span class="line">EndSection</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p><strong>目前发现的快捷键冲突: </strong><br>1、<code>Ctrl+Alt+方向</code>, 直接到系统设置里面改:<br><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/idea-setting-keyboard.png" alt></p>
<p>2、安装了搜狗之后, 按<code>Ctrl+Alt+B</code>会启动虚拟键盘, 所以在输入法里面打开Fcitx设置, 在附加组件里面, 点击高级, 再把虚拟键盘的选项去掉:<br><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/idea-sougou-conflict.png" alt><br>然后注销或重启电脑. </p>
<p>3、<code>Ctrl+Alt+S</code>, 这个在键盘设置里面找了很久, 原来这玩意在输入法设置里面, 点开输入法全局配置, 把<strong>显示高级选项</strong>钩上, 就会看到很多快捷键, 我都把它们干掉了.<br><img src="https://cdn.yangbingdong.com/img/learning-idea-under-ubuntu/shurufa.png" alt></p>
<h1 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h1><blockquote>
<p>IDEA真的智能到没朋友…<br>如果喜欢IDEA这款软件, 并且有经济能力的, 请付费购买~</p>
</blockquote>
]]></content><categories><category>IDE</category></categories><tags><tag>Ubuntu</tag><tag>IDE</tag></tags></entry><entry><title>Spring Boot应用集成Docker并结合Log4j2、Kafka、ELK管理Docker日志</title><url>/2018/spring-boot-docker-elk/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/spring-cloud-docker-integration/java-docker.png" alt></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><blockquote>
<p>微服务架构下, 微服务在带来良好的设计和架构理念的同时, 也带来了运维上的额外复杂性, 尤其是在服务部署和服务监控上. 单体应用是集中式的, 就一个单体跑在一起, 部署和管理的时候非常简单, 而微服务是一个网状分布的, 有很多服务需要维护和管理, 对它进行部署和维护的时候则比较复杂. 集成Docker之后, 我们可以很方便地部署以及编排服务, ELK的集中式日志管理可以让我们很方便地聚合Docker日志. </p>
</blockquote>
<a id="more"></a>
<h1 id="Log4j2-Related"><a href="#Log4j2-Related" class="headerlink" title="Log4j2 Related"></a>Log4j2 Related</h1><h2 id="使用Log4j2"><a href="#使用Log4j2" class="headerlink" title="使用Log4j2"></a>使用Log4j2</h2><p>下面是 Log4j2  官方性能测试结果: </p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/log4j2-performance.png" alt></p>
<h3 id="Maven配置"><a href="#Maven配置" class="headerlink" title="Maven配置"></a>Maven配置</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring Boot 依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 去除 logback 依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 日志 Log4j2 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Log4j2 异步支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lmax<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>disruptor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>: </p>
<ul>
<li>需要单独把<code>spring-boot-starter</code>里面的<code>logging</code>去除再引入<code>spring-boot-starter-web</code>, 否则后面引入的<code>starter</code>模块带有的<code>logging</code>不会自动去除</li>
<li><code>Disruptor</code>需要<strong>3.3.8</strong>以及以上版本</li>
</ul>
<h3 id="开启全局异步以及Disruptor参数设置"><a href="#开启全局异步以及Disruptor参数设置" class="headerlink" title="开启全局异步以及Disruptor参数设置"></a>开启全局异步以及Disruptor参数设置</h3><blockquote>
<p>官方说明: <strong><em><a href="https://logging.apache.org/log4j/2.x/manual/async.html#AllAsync" rel="external nofollow noopener noreferrer" target="_blank">https://logging.apache.org/log4j/2.x/manual/async.html#AllAsync</a></em></strong></p>
</blockquote>
<p>添加<code>Disruptor</code>依赖后只需要添加启动参数: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Dlog4j2.contextSelector=org.apache.logging.log4j.core.async.AsyncLoggerContextSelector</span><br></pre></td></tr></table></figure>
<p>也可以在程序启动时添加系统参数. </p>
<blockquote>
<p>若想知道Disruptor是否生效, 可以在<code>AsyncLogger#logMessage</code>中断点</p>
</blockquote>
<p>加大队列参数: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-DAsyncLogger.RingBufferSize=262144</span><br><span class="line">-DAsyncLoggerConfig.RingBufferSize=262144</span><br></pre></td></tr></table></figure>
<p>设置队列满了时的处理策略: 丢弃, 否则默认blocking, 异步就与同步无异了: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Dlog4j2.AsyncQueueFullPolicy=Discard</span><br></pre></td></tr></table></figure>
<h3 id="系统时钟参数"><a href="#系统时钟参数" class="headerlink" title="系统时钟参数"></a>系统时钟参数</h3><p>通过 <code>log4j2.clock</code> 指定, 默认使用 <code>SystemClock</code>, 我们可以使用 <code>org.apache.logging.log4j.core.util.CachedClock</code>. 其他选项看接口实现类, 也可以自己实现 <code>Clock</code> 接口.</p>
<h3 id="Log4j-环境变量配置文件"><a href="#Log4j-环境变量配置文件" class="headerlink" title="Log4j 环境变量配置文件"></a>Log4j 环境变量配置文件</h3><p>上面的全局异步以及系统始终参数配置都是通过系统环境变量来设置的, 下面方式可以通过配置文件的方式来设置.</p>
<p>在 <code>resource</code> 下定义 <code>log4j2.component.properties</code>  配置文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Log4jContextSelector=org.apache.logging.log4j.core.async.AsyncLoggerContextSelector</span><br><span class="line">log4j2.clock=com.xxx.CustomLog4jClock</span><br></pre></td></tr></table></figure>
<h3 id="application-yml简单配置"><a href="#application-yml简单配置" class="headerlink" title="application.yml简单配置"></a>application.yml简单配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logging:</span><br><span class="line">  config: classpath:log4j2.xml # 指定log4j2配置文件的路径, 默认就是这个</span><br><span class="line">  pattern:</span><br><span class="line">    console: &quot;%clr&#123;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;&#125;&#123;faint&#125; | %clr&#123;%5p&#125; | %clr&#123;%15.15t&#125;&#123;faint&#125; | %clr&#123;%-50.50c&#123;1.&#125;&#125;&#123;cyan&#125; | %5L | %clr&#123;%M&#125;&#123;magenta&#125; | %msg%n%xwEx&quot; # 控制台日志输出格式</span><br></pre></td></tr></table></figure>
<h3 id="log4j2-xml-详细配置"><a href="#log4j2-xml-详细配置" class="headerlink" title="log4j2.xml 详细配置"></a>log4j2.xml 详细配置</h3><p>先来看一下常用的输出格式:</p>
<ul>
<li><code>%d{yyyy-MM-dd HH:mm:ss.SSS}</code>: 输出时间，精确度为毫秒.</li>
<li><code>%-5level</code> | <code>%-5p</code>: 输出日志级别, -5表示左对齐并且固定占5个字符宽度, 如果不足用空格补齐.</li>
<li><code>%t</code> | <code>%thread</code>: 线程名称</li>
<li><code>%c{precision}</code> | <code>logger{precision}</code>: 输出的Logger名字, <code>{precision}</code> 表示保留的名字长度, 比如 <code>%c{1}</code> 是这样的 <code>Foo</code>, <code>%c{3}</code> 是这样的 <code>apache.commons.Foo</code></li>
<li><code>%C{precision}</code> | <code>%class{precision}</code>: 实际上输出log的类名, 如果一个类有子类(<code>Son extend Father</code>), 在 <code>Father</code> 中调用 <code>log.info</code>, 那么<code>%C{1}</code> 输出的是 <code>Father</code>. </li>
<li><code>M</code> | <code>method</code>: 输出log所在的方法名.</li>
<li><code>L</code> | <code>line</code>: 输出log所在的行数.</li>
<li><code>%msg{nolookups}</code>: 输出的log日志, <code>{nolookups}</code> 表示忽略掉一些内置函数比如 <code>logger.info(&quot;Try ${date:YYYY-MM-dd}&quot;)</code>, 如果不加 <code>{nolookups}</code> 那么输出的日志会是这样的 <code>Try 2019-05-28</code>.</li>
<li><code>%n</code>: 换行, 一般跟在 <code>%msg</code> 后面.</li>
<li><code>%xEx</code> | <code>%xwEx</code>: 输出异常, 后者会在异常信息的开始与结束append空的一行, 与 <code>%ex</code> 的区别在于在每一行异常信息后面会追加jar包的信息.</li>
<li><code>%clr</code>: 配置颜色, 比如 <code>%clr{字段}{颜色}</code><ul>
<li><code>blue</code>: 蓝色</li>
<li><code>cyan</code>: 青色</li>
<li><code>faint</code>: 不知道什么颜色, 输出来是黑色</li>
<li><code>green</code>: 绿色</li>
<li><code>magenta</code>: 粉色</li>
<li><code>red</code>: 红色</li>
<li><code>yellow</code>: 黄色</li>
</ul>
</li>
</ul>
<p>所以我们的pattern是这样的: <code>%d{yyyy-MM-dd HH:mm:ss.SSS}  | %-5level | ${server_name} | %X{IP} | %logger{1} | %thread -&gt; %class{1}#%method:%line | %msg{nolookups}%n%xwEx</code>.</p>
<p>使用 <code>|</code> 作为分隔符是因为后面输出到Logstash时用于字段分割.</p>
<h4 id="输出到-Kafka"><a href="#输出到-Kafka" class="headerlink" title="输出到 Kafka"></a>输出到 Kafka</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">status</span>=<span class="string">"OFF"</span> <span class="attr">monitorInterval</span>=<span class="string">"30"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"UNKNOWN"</span> <span class="attr">value</span>=<span class="string">"????"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"KAFKA_SERVERS"</span> <span class="attr">value</span>=<span class="string">"$&#123;spring:ybd.kafka.bootstrap&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"server_name"</span> <span class="attr">value</span>=<span class="string">"$&#123;spring:spring.application.name&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"LOG_PATTERN"</span> <span class="attr">value</span>=<span class="string">"%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; | %-5level | $&#123;server_name&#125; | %X&#123;IP&#125; | %logger&#123;1&#125; | %thread -&gt; %class&#123;1&#125;#%method:%line | %msg&#123;nolookups&#125;%n%xwEx"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">"console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"info"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"$&#123;LOG_PATTERN&#125;"</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">Kafka</span> <span class="attr">name</span>=<span class="string">"kafka"</span> <span class="attr">topic</span>=<span class="string">"log-collect"</span> <span class="attr">ignoreExceptions</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"INFO"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"$&#123;LOG_PATTERN&#125;"</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"bootstrap.servers"</span>&gt;</span>$&#123;KAFKA_SERVERS&#125;<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"request.timeout.ms"</span>&gt;</span>5000<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"transaction.timeout.ms"</span>&gt;</span>5000<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">"max.block.ms"</span>&gt;</span>3000<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Kafka</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">"failoverKafkaLog"</span> <span class="attr">fileName</span>=<span class="string">"./failoverKafka/$&#123;SERVER_NAME&#125;.log"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">filePattern</span>=<span class="string">"./failoverKafka/$&#123;SERVER_NAME&#125;.%d&#123;yyyy-MM-dd&#125;.log"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"INFO"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Pattern</span>&gt;</span>$&#123;LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">Pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">PatternLayout</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">Failover</span> <span class="attr">name</span>=<span class="string">"failover"</span> <span class="attr">primary</span>=<span class="string">"kafka"</span> <span class="attr">retryIntervalSeconds</span>=<span class="string">"300"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Failovers</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"failoverKafkaLog"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Failovers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Failover</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">"INFO"</span> <span class="attr">includeLocation</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"failover"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"console"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>bootstrap.servers</code>是kafka的地址, 接入Docker network之后可以配置成<code>kafka:9092</code></li>
<li><code>topic</code>要与Logstash中配置的一致</li>
<li>启用了全局异步需要将<code>includeLocation</code>设为<code>true</code>才能打印路径之类的信息</li>
<li>Kafka地址通过<code>${spring:ybd.kafka.bootstrap}</code>读取配置文件获取, 这个需要自己拓展Log4j, 具体请看下面的获取Application配置</li>
<li><code>LOG_PATTERN</code>中的<code>%X{IP}</code>、<code>%X{UA}</code>, 通过<code>MDC.put(key, value)</code>放进去, 同时在<code>&lt;Root&gt;</code>中设置<code>includeLocation=&quot;true&quot;</code>才能获取<code>%t</code>、<code>%c</code>等信息</li>
<li><code>KafkaAppender</code>结合<code>FailoverAppender</code>确保当Kafka Crash时, 日志触发Failover, 写到文件中, 不阻塞程序, 进而保证了吞吐. <code>retryIntervalSeconds</code>的默认值是1分钟, 是通过异常来切换的, 所以可以适量加大间隔. </li>
<li><code>KafkaAppender</code> <code>ignoreExceptions</code> 必须设置为<code>false</code>, 否则无法触发Failover</li>
<li><code>KafkaAppender</code> <code>max.block.ms</code>默认是1分钟, 当Kafka宕机时, 尝试写Kafka需要1分钟才能返回Exception, 之后才会触发Failover, 当请求量大时, log4j2 队列很快就会打满, 之后写日志就Blocking, 严重影响到主服务响应</li>
<li>日志的格式采用<code>&quot; | &quot;</code>作为分割符方便后面Logstash进行切分字段</li>
</ul>
<h4 id="输出到文件"><a href="#输出到文件" class="headerlink" title="输出到文件"></a>输出到文件</h4><blockquote>
<p>这种方式可以用于存档, 同是使用 Filebeat 抓取文件日志输出到 Logstash.</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Configuration后面的status,这个用于设置log4j2自身内部的信息输出,可以不设置,当设置成trace时,你会看到log4j2内部各种详细输出 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身,设置间隔秒数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">status</span>=<span class="string">"WARN"</span> <span class="attr">monitorInterval</span>=<span class="string">"1800"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"UNKNOWN"</span> <span class="attr">value</span>=<span class="string">"????"</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 应用的名字, 需要自己写spring的拓展 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"server_name"</span> <span class="attr">value</span>=<span class="string">"$&#123;spring:spring.application.name&#125;"</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 控制台输出的格式 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"log_pattern"</span> <span class="attr">value</span>=<span class="string">"%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; | %-5level | $&#123;server_name&#125; | %X&#123;IP&#125; | %logger&#123;1&#125; | %thread -&gt; %class&#123;1&#125;#%method:%line | %msg&#123;nolookups&#125;%n%xwEx"</span>/&gt;</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">&lt;!-- 日志默认存放的位置,这里设置为项目根路径下,也可指定绝对路径 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePath"</span>&gt;</span>./log4j2Logs/$&#123;server_name&#125;<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 日志默认切割的最小单位 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"every_file_size"</span>&gt;</span>20MB<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 日志默认输出级别 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"output_log_level"</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 日志默认存放路径(所有级别日志) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"rolling_fileName"</span>&gt;</span>$&#123;basePath&#125;/all.log<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 日志默认压缩路径,将超过指定文件大小的日志,自动存入按"年月"建立的文件夹下面并进行压缩,作为存档 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"rolling_filePattern"</span>&gt;</span>$&#123;basePath&#125;/%d&#123;yyyy-MM&#125;/all-%d&#123;yyyy-MM-dd&#125;-%i.log.gz<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 日志默认同类型日志,同一文件夹下可以存放的数量,不设置此属性则默认为7个 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"rolling_max"</span>&gt;</span>20<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"info_fileName"</span>&gt;</span>$&#123;basePath&#125;/info.log<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"info_filePattern"</span>&gt;</span>$&#123;basePath&#125;/%d&#123;yyyy-MM&#125;/info-%d&#123;yyyy-MM-dd&#125;-%i.log.gz<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"info_max"</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"warn_fileName"</span>&gt;</span>$&#123;basePath&#125;/warn.log<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"warn_filePattern"</span>&gt;</span>$&#123;basePath&#125;/%d&#123;yyyy-MM&#125;/warn-%d&#123;yyyy-MM-dd&#125;-%i.log.gz<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"warn_max"</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"error_fileName"</span>&gt;</span>$&#123;basePath&#125;/error.log<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"error_filePattern"</span>&gt;</span>$&#123;basePath&#125;/%d&#123;yyyy-MM&#125;/error-%d&#123;yyyy-MM-dd&#125;-%i.log.gz<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"error_max"</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 控制台显示的日志最低级别 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"console_print_level"</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--定义appender --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 用来定义输出到控制台的配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">"Console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 设置控制台只输出level及以上级别的信息(onMatch),其他的直接拒绝(onMismatch) --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"$&#123;console_print_level&#125;"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"$&#123;log_pattern&#125;"</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 打印root中指定的level级别以上的日志到文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">"RollingFile"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;rolling_fileName&#125;"</span> <span class="attr">filePattern</span>=<span class="string">"$&#123;rolling_filePattern&#125;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"$&#123;log_pattern&#125;"</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 设置同类型日志,同一文件夹下可以存放的数量,如果不设置此属性则默认存放7个文件 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"$&#123;every_file_size&#125;"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">"$&#123;rolling_max&#125;"</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 匹配INFO以及以上级别 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Filters</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"INFO"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Filters</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">"InfoFile"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;info_fileName&#125;"</span> <span class="attr">filePattern</span>=<span class="string">"$&#123;info_filePattern&#125;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"$&#123;log_pattern&#125;"</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"$&#123;every_file_size&#125;"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">"$&#123;info_max&#125;"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Filters</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"WARN"</span> <span class="attr">onMatch</span>=<span class="string">"DENY"</span> <span class="attr">onMismatch</span>=<span class="string">"NEUTRAL"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"INFO"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Filters</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">"WarnFile"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;warn_fileName&#125;"</span> <span class="attr">filePattern</span>=<span class="string">"$&#123;warn_filePattern&#125;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"$&#123;log_pattern&#125;"</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"$&#123;every_file_size&#125;"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">"$&#123;warn_max&#125;"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Filters</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"ERROR"</span> <span class="attr">onMatch</span>=<span class="string">"DENY"</span> <span class="attr">onMismatch</span>=<span class="string">"NEUTRAL"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"WARN"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Filters</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">"ErrorFile"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;error_fileName&#125;"</span> <span class="attr">filePattern</span>=<span class="string">"$&#123;error_filePattern&#125;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"$&#123;log_pattern&#125;"</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"$&#123;every_file_size&#125;"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">"$&#123;error_max&#125;"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Filters</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"FATAL"</span> <span class="attr">onMatch</span>=<span class="string">"DENY"</span> <span class="attr">onMismatch</span>=<span class="string">"NEUTRAL"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"ERROR"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Filters</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--然后定义logger,只有定义了logger并引入的appender,appender才会生效 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--建立一个默认的root的logger --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">"&#123;output_log_level&#125;"</span> <span class="attr">includeLocation</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"RollingFile"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"InfoFile"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"WarnFile"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"ErrorFile"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="也可以使用log4j2-yml"><a href="#也可以使用log4j2-yml" class="headerlink" title="也可以使用log4j2.yml"></a>也可以使用log4j2.yml</h3><p>需要引入依赖以识别: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 加上这个才能辨认到log4j2.yml文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-yaml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>log4j2.yml</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Configuration:</span></span><br><span class="line">  <span class="attr">status:</span> <span class="string">"OFF"</span></span><br><span class="line">  <span class="attr">monitorInterval:</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">Properties:</span></span><br><span class="line">    <span class="attr">Property:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">log.level.console</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">debug</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PID</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">????</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">LOG_PATTERN</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">"%clr&#123;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;&#125;&#123;faint&#125; | %clr&#123;%5p&#125; | %clr&#123;$&#123;sys:PID&#125;&#125;&#123;magenta&#125; | %clr&#123;%15.15t&#125;&#123;faint&#125; | %clr&#123;%-50.50c&#123;1.&#125;&#125;&#123;cyan&#125; | %5L | %clr&#123;%M&#125;&#123;magenta&#125; | %msg%n%xwEx"</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">Appenders:</span></span><br><span class="line">    <span class="attr">Console:</span>  <span class="comment">#输出到控制台</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">CONSOLE</span></span><br><span class="line">      <span class="attr">target:</span> <span class="string">SYSTEM_OUT</span></span><br><span class="line">      <span class="attr">ThresholdFilter:</span></span><br><span class="line">        <span class="attr">level:</span> <span class="string">$&#123;sys:log.level.console&#125;</span> <span class="comment"># “sys:”表示: 如果VM参数中没指定这个变量值, 则使用本文件中定义的缺省全局变量值</span></span><br><span class="line">        <span class="attr">onMatch:</span> <span class="string">ACCEPT</span></span><br><span class="line">        <span class="attr">onMismatch:</span> <span class="string">DENY</span></span><br><span class="line">      <span class="attr">PatternLayout:</span></span><br><span class="line">        <span class="attr">pattern:</span> <span class="string">$&#123;LOG_PATTERN&#125;</span></span><br><span class="line">        <span class="attr">charset:</span> <span class="string">UTF-8</span></span><br><span class="line">  <span class="attr">Loggers:</span></span><br><span class="line">    <span class="attr">Root:</span></span><br><span class="line">      <span class="attr">level:</span> <span class="string">info</span></span><br><span class="line">      <span class="attr">includeLocation:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">AppenderRef:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">ref:</span> <span class="string">CONSOLE</span></span><br><span class="line">    <span class="attr">AsyncRoot:</span></span><br><span class="line">      <span class="attr">level:</span> <span class="string">info</span></span><br><span class="line">      <span class="attr">includeLocation:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">AppenderRef:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">ref:</span> <span class="string">CONSOLE</span></span><br></pre></td></tr></table></figure>
<p>更多配置请参照: <em><a href="http://logging.apache.org/log4j/2.x/manual/layouts.html" rel="external nofollow noopener noreferrer" target="_blank">http://logging.apache.org/log4j/2.x/manual/layouts.html</a></em></p>
<h2 id="日志配置文件中获取Application配置"><a href="#日志配置文件中获取Application配置" class="headerlink" title="日志配置文件中获取Application配置"></a>日志配置文件中获取Application配置</h2><h3 id="Logback"><a href="#Logback" class="headerlink" title="Logback"></a>Logback</h3><p>方法1: 使用<code>logback-spring.xml</code>, 因为<code>logback.xml</code>加载早于<code>application.properties</code>, 所以如果你在<code>logback.xml</code>使用了变量时, 而恰好这个变量是写在<code>application.properties</code>时, 那么就会获取不到, 只要改成<code>logback-spring.xml</code>就可以解决. </p>
<p>方法2: 使用<code>&lt;springProperty&gt;</code>标签, 例如: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;springProperty scope=&quot;context&quot; name=&quot;LOG_HOME&quot; source=&quot;logback.file&quot;/&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Log4j2"><a href="#Log4j2" class="headerlink" title="Log4j2"></a>Log4j2</h3><p>只能写一个Lookup: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ybd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 18-5-11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@contact</span> yangbingdong1994@gmail.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Plugin</span>(name = LOOK_UP_PREFIX, category = StrLookup.CATEGORY)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringEnvironmentLookup</span> <span class="keyword">extends</span> <span class="title">AbstractLookup</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOOK_UP_PREFIX = <span class="string">"spring"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> LinkedHashMap profileYmlData;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> LinkedHashMap metaYmlData;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> profileExist;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROFILE_PREFIX = <span class="string">"application"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROFILE_SUFFIX = <span class="string">".yml"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String META_PROFILE = PROFILE_PREFIX + PROFILE_SUFFIX;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPRING_PROFILES_ACTIVE = <span class="string">"spring.profiles.active"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			metaYmlData = <span class="keyword">new</span> Yaml().loadAs(<span class="keyword">new</span> ClassPathResource(META_PROFILE).getInputStream(), LinkedHashMap<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">			Properties properties = System.getProperties();</span><br><span class="line">			String active = properties.getProperty(SPRING_PROFILES_ACTIVE);</span><br><span class="line">			<span class="keyword">if</span> (isBlank(active)) &#123;</span><br><span class="line">				active = getValueFromData(SPRING_PROFILES_ACTIVE, metaYmlData);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (isNotBlank(active)) &#123;</span><br><span class="line">				String configName = PROFILE_PREFIX + <span class="string">"-"</span> + active + PROFILE_SUFFIX;</span><br><span class="line">				ClassPathResource classPathResource = <span class="keyword">new</span> ClassPathResource(configName);</span><br><span class="line">				profileExist = classPathResource.exists();</span><br><span class="line">				<span class="keyword">if</span> (profileExist) &#123;</span><br><span class="line">					profileYmlData = <span class="keyword">new</span> Yaml().loadAs(classPathResource.getInputStream(), LinkedHashMap<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"SpringEnvironmentLookup initialize fail"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">lookup</span><span class="params">(LogEvent event, String key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> map.computeIfAbsent(key, SpringEnvironmentLookup::resolveYmlMapByKey);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">resolveYmlMapByKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">		Assert.isTrue(isNotBlank(key), <span class="string">"key can not be blank!"</span>);</span><br><span class="line">		String[] keyChain = key.split(<span class="string">"\\."</span>);</span><br><span class="line">		String value = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (profileExist) &#123;</span><br><span class="line">			value = getValueFromData(key, profileYmlData);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (isBlank(value)) &#123;</span><br><span class="line">			value = getValueFromData(key, metaYmlData);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getValueFromData</span><span class="params">(String key, LinkedHashMap dataMap)</span> </span>&#123;</span><br><span class="line">		String[] keyChain = key.split(<span class="string">"\\."</span>);</span><br><span class="line">		<span class="keyword">int</span> length = keyChain.length;</span><br><span class="line">		<span class="keyword">if</span> (length == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> getFinalValue(key, dataMap);</span><br><span class="line">		&#125;</span><br><span class="line">		String k;</span><br><span class="line">		LinkedHashMap[] mapChain = <span class="keyword">new</span> LinkedHashMap[length];</span><br><span class="line">		mapChain[<span class="number">0</span>] = dataMap;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i == length - <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> getFinalValue(keyChain[i], mapChain[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			k = keyChain[i];</span><br><span class="line">			Object o = mapChain[i].get(k);</span><br><span class="line">			<span class="keyword">if</span> (Objects.isNull(o)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (o <span class="keyword">instanceof</span> LinkedHashMap) &#123;</span><br><span class="line">				mapChain[i + <span class="number">1</span>] = (LinkedHashMap) o;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getFinalValue</span><span class="params">(String k, LinkedHashMap ymlData)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> defaultIfNull((String) ymlData.get(k), <span class="string">""</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在<code>log4j2.xml</code>中这样使用 <code>${spring:spring.application.name}</code></p>
<h2 id="自定义字段"><a href="#自定义字段" class="headerlink" title="自定义字段"></a>自定义字段</h2><p>可以利用<code>MDC</code>实现当前线程自定义字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MDC.put(&quot;IP&quot;, IpUtil.getIpAddr(request));</span><br></pre></td></tr></table></figure>
<p><code>log4j2.xml</code>中这样获取<code>%X{IP}</code></p>
<h1 id="Spring-Boot-Docker-Integration"><a href="#Spring-Boot-Docker-Integration" class="headerlink" title="Spring Boot Docker Integration"></a>Spring Boot Docker Integration</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>Docker</li>
<li>IDE（使用IDEA）</li>
<li>Maven环境</li>
<li>Docker私有仓库, 可以使用Harbor(<strong><em><a href="/2018/docker-visual-management-and-orchestrate-tools/#Harbor">Ubuntu中安装Harbor</a></em></strong>)</li>
</ul>
<p>集成Docker需要的插件<code>docker-maven-plugin</code>: <em><a href="https://github.com/spotify/docker-maven-plugin" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/spotify/docker-maven-plugin</a></em></p>
<h2 id="安全认证配置"><a href="#安全认证配置" class="headerlink" title="安全认证配置"></a>安全认证配置</h2><blockquote>
<p>当我们 push 镜像到 Docker 仓库中时, 不管是共有还是私有, 经常会需要安全认证, 登录完成之后才可以进行操作. 当然, 我们可以通过命令行 <code>docker login -u user_name -p password docker_registry_host</code> 登录, 但是对于自动化流程来说, 就不是很方便了. 使用 docker-maven-plugin 插件我们可以很容易实现安全认证. </p>
</blockquote>
<h3 id="普通配置"><a href="#普通配置" class="headerlink" title="普通配置"></a>普通配置</h3><p><code>settings.xml</code>: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>docker-registry<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">password</span>&gt;</span>12345678<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">email</span>&gt;</span>yangbingdong1994@gmail.com<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Maven-密码加密配置"><a href="#Maven-密码加密配置" class="headerlink" title="Maven 密码加密配置"></a>Maven 密码加密配置</h3><p><code>settings.xml</code>配置私有库的访问: </p>
<p>首先使用你的私有仓库访问密码生成主密码: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn --encrypt-master-password &lt;password&gt;</span><br></pre></td></tr></table></figure>
<p>其次在<code>settings.xml</code>文件的同级目录创建<code>settings-security.xml</code>文件, 将主密码写入: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;settingsSecurity&gt;</span><br><span class="line">  &lt;master&gt;&#123;Ns0JM49fW9gHMTZ44n*****************=&#125;&lt;/master&gt;</span><br><span class="line">&lt;/settingsSecurity&gt;</span><br></pre></td></tr></table></figure>
<p>最后使用你的私有仓库访问密码生成服务密码, 将生成的密码写入到<code>settings.xml</code>的<code>&lt;services&gt;</code>中（可能会提示目录不存在, 解决方法是创建一个<code>.m2</code>目录并把<code>settings-security.xml</code>复制进去）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn --encrypt-password &lt;password&gt;</span><br><span class="line">&#123;D9YIyWYvtYsHayLjIenj***********=&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;server&gt;</span><br><span class="line">    &lt;id&gt;docker-registry&lt;/id&gt;</span><br><span class="line">    &lt;username&gt;admin&lt;/username&gt;</span><br><span class="line">    &lt;password&gt;&#123;gKLNhblk/SQHBMooM******************=&#125;&lt;/password&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;email&gt;yangbingdong1994@gmail.com&lt;/email&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">&lt;/server&gt;</span><br></pre></td></tr></table></figure>
<h2 id="构建基础镜像"><a href="#构建基础镜像" class="headerlink" title="构建基础镜像"></a>构建基础镜像</h2><p>Dockerfile: </p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> frolvlad/alpine-oraclejdk8:slim</span><br><span class="line"><span class="keyword">MAINTAINER</span> ybd &lt;yangbingdong1994@gmail.com&gt;</span><br><span class="line"><span class="keyword">ARG</span> TZ </span><br><span class="line"><span class="keyword">ARG</span> HTTP_PROXY</span><br><span class="line"><span class="keyword">ENV</span> TZ=$&#123;TZ:-<span class="string">"Asia/Shanghai"</span>&#125; http_proxy=$&#123;HTTP_PROXY&#125; https_proxy=$&#123;HTTP_PROXY&#125;</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk update &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apk add --no-cache &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apk add curl bash tree tzdata &amp;&amp; \</span></span><br><span class="line"><span class="bash">    ln -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; \</span></span><br><span class="line"><span class="bash">    <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone </span></span><br><span class="line"><span class="keyword">ENV</span> http_proxy=</span><br><span class="line"><span class="keyword">ENV</span> https_proxy=</span><br></pre></td></tr></table></figure>
<p>构建: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build --build-arg HTTP_PROXY=192.168.6.113:8118 -t yangbingdong/docker-oraclejdk8 .</span><br></pre></td></tr></table></figure>
<p>其中<code>HTTP_PROXY</code>是http代理, 通过<code>--build-arg</code>参数传入, 注意<strong>不能</strong>是<code>127.0.0.1</code>或<code>localhost</code>. </p>
<h2 id="开始集成"><a href="#开始集成" class="headerlink" title="开始集成"></a>开始集成</h2><h3 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h3><p>在<code>src/main</code>下面新建<code>docker</code>文件夹, 并创建<code>Dockerfile</code>: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM yangbingdong/docker-oraclejdk8:latest</span><br><span class="line">MAINTAINER yangbingdong &lt;yangbingdong1994@gmail.com&gt;</span><br><span class="line">ENV PROJECT_NAME=&quot;@project.build.finalName@.@project.packaging@&quot; JAVA_OPTS=&quot;&quot;</span><br><span class="line">ADD $PROJECT_NAME /app.jar</span><br><span class="line">ENTRYPOINT exec java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -DLog4jContextSelector=org.apache.logging.log4j.core.async.AsyncLoggerContextSelector -Dspring.profiles.active=$&#123;ACTIVE:-docker&#125; -jar /app.jar</span><br></pre></td></tr></table></figure>
<ul>
<li>通过<code>@@</code>动态获取打包后的项目名（需要插件, 下面会介绍）</li>
<li><code>Dspring.profiles.active=${ACTIVE:-docker}</code>可以通过docker启动命令<code>-e ACTIVE=docker</code>参数修改配置</li>
</ul>
<h4 id="注意PID"><a href="#注意PID" class="headerlink" title="注意PID"></a>注意PID</h4><p>如果需要Java程序监听到<code>sigterm</code>信号, 那么Java程序的<code>PID</code>必须是1, 可以使用<code>ENTRYPOINT exec java -jar ...</code>这种方式实现. </p>
<h3 id="pom文件添加构建Docker镜像的相关插件"><a href="#pom文件添加构建Docker镜像的相关插件" class="headerlink" title="pom文件添加构建Docker镜像的相关插件"></a>pom文件添加构建Docker镜像的相关插件</h3><blockquote>
<p>继承<code>spring-boot-starter-parent</code>, 除了<code>docker-maven-plugin</code>, 下面的3个插件都不用填写版本号, 因为parent中已经定义版本号</p>
</blockquote>
<h4 id="spring-boot-maven-plugin"><a href="#spring-boot-maven-plugin" class="headerlink" title="spring-boot-maven-plugin"></a>spring-boot-maven-plugin</h4><p>这个不用多介绍了, 打包Spring Boot Jar包的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;repackage&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>
<h4 id="maven-resources-plugin"><a href="#maven-resources-plugin" class="headerlink" title="maven-resources-plugin"></a>maven-resources-plugin</h4><p>resources插件, 使用<code>@变量@</code>形式获取Maven变量到Dockerfile中（同时拷贝构建的Jar包到Dockerfile同一目录中, 这种方式是方便手动构建镜像）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>prepare-dockerfile<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>validate<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>copy-resources<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 编译后Dockerfile的输出位置 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;dockerfile.compiled.position&#125;<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">                	<span class="comment">&lt;!-- Dockerfile位置 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/docker<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 将Jar复制到target的docker目录中, 因为真正的Dockerfile也是在里面, 方便使用docker build命令构建Docker镜像 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>copy-jar<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>copy-resources<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;dockerfile.compiled.position&#125;<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">include</span>&gt;</span>*.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="build-helper-maven-plugin"><a href="#build-helper-maven-plugin" class="headerlink" title="build-helper-maven-plugin"></a>build-helper-maven-plugin</h4><p>这个是为了给镜像添加基于时间戳的版本号, maven也有自带的获取时间戳的变量<code>maven.build.timestamp.format</code> + <code>maven.build.timestamp</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;maven.build.timestamp.format&gt;yyyy-MM-dd_HH-mm-ss&lt;maven.build.timestamp.format&gt;</span><br><span class="line"></span><br><span class="line"># 获取时间戳</span><br><span class="line">$&#123;maven.build.timestamp&#125;</span><br></pre></td></tr></table></figure>
<p>但是这个时区是<code>UTC</code>, 接近于格林尼治标准时间, 所以出来的时间会比但前的时间慢8个小时. </p>
<p>如果要使用<code>GMT+8</code>, 就需要<code>build-helper-maven-plugin</code>插件, 当然也有其他的实现方式, 这里不做展开. </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>build-helper-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>timestamp-property<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>timestamp-property<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    	<span class="comment">&lt;!-- 其他地方可通过$&#123;timestamp&#125;获取时间戳 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">name</span>&gt;</span>timestamp<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>yyyyMMddHHmm<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">timeZone</span>&gt;</span>GMT+8<span class="tag">&lt;/<span class="name">timeZone</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后可以在pom中使用<code>${timestamp}</code>获取时间戳. </p>
<p>当然, 也可以使用<strong>另外一种方式实现</strong>, 打包前<code>export</code>一个格式化日期的环境变量, <code>pom.xml</code>中获取这个变量: </p>
<ul>
<li><code>export DOCKER_IMAGE_TAGE_DATE=yyyy-MM-dd_HH-mm</code></li>
<li><code>mvn help:system</code>可查看所有环境变量</li>
<li>所有的环境变量都可以用以<code>env.</code>开头的Maven属性引用: <code>${env.DOCKER_IMAGE_TAGE_DATE}</code></li>
</ul>
<h4 id="docker-maven-plugin"><a href="#docker-maven-plugin" class="headerlink" title="docker-maven-plugin"></a>docker-maven-plugin</h4><p>这也是集成并构建Docker镜像的关键</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>docker-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;docker-maven-plugin.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 绑定打包阶段执行Docker镜像操作 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 打包阶段构建镜像 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>build<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 部署阶段Push镜像 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>push-image<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>deploy<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>push<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- Push指定镜像 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--&lt;imageName&gt;$&#123;docker.registry.url&#125;/$&#123;docker.registry.name&#125;/$&#123;project.artifactId&#125;:$&#123;docker-latest-tag&#125;&lt;/imageName&gt;--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--suppress UnresolvedMavenProperty --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">imageName</span>&gt;</span>$&#123;docker.registry.url&#125;/$&#123;docker.registry.name&#125;/$&#123;project.artifactId&#125;:$&#123;timestamp&#125;<span class="tag">&lt;/<span class="name">imageName</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 是否跳过所有构建Docker镜像阶段 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">skipDocker</span>&gt;</span>$&#123;docker.skip.build&#125;<span class="tag">&lt;/<span class="name">skipDocker</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 是否跳过Push阶段 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">skipDockerPush</span>&gt;</span>$&#123;docker.skip.push&#125;<span class="tag">&lt;/<span class="name">skipDockerPush</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">forceTags</span>&gt;</span>true<span class="tag">&lt;/<span class="name">forceTags</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 最大重试次数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">retryPushCount</span>&gt;</span>2<span class="tag">&lt;/<span class="name">retryPushCount</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">imageTags</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 使用时间戳版本号 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--suppress UnresolvedMavenProperty --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">imageTag</span>&gt;</span>$&#123;timestamp&#125;<span class="tag">&lt;/<span class="name">imageTag</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">imageTags</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置镜像名称, 遵循Docker的命名规范: springio/image --&gt;</span><span class="tag">&lt;<span class="name">imageName</span>&gt;</span>$&#123;docker.registry.url&#125;/$&#123;docker.registry.name&#125;/$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">imageName</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Dockerfile位置, 由于配置了编译时动态获取Maven变量, 真正的Dockerfile位于位于编译后位置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dockerDirectory</span>&gt;</span>$&#123;dockerfile.compiled.position&#125;<span class="tag">&lt;/<span class="name">dockerDirectory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>/<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>$&#123;project.build.finalName&#125;.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 被推送服务器的配置ID, 与setting中的一直 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">serverId</span>&gt;</span>docker-registry<span class="tag">&lt;/<span class="name">serverId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;registryUrl&gt;$&#123;docker.registry.url&#125;&lt;/registryUrl&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>主要<code>properties</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ########## Docker 相关变量 ########## --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">docker-maven-plugin.version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">docker-maven-plugin.version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- resource插件编译Dockerfile后的位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dockerfile.compiled.position</span>&gt;</span>$&#123;project.build.directory&#125;/docker<span class="tag">&lt;/<span class="name">dockerfile.compiled.position</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">docker.skip.build</span>&gt;</span>false<span class="tag">&lt;/<span class="name">docker.skip.build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">docker.skip.push</span>&gt;</span>false<span class="tag">&lt;/<span class="name">docker.push.image</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">docker.registry.url</span>&gt;</span>192.168.0.202:8080<span class="tag">&lt;/<span class="name">docker.registry.url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">docker.registry.name</span>&gt;</span>dev-images<span class="tag">&lt;/<span class="name">docker.registry.name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">docker-latest-tag</span>&gt;</span>latest<span class="tag">&lt;/<span class="name">docker-latest-tag</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>: </p>
<ul>
<li>这里的<code>serverId</code>要与maven <code>setting.xml</code>里面的一样</li>
</ul>
<ul>
<li>Dockerfile构建文件在<code>src/main/docker</code>中</li>
<li>如果Dockerfile文件需要maven构建参数（比如需要构建后的打包文件名等）, 则使用<code>@@</code>占位符（如<a href="mailto:`@project.build.finalName" rel="external nofollow noopener noreferrer" target="_blank">`@project.build.finalName</a>@<code>）原因是Sping Boot 的pom将resource插件的占位符由</code>${}<code>改为</code>@@<code>, 非继承Spring Boot 的pom文件, 则使用</code>${}`占位符</li>
<li>如果不需要动态生成Dockerfile文件, 则可以将Dockerfile资源拷贝部分放入<code>docker-maven-plugin</code>插件的<code>&lt;resources&gt;</code>配置里</li>
<li><strong><code>spring-boot-maven-plugin</code>插件一定要在其他构建插件之上, 否则打包文件会有问题. </strong></li>
</ul>
<p><code>docker-maven-plugin</code> 插件还提供了很多很实用的配置, 稍微列举几个参数吧. </p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;forceTags&gt;true&lt;/forceTags&gt;</code></td>
<td>build 时强制覆盖 tag, 配合 imageTags 使用</td>
<td>false</td>
</tr>
<tr>
<td><code>&lt;noCache&gt;true&lt;/noCache&gt;</code></td>
<td>build 时, 指定 –no-cache 不使用缓存</td>
<td>false</td>
</tr>
<tr>
<td><code>&lt;pullOnBuild&gt;true&lt;/pullOnBuild&gt;</code></td>
<td>build 时, 指定 –pull=true 每次都重新拉取基础镜像</td>
<td>false</td>
</tr>
<tr>
<td><code>&lt;pushImage&gt;true&lt;/pushImage&gt;</code></td>
<td>build 完成后 push 镜像</td>
<td>false</td>
</tr>
<tr>
<td><code>&lt;pushImageTag&gt;true&lt;/pushImageTag&gt;</code></td>
<td>build 完成后, push 指定 tag 的镜像, 配合 imageTags 使用</td>
<td>false</td>
</tr>
<tr>
<td><code>&lt;retryPushCount&gt;5&lt;/retryPushCount&gt;</code></td>
<td>push 镜像失败, 重试次数</td>
<td>5</td>
</tr>
<tr>
<td><code>&lt;retryPushTimeout&gt;10&lt;/retryPushTimeout&gt;</code></td>
<td>push 镜像失败, 重试时间</td>
<td>10s</td>
</tr>
<tr>
<td><code>&lt;rm&gt;true&lt;/rm&gt;</code></td>
<td>build 时, 指定 –rm=true 即 build 完成后删除中间容器</td>
<td>false</td>
</tr>
<tr>
<td><code>&lt;useGitCommitId&gt;true&lt;/useGitCommitId&gt;</code></td>
<td>build 时, 使用最近的 git commit id 前7位作为tag, 例如: image:b50b604, 前提是不配置 newName</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>更多参数可查看插件中的定义. </p>
<h3 id="命令构建"><a href="#命令构建" class="headerlink" title="命令构建"></a>命令构建</h3><p>如果<code>&lt;skipDockerPush&gt;false&lt;/skipDockerPush&gt;</code>则install阶段将不提交Docker镜像, 只有maven的<code>deploy</code>阶段才提交. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn clean install</span><br><span class="line"></span><br><span class="line"># 如果由外部传入 TAG, pom.xml 中通过 $&#123;env.DOCKER_TAG_DATE&#125; 获取</span><br><span class="line">export DOCKER_TAG_DATE=`date &apos;+%Y-%m-%d_%H-%M&apos;` &amp;&amp; mvn clean install</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[INFO] --- spring-boot-maven-plugin:1.5.9.RELEASE:repackage (default) @ eureka-center-server ---</span><br><span class="line">[INFO] </span><br><span class="line">[INFO] --- docker-maven-plugin:1.0.0:build (default) @ eureka-center-server ---</span><br><span class="line">[INFO] Using authentication suppliers: [ConfigFileRegistryAuthSupplier, NoOpRegistryAuthSupplier]</span><br><span class="line">[WARNING] Ignoring run because dockerDirectory is set</span><br><span class="line">[INFO] Copying /home/ybd/data/git-repo/bitbucket/ms-iba/eureka-center-server/target/eureka-center-server-0.0.1-SNAPSHOT.jar -&gt; /home/ybd/data/git-repo/bitbucket/ms-iba/eureka-center-server/target/docker/eureka-center-server-0.0.1-SNAPSHOT.jar</span><br><span class="line">[INFO] Copying /home/ybd/data/git-repo/bitbucket/ms-iba/eureka-center-server/target/docker/eureka-center-server-0.0.1-SNAPSHOT.jar -&gt; /home/ybd/data/git-repo/bitbucket/ms-iba/eureka-center-server/target/docker/eureka-center-server-0.0.1-SNAPSHOT.jar</span><br><span class="line">[INFO] Copying /home/ybd/data/git-repo/bitbucket/ms-iba/eureka-center-server/target/docker/Dockerfile -&gt; /home/ybd/data/git-repo/bitbucket/ms-iba/eureka-center-server/target/docker/Dockerfile</span><br><span class="line">[INFO] Building image 192.168.6.113:8888/discover-server/eureka-center-server</span><br><span class="line">Step 1/7 : FROM frolvlad/alpine-oraclejdk8:slim</span><br><span class="line"></span><br><span class="line"> ---&gt; 491f45037124</span><br><span class="line">Step 2/7 : MAINTAINER ybd &lt;yangbingdong1994@gmail.com&gt;</span><br><span class="line"></span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 016c2033bd32</span><br><span class="line">Step 3/7 : VOLUME /tmp</span><br><span class="line"></span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; d2a287b6ed52</span><br><span class="line">Step 4/7 : ENV PROJECT_NAME=&quot;eureka-center-server-0.0.1-SNAPSHOT.jar&quot; JAVA_OPTS=&quot;&quot;</span><br><span class="line"></span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 34565a7de714</span><br><span class="line">Step 5/7 : ADD $PROJECT_NAME app.jar</span><br><span class="line"></span><br><span class="line"> ---&gt; 64d9055ce969</span><br><span class="line">Step 6/7 : RUN sh -c &apos;touch /app.jar&apos;</span><br><span class="line"></span><br><span class="line"> ---&gt; Running in 66f4eb550a57</span><br><span class="line">Removing intermediate container 66f4eb550a57</span><br><span class="line"> ---&gt; 93486965cad9</span><br><span class="line">Step 7/7 : CMD [&quot;sh&quot;, &quot;-c&quot;, &quot;java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -Dspring.profiles.active=$&#123;ACTIVE:-docker&#125;  -jar /app.jar&quot;]</span><br><span class="line"></span><br><span class="line"> ---&gt; Running in 8b42c471791f</span><br><span class="line">Removing intermediate container 8b42c471791f</span><br><span class="line"> ---&gt; 2eb3dbbab6c5</span><br><span class="line">ProgressMessage&#123;id=null, status=null, stream=null, error=null, progress=null, progressDetail=null&#125;</span><br><span class="line">Successfully built 2eb3dbbab6c5</span><br><span class="line">Successfully tagged 192.168.6.113:8888/discover-server/eureka-center-server:latest</span><br><span class="line">[INFO] Built 192.168.6.113:8888/discover-server/eureka-center-server</span><br><span class="line">[INFO] Tagging 192.168.6.113:8888/discover-server/eureka-center-server with 0.0.1-SNAPSHOT</span><br><span class="line">[INFO] Tagging 192.168.6.113:8888/discover-server/eureka-center-server with latest</span><br><span class="line">[INFO] Pushing 192.168.6.113:8888/discover-server/eureka-center-server</span><br><span class="line">The push refers to repository [192.168.6.113:8888/discover-server/eureka-center-server]</span><br><span class="line">40566d372b69: Pushed </span><br><span class="line">40566d372b69: Layer already exists </span><br><span class="line">4fd38f0d6712: Layer already exists </span><br><span class="line">d7cd646c41bd: Layer already exists </span><br><span class="line">ced237d13962: Layer already exists </span><br><span class="line">2aebd096e0e2: Layer already exists </span><br><span class="line">null: null </span><br><span class="line">null: null </span><br><span class="line">[INFO] </span><br><span class="line">[INFO] --- maven-install-plugin:2.4:install (default-install) @ eureka-center-server ---</span><br><span class="line">[INFO] Installing /home/ybd/data/git-repo/bitbucket/ms-iba/eureka-center-server/target/eureka-center-server-0.0.1-SNAPSHOT.jar to /home/ybd/data/application/maven/maven-repo/com/iba/server/eureka-center-server/0.0.1-SNAPSHOT/eureka-center-server-0.0.1-SNAPSHOT.jar</span><br><span class="line">[INFO] Installing /home/ybd/data/git-repo/bitbucket/ms-iba/eureka-center-server/pom.xml to /home/ybd/data/application/maven/maven-repo/com/iba/server/eureka-center-server/0.0.1-SNAPSHOT/eureka-center-server-0.0.1-SNAPSHOT.pom</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] BUILD SUCCESS</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br><span class="line">[INFO] Total time: 15.962 s</span><br><span class="line">[INFO] Finished at: 2017-12-25T13:33:39+08:00</span><br><span class="line">[INFO] Final Memory: 55M/591M</span><br><span class="line">[INFO] ------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<p>可以看到本地以及私有仓库都多了一个镜像: </p>
<p><img src="https://cdn.yangbingdong.com/img/spring-cloud-docker-integration/portainer.png" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/spring-cloud-docker-integration/harbor.png" alt></p>
<p><strong>此处有个疑问</strong>, 很明显看得出来这里上传了两个一样大小的包, 不知道是不是同一个jar包, 但id又不一样: </p>
<p><img src="https://cdn.yangbingdong.com/img/spring-cloud-docker-integration/duplicate01.png" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/spring-cloud-docker-integration/duplicate02.png" alt></p>
<h3 id="运行Docker"><a href="#运行Docker" class="headerlink" title="运行Docker"></a>运行Docker</h3><h4 id="普通运行"><a href="#普通运行" class="headerlink" title="普通运行"></a>普通运行</h4><p>运行程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name some-server -e ACTIVE=docker -p 8080:8080 -d [IMAGE]</span><br></pre></td></tr></table></figure>
<h4 id="Docker-Swarm-运行"><a href="#Docker-Swarm-运行" class="headerlink" title="Docker Swarm 运行"></a>Docker Swarm 运行</h4><p><code>docker-compose.yml</code> 中的 <code>image</code> 通过 <code>.env</code> 配置, 但 通过 <code>docker stack</code> 启动并不会读取到 <code>.env</code> 的镜像变量, 但可以通过以下命令解决:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export $(cat .env) &amp;&amp; docker stack deploy -c docker-compose.yml demo-stack</span><br></pre></td></tr></table></figure>
<h3 id="添加运行时JVM参数"><a href="#添加运行时JVM参数" class="headerlink" title="添加运行时JVM参数"></a>添加运行时JVM参数</h3><p>只需要在Docker启动命令中加上<code>-e &quot;JAVA_OPTS=-Xmx128m&quot;</code>即可</p>
<h3 id="其他的Docker构建工具"><a href="#其他的Docker构建工具" class="headerlink" title="其他的Docker构建工具"></a>其他的Docker构建工具</h3><h4 id="Jib"><a href="#Jib" class="headerlink" title="Jib"></a>Jib</h4><blockquote>
<p>Jib 是 Google 开源的另外一款Docker打包工具.</p>
<p>jib-maven-plugin: <strong><em><a href="https://github.com/GoogleContainerTools/jib/tree/master/jib-maven-plugin" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/GoogleContainerTools/jib/tree/master/jib-maven-plugin</a></em></strong></p>
</blockquote>
<p>pom配置:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.cloud.tools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jib-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--from节点用来设置镜像的基础镜像，相当于Docerkfile中的FROM关键字--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">from</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--使用openjdk官方镜像，tag是8-jdk-stretch，表示镜像的操作系统是debian9,装好了jdk8--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;image&gt;gcr.io/distroless/java:8&lt;/image&gt;--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">image</span>&gt;</span>yangbingdong/docker-oraclejdk8:latest<span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">to</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--镜像名称和tag，使用了mvn内置变量$&#123;project.version&#125;，表示当前工程的version--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--suppress MavenModelInspection, MybatisMapperXmlInspection --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">image</span>&gt;</span>$&#123;docker.registry.url&#125;/$&#123;docker.registry.name&#125;/$&#123;project.artifactId&#125;:$&#123;env.DOCKER_TAG_DATE&#125;<span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">auth</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">password</span>&gt;</span>Harbor12345<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">auth</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--容器相关的属性--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">container</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--jvm内存参数--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jvmFlags</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">jvmFlag</span>&gt;</span>-Xmx1g<span class="tag">&lt;/<span class="name">jvmFlag</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--suppress MavenModelInspection, MybatisMapperXmlInspection --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">jvmFlag</span>&gt;</span>-Dspring.profiles.active=$&#123;ACTIVE:-docker&#125;<span class="tag">&lt;/<span class="name">jvmFlag</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">jvmFlags</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--要暴露的端口--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ports</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ports</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">creationTime</span>&gt;</span>USE_CURRENT_TIMESTAMP<span class="tag">&lt;/<span class="name">creationTime</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">format</span>&gt;</span>OCI<span class="tag">&lt;/<span class="name">format</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">container</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">allowInsecureRegistries</span>&gt;</span>true<span class="tag">&lt;/<span class="name">allowInsecureRegistries</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--suppress MybatisMapperXmlInspection --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>dockerBuild<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--&lt;goal&gt;build&lt;/goal&gt;--&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>更多配置请看官方文档.</p>
<h4 id="Dockerfile-Maven"><a href="#Dockerfile-Maven" class="headerlink" title="Dockerfile Maven"></a>Dockerfile Maven</h4><p>这是 spotify 在 开源 <code>docker-maven-plugin</code> 之后的又一款插件, 用法大概如下:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dockerfile-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>default<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>build<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span>$&#123;docker.registry.url&#125;/$&#123;docker.registry.name&#125;<span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--suppress MavenModelInspection --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tag</span>&gt;</span>$&#123;env.DOCKER_TAG_DATE&#125;<span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">contextDirectory</span>&gt;</span>$&#123;dockerfile.compiled.position&#125;<span class="tag">&lt;/<span class="name">contextDirectory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dockerfile</span>&gt;</span>$&#123;dockerfile.compiled.position&#125;/Dockerfile<span class="tag">&lt;/<span class="name">dockerfile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>感觉灵活性没有 <code>docker-maven-plugin</code> 好.</p>
<h2 id="Docker-Swarm环境下获取ClientIp"><a href="#Docker-Swarm环境下获取ClientIp" class="headerlink" title="Docker Swarm环境下获取ClientIp"></a>Docker Swarm环境下获取ClientIp</h2><p>在Docker Swarm环境中, 服务中获取到的ClientIp永远是<code>10.255.0.X</code>这样的Ip, 搜索了一大圈, 最终的解决方安是通过Nginx转发中添加参数, 后端再获取. </p>
<p>在<code>location</code>中添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxy_set_header    X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br></pre></td></tr></table></figure>
<p>后端获取第一个Ip. </p>
<h2 id="服务注册IP问题"><a href="#服务注册IP问题" class="headerlink" title="服务注册IP问题"></a>服务注册IP问题</h2><p>一般安装了 Docker 会出现多网卡的情况, 在服务注册的时候会出现获取到的ip不准确的问题, 可以通过以下几种方式解决(可以混合使用)</p>
<p>方式一, 忽略指定名称的网卡</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">inetutils:</span></span><br><span class="line">      <span class="attr">ignored-interfaces:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">docker0</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">veth.*</span></span><br></pre></td></tr></table></figure>
<p>方式二, 使用正则表达式, 指定使用的网络地址</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">inetutils:</span></span><br><span class="line">      <span class="attr">preferred-networks:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">10.0</span></span><br></pre></td></tr></table></figure>
<p>方式三, 只使用站点本地地址</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">inetutils:</span></span><br><span class="line">      <span class="attr">use-only-site-local-interfaces:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="Demo地址"><a href="#Demo地址" class="headerlink" title="Demo地址"></a>Demo地址</h2><p><strong><em><a href="https://github.com/masteranthoneyd/spring-boot-learning/tree/master/spring-boot-docker" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/masteranthoneyd/spring-boot-learning/tree/master/spring-boot-docker</a></em></strong></p>
<h1 id="Kafka、ELK-collect-logs"><a href="#Kafka、ELK-collect-logs" class="headerlink" title="Kafka、ELK collect logs"></a>Kafka、ELK collect logs</h1><p><img src="https://cdn.yangbingdong.com/img/docker-logs-collect/elk-arch1.png" alt></p>
<p>传统的应用可以将日志存到日志中, 但集成Docker之后, 日志怎么处理？放到容器的某个目录然后挂在出来？这样也可以, 但这样就相当于给容器与外界绑定了一个状态, 弹性伸缩怎么办？个人还是觉得通过队列与ELK管理Docker日志比较合理, 而且Log4j2<strong>原生支持Kafka的Appender</strong>. </p>
<h2 id="镜像准备"><a href="#镜像准备" class="headerlink" title="镜像准备"></a>镜像准备</h2><p>Docker Hub中的ELK镜像并不是最新版本的, 我们需要到官方的网站获取最新的镜像: <strong><em><a href="https://www.docker.elastic.co" rel="external nofollow noopener noreferrer" target="_blank">https://www.docker.elastic.co</a></em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull zookeeper</span><br><span class="line">docker pull wurstmeister/kafka:1.1.0</span><br><span class="line">docker pull docker.elastic.co/elasticsearch/elasticsearch:6.3.0</span><br><span class="line">docker pull docker.elastic.co/kibana/kibana:6.3.0</span><br><span class="line">docker pull docker.elastic.co/logstash/logstash:6.3.0</span><br></pre></td></tr></table></figure>
<p>注意ELK版本最好保持一致</p>
<h2 id="启动Kafka与Zookeeper"><a href="#启动Kafka与Zookeeper" class="headerlink" title="启动Kafka与Zookeeper"></a>启动Kafka与Zookeeper</h2><p>这里直接使用docker-compose（需要先创建外部网络）:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.4'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">zoo:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"2181:2181"</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">backend:</span></span><br><span class="line">        <span class="attr">aliases:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">zoo</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wurstmeister/kafka:1.1.0</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"9092:9092"</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">KAFKA_PORT=9092</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">KAFKA_ADVERTISED_HOST_NAME=192.168.6.113</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">KAFKA_ZOOKEEPER_CONNECT=zoo:2181</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">KAFKA_ADVERTISED_PORT=9092</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">zoo</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">backend:</span></span><br><span class="line">        <span class="attr">aliases:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">kafka</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">backend:</span></span><br><span class="line">    <span class="attr">external:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">backend</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>KAFKA_ADVERTISED_HOST_NAME</code>是内网IP, 本地调试用, Docker环境下换成<code>kafka</code>（与别名<code>aliases的值保持一致</code>）, 其他Docker应用可通过<code>kafka:9092</code>这个域名访问到Kafka. </li>
</ul>
<h2 id="ELK配置以及启动"><a href="#ELK配置以及启动" class="headerlink" title="ELK配置以及启动"></a>ELK配置以及启动</h2><h3 id="X-Pack-破解"><a href="#X-Pack-破解" class="headerlink" title="X-Pack 破解"></a>X-Pack 破解</h3><h4 id="复制Jar包"><a href="#复制Jar包" class="headerlink" title="复制Jar包"></a>复制Jar包</h4><p>先启动一个Elasticsearch的容器, 将Jar包copy出来: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export CONTAINER_NAME=elk_elk-elasticsearch_1</span><br><span class="line">docker cp $&#123;CONTAINER_NAME&#125;:/usr/share/elasticsearch/modules/x-pack-core/x-pack-core-6.4.0.jar ./</span><br><span class="line">docker cp $&#123;CONTAINER_NAME&#125;:/usr/share/elasticsearch/lib ./lib</span><br></pre></td></tr></table></figure>
<h4 id="反编译并修改源码"><a href="#反编译并修改源码" class="headerlink" title="反编译并修改源码"></a>反编译并修改源码</h4><p>找到下面两个类:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.elasticsearch.license.LicenseVerifier.class org.elasticsearch.xpack.core.XPackBuild.class</span><br></pre></td></tr></table></figure></p>
<p>使用 <strong><em><a href="https://github.com/deathmarine/Luyten" rel="external nofollow noopener noreferrer" target="_blank">Luyten</a></em></strong> 进行反编译</p>
<p><img src="https://cdn.yangbingdong.com/img/docker-logs-collect/luyten.png" alt></p>
<p>将两个类复制IDEA（<strong>需要引入上面copy出来的lib以及<code>x-pack-core-6.4.0.jar</code>本身</strong>）, 修改为如下样子: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package org.elasticsearch.license;</span><br><span class="line"></span><br><span class="line">public class LicenseVerifier</span><br><span class="line">&#123;</span><br><span class="line">	public static boolean verifyLicense(final License license, final byte[] publicKeyData) &#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static boolean verifyLicense(final License license) &#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.elasticsearch.xpack.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.SuppressForbidden;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.io.PathUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URISyntaxException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XPackBuild</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> XPackBuild CURRENT;</span><br><span class="line">	<span class="keyword">private</span> String shortHash;</span><br><span class="line">	<span class="keyword">private</span> String date;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@SuppressForbidden</span>(reason = <span class="string">"looks up path of xpack.jar directly"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">static</span> Path <span class="title">getElasticsearchCodebase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> URL url = XPackBuild<span class="class">.<span class="keyword">class</span>.<span class="title">getProtectionDomain</span>().<span class="title">getCodeSource</span>().<span class="title">getLocation</span>()</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> PathUtils.get(url.toURI());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (URISyntaxException bogus) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(bogus);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	XPackBuild(<span class="keyword">final</span> String shortHash, <span class="keyword">final</span> String date) &#123;</span><br><span class="line">		<span class="keyword">this</span>.shortHash = shortHash;</span><br><span class="line">		<span class="keyword">this</span>.date = date;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">shortHash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.shortHash;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">date</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.date;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> Path path = getElasticsearchCodebase();</span><br><span class="line">		String shortHash = <span class="keyword">null</span>;</span><br><span class="line">		String date = <span class="keyword">null</span>;</span><br><span class="line">		Label_0157: &#123;  <span class="comment">// 将try-catch去掉</span></span><br><span class="line">			shortHash = <span class="string">"Unknown"</span>;</span><br><span class="line">			date = <span class="string">"Unknown"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		CURRENT = <span class="keyword">new</span> XPackBuild(shortHash, date);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再编译放回jar包中:</p>
<p><img src="https://cdn.yangbingdong.com/img/docker-logs-collect/jar-archive.png" alt></p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><h4 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h4><p><code>elasticsearch.yml</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cluster.name: &quot;docker-cluster&quot;</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line">discovery.zen.minimum_master_nodes: 1</span><br><span class="line">xpack.security.enabled: false # 不启用密码登陆</span><br><span class="line">xpack.monitoring.collection.enabled: true</span><br></pre></td></tr></table></figure>
<h4 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h4><h5 id="Kafka-Input"><a href="#Kafka-Input" class="headerlink" title="Kafka Input"></a>Kafka Input</h5><p><code>logstash.conf</code> 配置文件(<strong>注意下面的topics要与上面log4j2.xml中的一样</strong>):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    kafka &#123;</span><br><span class="line">        bootstrap_servers =&gt; [&quot;kafka:9092&quot;]</span><br><span class="line">        auto_offset_reset =&gt; &quot;latest&quot;</span><br><span class="line">        consumer_threads =&gt; 3 # 3个消费线程, 默认是1个</span><br><span class="line">        topics =&gt; [&quot;log-collect&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  mutate&#123;  # 切分日志信息并添加相应字段</span><br><span class="line">    split =&gt; [ &quot;message&quot;,&quot; | &quot; ]</span><br><span class="line"></span><br><span class="line">    add_field =&gt; &#123;</span><br><span class="line">      &quot;timestamp&quot; =&gt; &quot;%&#123;[message][0]&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add_field =&gt; &#123;</span><br><span class="line">      &quot;level&quot; =&gt; &quot;%&#123;[message][2]&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add_field =&gt; &#123;</span><br><span class="line">      &quot;server_name&quot; =&gt; &quot;%&#123;[message][1]&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add_field =&gt; &#123;</span><br><span class="line">      &quot;ip&quot; =&gt; &quot;%&#123;[message][3]&#125;&quot;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add_field =&gt; &#123;</span><br><span class="line">      &quot;device&quot; =&gt; &quot;%&#123;[message][4]&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add_field =&gt; &#123;</span><br><span class="line">      &quot;thread_class_method&quot; =&gt; &quot;%&#123;[message][5]&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add_field =&gt; &#123;</span><br><span class="line">      &quot;content&quot; =&gt; &quot;%&#123;[message][6]&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    remove_field =&gt; [ &quot;message&quot; ]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  date &#123;  # 将上面得到的日期信息, 也就是日志打印的时间作为时间戳</span><br><span class="line">    match =&gt; [ &quot;timestamp&quot;, &quot;yyyy-MM-dd HH:mm:ss.SSS&quot; ]</span><br><span class="line">    locale =&gt; &quot;en&quot;</span><br><span class="line">    target =&gt; [ &quot;@timestamp&quot; ]</span><br><span class="line">    timezone =&gt; &quot;Asia/Shanghai&quot; # 这里如果不设置时区, 在Kibana中展示的时候会多了8个小时</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  geoip &#123; # 分析ip</span><br><span class="line">    source =&gt; &quot;ip&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useragent &#123; # 分析User-Agent</span><br><span class="line">    source =&gt; &quot;device&quot;</span><br><span class="line">    target =&gt; &quot;userDevice&quot;</span><br><span class="line">    remove_field =&gt; [ &quot;device&quot; ]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">    stdout&#123; codec =&gt; rubydebug &#125; # 输出到控制台</span><br><span class="line">    elasticsearch &#123; # 输出到 Elasticsearch</span><br><span class="line">        action =&gt; &quot;index&quot;</span><br><span class="line">        hosts  =&gt; [&quot;elk-elasticsearch:9200&quot;]</span><br><span class="line">        index  =&gt; &quot;logstash-%&#123;server_name&#125;-%&#123;+yyyy.MM.dd&#125;&quot;</span><br><span class="line">        document_type =&gt; &quot;%&#123;server_name&#125;&quot;</span><br><span class="line">        # user =&gt; &quot;elastic&quot; # 如果选择开启xpack security需要输入帐号密码</span><br><span class="line">        # password =&gt; &quot;changeme&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Filebeat-Input"><a href="#Filebeat-Input" class="headerlink" title="Filebeat Input"></a>Filebeat Input</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">#    host =&gt; filebeat</span><br><span class="line">    port =&gt; 5044</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line"></span><br><span class="line">  mutate&#123;  # 切分日志信息并添加相应字段</span><br><span class="line"></span><br><span class="line">    split =&gt; [ &quot;message&quot;,&quot; | &quot; ]</span><br><span class="line"></span><br><span class="line">    add_field =&gt; &#123;</span><br><span class="line">      &quot;timestamp&quot; =&gt; &quot;%&#123;[message][0]&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add_field =&gt; &#123;</span><br><span class="line">      &quot;level&quot; =&gt; &quot;%&#123;[message][1]&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add_field =&gt; &#123;</span><br><span class="line">      &quot;server_name&quot; =&gt; &quot;%&#123;[message][2]&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add_field =&gt; &#123;</span><br><span class="line">      &quot;ip&quot; =&gt; &quot;%&#123;[message][3]&#125;&quot;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add_field =&gt; &#123;</span><br><span class="line">      &quot;logger&quot; =&gt; &quot;%&#123;[message][4]&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add_field =&gt; &#123;</span><br><span class="line">      &quot;thread_class_method&quot; =&gt; &quot;%&#123;[message][5]&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add_field =&gt; &#123;</span><br><span class="line">      &quot;content&quot; =&gt; &quot;%&#123;[message][6]&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  date &#123;  # 将上面得到的日期信息, 也就是日志打印的时间作为时间戳</span><br><span class="line">    match =&gt; [ &quot;timestamp&quot;, &quot;yyyy-MM-dd HH:mm:ss.SSS&quot; ]</span><br><span class="line">    locale =&gt; &quot;en&quot;</span><br><span class="line">    target =&gt; &quot;@timestamp&quot; </span><br><span class="line">    timezone =&gt; &quot;Asia/Shanghai&quot; # 这里如果不设置时区, 在Kibana中展示的时候会多了8个小时</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  geoip &#123; # 分析ip</span><br><span class="line">    source =&gt; &quot;ip&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mutate&#123;</span><br><span class="line">    # 定义去除的字段</span><br><span class="line">    remove_field =&gt; [&quot;agent&quot;, &quot;source&quot;, &quot;input&quot;, &quot;@version&quot;, &quot;log&quot;, &quot;ecs&quot;, &quot;_score&quot;, &quot;beat&quot;, &quot;offset&quot;,&quot;prospector&quot;, &quot;host.name&quot;, &quot;message&quot;]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">    # 输出到控制台</span><br><span class="line">    stdout&#123; codec =&gt; rubydebug &#125;</span><br><span class="line"></span><br><span class="line">    # 输出到 Elasticsearch</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">        hosts  =&gt; [&quot;elk-elasticsearch:9200&quot;]</span><br><span class="line">        index  =&gt; &quot;logstash-%&#123;server_name&#125;-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line"></span><br><span class="line">        # manage_template =&gt; false # 关闭logstash默认索引模板</span><br><span class="line">        # template_name =&gt; &quot;crawl&quot; #映射模板的名字</span><br><span class="line">        # template_overwrite =&gt; true</span><br><span class="line">        # user =&gt; &quot;elastic&quot; # 如果选择开启xpack security需要输入帐号密码</span><br><span class="line">        # password =&gt; &quot;changeme&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>logstash.yml</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.host: &quot;0.0.0.0&quot;</span><br><span class="line">xpack.monitoring.elasticsearch.url: http://elk-elasticsearch:9200 # Docker版的Logstash此配置的默认地址是http://elasticsearch:9200</span><br><span class="line"></span><br><span class="line"># xpack.monitoring.elasticsearch.username: &quot;elastic&quot; # 如果选择开启xpack security需要输入帐号密码</span><br><span class="line"># xpack.monitoring.elasticsearch.password: &quot;changeme&quot;</span><br></pre></td></tr></table></figure>
<p>User-Agent 分析配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 将 UA 输出到日志当中, 在 mutate 中添加:</span><br><span class="line">    add_field =&gt; &#123;</span><br><span class="line">      &quot;device&quot; =&gt; &quot;%&#123;[message][4]&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"># 在 filter 中添加</span><br><span class="line">  useragent &#123; # 分析User-Agent</span><br><span class="line">    source =&gt; &quot;device&quot;</span><br><span class="line">    target =&gt; &quot;userDevice&quot;</span><br><span class="line">    remove_field =&gt; [ &quot;device&quot; ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h4><p><code>kibana.yml</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server.name: kibana</span><br><span class="line">server.host: &quot;0&quot;</span><br><span class="line">elasticsearch.url: http://elk-elasticsearch:9200</span><br><span class="line">xpack.monitoring.ui.container.elasticsearch.enabled: true</span><br><span class="line">#elasticsearch.username: &quot;elastic&quot;</span><br><span class="line">#elasticsearch.password: &quot;changeme&quot;</span><br></pre></td></tr></table></figure>
<h4 id="Filebeat"><a href="#Filebeat" class="headerlink" title="Filebeat"></a>Filebeat</h4><p>这是另外一种基于文件的日志收集.</p>
<p>filebeat.yml:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/log4j2Logs/example/all.log</span></span><br><span class="line">  <span class="attr">multiline:</span></span><br><span class="line">    <span class="attr">pattern:</span> <span class="string">^\d&#123;4&#125;</span> <span class="comment"># 多行处理，正则表示如果前面几个数字不是4个数字开头，那么就会合并到一行</span></span><br><span class="line">    <span class="attr">negate:</span> <span class="literal">true</span> <span class="comment"># 正则是否开启，默认false不开启</span></span><br><span class="line">    <span class="attr">match:</span> <span class="string">after</span> <span class="comment"># 不匹配的正则的行是放在上面一行的前面还是后面</span></span><br><span class="line">  <span class="attr">fields:</span>      <span class="comment"># 在采集的信息中添加一个自定义字段 service</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">example</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">output.logstash:</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="string">["logstash:5044"]</span></span><br><span class="line"><span class="comment">#output.console:</span></span><br><span class="line"><span class="comment">#  pretty: true</span></span><br></pre></td></tr></table></figure>
<h3 id="申请License"><a href="#申请License" class="headerlink" title="申请License"></a>申请License</h3><p>转到 <strong><em><a href="https://license.elastic.co/registration" rel="external nofollow noopener noreferrer" target="_blank">License申请地址</a></em></strong> , 下载之后然后修改license中的<code>type</code>、<code>max_nodes</code>、<code>expiry_date_in_millis</code>: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;license&quot;: &#123;</span><br><span class="line">    &quot;uid&quot;: &quot;fe8c9a81-6651-4327-89a3-c9a33bfd8e3f&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;platinum&quot;,  // 这个类型是白金会员</span><br><span class="line">    &quot;issue_date_in_millis&quot;: 1536883200000,</span><br><span class="line">    &quot;expiry_date_in_millis&quot;: 2855980923000, // 过期时间</span><br><span class="line">    &quot;max_nodes&quot;: 100,  // 集群节点数量</span><br><span class="line">    &quot;issued_to&quot;: &quot;xxxx&quot;,</span><br><span class="line">    &quot;issuer&quot;: &quot;Web Form&quot;,</span><br><span class="line">    &quot;signature&quot;: &quot;AAAAAwAAAA0imCa5T/HVBQyiUbSBAAABmC9ZN0hjZDBGYnVyRXpCOW5Bb3FjZDAxOWpSbTVoMVZwUzRxVk1PSmkxaktJRVl5MUYvUWh3bHZVUTllbXNPbzBUemtnbWpBbmlWRmRZb25KNFlBR2x0TXc2K2p1Y1VtMG1UQU9TRGZVSGRwaEJGUjE3bXd3LzRqZ05iLzRteWFNekdxRGpIYlFwYkJiNUs0U1hTVlJKNVlXekMrSlVUdFIvV0FNeWdOYnlESDc3MWhlY3hSQmdKSjJ2ZTcvYlBFOHhPQlV3ZHdDQ0tHcG5uOElCaDJ4K1hob29xSG85N0kvTWV3THhlQk9NL01VMFRjNDZpZEVXeUtUMXIyMlIveFpJUkk2WUdveEZaME9XWitGUi9WNTZVQW1FMG1DenhZU0ZmeXlZakVEMjZFT2NvOWxpZGlqVmlHNC8rWVVUYzMwRGVySHpIdURzKzFiRDl4TmM1TUp2VTBOUlJZUlAyV0ZVL2kvVk10L0NsbXNFYVZwT3NSU082dFNNa2prQ0ZsclZ4NTltbU1CVE5lR09Bck93V2J1Y3c9PQAAAQAWq5AoReLA+uTiRhQ8M0qYERXNidAAsVw0LeN5H7qRXFBAvB+rId4vZNj2DN5W5GuaxuiUhiytvV6maf4ArTsROCMUKGyO9RH24bYgnRbbf6MwB8EBHjSZ6+D8ysCVgfyqAAEKURGSMWszi2mR9R+DINtaeFJnb4B1GeAppbwl7qGGetAQm0vbF7ncyojIfjFthmMUomwo3vs0his5e3UPumItGc57LEk2s5gx95NNP8aFsJXSSFHgWDWwJs18XSl3NZItnEWNfy9lEJeAkR+LWISfizZIfViOTlcDBVGKR7w8u8D5QXFUVdsTi2XU5qfIWFb78BOtpCHIlU+AjB6m&quot;,</span><br><span class="line">    &quot;start_date_in_millis&quot;: 1536883200000</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="启动ELK"><a href="#启动ELK" class="headerlink" title="启动ELK"></a>启动ELK</h3><p>在此之前, 官方提到了<code>vm.max_map_count</code>的值在生产环境最少要设置成262144, 设置的方式有两种:</p>
<ol>
<li><p>永久性的修改, 在<code>/etc/sysctl.conf</code>文件中添加一行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep vm.max_map_count /etc/sysctl.conf # 查找当前的值。</span><br><span class="line"></span><br><span class="line">vm.max_map_count=262144 # 修改或者新增</span><br></pre></td></tr></table></figure>
</li>
<li><p>正在运行的机器:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sysctl -w vm.max_map_count=262144</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><code>docker-compose.yml</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">elk-elasticsearch:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:6.4.0</span></span><br><span class="line"><span class="comment">#    ports:</span></span><br><span class="line"><span class="comment">#      - "9200:9200"</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.type=single-node</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ES_JAVA_OPTS=-Xms512m</span> <span class="string">-Xmx512m</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./crack/x-pack-core-6.4.0.jar:/usr/share/elasticsearch/modules/x-pack-core/x-pack-core-6.4.0.jar</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./config/license.json:/usr/share/elasticsearch/license.json</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">node.role</span> <span class="string">==</span> <span class="string">manager</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">backend:</span></span><br><span class="line">        <span class="attr">aliases:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">elk-elasticsearch</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">kibana:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/kibana/kibana:6.4.0</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"5601:5601"</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">node.role</span> <span class="string">==</span> <span class="string">manager</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">backend:</span></span><br><span class="line">        <span class="attr">aliases:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">kibana</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./config/kibana.yml:/usr/share/kibana/config/kibana.yml</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elk-elasticsearch</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">logstash:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/logstash/logstash:6.4.0</span></span><br><span class="line"><span class="comment">#    ports:</span></span><br><span class="line"><span class="comment">#      - "4560:4560"</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">LS_JAVA_OPTS=-Xmx512m</span> <span class="string">-Xms512m</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./config/logstash.conf:/etc/logstash.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./config/logstash.yml:/usr/share/logstash/config/logstash.yml</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">node.role</span> <span class="string">==</span> <span class="string">manager</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">backend:</span></span><br><span class="line">        <span class="attr">aliases:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">logstash</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elk-elasticsearch</span></span><br><span class="line">    <span class="attr">entrypoint:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">logstash</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">-f</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/logstash.conf</span></span><br><span class="line">      </span><br><span class="line"><span class="comment">#  filebeat:</span></span><br><span class="line"><span class="comment">#    image: docker.elastic.co/beats/filebeat:7.1.1</span></span><br><span class="line"><span class="comment">#    restart: always</span></span><br><span class="line"><span class="comment">#    volumes:</span></span><br><span class="line"><span class="comment">#      - ./filebeat/filebeat.yml:/usr/share/filebeat/filebeat.yml:ro</span></span><br><span class="line"><span class="comment">#      - /home/ybd/data/git-repo/bitbucket/central-city/cc-component/log4j2Logs:/log4j2Logs</span></span><br><span class="line"><span class="comment">#    deploy:</span></span><br><span class="line"><span class="comment">#      placement:</span></span><br><span class="line"><span class="comment">#        constraints:</span></span><br><span class="line"><span class="comment">#          - node.role == manager</span></span><br><span class="line"><span class="comment">#    networks:</span></span><br><span class="line"><span class="comment">#      backend:</span></span><br><span class="line"><span class="comment">#        aliases:</span></span><br><span class="line"><span class="comment">#          - filebeat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># docker network create -d=overlay --attachable backend</span></span><br><span class="line"><span class="comment"># docker network create --opt encrypted -d=overlay --attachable --subnet 10.10.0.0/16 backend</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">backend:</span></span><br><span class="line">    <span class="attr">external:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">backend</span></span><br></pre></td></tr></table></figure>
<p>启动后需要手动请求更新License: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br><span class="line">docker exec $&#123;CONTAINER_NAME&#125; curl -XPUT &apos;http://0.0.0.0:9200/_xpack/license&apos; -H &quot;Content-Type: application/json&quot; -d @license.json</span><br></pre></td></tr></table></figure>
<p>大概是下面这个样子: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ybd @ ybd-PC in ~/data/git-repo/bitbucket/ms-base/docker-compose/elk on git:master x [20:52:51] </span><br><span class="line">$ docker-compose up -d                                                   </span><br><span class="line"></span><br><span class="line">Creating elk_elk-elasticsearch_1 ... done</span><br><span class="line"></span><br><span class="line">Creating elk_elk-elasticsearch_1 ... </span><br><span class="line">Creating elk_logstash_1          ... done</span><br><span class="line">Creating elk_kibana_1            ... done</span><br><span class="line"></span><br><span class="line"># ybd @ ybd-PC in ~/data/git-repo/bitbucket/ms-base/docker-compose/elk on git:master x [20:53:58] </span><br><span class="line">$ docker exec elk_elk-elasticsearch_1 curl -XPUT &apos;http://0.0.0.0:9200/_xpack/license&apos; -H &quot;Content-Type: application/json&quot; -d @license.json</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100  1278  100    46  100  1232    328   8786 --:--:-- --:--:-- --:--:--  8800</span><br><span class="line">&#123;&quot;acknowledged&quot;:true,&quot;license_status&quot;:&quot;valid&quot;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.yangbingdong.com/kibana-license.png" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/docker-logs-collect/kibana02.png" alt></p>
<h3 id="动态模板"><a href="#动态模板" class="headerlink" title="动态模板"></a>动态模板</h3><p>我们可以自定义Logstash输出到ElasticSearch的Mapping.</p>
<p>logstash.conf 的 output 配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">output &#123;</span><br><span class="line">    # 输出到控制台</span><br><span class="line">    stdout&#123; codec =&gt; rubydebug &#125;</span><br><span class="line"></span><br><span class="line">    # 输出到 Elasticsearch</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">        hosts  =&gt; [&quot;elk-elasticsearch:9200&quot;]</span><br><span class="line">        index  =&gt; &quot;logstash-%&#123;server_name&#125;-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line"></span><br><span class="line">        template =&gt; &quot;/usr/share/logstash/config/logstash-template.json&quot;</span><br><span class="line">        template_name =&gt; &quot;logstash&quot; #映射模板的名字</span><br><span class="line">        template_overwrite =&gt; true</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>配置模板:</p>
<p>logstash-template.json:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"template"</span>:<span class="string">"logstash-*"</span>,</span><br><span class="line">    <span class="attr">"settings"</span>:&#123;</span><br><span class="line">        <span class="attr">"index.number_of_shards"</span>:<span class="number">5</span>,</span><br><span class="line">        <span class="attr">"number_of_replicas"</span>:<span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"mappings"</span>:&#123;</span><br><span class="line">        <span class="attr">"dynamic_templates"</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"message_field"</span>:&#123;</span><br><span class="line">                    <span class="attr">"match"</span>:<span class="string">"content"</span>,</span><br><span class="line">                    <span class="attr">"match_mapping_type"</span>:<span class="string">"string"</span>,</span><br><span class="line">                    <span class="attr">"mapping"</span>:&#123;</span><br><span class="line">                        <span class="attr">"type"</span>:<span class="string">"text"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"string_fields"</span>:&#123;</span><br><span class="line">                    <span class="attr">"match"</span>:<span class="string">"*"</span>,</span><br><span class="line">                    <span class="attr">"match_mapping_type"</span>:<span class="string">"string"</span>,</span><br><span class="line">                    <span class="attr">"mapping"</span>:&#123;</span><br><span class="line">                        <span class="attr">"type"</span>:<span class="string">"keyword"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"properties"</span>:&#123;</span><br><span class="line">            <span class="attr">"@timestamp"</span>:&#123;</span><br><span class="line">                <span class="attr">"type"</span>:<span class="string">"date"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"@version"</span>:&#123;</span><br><span class="line">                <span class="attr">"type"</span>:<span class="string">"keyword"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"geoip"</span>:&#123;</span><br><span class="line">                <span class="attr">"dynamic"</span>:<span class="literal">true</span>,</span><br><span class="line">                <span class="attr">"properties"</span>:&#123;</span><br><span class="line">                    <span class="attr">"ip"</span>:&#123;</span><br><span class="line">                        <span class="attr">"type"</span>:<span class="string">"ip"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">"location"</span>:&#123;</span><br><span class="line">                        <span class="attr">"type"</span>:<span class="string">"geo_point"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">"latitude"</span>:&#123;</span><br><span class="line">                        <span class="attr">"type"</span>:<span class="string">"float"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">"longitude"</span>:&#123;</span><br><span class="line">                        <span class="attr">"type"</span>:<span class="string">"float"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>docker-compose.yml 中添加配置文件的映射:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logstash:</span><br><span class="line">  image: docker.elastic.co/logstash/logstash:7.1.1</span><br><span class="line">  #    ports:</span><br><span class="line">  #      - &quot;4560:4560&quot;</span><br><span class="line">  restart: always</span><br><span class="line">  environment:</span><br><span class="line">    - LS_JAVA_OPTS=-Xmx512m -Xms512m</span><br><span class="line">  volumes:</span><br><span class="line">    - ./logstash/logstash.conf:/etc/logstash.conf</span><br><span class="line">    - ./logstash/logstash.yml:/usr/share/logstash/config/logstash.yml</span><br><span class="line">    - ./elasticsearch/logstash-template.json:/usr/share/logstash/config/logstash-template.json</span><br></pre></td></tr></table></figure>
<h2 id="Kibana相关设置"><a href="#Kibana相关设置" class="headerlink" title="Kibana相关设置"></a>Kibana相关设置</h2><h3 id="显示所有插件"><a href="#显示所有插件" class="headerlink" title="显示所有插件"></a>显示所有插件</h3><p>在Kibana首页最下面找到: </p>
<p><img src="https://cdn.yangbingdong.com/img/docker-logs-collect/kibana-full-plugin-button.png" alt></p>
<h3 id="Discover每页显示行数"><a href="#Discover每页显示行数" class="headerlink" title="Discover每页显示行数"></a>Discover每页显示行数</h3><p>找到Advanced Setting<img src="https://cdn.yangbingdong.com/img/docker-logs-collect/kibana-admin-setting.png" alt></p>
<p>点进去找到 <code>discover:sampleSize</code>再点击Edit修改:</p>
<p><img src="https://cdn.yangbingdong.com/img/docker-logs-collect/kibana-page-size.png" alt></p>
<h3 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h3><p>Kibana默认读取浏览器时区, 可通过<code>dateFormat:tz</code>进行修改: </p>
<p><img src="https://cdn.yangbingdong.com/img/docker-logs-collect/kibana-timezone.png" alt></p>
<h2 id="ElasticSearch-UI"><a href="#ElasticSearch-UI" class="headerlink" title="ElasticSearch UI"></a>ElasticSearch UI</h2><ul>
<li><strong><em><a href="https://github.com/360EntSecGroup-Skylar/ElasticHD" rel="external nofollow noopener noreferrer" target="_blank">ElasticHD</a></em></strong></li>
<li><strong><em><a href="https://github.com/appbaseio/dejavu/" rel="external nofollow noopener noreferrer" target="_blank">Dejavu</a></em></strong></li>
</ul>
<h1 id="Spring-Boot-集成-Elastic-APM"><a href="#Spring-Boot-集成-Elastic-APM" class="headerlink" title="Spring Boot 集成 Elastic APM"></a>Spring Boot 集成 Elastic APM</h1><h2 id="运行APM-Server"><a href="#运行APM-Server" class="headerlink" title="运行APM Server"></a>运行APM Server</h2><p><code>docker-compose</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">apm-server:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/apm/apm-server:6.4.0</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"8200:8200"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./config/apm-server.yml:/usr/share/apm-server/apm-server.yml</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">placement:</span></span><br><span class="line">        <span class="attr">constraints:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">node.role</span> <span class="string">==</span> <span class="string">manager</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">backend-swarm:</span></span><br><span class="line">        <span class="attr">aliases:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">apm-server</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># docker network create -d=overlay --attachable backend-swarm</span></span><br><span class="line"><span class="comment"># docker network create --opt encrypted -d=overlay --attachable --subnet 10.10.0.0/16 backend-swarm</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">backend-swarm:</span></span><br><span class="line">    <span class="attr">external:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">backend-swarm</span></span><br></pre></td></tr></table></figure>
<p><code>apm-server.yml</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apm-server:</span><br><span class="line">  host: &quot;0.0.0.0:8200&quot;</span><br><span class="line"></span><br><span class="line">setup.template.settings:</span><br><span class="line"></span><br><span class="line">  index:</span><br><span class="line">    number_of_shards: 1</span><br><span class="line">    codec: best_compression</span><br><span class="line">    </span><br><span class="line">output.elasticsearch:</span><br><span class="line">  hosts: [&quot;elk-elasticsearch:9200&quot;]</span><br><span class="line"></span><br><span class="line">  indices:</span><br><span class="line">  - index: &quot;apm-%&#123;[beat.version]&#125;-sourcemap&quot;</span><br><span class="line">    when.contains:</span><br><span class="line">      processor.event: &quot;sourcemap&quot;</span><br><span class="line"></span><br><span class="line">  - index: &quot;apm-%&#123;[beat.version]&#125;-error-%&#123;+yyyy.MM.dd&#125;&quot;</span><br><span class="line">    when.contains:</span><br><span class="line">      processor.event: &quot;error&quot;</span><br><span class="line"></span><br><span class="line">  - index: &quot;apm-%&#123;[beat.version]&#125;-transaction-%&#123;+yyyy.MM.dd&#125;&quot;</span><br><span class="line">    when.contains:</span><br><span class="line">      processor.event: &quot;transaction&quot;</span><br><span class="line"></span><br><span class="line">  - index: &quot;apm-%&#123;[beat.version]&#125;-span-%&#123;+yyyy.MM.dd&#125;&quot;</span><br><span class="line">    when.contains:</span><br><span class="line">      processor.event: &quot;span&quot;</span><br><span class="line"></span><br><span class="line">  - index: &quot;apm-%&#123;[beat.version]&#125;-metric-%&#123;+yyyy.MM.dd&#125;&quot;</span><br><span class="line">    when.contains:</span><br><span class="line">      processor.event: &quot;metric&quot;</span><br><span class="line"></span><br><span class="line">  - index: &quot;apm-%&#123;[beat.version]&#125;-onboarding-%&#123;+yyyy.MM.dd&#125;&quot;</span><br><span class="line">    when.contains:</span><br><span class="line">      processor.event: &quot;onboarding&quot;</span><br><span class="line"></span><br><span class="line">logging.level: warning</span><br><span class="line"></span><br><span class="line">logging.metrics.enabled: false</span><br></pre></td></tr></table></figure>
<p>这个配置文件从容器中<code>/usr/share/apm-server/apm-server.yml</code>复制出来稍微改了一下Elasticsearch的Url. </p>
<p>若开启了X-Pack, 则需要在yml中配置帐号密码: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">output.elasticsearch:</span><br><span class="line">    hosts: [&quot;&lt;es_url&gt;&quot;]</span><br><span class="line">    username: &lt;username&gt;</span><br><span class="line">    password: &lt;password&gt;</span><br></pre></td></tr></table></figure>
<h2 id="集成到Spring-Boot"><a href="#集成到Spring-Boot" class="headerlink" title="集成到Spring Boot"></a>集成到Spring Boot</h2><p>下载 <strong><em><a href="http://search.maven.org/#search%7Cga%7C1%7Ca%3Aelastic-apm-agent" rel="external nofollow noopener noreferrer" target="_blank">APM代理依赖</a></em></strong></p>
<p>在启动参数中添加:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -javaagent:/path/to/elastic-apm-agent-&lt;version&gt;.jar \</span><br><span class="line">     -Delastic.apm.service_name=my-application \</span><br><span class="line">     -Delastic.apm.server_url=http://localhost:8200 \ </span><br><span class="line">     -Delastic.apm.application_packages=org.example \ </span><br><span class="line">     -jar my-application.jar</span><br></pre></td></tr></table></figure>
<p>启动后在Kibana的APM模块中更新一下索引, 效果图大概是这样的: </p>
<p><img src="https://cdn.yangbingdong.com/img/docker-logs-collect/apm.png" alt></p>
<h1 id="log-pilot"><a href="#log-pilot" class="headerlink" title="log-pilot"></a>log-pilot</h1><p>Github: <strong><em><a href="https://github.com/AliyunContainerService/log-pilot" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/AliyunContainerService/log-pilot</a></em></strong></p>
<p>更多说明: <strong><em><a href="https://yq.aliyun.com/articles/69382" rel="external nofollow noopener noreferrer" target="_blank">https://yq.aliyun.com/articles/69382</a></em></strong></p>
<p>这个是Ali开源的日志收集组件, 通过中间件的方式部署, 自动监听其他容器的日志, 非常方便: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --rm -it -v /var/run/docker.sock:/var/run/docker.sock -v /etc/localtime:/etc/localtime -v /:/host -e PILOT_TYPE=fluentd -e FLUENTD_OUTPUT=elasticsearch -e ELASTICSEARCH_HOST=192.168.6.113 -e ELASTICSEARCH_PORT=9200 -e TZ=Asia/Chongqing --privileged registry.cn-hangzhou.aliyuncs.com/acs-sample/log-pilot:latest</span><br></pre></td></tr></table></figure>
<p>需要手机日志的容器: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --rm --label aliyun.logs.demo=stdout -p 8080:8080 192.168.0.202:8080/dev-images/demo:latest</span><br></pre></td></tr></table></figure>
<ul>
<li>通过<code>--label aliyun.logs.demo=stdout</code>告诉<code>log-pilot</code>需要收集日志, 索引为<code>demo</code></li>
</ul>
<p>然后打开Kibana就可以看到日志了. </p>
<p>问题: </p>
<ul>
<li>日志稍微延迟</li>
<li>日志顺序混乱</li>
<li>异常堆栈不集中</li>
</ul>
<h1 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h1><blockquote>
<p>参考:</p>
<p><strong><em><a href="https://www.yinchengli.com/2016/09/16/logstash/" rel="external nofollow noopener noreferrer" target="_blank">https://www.yinchengli.com/2016/09/16/logstash/</a></em></strong></p>
<p><strong><em><a href="https://www.jianshu.com/p/ba1aa0c52942" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/ba1aa0c52942</a></em></strong></p>
<p><strong><em><a href="https://www.jianshu.com/p/eb10c414a93f" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/eb10c414a93f</a></em></strong></p>
<p><strong><em><a href="https://my.oschina.net/kkrgwbj/blog/734530" rel="external nofollow noopener noreferrer" target="_blank">https://my.oschina.net/kkrgwbj/blog/734530</a></em></strong></p>
</blockquote>
]]></content><categories><category>Programming</category><category>Java</category><category>Spring Boot</category></categories><tags><tag>Java</tag><tag>Spring Boot</tag><tag>Spring</tag><tag>Docker</tag><tag>Elasticsearch</tag></tags></entry><entry><title>Spring Boot学习之杂记篇</title><url>/2018/spring-boot-learning-hodgepodge/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/spring-boot.png" alt></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><blockquote>
<p>Spring Boot作为当下最流行的微服务项目构建基础, 有的时候我们根本不需要额外的配置就能够干很多的事情, 这得益于它的一个核心理念: “习惯优于配置”. . . </p>
<p>说白的就是大部分的配置都已经按照<del>最佳实践</del>的编程规范配置好了</p>
<p>本文基于 Spring Boot 2的学习杂记, 还是与1.X版本还是有一定区别的</p>
</blockquote>
<a id="more"></a>
<h1 id="构建依赖版本管理工程"><a href="#构建依赖版本管理工程" class="headerlink" title="构建依赖版本管理工程"></a>构建依赖版本管理工程</h1><p>学习Demo: <strong><em><a href="https://github.com/masteranthoneyd/spring-boot-learning" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/masteranthoneyd/spring-boot-learning</a></em></strong></p>
<blockquote>
<p>为什么要分开为两个工程？因为考虑到common工程也需要版本控制, 但parent工程中依赖了common工程, 所以common工程不能依赖parent工程（循环依赖）, 故例外抽离出一个dependencies的工程, 专门用作依赖版本管理, 而parent工程用作其他子工程的公共依赖. </p>
</blockquote>
<h2 id="依赖版本管理工程"><a href="#依赖版本管理工程" class="headerlink" title="依赖版本管理工程"></a>依赖版本管理工程</h2><p>跟下面父工程一样只有一个<code>pom.xml</code></p>
<p><em><a href="https://github.com/masteranthoneyd/spring-boot-learning/tree/master/spring-boot-parent-dependencies" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/masteranthoneyd/spring-boot-learning/tree/master/spring-boot-parent-dependencies</a></em></p>
<h2 id="父工程"><a href="#父工程" class="headerlink" title="父工程"></a>父工程</h2><p><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/parent.png" alt></p>
<p><em><a href="https://github.com/masteranthoneyd/spring-boot-learning/blob/master/spring-boot-parent/pom.xml" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/masteranthoneyd/spring-boot-learning/blob/master/spring-boot-parent/pom.xml</a></em></p>
<p>说明: </p>
<ul>
<li><code>&lt;packaging&gt;</code> 为 <code>pom</code> 表示此会被打包成 pom 文件被其他子项目依赖. </li>
<li>由于 Spring Boot 以及集成了 <code>maven-surefire-plugin</code> 插件, 跳过测试只需要在 properties中添加 <code>&lt;maven.test.skip&gt;true&lt;/maven.test.skip&gt;</code>即可, 等同 <code>mvn package -Dmaven.test.skip=true</code>, 也可使用 <code>&lt;skipTests&gt;true&lt;/skipTests&gt;</code>, 两者的区别在于 <code>&lt;maven.test.skip&gt;</code> 标签连 <code>.class</code> 文件都不会生成, 而 <code>&lt;skipTests&gt;</code> 会编译生成 <code>.class</code> 文件</li>
</ul>
<ul>
<li>子项目会继承父项目的 <code>properties</code>, 若子项目重新定义属性, 则会覆盖父项目的属性. </li>
<li><code>&lt;dependencyManagement&gt;</code> 管理依赖版本, 不使用 <code>&lt;parent&gt;</code> 来依赖 Spring Boot, 可以使用上面方式, 添加 <code>&lt;type&gt;</code> 为 <code>pom</code> 以及 <code>&lt;scope&gt;</code> 为 <code>import</code>. </li>
<li><code>&lt;pluginManagement&gt;</code> 的功能类似于 <code>&lt;dependencyManagement&gt;</code>, 在父项目中设置好插件属性, 在子项目中直接依赖就可以, 不需要每个子项目都配置一遍, 当然了, 子项目也可以覆盖插件属性. </li>
</ul>
<h1 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h1><h2 id="打包成可执行的Jar"><a href="#打包成可执行的Jar" class="headerlink" title="打包成可执行的Jar"></a>打包成可执行的Jar</h2><p>默认情况下Spring Boot打包出来的jar包是不可执行的, 需要这样配置: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>打包之后会发现有<strong>两个</strong>jar, 一个是本身的代码, 一个是集成了Spring Boot的可运行jar: </p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/repackage.png" alt></p>
<h2 id="打包依赖了Spring-Boot的工具库"><a href="#打包依赖了Spring-Boot的工具库" class="headerlink" title="打包依赖了Spring Boot的工具库"></a>打包依赖了Spring Boot的工具库</h2><p>只需要在打包插件<code>spring-boot-maven-plugin</code>中这样配置: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>none<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="打包契约类"><a href="#打包契约类" class="headerlink" title="打包契约类"></a>打包契约类</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>com/yangbingdong/server/**/contract/**/*.class<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>none<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后指定该pom文件构建: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn -f pom_own.xml package</span><br></pre></td></tr></table></figure>
<p>参数说明:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;repackage&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;executable&gt;true&lt;/executable&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>executable</code>: 打包出来的Jar包是否可执行, 设置为true打包是会有额外的脚本使得Jar包可直接执行.</li>
<li><code>goal:repackage</code>: 默认的 goal, 将 Spring Boot 再次打包成可执行的Jar</li>
</ul>
<h1 id="配置文件-Properties-和-YAML"><a href="#配置文件-Properties-和-YAML" class="headerlink" title="配置文件: Properties 和 YAML"></a>配置文件: Properties 和 YAML</h1><h2 id="配置文件的生效顺序-会对值进行覆盖"><a href="#配置文件的生效顺序-会对值进行覆盖" class="headerlink" title="配置文件的生效顺序, 会对值进行覆盖"></a>配置文件的生效顺序, 会对值进行覆盖</h2><ol>
<li>Devtools 全局配置：当 devtools 启用时，<code>$HOME/.config/spring-boot</code></li>
<li>测试类中的 <code>@TestPropertySource</code></li>
<li>测试中的 <code>properties</code> 属性：在 @SpringBootTest 和 用来测试特定片段的测试注解</li>
<li>命令行参数</li>
<li><code>SPRING_APPLICATION_JSON</code> 中的属性：内嵌在环境变量或系统属性中的 JSON</li>
<li><code>ServletConfig</code> 初始化参数</li>
<li><code>ServletContext</code> 初始化参数</li>
<li><code>java:comp/env</code> 中的 JNDI 属性</li>
<li>Java 系统属性：<code>System.getProperties()</code></li>
<li>操作系统环境变量</li>
<li>随机值（<code>RandomValuePropertySource</code>）：<code>random.*</code>属性</li>
<li>jar 包<strong>外</strong>的指定 profile 配置文件：<code>application-{profile}.properties</code></li>
<li>jar 包<strong>内</strong>的指定 profile 配置文件：<code>application-{profile}.properties</code></li>
<li>jar 包<strong>外</strong>的默认配置文件：<code>application.properties</code></li>
<li>jar 包<strong>内</strong>的默认配置文件：<code>application.properties</code></li>
<li>代码内的 <code>@PropertySource</code>注解：用于 <code>@Configuration</code> 类上</li>
<li>默认属性：通过设置 <code>SpringApplication.setDefaultProperties</code> 指定</li>
</ol>
<h2 id="配置随机值"><a href="#配置随机值" class="headerlink" title="配置随机值"></a>配置随机值</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">roncoo.secret=$&#123;random.value&#125;</span><br><span class="line">roncoo.number=$&#123;random.int&#125;</span><br><span class="line">roncoo.bignumber=$&#123;random.long&#125;</span><br><span class="line">roncoo.number.less.than.ten=$&#123;random.int(10)&#125;</span><br><span class="line">roncoo.number.in.range=$&#123;random.int[1024,65536]&#125;</span><br><span class="line"></span><br><span class="line">读取使用注解: @Value(value = &quot;$&#123;roncoo.secret&#125;&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="应用简单配置"><a href="#应用简单配置" class="headerlink" title="应用简单配置"></a>应用简单配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#端口配置: </span><br><span class="line">server.port=8090</span><br><span class="line">#应用名</span><br><span class="line">spring.application.name=test-demo</span><br><span class="line">#时间格式化</span><br><span class="line">spring.jackson.date-format=yyyy-MM-dd HH:mm:ss</span><br><span class="line">#时区设置</span><br><span class="line">spring.jackson.time-zone=Asia/Chongqing</span><br></pre></td></tr></table></figure>
<h2 id="导入其他配置"><a href="#导入其他配置" class="headerlink" title="导入其他配置"></a>导入其他配置</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">include:</span> <span class="string">docker-log4j2</span></span><br></pre></td></tr></table></figure>
<p>此时在项目或其他JAR包中应该存在<code>application-docker-log4j2.yml</code>.</p>
<h3 id="通过编码导入配置文件"><a href="#通过编码导入配置文件" class="headerlink" title="通过编码导入配置文件"></a>通过编码导入配置文件</h3><p>实现 <code>SpringApplicationRunListener</code>(<strong>注意构造器, 不声明会报错, 因为Spring是通过反射调用构造器的</strong>):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MvcProfileIncludeInitializer</span> <span class="keyword">implements</span> <span class="title">SpringApplicationRunListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROFILE_MVC = <span class="string">"mvc"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MvcProfileIncludeInitializer</span><span class="params">(SpringApplication application, String[] args)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">starting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		SystemProfileAppender.appendProfile(PROFILE_MVC);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">started</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">running</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemProfileAppender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">appendProfile</span><span class="params">(String profile)</span> </span>&#123;</span><br><span class="line">		String property = System.getProperty(ConfigFileApplicationListener.INCLUDE_PROFILES_PROPERTY);</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.isBlank(property)) &#123;</span><br><span class="line">			property = profile;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			property = property + <span class="string">","</span> + profile;</span><br><span class="line">		&#125;</span><br><span class="line">		System.setProperty(ConfigFileApplicationListener.INCLUDE_PROFILES_PROPERTY, property);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>resource/META-INF/spring-factories</code> 中添加:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.SpringApplicationRunListener=\</span><br><span class="line">  com.xxx.xxx.MvcProfileIncludeInitializer</span><br></pre></td></tr></table></figure>
<p>这样相当于 include 了 <code>application-mvc.yml</code> 了.</p>
<h3 id="通过-PropertySource"><a href="#通过-PropertySource" class="headerlink" title="通过 PropertySource"></a>通过 PropertySource</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YamlPropertySourceFactory</span> <span class="keyword">implements</span> <span class="title">PropertySourceFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PropertySource&lt;?&gt; createPropertySource(<span class="meta">@Nullable</span> String name, EncodedResource resource) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Properties propertiesFromYaml = loadYamlIntoProperties(resource);</span><br><span class="line">        String sourceName = name != <span class="keyword">null</span> ? name : resource.getResource().getFilename();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PropertiesPropertySource(sourceName, propertiesFromYaml);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Properties <span class="title">loadYamlIntoProperties</span><span class="params">(EncodedResource resource)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            YamlPropertiesFactoryBean factory = <span class="keyword">new</span> YamlPropertiesFactoryBean();</span><br><span class="line">            factory.setResources(resource.getResource());</span><br><span class="line">            factory.afterPropertiesSet();</span><br><span class="line">            <span class="keyword">return</span> factory.getObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">            <span class="comment">// for ignoreResourceNotFound</span></span><br><span class="line">            Throwable cause = e.getCause();</span><br><span class="line">            <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> FileNotFoundException)</span><br><span class="line">                <span class="keyword">throw</span> (FileNotFoundException) e.getCause();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource</span>(factory = YamlPropertySourceFactory<span class="class">.<span class="keyword">class</span>, <span class="title">value</span> </span>= <span class="string">"classpath:MQ-CONF/rabbitmq.yml"</span>)</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMqConfiguration</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="配置文件-多环境配置"><a href="#配置文件-多环境配置" class="headerlink" title="配置文件-多环境配置"></a>配置文件-多环境配置</h2><h3 id="多环境配置的好处"><a href="#多环境配置的好处" class="headerlink" title="多环境配置的好处"></a>多环境配置的好处</h3><blockquote>
<ul>
<li>不同环境配置可以配置不同的参数</li>
<li>便于部署, 提高效率, 减少出错</li>
</ul>
</blockquote>
<h3 id="Properties多环境配置"><a href="#Properties多环境配置" class="headerlink" title="Properties多环境配置"></a>Properties多环境配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 配置激活选项</span><br><span class="line">spring.profiles.active=dev</span><br><span class="line"></span><br><span class="line">2.添加其他配置文件</span><br><span class="line">application.properties</span><br><span class="line">application-dev.properties</span><br><span class="line">application-prod.properties</span><br><span class="line">application-test.properties</span><br></pre></td></tr></table></figure>
<h3 id="YAML多环境配置"><a href="#YAML多环境配置" class="headerlink" title="YAML多环境配置"></a>YAML多环境配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">.配置激活选项</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line"><span class="number">2</span><span class="string">.在配置文件添加三个英文状态下的短横线即可区分</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure>
<h3 id="两种配置方式的比较"><a href="#两种配置方式的比较" class="headerlink" title="两种配置方式的比较"></a>两种配置方式的比较</h3><ul>
<li>Properties配置多环境, 需要添加多个配置文件, YAML只需要一个配件文件</li>
<li>书写格式的差异, yaml相对比较简洁, 优雅</li>
<li>YAML的缺点: 不能通过<code>@PropertySource</code>注解加载. 如果需要使用<code>@PropertySource</code>注解的方式加载值, 那就要使用properties文件. </li>
</ul>
<h3 id="启动时指定环境"><a href="#启动时指定环境" class="headerlink" title="启动时指定环境"></a>启动时指定环境</h3><h4 id="通过命令行参数"><a href="#通过命令行参数" class="headerlink" title="通过命令行参数"></a>通过命令行参数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar myapp.jar --spring.profiles.active=dev</span><br></pre></td></tr></table></figure>
<h4 id="通过-Java-系统参数"><a href="#通过-Java-系统参数" class="headerlink" title="通过 Java 系统参数"></a>通过 Java 系统参数</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -Dspring.profiles.active=dev -jar myapp.jar</span><br></pre></td></tr></table></figure>
<h4 id="通过OS环境变量"><a href="#通过OS环境变量" class="headerlink" title="通过OS环境变量"></a>通过OS环境变量</h4><p>Spring Boot 在启动时加载环境变量 <code>SPRING_PROFILES_ACTIVE</code> 并将其设置为配置文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export SPRING_PROFILES_ACTIVE=dev</span><br></pre></td></tr></table></figure>
<h1 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h1><p><code>pom.xml</code>添加依赖: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--支持热启动jar包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- optional=true,依赖不会传递, 该项目依赖devtools；之后依赖该项目的项目如果想要使用devtools, 需要重新引入 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">fork</span>&gt;</span>true<span class="tag">&lt;/<span class="name">fork</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>application.yml</code>配置文件中添加: </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">devtools:</span></span><br><span class="line">    <span class="attr">restart:</span></span><br><span class="line">      <span class="comment">#热部署生效 默认就是为true</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment">#classpath目录下的WEB-INF文件夹内容修改不重启</span></span><br><span class="line">      <span class="attr">exclude:</span> <span class="string">WEB-INF/**</span></span><br></pre></td></tr></table></figure>
<p>关于DevTools的键值如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># DEVTOOLS (DevToolsProperties)</span><br><span class="line">spring.devtools.livereload.enabled=true # Enable a livereload.com compatible server.</span><br><span class="line">spring.devtools.livereload.port=35729 # Server port.</span><br><span class="line">spring.devtools.restart.additional-exclude= # Additional patterns that should be excluded from triggering a full restart.</span><br><span class="line">spring.devtools.restart.additional-paths= # Additional paths to watch for changes.</span><br><span class="line">spring.devtools.restart.enabled=true # Enable automatic restart.</span><br><span class="line">spring.devtools.restart.exclude=META-INF/maven/**,META-INF/resources/**,resources/**,static/**,public/**,templates/**,**/*Test.class,**/*Tests.class,git.properties # Patterns that should be excluded from triggering a full restart.</span><br><span class="line">spring.devtools.restart.poll-interval=1000 # Amount of time (in milliseconds) to wait between polling for classpath changes.</span><br><span class="line">spring.devtools.restart.quiet-period=400 # Amount of quiet time (in milliseconds) required without any classpath changes before a restart is triggered.</span><br><span class="line">spring.devtools.restart.trigger-file= # Name of a specific file that when changed will trigger the restart check. If not specified any classpath file change will trigger the restart.</span><br><span class="line"></span><br><span class="line"># REMOTE DEVTOOLS (RemoteDevToolsProperties)</span><br><span class="line">spring.devtools.remote.context-path=/.~~spring-boot!~ # Context path used to handle the remote connection.</span><br><span class="line">spring.devtools.remote.debug.enabled=true # Enable remote debug support.</span><br><span class="line">spring.devtools.remote.debug.local-port=8000 # Local remote debug server port.</span><br><span class="line">spring.devtools.remote.proxy.host= # The host of the proxy to use to connect to the remote application.</span><br><span class="line">spring.devtools.remote.proxy.port= # The port of the proxy to use to connect to the remote application.</span><br><span class="line">spring.devtools.remote.restart.enabled=true # Enable remote restart.</span><br><span class="line">spring.devtools.remote.secret= # A shared secret required to establish a connection (required to enable remote support).</span><br><span class="line">spring.devtools.remote.secret-header-name=X-AUTH-TOKEN # HTTP header used to transfer the shared secret.</span><br></pre></td></tr></table></figure></p>
<p>当我们修改了java类后, IDEA默认是不自动编译的, 而<code>spring-boot-devtools</code>又是监测<code>classpath</code>下的文件发生变化才会重启应用, 所以需要设置IDEA的自动编译: </p>
<p>（1）<strong>File-Settings-Compiler-Build Project automatically</strong></p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/spring-boot-devtools01.png" alt></p>
<p>（2）<strong>ctrl + shift + alt + /,选择Registry,勾上 Compiler autoMake allow when app running</strong></p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/spring-boot-devtools02.png" alt></p>
<p>OK了, 重启一下项目, 然后改一下类里面的内容, IDEA就会自动去make了. </p>
<blockquote>
<p><strong>热部署可能会牺牲一定的系统性能, 因为是动态的编译</strong></p>
</blockquote>
<h1 id="使用为Undertow作为Web容器"><a href="#使用为Undertow作为Web容器" class="headerlink" title="使用为Undertow作为Web容器"></a>使用为Undertow作为Web容器</h1><blockquote>
<p>Spring Boot内嵌容器支持Tomcat、Jetty、Undertow.<br>根据 <a href="https://link.jianshu.com/?t=https://examples.javacodegeeks.com/enterprise-java/spring/tomcat-vs-jetty-vs-undertow-comparison-of-spring-boot-embedded-servlet-containers/" rel="external nofollow noopener noreferrer" target="_blank">Tomcat vs. Jetty vs. Undertow: Comparison of Spring Boot Embedded Servlet Containers</a> 这篇文章统计, Undertow的综合性能更好. </p>
<p>在Spring Boot 2中, 已经把netty作为webflux的默认容器</p>
</blockquote>
<h2 id="与Tomcat性能对比"><a href="#与Tomcat性能对比" class="headerlink" title="与Tomcat性能对比"></a>与Tomcat性能对比</h2><p>以下是Undertow与Tomcat简单的性能测试（同样是默认配置）</p>
<p>Tomcat:</p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/tomcat-gatling-test.jpg" alt></p>
<p>Undertow:</p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/undertow-gatling-test.jpg" alt></p>
<p>显然Undertow的吞吐量要比Tomcat高</p>
<h2 id="Maven配置"><a href="#Maven配置" class="headerlink" title="Maven配置"></a>Maven配置</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 移除默认web容器, 使用undertow --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">如果是webflux, 默认的容器的netty</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 移除默认web容器, 使用undertow --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-reactor-netty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用高性能 Web 容器 undertow --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-undertow<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="监听多个端口与HTTP2支持"><a href="#监听多个端口与HTTP2支持" class="headerlink" title="监听多个端口与HTTP2支持"></a>监听多个端口与HTTP2支持</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在@Configuration的类中添加@bean</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">UndertowEmbeddedServletContainerFactory <span class="title">embeddedServletContainerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    UndertowEmbeddedServletContainerFactory factory = <span class="keyword">new</span> UndertowEmbeddedServletContainerFactory();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里也可以做其他配置</span></span><br><span class="line">	<span class="comment">// 支持HTTP2</span></span><br><span class="line">	factory.addBuilderCustomizers(builder -&gt; &#123;</span><br><span class="line">		builder.setServerOption(UndertowOptions.ENABLE_HTTP2, <span class="keyword">true</span>);</span><br><span class="line">		<span class="comment">// 监听多个端口</span></span><br><span class="line">		builder.addHttpListener(<span class="number">8080</span>, <span class="string">"0.0.0.0"</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Undertow相关配置"><a href="#Undertow相关配置" class="headerlink" title="Undertow相关配置"></a>Undertow相关配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Undertow 日志存放目录</span><br><span class="line">server.undertow.accesslog.dir</span><br><span class="line"># 是否启动日志</span><br><span class="line">server.undertow.accesslog.enabled=false </span><br><span class="line"># 日志格式</span><br><span class="line">server.undertow.accesslog.pattern=common</span><br><span class="line"># 日志文件名前缀</span><br><span class="line">server.undertow.accesslog.prefix=access_log</span><br><span class="line"># 日志文件名后缀</span><br><span class="line">server.undertow.accesslog.suffix=log</span><br><span class="line"># HTTP POST请求最大的大小</span><br><span class="line">server.undertow.max-http-post-size=0 </span><br><span class="line"># 设置IO线程数, 它主要执行非阻塞的任务,它们会负责多个连接, 默认设置每个CPU核心一个线程</span><br><span class="line">server.undertow.io-threads=4</span><br><span class="line"># 阻塞任务线程池, 当执行类似servlet请求阻塞操作, undertow会从这个线程池中取得线程,它的值设置取决于系统的负载, 默认数量为 CPU核心*8</span><br><span class="line">server.undertow.worker-threads=20</span><br><span class="line"># 以下的配置会影响buffer,这些buffer会用于服务器连接的IO操作,有点类似netty的池化内存管理</span><br><span class="line"># 每块buffer的空间大小,越小的空间被利用越充分</span><br><span class="line">server.undertow.buffer-size=1024</span><br><span class="line"># 每个区分配的buffer数量 , 所以pool的大小是buffer-size * buffers-per-region</span><br><span class="line">server.undertow.buffers-per-region=1024</span><br><span class="line"># 是否分配的直接内存</span><br><span class="line">server.undertow.direct-buffers=true</span><br></pre></td></tr></table></figure>
<h1 id="查看依赖树"><a href="#查看依赖树" class="headerlink" title="查看依赖树"></a>查看依赖树</h1><p>如果引入了某些jar包带有<code>logback</code>依赖, log4j2会失效, 需要通过IDEA或Maven查找排除依赖: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn dependency:tree</span><br></pre></td></tr></table></figure>
<h1 id="创建异步方法"><a href="#创建异步方法" class="headerlink" title="创建异步方法"></a>创建异步方法</h1><h2 id="启动异步"><a href="#启动异步" class="headerlink" title="启动异步"></a>启动异步</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringAsyncConfig</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置完这个就已经具备异步方法功能了, 只需要在方法上面添加<code>@Async</code>即可</p>
<p>如果被<code>@Async</code>注解的方法所在类是基于接口实现的, 想要直接注入实现类, 需要添加: <code>@EnableAsync(proxyTargetClass = true)</code> 以使用CGLIB代理</p>
<h2 id="编写异步方法"><a href="#编写异步方法" class="headerlink" title="编写异步方法"></a>编写异步方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">asyncMethodWithVoidReturnType</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"Execute method asynchronously. "</span> + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="配置线程池"><a href="#配置线程池" class="headerlink" title="配置线程池"></a>配置线程池</h2><p>在不配置线程池的情况下, Spring<strong>默认使用</strong><code>SimpleAsyncTaskExecutor</code>, 每一次的执行任务都会使用新的线程, 性能不太好, 所以我们可以自定义线程池</p>
<h3 id="直接声明线程池"><a href="#直接声明线程池" class="headerlink" title="直接声明线程池"></a>直接声明线程池</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringAsyncConfig</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Executor <span class="title">threadPoolTaskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">		executor.setCorePoolSize(<span class="number">10</span>);</span><br><span class="line">		executor.setMaxPoolSize(<span class="number">20</span>);</span><br><span class="line">		executor.setQueueCapacity(<span class="number">500</span>);</span><br><span class="line">		executor.setKeepAliveSeconds(<span class="number">60</span>);</span><br><span class="line">		executor.setThreadNamePrefix(<span class="string">"asyncExecutor-"</span>);</span><br><span class="line">		executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">		executor.initialize();</span><br><span class="line">		<span class="keyword">return</span> executor;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过使用<code>ThreadPoolTaskExecutor</code>创建了一个线程池, 同时设置了以下这些参数: </p>
<ul>
<li>核心线程数10: 线程池创建时候初始化的线程数</li>
<li>最大线程数20: 线程池最大的线程数, 只有在缓冲队列满了之后才会申请超过核心线程数的线程</li>
<li>缓冲队列500: 用来缓冲执行任务的队列</li>
<li>允许线程的空闲时间60秒: 当超过了核心线程出之外的线程在空闲时间到达之后会被销毁</li>
<li>线程池名的前缀: 设置好了之后可以方便我们定位处理任务所在的线程池</li>
<li>线程池对拒绝任务的处理策略: 这里采用了<code>CallerRunsPolicy</code>策略, 当线程池没有处理能力的时候, 该策略会直接在 execute 方法的调用线程中运行被拒绝的任务；如果执行程序已关闭, 则会丢弃该任务</li>
</ul>
<h3 id="实现AsyncConfigurer"><a href="#实现AsyncConfigurer" class="headerlink" title="实现AsyncConfigurer"></a>实现AsyncConfigurer</h3><blockquote>
<p>通过这种方式, 可以<strong>对异常进行处理</strong></p>
</blockquote>
<p><code>AsyncConfigurer</code>接口有两个方法: </p>
<ul>
<li><code>getAsyncExecutor()</code>: 提供线程池</li>
<li><code>getAsyncUncaughtExceptionHandler()</code>: 异步任务异常处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringAsyncConfig</span> <span class="keyword">implements</span> <span class="title">AsyncConfigurer</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Executor <span class="title">getAsyncExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">		executor.setCorePoolSize(<span class="number">8</span>);</span><br><span class="line">		executor.setMaxPoolSize(<span class="number">42</span>);</span><br><span class="line">		executor.setQueueCapacity(<span class="number">500</span>);</span><br><span class="line">		executor.setThreadNamePrefix(<span class="string">"MyExecutor-"</span>);</span><br><span class="line">		executor.initialize();</span><br><span class="line">		<span class="keyword">return</span> executor;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> AsyncUncaughtExceptionHandler <span class="title">getAsyncUncaughtExceptionHandler</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (ex, method, params) -&gt; &#123;</span><br><span class="line">			ExceptionUtils.printRootCauseStackTrace(ex);</span><br><span class="line">			System.out.println(<span class="string">"Exception message - "</span> + ex.getMessage());</span><br><span class="line">			System.out.println(<span class="string">"Method name - "</span> + method.getName());</span><br><span class="line">			<span class="keyword">for</span> (Object param : params) &#123;</span><br><span class="line">				System.out.println(<span class="string">"Parameter value - "</span> + param);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优雅关闭线程池"><a href="#优雅关闭线程池" class="headerlink" title="优雅关闭线程池"></a>优雅关闭线程池</h3><p>有时候, 存在关闭程序但还有异步任务在执行的情况, 这时候, 我们需要优雅地关闭线程池, 只需要两个参数: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">executor.setWaitForTasksToCompleteOnShutdown(<span class="keyword">true</span>);</span><br><span class="line">executor.setAwaitTerminationSeconds(<span class="number">60</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Async使用指定线程池"><a href="#Async使用指定线程池" class="headerlink" title="Async使用指定线程池"></a>Async使用指定线程池</h2><p>如果同时实现了<code>AsyncConfigurer</code>以及配置线程池, 那么<code>@Async</code>默认使用<code>AsyncConfigurer.getAsyncExecutor</code>的线程池. </p>
<p>如果需要指定线程池可以这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Async</span>(<span class="string">"threadPoolTaskExecutor"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">()</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取异步执行结果"><a href="#获取异步执行结果" class="headerlink" title="获取异步执行结果"></a>获取异步执行结果</h2><p>Service: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Async</span>(<span class="string">"threadPoolTaskExecutor"</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;String&gt; <span class="title">asyncMethodWithVoidReturnType</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">	<span class="keyword">return</span> AsyncResult.forValue(<span class="string">"Execute method asynchronously. "</span> + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Controller: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Mono&lt;String&gt; <span class="title">syaHello</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">	Future&lt;String&gt; stringFuture = someService.asyncMethodWithVoidReturnType();</span><br><span class="line">	<span class="keyword">while</span> (!stringFuture.isDone())&#123;</span><br><span class="line">		System.out.println(<span class="string">"wait..."</span>);</span><br><span class="line">		Thread.sleep(<span class="number">500L</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(stringFuture.get());</span><br><span class="line">	<span class="keyword">return</span> Mono.just(<span class="string">"Hello World"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wait...</span><br><span class="line">wait...</span><br><span class="line">wait...</span><br><span class="line">wait...</span><br><span class="line">wait...</span><br><span class="line">Execute method asynchronously. asyncExecutor-1</span><br></pre></td></tr></table></figure>
<h1 id="Spring启动后执行程序的几种方式"><a href="#Spring启动后执行程序的几种方式" class="headerlink" title="Spring启动后执行程序的几种方式"></a>Spring启动后执行程序的几种方式</h1><h2 id="PostConstruct-或-InitializingBean"><a href="#PostConstruct-或-InitializingBean" class="headerlink" title="@PostConstruct 或 InitializingBean"></a>@PostConstruct 或 InitializingBean</h2><p>通过<code>@PostConstruct</code>或实现<code>InitializingBean</code>实现初始化<code>bean</code>的时候干一些事情, 两者区别在于<code>InitializingBean</code>是在属性设置完之后执行的, 所以执行顺序是在<code>@PostConstruct</code>之前</p>
<blockquote>
<p>由于此接口的方法<code>afterPropertiesSet</code>是在对象的所有属性被初始化后才会调用. 当Spring的配置文件中设置类初始默认为”延迟初始”（<code>default-lazy-init=&quot;true&quot;</code>, 此值默认为<code>false</code>）时, </p>
<p>类对象如果不被使用, 则不会实例化该类对象. 所以 <code>InitializingBean</code>子类不能用于在容器启动时进行初始化的工作, 则应使用Spring提供的<code>ApplicationListener</code>接口来进行程序的初始化工作. </p>
<p>另外, 如果需要<code>InitializingBean</code>子类对象在Spring容器启动时就初始化并则容器调用<code>afterPropertiesSet</code>方法则需要在类上增加<code>org.springframework.context.annotation.Lazy</code>注解并设置为false即可（也可通过spring配置bean时添加<code>lazy-init=&quot;false&quot;</code>). </p>
</blockquote>
<h2 id="监听ContextRefreshedEvent"><a href="#监听ContextRefreshedEvent" class="headerlink" title="监听ContextRefreshedEvent"></a>监听ContextRefreshedEvent</h2><p>通过监听<code>ContextRefreshedEvent</code>事件: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContextRefreshedEventListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"ContextRefreshedEvent process..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processContextRefreshedEvent</span><span class="params">(ContextRefreshedEvent event)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	log.info(<span class="string">"ContextRefreshedEvent process..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring的事件处理是单线程的, 所以如果一个事件被触发, 除非所有的接收者得到消息, 否则这些进程被阻止, 流程将不会继续. 因此, 如果要使用事件处理, 在设计应用程序时应小心. </p>
<h3 id="Spring内置事件"><a href="#Spring内置事件" class="headerlink" title="Spring内置事件"></a>Spring内置事件</h3><p>以下是Spring的内置事件</p>
<table>
<thead>
<tr>
<th>Spring 内置事件</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ContextRefreshedEvent</strong></td>
<td><code>ApplicationContext</code>被初始化或刷新时, 该事件被发布. 这也可以在<code>ConfigurableApplicationContext</code>接口中使用<code>refresh()</code>方法来发生.</td>
</tr>
<tr>
<td><strong>ContextStartedEvent</strong></td>
<td>当使用<code>ConfigurableApplicationContext</code>接口中的<code>start()</code>方法启动<code>ApplicationContext</code>时, 该事件被触发. 你可以查询你的数据库, 或者你可以在接受到这个事件后重启任何停止的应用程序.</td>
</tr>
<tr>
<td><strong>ContextStoppedEvent</strong></td>
<td>当使用<code>ConfigurableApplicationContext</code>接口中的<code>stop()</code>方法停止<code>ApplicationContext</code>时, 该事件被触发. 你可以在接受到这个事件后做必要的清理的工作.</td>
</tr>
<tr>
<td><strong>ContextClosedEvent</strong></td>
<td>当使用<code>ConfigurableApplicationContext</code>接口中的<code>close()</code>方法关闭<code>ApplicationContext</code>时, 该事件被触发. 一个已关闭的上下文到达生命周期末端；它不能被刷新或重启.</td>
</tr>
<tr>
<td><strong>RequestHandledEvent</strong></td>
<td>这是一个<code>web-specific</code>事件, 告诉所有<code>bean</code> HTTP请求已经被服务.</td>
</tr>
</tbody>
</table>
<h3 id="Spring-Boot-2-0新增事件"><a href="#Spring-Boot-2-0新增事件" class="headerlink" title="Spring Boot 2.0新增事件"></a>Spring Boot 2.0新增事件</h3><p>在Spring Boot 2.0中对事件模型做了一些增强, 主要就是增加了<code>ApplicationStartedEvent</code>事件, 所以在2.0版本中所有的事件按执行的先后顺序如下: </p>
<ul>
<li><code>ApplicationStartingEvent</code></li>
<li><code>ApplicationEnvironmentPreparedEvent</code></li>
<li><code>ApplicationPreparedEvent</code></li>
<li><code>ApplicationStartedEvent</code> &lt;= 新增的事件</li>
<li><code>ApplicationReadyEvent</code></li>
<li><code>ApplicationFailedEvent</code></li>
</ul>
<h2 id="ApplicationRunner-或-CommandLineRunner"><a href="#ApplicationRunner-或-CommandLineRunner" class="headerlink" title="ApplicationRunner 或 CommandLineRunner"></a>ApplicationRunner 或 CommandLineRunner</h2><p>实现<code>ApplicationRunner</code>或<code>CommandLineRunner</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProdSyncLayerApplication</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span>,<span class="title">CommandLineRunner</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(ProdSyncLayerApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"ApplicationRunner..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"CommandLineRunner..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ApplicationRunner</code>比<code>CommandLineRunner</code>先执行</p>
<p><strong>总结</strong>: 以上三种方式的顺序跟其序号一样</p>
<h2 id="onApplicationEvent执行两次问题"><a href="#onApplicationEvent执行两次问题" class="headerlink" title="onApplicationEvent执行两次问题"></a>onApplicationEvent执行两次问题</h2><p><code>applicationontext</code>和使用MVC之后的<code>webApplicationontext</code>会两次调用上面的方法, 如何区分这个两种容器呢？</p>
<p>但是这个时候, 会存在一个问题, 在web 项目中（spring mvc）, 系统会存在两个容器, 一个是<code>root application context</code> ,另一个就是我们自己的 <code>projectName-servlet context</code>（作为root application context的子容器）. </p>
<p>这种情况下, 就会造成<code>onApplicationEvent</code>方法被执行两次. 为了避免上面提到的问题, 我们可以只在<code>root application context</code>初始化完成后调用逻辑代码, 其他的容器的初始化完成, 则不做任何处理, 修改后代码 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">if</span>(event.getApplicationContext().getParent() == <span class="keyword">null</span>)&#123;<span class="comment">//root application context 没有parent, 他就是老大.  </span></span><br><span class="line">       <span class="comment">//需要执行的逻辑代码, 当spring容器初始化完成后就会执行该方法.  </span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>后续发现加上以上判断还是能执行两次, 不加的话三次, 最终研究结果使用以下判断更加准确: <code>event.getApplicationContext().getDisplayName().equals(&quot;Root WebApplicationContext&quot;)</code></p>
</blockquote>
<h1 id="Spring应用停止前执行程序的几种方式"><a href="#Spring应用停止前执行程序的几种方式" class="headerlink" title="Spring应用停止前执行程序的几种方式"></a>Spring应用停止前执行程序的几种方式</h1><ol>
<li><p>监听<code>ContextClosedEvent</code></p>
</li>
<li><p>实现<code>DisposableBean</code>或使用<code>@PostConstruct</code>, 执行顺序: <code>@PostConstruct</code> &gt; <code>DisposableBean</code></p>
</li>
<li><p>使用ShutdownHook:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownHook</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> (FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"hook.log"</span>)) &#123;</span><br><span class="line">                <span class="comment">// 假设记录日志/或者发送消息</span></span><br><span class="line">                fw.write(<span class="string">"完成销毁操作,回收内存! "</span> + (<span class="keyword">new</span> Date()).toString());</span><br><span class="line">                System.out.println(<span class="string">"退出程序..."</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">10</span>).forEach(i -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"正在工作..."</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="Spring-Bean生命周期"><a href="#Spring-Bean生命周期" class="headerlink" title="Spring Bean生命周期"></a>Spring Bean生命周期</h1><p><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/spring-bean-process.webp" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">实例化</span><br><span class="line">↓</span><br><span class="line">设置bean的Aware</span><br><span class="line">↓</span><br><span class="line">BeanPostProcessor.postProcessBeforeInitialization(Object bean, String beanName)</span><br><span class="line">↓</span><br><span class="line">InitializingBean.afterPorpertiesSet</span><br><span class="line">↓</span><br><span class="line">BeanPostProcessor.postProcessAfterInitialization(Object bean, String beanName)</span><br><span class="line">↓</span><br><span class="line">SmartInitializingSingleton.afterSingletonsInstantiated</span><br><span class="line">↓</span><br><span class="line">SmartLifecycle.start</span><br><span class="line">↓</span><br><span class="line">bean已经在spring容器的管理下，可以做我们想做的事</span><br><span class="line">↓</span><br><span class="line">SmartLifecycle.stop(Runnable callback)</span><br><span class="line">↓</span><br><span class="line">DisposableBean.destroy()</span><br></pre></td></tr></table></figure>
<h1 id="元注解与组合注解"><a href="#元注解与组合注解" class="headerlink" title="元注解与组合注解"></a>元注解与组合注解</h1><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>Spring4.0的许多注解都可以用作meta annotation（元注解）. 元注解是一种使用在别的注解上的注解. 这意味着我们可以使用Spring的注解组合成一个我们自己的注解. </p>
<p>类似于: <code>@Documented</code>, <code>@Component</code>, <code>@RequestMapping</code>, <code>@Controller</code>, <code>@ResponseBody</code>等等</p>
<p>对于元注解, 是Spring框架中定义的部分, 都有特定的含义. 我们并不能修改, 但是对于组合注解, 我们完全可以基于自己的定义进行实现. </p>
<h2 id="组合注解"><a href="#组合注解" class="headerlink" title="组合注解"></a>组合注解</h2><p>自定义注解或组合注解是从其他的Spring元注解创建的, 我们先看一下<code>@SpringBootApplication</code>这个神奇的注解（去除注释）: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">		<span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">		@<span class="title">Filter</span>(<span class="title">type</span> </span>= FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>) &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">SpringBootApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@AliasFor</span>(annotation = EnableAutoConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">	Class&lt;?&gt;[] exclude() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@AliasFor</span>(annotation = EnableAutoConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">	String[] excludeName() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@AliasFor</span>(annotation = ComponentScan<span class="class">.<span class="keyword">class</span>, <span class="title">attribute</span> </span>= <span class="string">"basePackages"</span>)</span><br><span class="line">	String[] scanBasePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@AliasFor</span>(annotation = ComponentScan<span class="class">.<span class="keyword">class</span>, <span class="title">attribute</span> </span>= <span class="string">"basePackageClasses"</span>)</span><br><span class="line">	Class&lt;?&gt;[] scanBasePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现这个注解中有含有大量其他注解, 并使用了<code>@AliasFor</code>这个注解传递注解属性值. </p>
<h2 id="自定义组合注解"><a href="#自定义组合注解" class="headerlink" title="自定义组合注解"></a>自定义组合注解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(produces = MediaType.APPLICATION_JSON_UTF8_VALUE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Rest &#123;</span><br><span class="line">	<span class="meta">@AliasFor</span>(annotation = RequestMapping<span class="class">.<span class="keyword">class</span>, <span class="title">attribute</span> </span>= <span class="string">"value"</span>)</span><br><span class="line">	String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Rest(&quot;/ex&quot;)</span><br><span class="line">public class ExampleController &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><blockquote>
<p>AOP为<strong>Aspect Oriented Programming</strong>的缩写, 意为: 面向切面编程, 通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术. AOP是Spring框架中的一个重要内容, 它通过对既有程序定义一个切入点, 然后在其前后切入不同的执行内容, 比如常见的有: 打开数据库连接/关闭数据库连接、打开事务/关闭事务、记录日志等. 基于AOP不会破坏原来程序逻辑, 因此它可以很好的对业务逻辑的各个部分进行<strong>隔离</strong>, 从而使得业务逻辑各部分之间的<strong>耦合度降低</strong>, 提高程序的可重用性, 同时提高了开发的效率. </p>
</blockquote>
<h2 id="注解说明"><a href="#注解说明" class="headerlink" title="注解说明"></a>注解说明</h2><p>实现AOP的切面主要有以下几个要素: </p>
<ul>
<li>使用<code>@Aspect</code>注解将一个java类定义为切面类</li>
<li>使用<code>@Pointcut</code>定义一个切入点, 可以是一个规则表达式, 比如下例中某个package下的所有函数, 也可以是一个注解等. </li>
<li>根据需要在切入点不同位置的切入内容<ul>
<li>使用<code>@Before</code>在切入点开始处切入内容</li>
<li>使用<code>@After</code>在切入点结尾处切入内容</li>
<li>使用<code>@AfterReturning</code>在切入点return内容之后切入内容（可以用来对处理返回值做一些加工处理）</li>
<li>使用<code>@Around</code>在切入点前后切入内容, 并自己控制何时执行切入点自身的内容</li>
<li>使用<code>@AfterThrowing</code>用来处理当切入内容部分抛出异常之后的处理逻辑</li>
</ul>
</li>
</ul>
<h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><p>与其他模块一样, 使用需要引入pom依赖: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>引入依赖程序将自动启用AOP</strong>, 只要引入了AOP依赖后, 默认已经增加了<code>@EnableAspectJAutoProxy</code>, 并且默认启用<strong>Cglib</strong>代理: </p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/spring-boot-cglib-default.png" alt></p>
<h2 id="AOP顺序"><a href="#AOP顺序" class="headerlink" title="AOP顺序"></a>AOP顺序</h2><p>由于通过AOP实现, 程序得到了很好的解耦, 但是也会带来一些问题, 比如: 我们可能会对Web层做多个切面, 校验用户, 校验头信息等等, 这个时候经常会碰到切面的处理<strong>顺序问题</strong>. </p>
<p>所以, 我们需要定义每个切面的优先级, 我们需要<code>@Order(i)</code>注解来标识切面的优先级. <strong>i的值越小, 优先级越高</strong>. </p>
<h2 id="AOP记录Web访问日志用例"><a href="#AOP记录Web访问日志用例" class="headerlink" title="AOP记录Web访问日志用例"></a>AOP记录Web访问日志用例</h2><h3 id="日志注解"><a href="#日志注解" class="headerlink" title="日志注解"></a>日志注解</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">public @interface ReqLog &#123;</span><br><span class="line">	String value() default "";</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>别忘了加上<code>@Retention(RetentionPolicy.RUNTIME)</code></p>
<h3 id="声明Pointcut"><a href="#声明Pointcut" class="headerlink" title="声明Pointcut"></a>声明Pointcut</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(public * com.yangbingdong.docker.controller..*.*(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">path</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@annotation(ReqLog)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">annotation</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"path() &amp;&amp; annotation()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logHttp</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>然后这样使用: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"path() &amp;&amp; @annotation(reqLog)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要很方便地获取<code>@ReqLog</code>的<code>value</code>, 我们可以将其<strong>绑定</strong>为参数: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(public * com.yangbingdong.docker.controller..*.*(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">path</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"path() &amp;&amp; @annotation(reqLog)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint, ReqLog reqLog)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Pointcut匹配表达式详解可以参考: <strong><em><a href="https://blog.csdn.net/elim168/article/details/78150438" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/elim168/article/details/78150438</a></em></strong></p>
<p>如果是使用<code>@Around</code>, 则方法参数应该使用<code>ProceedingJoinPoint,</code>因为<code>ProceedingJoinPoint.proceed()</code>可获取方法返回值, 且必须返回<code>Object</code>: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"logHttp()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(<span class="keyword">final</span> ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="函数式方式动态注册-Bean"><a href="#函数式方式动态注册-Bean" class="headerlink" title="函数式方式动态注册 Bean"></a>函数式方式动态注册 Bean</h1><blockquote>
<p>Spring 5 支持在应用程序上下文中以函数式方式注册 bean. 简单地说, 您可以通过在 <strong><code>GenericApplicationContext</code></strong> 类中定义的一个新 <strong><code>registerBean()</code></strong> 方法重载来完成. </p>
</blockquote>
<p>看一下有哪些方法重载: </p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/spring-reg-bean.png" alt></p>
<p>注入<code>GenericWebApplicationContext</code>: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> GenericWebApplicationContext context;</span><br></pre></td></tr></table></figure>
<p>注册并设置bean: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String beanName = lowercaseInitial(handler.getClass().getSimpleName()) + <span class="string">"-"</span> + j;</span><br><span class="line">context.registerBean(beanName, handler.getClass());</span><br><span class="line">AbstractShardingHandler&lt;AopLogEvent&gt; shardingBean = (AbstractShardingHandler&lt;AopLogEvent&gt;) context.getBean(beanName);</span><br></pre></td></tr></table></figure>
<p>上面的 <code>registerBean</code> 底层是用到了 <code>DefaultListableBeanFactory# registerBeanDefinition</code>, 以前的用法是这样的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BeanDefinitionBuilder beanDefinitionBuilder =</span><br><span class="line">                BeanDefinitionBuilder.genericBeanDefinition(PersonManager<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        beanDefinitionBuilder.addPropertyReference(<span class="string">"personDao"</span>, <span class="string">"personDao"</span>);</span><br><span class="line">        BeanDefinition personManagerBeanDefinition = beanDefinitionBuilder.getRawBeanDefinition();</span><br><span class="line">        defaultListableBeanFactory.registerBeanDefinition(<span class="string">"personManager1"</span>, personManagerBeanDefinition);</span><br></pre></td></tr></table></figure>
<p>更多动态注册请看 <strong><em><a href="https://zhuanlan.zhihu.com/p/30590254" rel="external nofollow noopener noreferrer" target="_blank">https://zhuanlan.zhihu.com/p/30590254</a></em></strong></p>
<h1 id="自动配置的原理与自定义starter"><a href="#自动配置的原理与自定义starter" class="headerlink" title="自动配置的原理与自定义starter"></a>自动配置的原理与自定义starter</h1><p>在自定义starter之前, 先看一下Spring Boot的一些原理</p>
<h2 id="Spring-Boot实现自动配置的原理"><a href="#Spring-Boot实现自动配置的原理" class="headerlink" title="Spring Boot实现自动配置的原理"></a>Spring Boot实现自动配置的原理</h2><h3 id="入口注解类-EnableAutoConfiguration"><a href="#入口注解类-EnableAutoConfiguration" class="headerlink" title="入口注解类@EnableAutoConfiguration"></a>入口注解类@EnableAutoConfiguration</h3><p><code>@SpringBootApplication</code>注解中包含了自动配置的入口注解: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">        <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">        @<span class="title">Filter</span>(<span class="title">type</span> </span>= FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>) &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">SpringBootApplication</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(EnableAutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAutoConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个注解的Javadoc内容还是不少, 所有就不贴在文章里面了, 概括一下: </p>
<ol>
<li>自动配置基于应用的类路径以及你定义了什么Beans</li>
<li>如果使用了<code>@SpringBootApplication</code>注解, 那么自动就启用了自动配置</li>
<li>可以通过设置注解的<code>excludeName</code>属性或者通过<code>spring.autoconfigure.exclude</code>配置项来指定不需要自动配置的项目</li>
<li>自动配置的发生时机在用户定义的Beans被注册之后</li>
<li>如果没有和<code>@SpringBootApplication</code>一同使用, 最好将<code>@EnableAutoConfiguration</code>注解放在root package的类上, 这样就能够搜索到所有子packages中的类了</li>
<li>自动配置类就是普通的Spring <code>@Configuration</code>类, 通过<code>SpringFactoriesLoader</code>机制完成加载, 实现上通常使用<code>@Conditional</code>(比如<code>@ConditionalOnClass</code>或者<code>@ConditionalOnMissingBean</code>)</li>
</ol>
<h3 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import</span>(AutoConfigurationPackages.Registrar<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">AutoConfigurationPackage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个注解的职责就是<strong>引入</strong>了另外一个配置类: <code>AutoConfigurationPackages.Registrar</code>. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ImportBeanDefinitionRegistrar用来从导入的Config中保存base package</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Order</span>(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Registrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">DeterminableImports</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">            BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        register(registry, <span class="keyword">new</span> PackageImport(metadata).getPackageName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">determineImports</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.&lt;Object&gt;singleton(<span class="keyword">new</span> PackageImport(metadata));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个注解实现的功能已经比较底层了, 调试看看上面的register方法什么会被调用: </p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/spring-boot-code.png" alt></p>
<p>调用参数中的<code>packageNames</code>数组中仅包含一个值: <code>com.example.demo</code>, 也就是项目的root package名. </p>
<p>从调用栈来看的话, 调用<code>register</code>方法的时间在容器刷新期间: </p>
<p><code>refresh</code> -&gt; <code>invokeBeanFactoryPostProcessors</code> -&gt; <code>invokeBeanDefinitionRegistryPostProcessors</code> -&gt; <code>postProcessBeanDefinitionRegistry</code> -&gt; <code>processConfigBeanDefinitions</code>(开始处理配置Bean的定义) -&gt; <code>loadBeanDefinitions</code> -&gt; <code>loadBeanDefinitionsForConfigurationClass</code>(读取配置Class中的Bean定义) -&gt; <code>loadBeanDefinitionsFromRegistrars</code>(这里开始准备进入上面的register方法) -&gt; <code>registerBeanDefinitions</code>(即上述方法)</p>
<p>这个过程已经比较复杂了, 目前暂且不深入研究了. 它的功能简单说就是将应用的root package给注册到Spring容器中, 供后续使用. </p>
<p>相比而言, 下面要讨论的几个类型才是实现自动配置的关键. </p>
<h3 id="Import-EnableAutoConfigurationImportSelector-class"><a href="#Import-EnableAutoConfigurationImportSelector-class" class="headerlink" title="@Import(EnableAutoConfigurationImportSelector.class)"></a>@Import(EnableAutoConfigurationImportSelector.class)</h3><p><code>@EnableAutoConfiguration</code>注解的另外一个作用就是引入了<code>EnableAutoConfigurationImportSelector</code>: </p>
<p>它的类图如下所示: </p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/spring-boot-code02.png" alt></p>
<p>可以发现它除了实现几个Aware类接口外, 最关键的就是实现了<code>DeferredImportSelector</code>(继承自<code>ImportSelector</code>)接口. </p>
<p>所以我们先来看看<code>ImportSelector</code>以及<code>DeferredImportSelector</code>接口的定义: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于被引入的Configuration类的AnnotationMetadata信息选择并返回需要引入的类名列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] selectImports(AnnotationMetadata importingClassMetadata);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个接口的Javadoc比较长, 还是捡重点说明一下: </p>
<ol>
<li>主要功能通过<code>selectImports</code>方法实现, 用于筛选需要引入的类名</li>
<li>实现了<code>ImportSelector</code>的类也可以实现一系列Aware接口, 这些Aware接口中的相应方法会在<code>selectImports</code>方法之前被调用(这一点通过上面的类图也可以佐证, <code>EnableAutoConfigurationImportSelector</code>确实实现了四个Aware类型的接口)</li>
<li><code>ImportSelector</code>的实现和通常的<code>@Import</code>在处理方式上是一致的, 然而还是可以在所有<code>@Configuration</code>类都被处理后再进行引入筛选(具体看下面即将介绍的<code>DeferredImportSelector</code>)</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DeferredImportSelector</span> <span class="keyword">extends</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个接口是一个<strong>标记接口</strong>, 它本身没有定义任何方法. 那么这个接口的含义是什么呢: </p>
<ol>
<li>它是<code>ImportSelector</code>接口的一个变体, 在所有的<code>@Configuration</code>被处理之后才会执行. 在需要筛选的引入类型具备<code>@Conditional</code>注解的时候非常有用</li>
<li>实现类同样也可以实现<code>Ordered</code>接口, 来定义多个<code>DeferredImportSelector</code>的优先级别(同样地, <code>EnableAutoConfigurationImportSelector</code>也实现了<code>Ordered</code>接口)</li>
</ol>
<p>明确了这两个接口的意义, 下面来看看是如何实现的: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Step1: 得到注解信息</span></span><br><span class="line">        AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader</span><br><span class="line">                .loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">        <span class="comment">// Step2: 得到注解中的所有属性信息</span></span><br><span class="line">        AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">        <span class="comment">// Step3: 得到候选配置列表</span></span><br><span class="line">        List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,</span><br><span class="line">                attributes);</span><br><span class="line">        <span class="comment">// Step4: 去重</span></span><br><span class="line">        configurations = removeDuplicates(configurations);</span><br><span class="line">        <span class="comment">// Step5: 排序</span></span><br><span class="line">        configurations = sort(configurations, autoConfigurationMetadata);</span><br><span class="line">        <span class="comment">// Step6: 根据注解中的exclude信息去除不需要的</span></span><br><span class="line">        Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">        checkExcludedClasses(configurations, exclusions);</span><br><span class="line">        configurations.removeAll(exclusions);</span><br><span class="line">        configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">        <span class="comment">// Step7: 派发事件</span></span><br><span class="line">        fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">        <span class="keyword">return</span> configurations.toArray(<span class="keyword">new</span> String[configurations.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显, 核心就在于上面的<strong>步骤3</strong>: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata,</span></span></span><br><span class="line"><span class="function"><span class="params">        AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(</span><br><span class="line">            getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations,</span><br><span class="line">            <span class="string">"No auto configuration classes found in META-INF/spring.factories. If you "</span></span><br><span class="line">                    + <span class="string">"are using a custom packaging, make sure that file is correct."</span>);</span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它将实现委托给了<code>SpringFactoriesLoader</code>的<code>loadFactoryNames</code>方法: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入的factoryClass: org.springframework.boot.autoconfigure.EnableAutoConfiguration</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    String factoryClassName = factoryClass.getName();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">                ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">            URL url = urls.nextElement();</span><br><span class="line">            Properties properties = PropertiesLoaderUtils.loadProperties(<span class="keyword">new</span> UrlResource(url));</span><br><span class="line">            String factoryClassNames = properties.getProperty(factoryClassName);</span><br><span class="line">            result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unable to load ["</span> + factoryClass.getName() +</span><br><span class="line">                <span class="string">"] factories from location ["</span> + FACTORIES_RESOURCE_LOCATION + <span class="string">"]"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相关常量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FACTORIES_RESOURCE_LOCATION = <span class="string">"META-INF/spring.factories"</span>;</span><br></pre></td></tr></table></figure>
<p>这段代码的意图很明确, 在第一篇文章讨论Spring Boot启动过程的时候就已经接触到了. 它会从类路径中拿到所有名为<strong><code>META-INF/spring.factories</code></strong>的配置文件, 然后按照<code>factoryClass</code>的名称取到对应的值. 那么我们就来找一个<strong><code>META-INF/spring.factories</code></strong>配置文件看看. </p>
<h4 id="META-INF-spring-factories"><a href="#META-INF-spring-factories" class="headerlink" title="META-INF/spring.factories"></a>META-INF/spring.factories</h4><p>比如<code>spring-boot-autoconfigure</code>包: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure>
<p>列举了非常多的自动配置候选项, 挑一个AOP相关的<code>AopAutoConfiguration</code>看看究竟: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果设置了spring.aop.auto=false, 那么AOP不会被配置</span></span><br><span class="line"><span class="comment">// 需要检测到@EnableAspectJAutoProxy注解存在才会生效</span></span><br><span class="line"><span class="comment">// 默认使用JdkDynamicAutoProxyConfiguration, 如果设置了spring.aop.proxy-target-class=true, 那么使用CglibAutoProxyConfiguration</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; EnableAspectJAutoProxy<span class="class">.<span class="keyword">class</span>, <span class="title">Aspect</span>.<span class="title">class</span>, <span class="title">Advice</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnProperty</span>(<span class="title">prefix</span> </span>= <span class="string">"spring.aop"</span>, name = <span class="string">"auto"</span>, havingValue = <span class="string">"true"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class="keyword">false</span>)</span><br><span class="line">    <span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.aop"</span>, name = <span class="string">"proxy-target-class"</span>, havingValue = <span class="string">"false"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAutoProxyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@EnableAspectJAutoProxy</span>(proxyTargetClass = <span class="keyword">true</span>)</span><br><span class="line">    <span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.aop"</span>, name = <span class="string">"proxy-target-class"</span>, havingValue = <span class="string">"true"</span>, matchIfMissing = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibAutoProxyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个自动配置类的作用是判断是否存在配置项: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.aop.proxy-target-class=true</span><br></pre></td></tr></table></figure>
<p>如果存在并且值为<code>true</code>的话使用基于<strong>CGLIB</strong>字节码操作的动态代理方案, 否则使用JDK自带的动态代理机制. </p>
<p>下面列举所有由Spring Boot提供的条件注解: </p>
<ul>
<li><code>@ConditionalOnBean</code></li>
<li><code>@ConditionalOnClass</code></li>
<li><code>@ConditionalOnCloudPlatform</code></li>
<li><code>@ConditionalOnExpression</code></li>
<li><code>@ConditionalOnJava</code></li>
<li><code>@ConditionalOnJndi</code></li>
<li><code>@ConditionalOnMissingBean</code></li>
<li><code>@ConditionalOnMissingClass</code></li>
<li><code>@ConditionalOnNotWebApplication</code></li>
<li><code>@ConditionalOnProperty</code></li>
<li><code>@ConditionalOnResource</code></li>
<li><code>@ConditionalOnSingleCandidate</code></li>
<li><code>@ConditionalOnWebApplication</code></li>
</ul>
<p>一般的模式, 就是一个条件注解对应一个继承自<code>SpringBootCondition</code>的具体实现类. </p>
<h2 id="自定义starter"><a href="#自定义starter" class="headerlink" title="自定义starter"></a>自定义starter</h2><p>看完上面描述之后, 应该不难发现, 自定义starter的关键就是<strong><code>META-INF/spring.factories</code></strong>了, Spring Boot会在启动时加载这个文件中声明的第三方类. </p>
<h3 id="自定义properties"><a href="#自定义properties" class="headerlink" title="自定义properties"></a>自定义properties</h3><p>为了给可配置的bean属性生成元数据, 我们需要引入如下jar包: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 将被@ConfigurationProperties注解的类的属性注入到元数据 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>application.properties</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ybd.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">ybd.datasource.url=jdbc:mysql://192.168.0.200:3306/transaction_message_test?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false</span><br><span class="line">ybd.datasource.username=xxx</span><br><span class="line">ybd.datasource.password=xxx</span><br><span class="line">ybd.datasource.dbcp2.validation-query=select &apos;x&apos;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>生成的元数据位于jar文件中的<code>META-INF/spring-configurationmetadata. json</code>. 元数据本身并不会修改被<code>@ConfigurationProperties</code>修饰的类属性, 在我的理解里元数据仅仅只是表示配置类的默认值以及java doc, 供调用者便利的了解默认配置有哪些以及默认配置的含义, 在idea里面如果有元数据则可以提供良好的代码提示功能以方便了解默认的配置. </p>
</blockquote>
<h3 id="properties接收类"><a href="#properties接收类" class="headerlink" title="properties接收类"></a>properties接收类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(DataSourceProperties.DATASOURCE_PREFIX)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceProperties</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATASOURCE_PREFIX = <span class="string">"ybd.datasource"</span>;</span><br><span class="line">	<span class="keyword">private</span> Boolean tcc;</span><br><span class="line">	<span class="keyword">private</span> String driverClassName = <span class="string">"com.mysql.jdbc.Driver"</span>;</span><br><span class="line">	<span class="keyword">private</span> String url;</span><br><span class="line">	<span class="keyword">private</span> String username = <span class="string">"root"</span>;</span><br><span class="line">	<span class="keyword">private</span> String password = <span class="string">"root"</span>;</span><br><span class="line">	<span class="keyword">private</span> Dbcp2 dbcp2;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Data</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Dbcp2</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> Integer maxTotal = <span class="number">50</span>;</span><br><span class="line">		<span class="keyword">private</span> Integer initialSize = <span class="number">20</span>;</span><br><span class="line">		<span class="keyword">private</span> Long maxWaitMillis = <span class="number">60000L</span>;</span><br><span class="line">		<span class="keyword">private</span> Integer minIdle = <span class="number">6</span>;</span><br><span class="line">		<span class="keyword">private</span> Boolean logAbandoned = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">private</span> Boolean removeAbandonedOnBorrow = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">private</span> Boolean removeAbandonedOnMaintenance = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">private</span> Integer removeAbandonedTimeout = <span class="number">1800</span>;</span><br><span class="line">		<span class="keyword">private</span> Boolean testWhileIdle = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">private</span> Boolean testOnBorrow = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">private</span> Boolean testOnReturn = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">private</span> String validationQuery;</span><br><span class="line">		<span class="keyword">private</span> Integer validationQueryTimeout = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">private</span> Long timeBetweenEvictionRunsMillis = <span class="number">30000L</span>;</span><br><span class="line">		<span class="keyword">private</span> Integer numTestsPerEvictionRun = <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@ConfigurationProperties</code>会将<code>application.properties</code>中指定的前缀的属性注入到bean中</p>
<h3 id="Config类"><a href="#Config类" class="headerlink" title="Config类"></a>Config类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(SpringCloudConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnClass</span>(</span>&#123;LocalXADataSource<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">@<span class="title">EnableConfigurationProperties</span>(</span>&#123;DataSourceProperties<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">DataSourceConfiguration</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> DataSourceProperties dataSourceProperties;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DataSourceConfiguration</span><span class="params">(DataSourceProperties dataSourceProperties)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.dataSourceProperties = dataSourceProperties;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span>(<span class="string">"dataSource"</span>)</span><br><span class="line">	<span class="meta">@ConditionalOnProperty</span>(prefix = DATASOURCE_PREFIX, value = <span class="string">"tcc"</span>, havingValue = <span class="string">"true"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> DataSource <span class="title">getTccDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		LocalXADataSource dataSource = <span class="keyword">new</span> LocalXADataSource();</span><br><span class="line">		dataSource.setDataSource(<span class="keyword">this</span>.resolveDbcp2DataSource());</span><br><span class="line">		<span class="keyword">return</span> dataSource;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> DataSource <span class="title">resolveDbcp2DataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		BasicDataSource dataSource = <span class="keyword">new</span> BasicDataSource();</span><br><span class="line">		dataSource.setDriverClassName(dataSourceProperties.getDriverClassName());</span><br><span class="line">		dataSource.setUrl(dataSourceProperties.getUrl());</span><br><span class="line">		dataSource.setUsername(dataSourceProperties.getUsername());</span><br><span class="line">		dataSource.setPassword(dataSourceProperties.getPassword());</span><br><span class="line">		dataSource.setMaxTotal(dataSourceProperties.getDbcp2().getMaxTotal());</span><br><span class="line">		dataSource.setInitialSize(dataSourceProperties.getDbcp2().getInitialSize());</span><br><span class="line">		dataSource.setMaxWaitMillis(dataSourceProperties.getDbcp2().getMaxWaitMillis());</span><br><span class="line">		dataSource.setMinIdle(dataSourceProperties.getDbcp2().getMinIdle());</span><br><span class="line">		dataSource.setLogAbandoned(dataSourceProperties.getDbcp2().getLogAbandoned());</span><br><span class="line">		dataSource.setRemoveAbandonedOnBorrow(dataSourceProperties.getDbcp2().getRemoveAbandonedOnBorrow());</span><br><span class="line">		dataSource.setRemoveAbandonedOnMaintenance(dataSourceProperties.getDbcp2().getRemoveAbandonedOnMaintenance());</span><br><span class="line">		dataSource.setRemoveAbandonedTimeout(dataSourceProperties.getDbcp2().getRemoveAbandonedTimeout());</span><br><span class="line">		dataSource.setTestWhileIdle(dataSourceProperties.getDbcp2().getTestWhileIdle());</span><br><span class="line">		dataSource.setTestOnBorrow(dataSourceProperties.getDbcp2().getTestOnBorrow());</span><br><span class="line">		dataSource.setTestOnReturn(dataSourceProperties.getDbcp2().getTestOnReturn());</span><br><span class="line">		dataSource.setValidationQuery(dataSourceProperties.getDbcp2().getValidationQuery());</span><br><span class="line">		dataSource.setValidationQueryTimeout(dataSourceProperties.getDbcp2().getValidationQueryTimeout());</span><br><span class="line">		dataSource.setTimeBetweenEvictionRunsMillis(dataSourceProperties.getDbcp2().getTimeBetweenEvictionRunsMillis());</span><br><span class="line">		dataSource.setNumTestsPerEvictionRun(dataSourceProperties.getDbcp2().getNumTestsPerEvictionRun());</span><br><span class="line">		<span class="keyword">return</span> dataSource;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>@Import</code>引入其他配置类</li>
<li><code>@ConditionalOnClass</code>在指定类存在时该配置类生效</li>
<li><code>@EnableConfigurationProperties</code>启用配置接受类, 通过Spring字段注入或构造器注入properties配置Bean</li>
</ul>
<h3 id="使Spring-Boot可以自动加载配置类"><a href="#使Spring-Boot可以自动加载配置类" class="headerlink" title="使Spring Boot可以自动加载配置类"></a>使Spring Boot可以自动加载配置类</h3><p>在<code>/resource</code>目录创建<strong><code>META-INF/spring.factories</code></strong>: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.yangbingdong.configuration.WebMvcMessageConvertConfiguration</span><br></pre></td></tr></table></figure>
<p>然后打包成Jar, 第三方Spring Boot系统通过引入这个Jar包, 会自动加载该类. </p>
<p>如果有需要, 可以配合<code>@AutoConfigureAfter</code>, <code>@ConditionalOnBean</code>, <code>@ConditionalOnProperty</code>等注解控制配置是否需要加载以及加载顺序. </p>
<p>需要更灵活的配置可以实现<code>Condition</code>或<code>SpringBootCondition</code>通过<code>@Conditional(XXXCondition.class)</code>实现类加载判断. </p>
<h1 id="自定义Banner"><a href="#自定义Banner" class="headerlink" title="自定义Banner"></a>自定义Banner</h1><p>新建一个<code>banner.txt</code>到<code>resources</code>目录下: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$&#123;AnsiColor.BRIGHT_GREEN&#125;</span><br><span class="line">                   $&#123;AnsiColor.BRIGHT_YELLOW&#125;_ooOoo_$&#123;AnsiColor.BRIGHT_YELLOW&#125;</span><br><span class="line">                  $&#123;AnsiColor.BRIGHT_YELLOW&#125;o8888888o$&#123;AnsiColor.BRIGHT_YELLOW&#125;</span><br><span class="line">                  $&#123;AnsiColor.BRIGHT_YELLOW&#125;88$&#123;AnsiColor.BRIGHT_GREEN&#125;&quot; $&#123;AnsiStyle.BOLD&#125;$&#123;AnsiColor.BRIGHT_RED&#125;. $&#123;AnsiColor.BRIGHT_GREEN&#125;&quot;$&#123;AnsiColor.BRIGHT_YELLOW&#125;88$&#123;AnsiColor.BRIGHT_GREEN&#125;</span><br><span class="line">                  (| -_- |)</span><br><span class="line">                  $&#123;AnsiColor.BRIGHT_YELLOW&#125;O$&#123;AnsiColor.BRIGHT_GREEN&#125;\  =  /$&#123;AnsiColor.BRIGHT_YELLOW&#125;O$&#123;AnsiColor.BRIGHT_GREEN&#125;</span><br><span class="line">               ____/`---&apos;\____</span><br><span class="line">             .&apos;  \\|     |//  `.</span><br><span class="line">            /  \\|||  :  |||//  \</span><br><span class="line">           /  _||||| -:- |||||-  \</span><br><span class="line">           |   | \\\  -  /// |   |</span><br><span class="line">           | \_|  &apos;&apos;\---/&apos;&apos;  |   |</span><br><span class="line">           \  .-\__  `-`  ___/-. /</span><br><span class="line">         ___`. .&apos;  /--.--\  `. . __</span><br><span class="line">      .&quot;&quot; &apos;&lt;  `.___\_&lt;|&gt;_/___.&apos;  &gt;&apos;&quot;&quot;.</span><br><span class="line">     | | :  `- \`.;`\ _ /`;.`/ - ` : | |</span><br><span class="line">     \  \ `-.   \_ __\ /__ _/   .-` /  /</span><br><span class="line">======`-.____`-.___\_____/___.-`____.-&apos;======</span><br><span class="line">                   `=---=&apos;</span><br><span class="line">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^         $&#123;spring-boot.formatted-version&#125;</span><br><span class="line">         $&#123;AnsiStyle.BOLD&#125;$&#123;AnsiColor.BRIGHT_GREEN&#125;佛祖保佑       永无BUG</span><br><span class="line"></span><br><span class="line">$&#123;AnsiStyle.NORMAL&#125;</span><br></pre></td></tr></table></figure>
<h1 id="自定义favico"><a href="#自定义favico" class="headerlink" title="自定义favico"></a>自定义favico</h1><p>将自己的<code>favicon.ico</code>放到<code>src/main/resources</code>即可.</p>
<h1 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h1><blockquote>
<p>各个厂商的STMP服务以及端口请自行搜索. . . </p>
</blockquote>
<p>主要pom依赖: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>邮件模板: </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">您好,恭喜您中得【一等奖】,这是验证邮件,请点击下面的链接完成验证并领奖 -&gt; <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">th:href</span>=<span class="string">"@&#123; https://yangbingdong.com/&#123;id&#125;(id=$&#123;id&#125;) &#125;"</span>&gt;</span>领取奖品<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>yml:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">mail</span></span><br><span class="line">  <span class="attr">mail:</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">smtp</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">smtp.qq.com</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">587</span></span><br><span class="line">    <span class="attr">username:</span> <span class="number">730493388</span><span class="string">@qq.com</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123123</span></span><br></pre></td></tr></table></figure>
<p>发送邮件: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line">@ActiveProfiles("qq")</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootMailApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> JavaMailSender javaMailSender;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> TemplateEngine templateEngine;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendSimple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		SimpleMailMessage message = <span class="keyword">new</span> SimpleMailMessage();</span><br><span class="line">		message.setFrom(<span class="string">"730493388@qq.com"</span>);</span><br><span class="line">		message.setTo(<span class="string">"masteranthoneyd@163.com"</span>);</span><br><span class="line">		message.setSubject(<span class="string">"标题: 测试标题"</span>);</span><br><span class="line">		message.setText(<span class="string">"测试内容部份"</span>);</span><br><span class="line">		javaMailSender.send(message);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendTemplateByQQ</span><span class="params">()</span> <span class="keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">		Context context = <span class="keyword">new</span> Context();</span><br><span class="line">		context.setVariable(<span class="string">"id"</span>, <span class="string">"/archives"</span>);</span><br><span class="line">		String email = templateEngine.process(<span class="string">"email"</span>, context);</span><br><span class="line"></span><br><span class="line">		MimeMessage message = javaMailSender.createMimeMessage();</span><br><span class="line"></span><br><span class="line">		MimeMessageHelper helper = <span class="keyword">new</span> MimeMessageHelper(message);</span><br><span class="line">		helper.setFrom(<span class="string">"730493388@qq.com"</span>);</span><br><span class="line">		helper.setTo(<span class="string">"masteranthoneyd@163.com"</span>);</span><br><span class="line">		helper.setSubject(<span class="string">"标题: 测试标题"</span>);</span><br><span class="line">		helper.setText(email, <span class="keyword">true</span>);</span><br><span class="line">		javaMailSender.send(message);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendTemplateBy163</span><span class="params">()</span> <span class="keyword">throws</span> MessagingException </span>&#123;</span><br><span class="line">		Context context = <span class="keyword">new</span> Context();</span><br><span class="line">		context.setVariable(<span class="string">"id"</span>, <span class="string">"/archives"</span>);</span><br><span class="line">		String email = templateEngine.process(<span class="string">"email"</span>, context);</span><br><span class="line">		MimeMessage message = javaMailSender.createMimeMessage();</span><br><span class="line">		MimeMessageHelper helper = <span class="keyword">new</span> MimeMessageHelper(message);</span><br><span class="line">		helper.setFrom(<span class="string">"masteranthoneyd@163.com"</span>);</span><br><span class="line">		helper.setTo(<span class="string">"730493388@qq.com"</span>);</span><br><span class="line">		helper.setSubject(<span class="string">"标题: 测试标题"</span>);</span><br><span class="line">		helper.setText(email, <span class="keyword">true</span>);</span><br><span class="line">		javaMailSender.send(message);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="手动停机"><a href="#手动停机" class="headerlink" title="手动停机"></a>手动停机</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownController</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/close"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ((ConfigurableApplicationContext) applicationContext).close();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/exit"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> exit = SpringApplication.exit(applicationContext, () -&gt; <span class="number">0</span>);</span><br><span class="line">        System.exit(exit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.warn(<span class="string">"Application closing..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="优雅停机"><a href="#优雅停机" class="headerlink" title="优雅停机"></a>优雅停机</h1><blockquote>
<p>Spring Boot 2.3.0 之后支持配置方式实现优雅停机</p>
</blockquote>
<p>通过配置:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">shutdown:</span> <span class="string">graceful</span>  <span class="comment">#开启优雅停机, 默认 IMMEDIATE 立刻停机</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">lifecyle:</span></span><br><span class="line">    <span class="attr">timeout-per-shutdown-phase:</span> <span class="string">30s</span>  <span class="comment"># 最大等待 30 秒</span></span><br></pre></td></tr></table></figure>
]]></content><categories><category>Programming</category><category>Java</category><category>Spring Boot</category></categories><tags><tag>Java</tag><tag>Spring Boot</tag><tag>Spring</tag></tags></entry><entry><title>Redis拾遗与Spring Boot整合</title><url>/2018/spring-boot-learning-redis/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/spring-boot-redis/redis-logo.png" alt></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><blockquote>
<p>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库, 并提供多种语言的API. 相比<code>Memcached</code>它支持存储的类型相对更多<strong>（字符、哈希、集合、有序集合、列表、GEO）</strong>, <strong>同时Redis是线程安全的</strong>. 2010年3月15日起, Redis的开发工作由VMware主持, 2013年5月开始, Redis的开发由<code>Pivotal</code>赞助. </p>
</blockquote>
<a id="more"></a>
<h1 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="基于Docker安装"><a href="#基于Docker安装" class="headerlink" title="基于Docker安装"></a>基于Docker安装</h3><p>拉取镜像: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull redis:latest</span><br></pre></td></tr></table></figure>
<p>运行实例: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REDIS=/home/ybd/data/docker/redis &amp;&amp; \</span><br><span class="line">docker run -p 6379:6379 --restart=always \</span><br><span class="line">-v $REDIS/redis.conf:/usr/local/etc/redis/redis.conf \</span><br><span class="line">-v $REDIS/data:/data \</span><br><span class="line">--name redis -d redis \</span><br><span class="line">redis-server /usr/local/etc/redis/redis.conf --appendonly yes</span><br></pre></td></tr></table></figure>
<p>安装链接工具: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install redis-tools</span><br><span class="line"></span><br><span class="line">// 连接</span><br><span class="line">redis-cli -h 127.0.0.1 -p 6379</span><br></pre></td></tr></table></figure>
<p>或者docker-compose启动: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &apos;3&apos;</span><br><span class="line">services:</span><br><span class="line">  redis:</span><br><span class="line">    image: redis:latest</span><br><span class="line">#    command: [&quot;redis-server&quot;, &quot;--appendonly&quot;, &quot;yes&quot;]</span><br><span class="line">    command: [&quot;redis-server&quot;, &quot;/usr/local/etc/redis/redis.conf&quot;]</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;6379:6379&quot;</span><br><span class="line">    networks:</span><br><span class="line">      backend-swarm:</span><br><span class="line">        aliases:</span><br><span class="line">         - redis</span><br><span class="line">    volumes:</span><br><span class="line">      - ./data:/data</span><br><span class="line">      - ./config/redis.conf:/usr/local/etc/redis/redis.conf</span><br><span class="line"></span><br><span class="line"># docker network create -d=overlay --attachable backend</span><br><span class="line">networks:</span><br><span class="line">  backend-swarm:</span><br><span class="line">    external:</span><br><span class="line">      name: backend-swarm</span><br></pre></td></tr></table></figure>
<h3 id="Ubuntu-Apt安装"><a href="#Ubuntu-Apt安装" class="headerlink" title="Ubuntu Apt安装"></a>Ubuntu Apt安装</h3><p>终端执行:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt install redis-server</span><br><span class="line"></span><br><span class="line"># 启动</span><br><span class="line">redis-server</span><br><span class="line"></span><br><span class="line"># 连接</span><br><span class="line">redis-cli -h 127.0.0.1 -p 6379</span><br></pre></td></tr></table></figure></p>
<h2 id="配置相关"><a href="#配置相关" class="headerlink" title="配置相关"></a>配置相关</h2><blockquote>
<p>稳定版本配置文件: <strong><em><a href="http://download.redis.io/redis-stable/redis.conf" rel="external nofollow noopener noreferrer" target="_blank">http://download.redis.io/redis-stable/redis.conf</a></em></strong></p>
</blockquote>
<p><code>/etc/redis</code>: 存放redis配置文件<br><code>/var/redis/端口号</code>: 存放redis的持久化文件</p>
<p>通过下面的命令停止/启动/重启redis:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/etc/init.d/redis-server stop</span><br><span class="line">/etc/init.d/redis-server start</span><br><span class="line">/etc/init.d/redis-server restart</span><br></pre></td></tr></table></figure></p>
<p>如果是通过源码安装的redis, 则可以通过redis的客户端程序<code>redis-cli</code>的<code>shutdown</code>命令来重启redis<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379 shutdown</span><br></pre></td></tr></table></figure></p>
<p>如果上述方式都没有成功停止redis, 则可以使用终极武器 <code>kill -9</code></p>
<h2 id="开启远程访问"><a href="#开启远程访问" class="headerlink" title="开启远程访问"></a>开启远程访问</h2><p>找到<code>redis.conf</code>文件, 一般在<code>/etc</code>下面: </p>
<p>找到<code>bind 127.0.0.1</code>注释掉<br>注释掉本机,局域网内的所有计算机都能访问.<br><code>band localhost</code> 只能本机访问,局域网内计算机不能访问.<br><code>bind 局域网IP</code> 只能局域网内IP的机器访问, 本地localhost都无法访问. </p>
<p>博主选择将<code>bind 127.0.0.1</code> 改成了<code>bind 0.0.0.0</code></p>
<h2 id="开启发布订阅监听"><a href="#开启发布订阅监听" class="headerlink" title="开启发布订阅监听"></a>开启发布订阅监听</h2><blockquote>
<p>Redis自2.8.0之后版本提供<a href="https://redis.io/topics/notifications" rel="external nofollow noopener noreferrer" target="_blank">Keyspace Notifications</a>功能, 允许客户订阅Pub / Sub频道, 以便以某种方式接收影响Redis数据集的事件. </p>
<p>Redis默认关闭, 键空间通知通常是不启用的, 因为这个过程会产生额外消耗</p>
</blockquote>
<p>还是修改<code>redis.conf</code>文件, 找到<code>notify-keyspace-events &quot;&quot;</code>, 修改为<code>notify-keyspace-events Ex</code>或者<code>notify-keyspace-events AKE</code>, 然后重启. </p>
<table>
<thead>
<tr>
<th>字符</th>
<th>发送通知</th>
</tr>
</thead>
<tbody>
<tr>
<td>K</td>
<td>键空间通知, 所有通知以 <strong>keyspace@</strong> 为前缀, 针对Key</td>
</tr>
<tr>
<td>E</td>
<td>键事件通知, 所有通知以 <strong>keyevent@</strong> 为前缀, 针对event</td>
</tr>
<tr>
<td><em>g</em></td>
<td><em>DEL 、 EXPIRE 、 RENAME 等类型无关的通用命令的通知</em></td>
</tr>
<tr>
<td><strong>$</strong></td>
<td><strong>字符串命令的通知</strong></td>
</tr>
<tr>
<td><strong>l</strong></td>
<td><strong>列表命令的通知</strong></td>
</tr>
<tr>
<td><strong>s</strong></td>
<td><strong>集合命令的通知</strong></td>
</tr>
<tr>
<td><strong>h</strong></td>
<td><strong>哈希命令的通知</strong></td>
</tr>
<tr>
<td><strong>z</strong></td>
<td><strong>有序集合命令的通知</strong></td>
</tr>
<tr>
<td><em>x</em></td>
<td><em>过期事件: 每当有过期键被删除时发送</em></td>
</tr>
<tr>
<td><em>e</em></td>
<td><em>驱逐(evict)事件: 每当有键因为 maxmemory 政策而被删除时发送</em></td>
</tr>
<tr>
<td>A</td>
<td>参数 g$lshzxe 的别名, 相当于是All</td>
</tr>
</tbody>
</table>
<p><code>SUBSCRIBE</code>与<code>PSUBSCRIBE</code>都可以订阅事件, 后者可以通过正则表达匹配对应的Channel, 比如<code>__keyevent*__:expired</code>订阅所有数据库的过期事件</p>
<p>打开一个终端订阅key过期事件: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.6.113:6379&gt; PSUBSCRIBE __keyevent*__:expired</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;psubscribe&quot;</span><br><span class="line">2) &quot;__keyevent*__:expired&quot;</span><br><span class="line">3) (integer) 1</span><br></pre></td></tr></table></figure>
<p>再开一个终端设置一个会过期的kv: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.6.113:6379&gt; set test ybd EX 10</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>10秒后在第一个终端将会受到如下信息: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1) &quot;pmessage&quot;</span><br><span class="line">2) &quot;__keyevent*__:expired&quot;</span><br><span class="line">3) &quot;__keyevent@0__:expired&quot;</span><br><span class="line">4) &quot;test&quot;</span><br></pre></td></tr></table></figure>
<h1 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h1><p><strong><em><a href="https://github.com/uglide/RedisDesktopManager" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/uglide/RedisDesktopManager</a></em></strong></p>
<p><strong><em><a href="https://redislabs.com/redisinsight/" rel="external nofollow noopener noreferrer" target="_blank">https://redislabs.com/redisinsight/</a></em></strong></p>
<p><strong><em><a href="https://github.com/diego3g/rocketredis" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/diego3g/rocketredis</a></em></strong></p>
<h1 id="Redis常用命令"><a href="#Redis常用命令" class="headerlink" title="Redis常用命令"></a>Redis常用命令</h1><blockquote>
<p>最新命令参考: <strong><em><a href="http://redisdoc.com" rel="external nofollow noopener noreferrer" target="_blank">http://redisdoc.com</a></em></strong></p>
</blockquote>
<h2 id="连接操作命令"><a href="#连接操作命令" class="headerlink" title="连接操作命令"></a>连接操作命令</h2><ul>
<li><code>quit</code>: 关闭连接（connection）</li>
<li><code>auth</code>: 简单密码认证</li>
<li><code>help cmd</code>: 查看cmd帮助, 例如: help quit</li>
</ul>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><ul>
<li><code>save</code>: 将数据同步保存到磁盘</li>
<li><code>bgsave</code>: 将数据异步保存到磁盘</li>
<li><code>lastsave</code>: 返回上次成功将数据保存到磁盘的Unix时戳</li>
<li><code>shutdown</code>: 将数据同步保存到磁盘, 然后关闭服务</li>
</ul>
<h2 id="远程服务控制"><a href="#远程服务控制" class="headerlink" title="远程服务控制"></a>远程服务控制</h2><ul>
<li><code>info</code>: 提供服务器的信息和统计</li>
<li><code>monitor</code>: 实时转储收到的请求</li>
<li><code>slaveof</code>: 改变复制策略设置</li>
<li><code>config</code>: 在运行时配置Redis服务器</li>
</ul>
<h2 id="对key操作的命令"><a href="#对key操作的命令" class="headerlink" title="对key操作的命令"></a>对key操作的命令</h2><ul>
<li><code>exists(key)</code>: 确认一个key是否存在</li>
<li><code>del(key)</code>: 删除一个key</li>
<li><code>type(key)</code>: 返回值的类型</li>
<li><code>keys(pattern)</code>: 返回满足给定pattern的所有key</li>
<li><code>randomkey</code>: 随机返回key空间的一个</li>
<li><code>keyrename(oldname, newname)</code>: 重命名key</li>
<li><code>dbsize</code>: 返回当前数据库中key的数目</li>
<li><code>expire</code>: 设定一个key的活动时间（s）</li>
<li><code>ttl</code>: 获得一个key的活动时间</li>
<li><code>select(index)</code>: 按索引查询</li>
<li><code>move(key, dbindex)</code>: 移动当前数据库中的key到dbindex数据库</li>
<li><code>flushdb</code>: 删除当前选择数据库中的所有key</li>
<li><code>flushall</code>: 删除所有数据库中的所有key</li>
</ul>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ul>
<li><code>set(key, value [EX seconds] [PX milliseconds] [NX|XX])</code>: 给数据库中名称为key的string赋予值value, EX与PX都是过期时间, 前者是秒为单位, 后者是毫秒, NX表示当key不存在时赋值, XX表示当key存在时赋值</li>
<li><code>get(key)</code>: 返回数据库中名称为key的string的value</li>
<li><code>getset(key, value)</code>: 给名称为key的string赋予上一次的value</li>
<li><code>mget(key1, key2,…, key N)</code>: 返回库中多个string的value</li>
<li><code>setnx(key, value)</code>: 添加string, 名称为key, 值为value</li>
<li><code>setex(key, time, value)</code>: 向库中添加string, 设定过期时间time</li>
<li><code>mset(key N, value N)</code>: 批量设置多个string的值</li>
<li><code>msetnx(key N, value N)</code>: 如果所有名称为key i的string都不存在</li>
<li><code>incr(key)</code>: 名称为key的string增1操作</li>
<li><code>incrby(key, integer)</code>: 名称为key的string增加integer</li>
<li><code>decr(key)</code>: 名称为key的string减1操作</li>
<li><code>decrby(key, integer)</code>: 名称为key的string减少integer</li>
<li><code>append(key, value)</code>: 名称为key的string的值附加value</li>
<li><code>substr(key, start, end)</code>: 返回名称为key的string的value的子串</li>
</ul>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><ul>
<li><code>rpush(key, value)</code>: 在名称为key的list尾添加一个值为value的元素</li>
<li><code>lpush(key, value)</code>: 在名称为key的list头添加一个值为value的 元素</li>
<li><code>llen(key)</code>: 返回名称为key的list的长度</li>
<li><code>lrange(key, start, end)</code>: 返回名称为key的list中start至end之间的元素</li>
<li><code>ltrim(key, start, end)</code>: 截取名称为key的list</li>
<li><code>lindex(key, index)</code>: 返回名称为key的list中index位置的元素</li>
<li><code>lset(key, index, value)</code>: 给名称为key的list中index位置的元素赋值</li>
<li><code>lrem(key, count, value)</code>: 删除count个key的list中值为value的元素</li>
<li><code>lpop(key)</code>: 返回并删除名称为key的list中的首元素</li>
<li><code>rpop(key)</code>: 返回并删除名称为key的list中的尾元素</li>
<li><code>blpop(key1, key2,… key N, timeout)</code>: lpop命令的block版本. </li>
<li><code>brpop(key1, key2,… key N, timeout)</code>: rpop的block版本. </li>
<li><code>rpoplpush(srckey, dstkey)</code>: 返回并删除名称为srckey的list的尾元素, 并将该元素添加到名称为dstkey的list的头部</li>
</ul>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul>
<li><code>sadd(key, member)</code>: 向名称为key的set中添加元素member</li>
<li><code>srem(key, member)</code> : 删除名称为key的set中的元素member</li>
<li><code>spop(key)</code> : 随机返回并删除名称为key的set中一个元素</li>
<li><code>smove(srckey, dstkey, member)</code> : 移到集合元素</li>
<li><code>scard(key)</code> : 返回名称为key的set的基数</li>
<li><code>sismember(key, member)</code> : member是否是名称为key的set的元素</li>
<li><code>sinter(key1, key2,…key N)</code> : 求交集</li>
<li><code>sinterstore(dstkey, (keys))</code> : 求交集并将交集保存到dstkey的集合</li>
<li><code>sunion(key1, (keys))</code> : 求并集</li>
<li><code>sunionstore(dstkey, (keys))</code> : 求并集并将并集保存到dstkey的集合</li>
<li><code>sdiff(key1, (keys))</code> : 求差集</li>
<li><code>sdiffstore(dstkey, (keys))</code> : 求差集并将差集保存到dstkey的集合</li>
<li><code>smembers(key)</code> : 返回名称为key的set的所有元素</li>
<li><code>srandmember(key)</code> : 随机返回名称为key的set的一个元素</li>
</ul>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><ul>
<li><code>hset(key, field, value)</code>: 向名称为key的hash中添加元素field</li>
<li><code>hget(key, field)</code>: 返回名称为key的hash中field对应的value</li>
<li><code>hmget(key, (fields))</code>: 返回名称为key的hash中field i对应的value</li>
<li><code>hmset(key, (fields))</code>: 向名称为key的hash中添加元素field</li>
<li><code>hincrby(key, field, integer)</code>: 将名称为key的hash中field的value增加integer</li>
<li><code>hexists(key, field)</code>: 名称为key的hash中是否存在键为field的域</li>
<li><code>hdel(key, field)</code>: 删除名称为key的hash中键为field的域</li>
<li><code>hlen(key)</code>: 返回名称为key的hash中元素个数</li>
<li><code>hkeys(key)</code>: 返回名称为key的hash中所有键</li>
<li><code>hvals(key)</code>: 返回名称为key的hash中所有键对应的value</li>
<li><code>hgetall(key)</code>: 返回名称为key的hash中所有的键（field）及其对应的value</li>
</ul>
<h1 id="不同数据类型的常见应用场景"><a href="#不同数据类型的常见应用场景" class="headerlink" title="不同数据类型的常见应用场景"></a>不同数据类型的常见应用场景</h1><blockquote>
<p>为缓存而生的Redis, 其所有数据都在内存中, 固其最大的应用场景就是缓存了, 但这只是个大的概念, 其不同的数据类型都有对应的应用场景. </p>
</blockquote>
<h2 id="String-1"><a href="#String-1" class="headerlink" title="String"></a>String</h2><h3 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h3><p>这应该是最最最常用的场景了, 将对象序列化后再<code>set</code>进去, 所以选择一个好的序列化方案很重要, 需要从时间复杂度以及空间复杂度这两个维度综合考虑. 个人觉得<code>Protostuff</code>选当不错, 基于Google的Protobuff. 详情请看下面的<strong>序列化</strong>一节. </p>
<h3 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h3><p><code>INCRBY</code>可以原子性地递增, 通常用作分布式计数器, 也可以用作生成ID. </p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>正由于Redis是单线程客户端, 这不单单是一个特性, 更是一个应用场景, 最常用的就是分布式锁了. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET key value [EX seconds] [PX milliseconds] [NX|XX]</span><br></pre></td></tr></table></figure>
<p>利用上面命令, 可以做到加锁与过期的原子性. </p>
<p>释放锁可以利用LUA脚本完成: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1]</span><br><span class="line">then</span><br><span class="line">    return redis.call(&quot;del&quot;,KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h3 id="超大数量的布尔统计"><a href="#超大数量的布尔统计" class="headerlink" title="超大数量的布尔统计"></a>超大数量的布尔统计</h3><p>比如要统计几亿人的在线情况、数十亿的布尔存储（布尔标识符）都可以使用<code>GETBIT</code>、<code>SETBIT</code>、<code>BITCOUNT</code>来完成. </p>
<h2 id="List-1"><a href="#List-1" class="headerlink" title="List"></a>List</h2><h3 id="显示最新的分页列表"><a href="#显示最新的分页列表" class="headerlink" title="显示最新的分页列表"></a>显示最新的分页列表</h3><p>一种很常见的需求, 分页, 比如列出最新的5页评论、列出最新的某活动5页商品, 在QPS高的时候, 采用传统的RDBS查询往往会有性能问题. BUT, 结合Redis的<code>LPUSH</code>与<code>LTRIM</code>可以优雅地缓存最新的数据并做到分页, 一般大部分用户只关注前几页数据, 那么后面的数据可以用数据库补上. 这时候前5页的数据是走缓存的, QPS可以提高几个数量级</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>Redis 的 list 数据类型对于大部分使用者来说, 是实现队列服务的最经济, 最简单的方式. </p>
<h2 id="Set-1"><a href="#Set-1" class="headerlink" title="Set"></a>Set</h2><h3 id="共同好友列表（求交集系列）"><a href="#共同好友列表（求交集系列）" class="headerlink" title="共同好友列表（求交集系列）"></a>共同好友列表（求交集系列）</h3><p>社交类应用中, 获取两个人或多个人的共同好友, 两个人或多个人共同关注的微博这样类似的功能, 用 MySQL 的话操作很复杂, 可以把每个人的好友 id 存到集合中, 获取共同好友的操作就可以简单到一个取交集的命令就搞定. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sadd user:wade james melo paul kobe</span><br><span class="line">sadd user:james wade melo paul kobe</span><br><span class="line">sadd user:paul wade james melo kobe</span><br><span class="line">sadd user:melo wade james paul kobe</span><br><span class="line"></span><br><span class="line">// 获取 wade 和 james 的共同好友</span><br><span class="line">sinter user:wade user:james</span><br><span class="line">/* 输出: </span><br><span class="line"> *      1) &quot;kobe&quot;</span><br><span class="line"> *      2) &quot;paul&quot;</span><br><span class="line"> *      3) &quot;melo&quot;</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line"> // 获取香蕉四兄弟的共同好友</span><br><span class="line"> sinter user:wade user:james user:paul user:melo</span><br><span class="line"> /* 输出: </span><br><span class="line"> *      1) &quot;kobe&quot;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>类似的需求还有很多 , 必须把每个标签下的文章 id 存到集合中, 可以很容易的求出几个不同标签下的共同文章；<br> 把每个人的爱好存到集合中, 可以很容易的求出几个人的共同爱好. </p>
<h2 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h2><h3 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h3><p>SortedSet 是在 Set 的基础上给集合中每个元素关联了一个分数, 往有序集合中插入数据时会自动根据这个分数排序, 很适合排行榜之类的需求: </p>
<p>– 列出前100名高分选手</p>
<p>– 列出某用户当前的全球排名</p>
<h1 id="慢查询查看"><a href="#慢查询查看" class="headerlink" title="慢查询查看"></a>慢查询查看</h1><blockquote>
<p>Redis 通过 <code>slowlog-log-slower-than</code> 和 <code>slowlog-max-len</code> 分别配置慢查询的阈值, 以及慢查询记录的日志长度. <code>slowlog-log-slower-than</code> 默认值 10*1000 <strong>微秒</strong>, 当命令执行时间查过设定时, 那么将会被记录在慢查询日志中. 如果<code>slowlog-log-slower-than=0</code>会记录所有的命令, <code>slowlog-log-slower-than&lt;0</code> 对于任何命令都不会进行记录. </p>
</blockquote>
<p>参数设定: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config set slowlog-log-slower-than 20000</span><br><span class="line">config set slowlog-max-len 1000</span><br><span class="line">config rewrite</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果要 Redis 将配置<strong>持久化</strong>到本地配置文件, 需要执行 <code>config rewrite</code> 命令.</p>
</blockquote>
<p><strong>获取慢查询日志:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slowlog get [n] // n 表示返回的日志记录条数</span><br></pre></td></tr></table></figure>
<p>每个慢查询日志有 4 个属性组成, 分别是慢查询日志的标识 id、发生时间戳、命令耗时、执行命令和参数, 慢查询列表如下: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6378&gt; slowlog get</span><br><span class="line">1) 1) (integer) 0                       //标识 id</span><br><span class="line">   2) (integer) 1501750261      //时间戳</span><br><span class="line">   3) (integer) 19                      // 命令耗时</span><br><span class="line">   4) 1) &quot;config&quot;                        // 执行命令</span><br><span class="line">      2) &quot;set&quot;</span><br><span class="line">      3) &quot;slowlog-log-slower-than&quot;</span><br><span class="line">      4) &quot;0&quot;</span><br><span class="line">127.0.0.1:6378&gt;</span><br></pre></td></tr></table></figure>
<p><strong>获取慢查询日志列表当前的长度:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6378&gt; slowlog len</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6378&gt;</span><br></pre></td></tr></table></figure>
<p><strong>慢查询最佳实践</strong></p>
<ul>
<li><code>slowlog-max-len</code> 配置建议: 线上建议调大慢查询列表, 记录慢查询时 Redis 会对长命令做截断操作, 并不会占用大量内存. 增大慢查询列表可以减缓慢查询被剔除的可能, 例如线上可设置为 1000 以上. </li>
<li><code>slowlog-log-slower-than</code> 配置建议: 默认值超过 10 毫秒判定为慢查询, 需要根据 Redis 并发量调整该值. 由于 Redis 采用单线程响应命令, 对于高流量的场景, 如果命令执行时间在 1 毫秒以上, 那么 Redis 最多可支撑 OPS 不到 1000. 因此对于高 OPS （operation per second）场景的 Redis 建议设置为 1 毫秒. </li>
<li>慢查询只记录命令执行时间, 并不包括命令排队和网络传输时间. 因此客户端执行命<br>令的时间会大于命令实际执行时间. 因为命令执行排队机制, 慢查询会导致其他命令级联阻塞, 因此当客户端出现请求超时, 需要检查该时间点是否有对应的慢查询, 从<br>而分析出是否为慢查询导致的命令级联阻塞. </li>
<li>由于慢查询日志是一个先进先出的队列, 也就是说如果慢查询比较多的情况下, 可能<br>会丢失部分慢查询命令, 为了防止这种情况发生, 可以定期执行 slow get 命令将慢查询日志持久化到其他存储中（例如 MySQL）, 然后可以制作可视化界面进行查询. </li>
</ul>
<h1 id="rdb文件分析"><a href="#rdb文件分析" class="headerlink" title="rdb文件分析"></a>rdb文件分析</h1><h2 id="RCT-Redis-Computed-Tomography"><a href="#RCT-Redis-Computed-Tomography" class="headerlink" title="RCT(Redis Computed Tomography)"></a>RCT(Redis Computed Tomography)</h2><p><strong><em><a href="https://github.com/xaecbd/RCT" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/xaecbd/RCT</a></em></strong></p>
<h2 id="redis-rdb-tools"><a href="#redis-rdb-tools" class="headerlink" title="redis-rdb-tools"></a>redis-rdb-tools</h2><p><strong><em><a href="https://github.com/sripathikrishnan/redis-rdb-tools" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/sripathikrishnan/redis-rdb-tools</a></em></strong></p>
<h2 id="rdr"><a href="#rdr" class="headerlink" title="rdr"></a>rdr</h2><blockquote>
<p><strong><em><a href="https://github.com/xueqiu/rdr" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/xueqiu/rdr</a></em></strong></p>
<p>下载链接失效了, 可以在这里下载: <strong><em><a href="https://github.com/gohouse/rdr/releases" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/gohouse/rdr/releases</a></em></strong></p>
</blockquote>
<p>首先查看Redis的dump目录设置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONFIG GET dir</span><br></pre></td></tr></table></figure>
<p>再使用<code>bgsave</code>命令导出<code>dump.rdb</code>, 将<code>dump.rdb</code>复制出来, 再使用 <strong><em><a href="https://github.com/xueqiu/rdr" rel="external nofollow noopener noreferrer" target="_blank">rdr</a></em></strong> 分析: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./rdr show -p 8080 *.rdb</span><br></pre></td></tr></table></figure>
<p>效果图: </p>
<p><img src="https://cdn.yangbingdong.com/img/javaDevEnv/rdr.png" alt></p>
<h1 id="Spring-Boot整合"><a href="#Spring-Boot整合" class="headerlink" title="Spring Boot整合"></a>Spring Boot整合</h1><h2 id="Lettuce"><a href="#Lettuce" class="headerlink" title="Lettuce"></a>Lettuce</h2><h3 id="核心依赖"><a href="#核心依赖" class="headerlink" title="核心依赖"></a>核心依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用连接池需要用到<code>commons-pool2</code></li>
</ul>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="comment">#最大连接数</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">128</span></span><br><span class="line">        <span class="comment">#最大阻塞等待时间(负数表示没限制)</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">5s</span></span><br><span class="line">        <span class="comment">#最大空闲</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">16</span></span><br><span class="line">        <span class="comment">#最小空闲</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">    <span class="comment">#连接超时时间</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="string">10s</span></span><br></pre></td></tr></table></figure>
<h2 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h2><p>Redisson 中已经实现了 Spring redis data, 可直接使用:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可使用 Spring data redis 的配置, 或者自定义 redisson 配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.redis.redisson.config=classpath:redisson.yaml</span><br></pre></td></tr></table></figure>
<p>然后可正常 autowire <code>RedisTemplate</code> 或者 <code>RedissonClient</code>, 包括 redisson 中的一些常用功能比如分布式锁.</p>
<blockquote>
<p> 文档: <em><a href="https://github.com/redisson/redisson/wiki/Redisson项目介绍" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/redisson/redisson/wiki/Redisson%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D</a></em></p>
</blockquote>
<h1 id="客户端序列化选择"><a href="#客户端序列化选择" class="headerlink" title="客户端序列化选择"></a>客户端序列化选择</h1><blockquote>
<p><strong><em><a href="https://github.com/masteranthoneyd/serializer" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/masteranthoneyd/serializer</a></em></strong></p>
</blockquote>
<p>以下是序列化框架性能对比（纳秒）</p>
<p>操作系统: Ubuntu 18.04 64位</p>
<p>CPU: I7-8700</p>
<p>内存: 32G </p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-redis/serialize-performance.png" alt></p>
<ul>
<li><code>Protostuff</code>不能直接序列化集合, 需要用包装类封装起来. </li>
<li><code>String</code>类型还是建议直接使用<code>StringRedisSerializer</code>, 速度最快. </li>
</ul>
<p>Kryo 序列化示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kryo5Serializer</span> <span class="keyword">implements</span> <span class="title">RedisSerializer</span>&lt;<span class="title">CacheWrapper</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Kryo5Serializer INSTANCE = <span class="keyword">new</span> Kryo5Serializer();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Pool&lt;Kryo&gt; kryoPool;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Pool&lt;Input&gt; inputPool;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Pool&lt;Output&gt; outputPool;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Kryo5Serializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.kryoPool = <span class="keyword">new</span> Pool&lt;Kryo&gt;(<span class="keyword">true</span>, <span class="keyword">false</span>, <span class="number">1024</span>) &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">protected</span> Kryo <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> createKryo();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>.inputPool = <span class="keyword">new</span> Pool&lt;Input&gt;(<span class="keyword">true</span>, <span class="keyword">false</span>, <span class="number">512</span>) &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">protected</span> Input <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> Input(<span class="number">8192</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>.outputPool = <span class="keyword">new</span> Pool&lt;Output&gt;(<span class="keyword">true</span>, <span class="keyword">false</span>, <span class="number">512</span>) &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">protected</span> Output <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> Output(<span class="number">8192</span>, -<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Kryo <span class="title">createKryo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Kryo kryo = <span class="keyword">new</span> Kryo();</span><br><span class="line">		kryo.setRegistrationRequired(<span class="keyword">false</span>);</span><br><span class="line">		kryo.setReferences(<span class="keyword">false</span>);</span><br><span class="line">		kryo.addDefaultSerializer(Throwable<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">JavaSerializer</span>())</span>;</span><br><span class="line">		kryo.register(CacheWrapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		<span class="keyword">return</span> kryo;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(CacheWrapper cacheWrapper) <span class="keyword">throws</span> SerializationException &#123;</span><br><span class="line">		Kryo kryo = kryoPool.obtain();</span><br><span class="line">		Output output = outputPool.obtain();</span><br><span class="line">		ByteArrayOutputStream stream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			output.setOutputStream(stream);</span><br><span class="line">			kryo.writeClassAndObject(output, cacheWrapper);</span><br><span class="line">			output.flush();</span><br><span class="line">			<span class="keyword">return</span> stream.toByteArray();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			output.setOutputStream(<span class="keyword">null</span>);</span><br><span class="line">			kryoPool.free(kryo);</span><br><span class="line">			outputPool.free(output);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> CacheWrapper <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> SerializationException </span>&#123;</span><br><span class="line">		Kryo kryo = kryoPool.obtain();</span><br><span class="line">		Input input = inputPool.obtain();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			input.setInputStream(<span class="keyword">new</span> ByteArrayInputStream(bytes));</span><br><span class="line">			<span class="keyword">return</span> (CacheWrapper) kryo.readClassAndObject(input);</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			input.setInputStream(<span class="keyword">null</span>);</span><br><span class="line">			kryoPool.free(kryo);</span><br><span class="line">			inputPool.free(input);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Spring监听Redis-Keyspace-Event"><a href="#Spring监听Redis-Keyspace-Event" class="headerlink" title="Spring监听Redis Keyspace Event"></a>Spring监听Redis Keyspace Event</h1><p>在Spring Boot应用中, 可使用方式一和二, 集成非常快. </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="方式一、通过RedisMessageListenerContainer"><a href="#方式一、通过RedisMessageListenerContainer" class="headerlink" title="方式一、通过RedisMessageListenerContainer"></a>方式一、通过<code>RedisMessageListenerContainer</code></h2><p>这个类是使用线程池监听并执行后续动作的, 可以添加多个监听者. </p>
<p>配置类: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Resource</span></span><br><span class="line">	<span class="keyword">private</span> LettuceConnectionFactory lettuceConnectionFactory</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> RedisMessageListenerContainer <span class="title">redisMessageListenerContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		RedisMessageListenerContainer redisMessageListenerContainer = <span class="keyword">new</span> RedisMessageListenerContainer();</span><br><span class="line">		redisMessageListenerContainer.setConnectionFactory(lettuceConnectionFactory);</span><br><span class="line">		redisMessageListenerContainer.addMessageListener(<span class="keyword">new</span> KeyExpireListener(), <span class="keyword">new</span> PatternTopic(<span class="string">"__keyevent@*__:expired"</span>));</span><br><span class="line">		<span class="keyword">return</span> redisMessageListenerContainer;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>监听类: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyExpireListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> RedisSerializer&lt;String&gt; stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, <span class="keyword">byte</span>[] pattern)</span> </span>&#123;</span><br><span class="line">		Thread thread = Thread.currentThread();</span><br><span class="line">		System.out.println(thread.getId() + <span class="string">" "</span> + thread.getName() + <span class="string">" -&gt; "</span> + stringRedisSerializer.deserialize(pattern) + <span class="string">": "</span> + message);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此简单的几行代码就可以监听Redis Key过期事件, 但<code>RedisMessageListenerContainer</code>默认使用<code>SimpleAsyncTaskExecutor</code>作为线程池, 这个线程池比较坑的地方在于每次都是用新的线程去执行任务, 不重用线程, 不是真正意义上的线程池. </p>
<h2 id="方式二、监听RedisKeyspaceEvent"><a href="#方式二、监听RedisKeyspaceEvent" class="headerlink" title="方式二、监听RedisKeyspaceEvent"></a>方式二、监听RedisKeyspaceEvent</h2><p>通过创建并注册<code>KeyExpirationEventMessageListener</code>, 监听到过期事件后, 会发布一个<code>RedisKeyExpiredEvent</code>. </p>
<p><code>KeyExpirationEventMessageListener</code>继承<code>KeyspaceEventMessageListener</code>, <code>KeyspaceEventMessageListener</code>实现<code>MessageListener</code>, 在<code>onMessage(...)</code>方法中提供了<code>doHandleMessage(message)</code>抽象方法, 最终由<code>KeyExpirationEventMessageListener</code>实现. </p>
<p>配之类: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Resource</span></span><br><span class="line">	<span class="keyword">private</span> LettuceConnectionFactory lettuceConnectionFactory;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> KeyExpirationEventMessageListener <span class="title">keyExpirationEventMessageListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> KeyExpirationEventMessageListener(redisMessageListenerContainer());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> RedisMessageListenerContainer <span class="title">redisMessageListenerContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		RedisMessageListenerContainer redisMessageListenerContainer = <span class="keyword">new</span> RedisMessageListenerContainer();</span><br><span class="line">		redisMessageListenerContainer.setConnectionFactory(lettuceConnectionFactory);</span><br><span class="line">		<span class="keyword">return</span> redisMessageListenerContainer;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事件监听类: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyExpireApplicationEventListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">RedisKeyExpiredEvent</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(RedisKeyExpiredEvent event)</span> </span>&#123;</span><br><span class="line">		System.out.println(event);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上<code>KeyExpirationEventMessageListener</code>也是<code>MessageListener</code>的实现, 最终还是由<code>RedisMessageListenerContainer</code>管理, 没有设置线程池的话, 还是使用<code>SimpleAsyncTaskExecutor</code>. . . </p>
<p>两种方式最终都是<code>RedisPubSubCommands.pSubscribe(MessageListener listener, byte[]... patterns);</code></p>
<h2 id="方式三、结合Disruptor"><a href="#方式三、结合Disruptor" class="headerlink" title="方式三、结合Disruptor"></a>方式三、结合Disruptor</h2><p>上面两种方式操作简单, 但是如果每天有上千万的过期通知, 在一个链接的情况下可能会影响吞吐量, 某些业务处理比较慢, 阻塞后面的通知, 这种情况下我们可以结合高性能队列框架<code>Disruptor</code>异步处理. </p>
<p>先定义Event: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.Message;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ybd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 18-10-19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@contact</span> yangbingdong1994@gmail.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisKeyExpireEvent</span> <span class="keyword">implements</span> <span class="title">CleanEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Message message;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] pattern;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Message <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisKeyExpireEvent <span class="title">setMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getPattern() &#123;</span><br><span class="line">        <span class="keyword">return</span> pattern;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisKeyExpireEvent <span class="title">setPattern</span><span class="params">(<span class="keyword">byte</span>[] pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pattern = pattern;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.pattern = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CleanEvent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个Event是由用户自己定义的. </li>
</ul>
<p>定义Event处理类: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.lmax.disruptor.WorkHandler;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ybd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 18-10-19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@contact</span> yangbingdong1994@gmail.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisKeyExpireEventHandler</span> <span class="keyword">implements</span> <span class="title">WorkHandler</span>&lt;<span class="title">RedisKeyExpireEvent</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> RedisSerializer&lt;String&gt; stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(RedisKeyExpireEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">			Thread thread = Thread.currentThread();</span><br><span class="line">			log.info(thread.getId() + <span class="string">" "</span> + thread.getName() + <span class="string">" -&gt; "</span> + stringRedisSerializer.deserialize(event.getPattern()) + <span class="string">": "</span> + event.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            event.clean();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>实现的是<code>WorkHandler</code>而不是<code>EventHandler</code>, 因为我们调用的是<code>disruptor.handleEventsWithWorkerPool</code>, 区别是<code>WorkerPool</code>可以达到Sharding的效果. </li>
</ul>
<p>异常处理类: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.lmax.disruptor.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ybd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 18-10-19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@contact</span> yangbingdong1994@gmail.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisKeyExpireEventExceptionHandler</span> <span class="keyword">implements</span> <span class="title">ExceptionHandler</span>&lt;<span class="title">RedisKeyExpireEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StringRedisSerializer strSerial = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleEventException</span><span class="params">(Throwable ex, <span class="keyword">long</span> sequence, RedisKeyExpireEvent event)</span> </span>&#123;</span><br><span class="line">        String msgBody = strSerial.deserialize(event.getMessage().getBody());</span><br><span class="line">        log.error(<span class="string">"处理Redis Key过期事件失败: "</span> + msgBody, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleOnStartException</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">		log.error(<span class="string">"Disruptor&lt;RedisKeyExpireEvent&gt; handleOnStartException:"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleOnShutdownException</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">		log.error(<span class="string">"Disruptor&lt;RedisKeyExpireEvent&gt; handleOnShutdownException:"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用于发布事件的Disruptor: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.lmax.disruptor.BlockingWaitStrategy;</span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.EventTranslatorTwoArg;</span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.RingBuffer;</span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.dsl.Disruptor;</span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.dsl.ProducerType;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.InitializingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.event.ContextClosedEvent;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ybd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 18-10-19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@contact</span> yangbingdong1994@gmail.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisKeyExpireDisruptor</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ContextClosedEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TOTAL_SHARDING = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Disruptor&lt;RedisKeyExpireEvent&gt; disruptor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EventTranslatorTwoArg&lt;RedisKeyExpireEvent, Message, <span class="keyword">byte</span>[]&gt; translatorTwoArg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RingBuffer&lt;RedisKeyExpireEvent&gt; ringBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">	<span class="keyword">private</span> RedisKeyExpireEventHandler redisKeyExpireEventHandler;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initDisruptor();</span><br><span class="line">		RedisKeyExpireEventHandler[] handlers = buildHandler();</span><br><span class="line">        disruptor.handleEventsWithWorkerPool(handlers);</span><br><span class="line">        disruptor.start();</span><br><span class="line">        ringBuffer = disruptor.getRingBuffer();</span><br><span class="line">        translatorTwoArg = (event, sequence, message, pattern) -&gt; event.setMessage(message).setPattern(pattern);</span><br><span class="line">        log.info(<span class="string">"RedisKeyExpireDisruptor initialized"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RedisKeyExpireEventHandler[] buildHandler() &#123;</span><br><span class="line">        <span class="keyword">return</span> IntStream.range(<span class="number">0</span>, TOTAL_SHARDING)</span><br><span class="line">                        .mapToObj(i -&gt; redisKeyExpireEventHandler)</span><br><span class="line">                        .toArray(RedisKeyExpireEventHandler[]::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initDisruptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        disruptor = <span class="keyword">new</span> Disruptor&lt;&gt;(RedisKeyExpireEvent::<span class="keyword">new</span>, <span class="number">1</span> &lt;&lt; <span class="number">10</span>, DisruptorUtil.getThreadFactory(<span class="string">"keyspace-disruptor-%d"</span>), ProducerType.SINGLE, <span class="keyword">new</span> BlockingWaitStrategy());</span><br><span class="line">        disruptor.setDefaultExceptionHandler(<span class="keyword">new</span> RedisKeyExpireEventExceptionHandler());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextClosedEvent event)</span> </span>&#123;</span><br><span class="line">        DisruptorUtil.shutDownDisruptor(disruptor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">(Message message, <span class="keyword">byte</span>[] pattern)</span> </span>&#123;</span><br><span class="line">        ringBuffer.publishEvent(translatorTwoArg, message, pattern);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>工具类: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.lmax.disruptor.TimeoutException;</span><br><span class="line"><span class="keyword">import</span> com.lmax.disruptor.dsl.Disruptor;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.concurrent.BasicThreadFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ybd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 18-9-29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@contact</span> yangbingdong1994@gmail.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DisruptorUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BasicThreadFactory <span class="title">getThreadFactory</span><span class="params">(String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BasicThreadFactory.Builder().namingPattern(pattern)</span><br><span class="line">                                               .daemon(<span class="keyword">true</span>)</span><br><span class="line">                                               .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shutDownDisruptor</span><span class="params">(Disruptor disruptor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (disruptor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                disruptor.shutdown(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">                log.error(<span class="string">"Disruptor shutdown error!"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图: </p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-redis/redis-key-expire-disruptor.png" alt></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><blockquote>
<h2 id="Timing-of-expired-events"><a href="#Timing-of-expired-events" class="headerlink" title="Timing of expired events"></a>Timing of expired events</h2><p>Keys with a time to live associated are expired by Redis in two ways:</p>
<ul>
<li>When the key is accessed by a command and is found to be expired.</li>
<li>Via a background system that looks for expired keys in background, incrementally, in order to be able to also collect keys that are never accessed.</li>
</ul>
<p>The <code>expired</code> events are generated when a key is accessed and is found to be expired by one of the above systems, as a result there are no guarantees that the Redis server will be able to generate the <code>expired</code> event at the time the key time to live reaches the value of zero.</p>
<p>If no command targets the key constantly, and there are many keys with a TTL associated, there can be a significant delay between the time the key time to live drops to zero, and the time the <code>expired</code> event is generated.</p>
<p>Basically <code>expired</code> events <strong>are generated when the Redis server deletes the key</strong> and not when the time to live theoretically reaches the value of zero.</p>
</blockquote>
<p>上面是官方文档的原文, 在删除key的时候发送事件, 而删除key不是实时的, 而是后台逐步删除的, 所有可能会与TTL时间存在误差. 在客户端链接丢失期间（比如项目迭代发布版本）, 也是会丢失消息的. </p>
<h1 id="分布式ID"><a href="#分布式ID" class="headerlink" title="分布式ID"></a>分布式ID</h1><p>虽然 Redis 的 incr 命令可以做 分布式 id, 但是过于地依赖 Redis.<br>其他方案:</p>
<ul>
<li>百度 Uid: <strong><em><a href="https://github.com/baidu/uid-generator" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/baidu/uid-generator</a></em></strong></li>
<li>美团 Leaf: <strong><em><a href="https://github.com/Meituan-Dianping/Leaf" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/Meituan-Dianping/Leaf</a></em></strong></li>
<li>滴滴 Tinyid: <strong><em><a href="https://github.com/didi/tinyid" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/didi/tinyid</a></em></strong></li>
</ul>
]]></content><categories><category>Programming</category><category>Java</category><category>Spring Boot</category></categories><tags><tag>Redis</tag><tag>Spring Boot</tag></tags></entry><entry><title>Spring Boot 之数据篇</title><url>/2019/spring-boot-learning-orm/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/spring-boot-orm/spring-data-learning.png" alt></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><blockquote>
<p>后端应用当中与DB交互也是必不可少的一部, 在Java中我们将交互部分抽象成了 <strong>ORM</strong>(Object Relational Mapping), 以下是数据源以及ORM相关…</p>
</blockquote>
<a id="more"></a>
<h1 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h1><h2 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h2><blockquote>
<p>更多请查看官方指导：<strong><em><a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#howto-configure-a-datasource" rel="external nofollow noopener noreferrer" target="_blank">https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#howto-configure-a-datasource</a></em></strong></p>
</blockquote>
<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>pom.xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>application.yml:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.6.113:3306/sync?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false</span> <span class="comment"># 注意加上 useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span> <span class="comment"># 这个可以不加，会智能感知</span></span><br></pre></td></tr></table></figure>
<h3 id="H2"><a href="#H2" class="headerlink" title="H2"></a>H2</h3><p><strong>注意：使用H2控制台不能使用WebFlux，否则控制台出不来</strong></p>
<p>pom.xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- h2 数据源连接驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>application.yml:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:h2:mem:test</span> <span class="comment"># 使用内存存储</span></span><br><span class="line"><span class="comment">#    url: jdbc:h2:file:~/test # 使用物理盘存储</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">sa</span></span><br><span class="line">    <span class="attr">password:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">org.h2.Driver</span></span><br></pre></td></tr></table></figure>
<p><strong>开启H2控制台</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">h2:</span></span><br><span class="line">    <span class="attr">console:</span></span><br><span class="line">      <span class="comment"># 开启控制台，默认为 false</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># 配置控制台路径，默认为 /h2-console</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/console</span></span><br><span class="line">      <span class="attr">settings:</span></span><br><span class="line">        <span class="attr">trace:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">web-allow-others:</span> <span class="literal">true</span> <span class="comment"># 允许内网访问</span></span><br></pre></td></tr></table></figure>
<h2 id="常用连接池配置"><a href="#常用连接池配置" class="headerlink" title="常用连接池配置"></a>常用连接池配置</h2><blockquote>
<p>Spring Boot 2 默认使用 <a href="https://github.com/brettwooldridge/HikariCP" rel="external nofollow noopener noreferrer" target="_blank"><em>HikariCP</em></a> 作为连接池</p>
</blockquote>
<p>如果项目中已包含<code>spring-boot-starter-jdbc</code>或<code>spring-boot-starter-jpa</code>模块，那么连接池将<strong>自动激活</strong>！</p>
<p>在Spring Boot2中选择数据库链接池实现的判断逻辑：</p>
<ol>
<li>检查HikariCP是否可用，如可用，则启用。使用<code>spring.datasource.hikari.*</code>可以控制链接池的行为。</li>
<li>检查Tomcat的数据库链接池实现是否可用，如可用，则启用。使用<code>spring.datasource.tomcat.*</code>可以控制链接池的行为。</li>
<li>检查Commons DBCP2是否可用，如可用，则启用。使用<code>spring.datasource.dbcp2.*</code>可以控制链接池的行为。</li>
</ol>
<p>Spring Boot 2中已经使用Hikari作为默认连接池，如果需要指定其他使用<code>spring.datasource.type</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    hikari:</span><br><span class="line">      connection-timeout: 30000 #等待连接池分配连接的最大时长(毫秒)，超过这个时长还没可用的连接则发生SQLException， 缺省:30秒</span><br><span class="line">      idle-timeout: 600000 #一个连接idle状态的最大时长(毫秒)，超时则被释放(retired)，缺省:10分钟</span><br><span class="line">      max-lifetime: 1800000 #一个连接的生命时长(毫秒)，超时而且没被使用则被释放(retired)，缺省:30分钟，建议设置比数据库超时时长少30秒以上，参考MySQL wait_timeout参数(show variables like &apos;%timeout%&apos;;)</span><br><span class="line">      maximum-pool-size: 9 #连接池中允许的最大连接数。缺省值：10; 推荐的公式：((core_count * 2) + effective_spindle_count)</span><br></pre></td></tr></table></figure>
<h3 id="HikariCP-连接池常用属性"><a href="#HikariCP-连接池常用属性" class="headerlink" title="HikariCP 连接池常用属性"></a>HikariCP 连接池常用属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>dataSourceClassName</td>
<td>JDBC 驱动程序提供的 DataSource 类的名称，如果使用了jdbcUrl则不需要此属性</td>
<td>-</td>
</tr>
<tr>
<td>jdbcUrl</td>
<td>数据库连接地址</td>
<td>-</td>
</tr>
<tr>
<td>username</td>
<td>数据库账户，如果使用了jdbcUrl则需要此属性</td>
<td>-</td>
</tr>
<tr>
<td>password</td>
<td>数据库密码，如果使用了jdbcUrl则需要此属性</td>
<td>-</td>
</tr>
<tr>
<td>autoCommit</td>
<td>是否自动提交事务</td>
<td>true</td>
</tr>
<tr>
<td>connectionTimeout</td>
<td>连接超时时间(毫秒)，如果在没有连接可用的情况下等待超过此时间，则抛出 SQLException</td>
<td>30000(30秒)</td>
</tr>
<tr>
<td>idleTimeout</td>
<td>空闲超时时间(毫秒)，只有在minimumIdle&lt;maximumPoolSize时生效，超时的连接可能被回收，数值 0 表示空闲连接永不从池中删除</td>
<td>600000(10分钟)</td>
</tr>
<tr>
<td>maxLifetime</td>
<td>连接池中的连接的最长生命周期(毫秒)。数值 0 表示不限制</td>
<td>1800000(30分钟)</td>
</tr>
<tr>
<td>connectionTestQuery</td>
<td>连接池每分配一条连接前执行的查询语句(如：SELECT 1)，以验证该连接是否是有效的。如果你的驱动程序支持 JDBC4，HikariCP 强烈建议我们不要设置此属性</td>
<td>-</td>
</tr>
<tr>
<td>minimumIdle</td>
<td>最小空闲连接数，HikariCP 建议我们不要设置此值，而是充当固定大小的连接池</td>
<td>与maximumPoolSize数值相同</td>
</tr>
<tr>
<td>maximumPoolSize</td>
<td>连接池中可同时连接的最大连接数，当池中没有空闲连接可用时，就会阻塞直到超出connectionTimeout设定的数值，推荐的公式：((core_count * 2) + effective_spindle_count)</td>
<td>10</td>
</tr>
<tr>
<td>poolName</td>
<td>连接池名称，主要用于显示在日志记录和 JMX 管理控制台中</td>
<td>auto-generated</td>
</tr>
</tbody>
</table>
<p><code>application.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1/spring_boot_testing_storage</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="comment">#     type: com.zaxxer.hikari.HikariDataSource #Spring Boot2.0默认使用HikariDataSource</span></span><br><span class="line">      <span class="attr">hikari:</span></span><br><span class="line">        <span class="attr">auto-commit:</span> <span class="literal">false</span></span><br><span class="line">        <span class="attr">maximum-pool-size:</span> <span class="number">9</span> <span class="comment">#连接池中允许的最大连接数。缺省值：10; 推荐的公式：((core_count * 2) + effective_spindle_count)</span></span><br></pre></td></tr></table></figure>
<h3 id="Tomcat连接池常用的属性"><a href="#Tomcat连接池常用的属性" class="headerlink" title="Tomcat连接池常用的属性"></a>Tomcat连接池常用的属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>defaultAutoCommit</td>
<td>连接池中创建的连接默认是否自动提交事务</td>
<td>驱动的缺省值</td>
</tr>
<tr>
<td>defaultReadOnly</td>
<td>连接池中创建的连接默认是否为只读状态</td>
<td>-</td>
</tr>
<tr>
<td>defaultCatalog</td>
<td>连接池中创建的连接默认的 catalog</td>
<td>-</td>
</tr>
<tr>
<td>driverClassName</td>
<td>驱动类的名称</td>
<td>-</td>
</tr>
<tr>
<td>username</td>
<td>数据库账户</td>
<td>-</td>
</tr>
<tr>
<td>password</td>
<td>数据库密码</td>
<td>-</td>
</tr>
<tr>
<td>maxActive</td>
<td>连接池同一时间可分配的最大活跃连接数</td>
<td>100</td>
</tr>
<tr>
<td>maxIdle</td>
<td>始终保留在池中的最大连接数，如果启用，将定期检查限制连接，超出此属性设定的值且空闲时间超过minEvictableIdleTimeMillis的连接则释放</td>
<td>与maxActive设定的值相同</td>
</tr>
<tr>
<td>minIdle</td>
<td>始终保留在池中的最小连接数，池中的连接数量若低于此值则创建新的连接，如果连接验证失败将缩小至此值</td>
<td>与initialSize设定的值相同</td>
</tr>
<tr>
<td>initialSize</td>
<td>连接池启动时创建的初始连接数量</td>
<td>10</td>
</tr>
<tr>
<td>maxWait</td>
<td>最大等待时间(毫秒)，如果在没有连接可用的情况下等待超过此时间，则抛出异常</td>
<td>30000(30秒)</td>
</tr>
<tr>
<td>testOnBorrow</td>
<td>当从连接池中取出一个连接时是否进行验证，若验证失败则从池中删除该连接并尝试取出另一个连接</td>
<td>false</td>
</tr>
<tr>
<td>testOnConnect</td>
<td>当一个连接首次被创建时是否进行验证，若验证失败则抛出 SQLException 异常</td>
<td>false</td>
</tr>
<tr>
<td>testOnReturn</td>
<td>当一个连接使用完归还到连接池时是否进行验证</td>
<td>false</td>
</tr>
<tr>
<td>testWhileIdle</td>
<td>对池中空闲的连接是否进行验证，验证失败则回收此连接</td>
<td>false</td>
</tr>
<tr>
<td>validationQuery</td>
<td>在连接池返回连接给调用者前用来对连接进行验证的查询 SQL</td>
<td>null</td>
</tr>
<tr>
<td>validationQueryTimeout</td>
<td>SQL 查询验证超时时间(秒)，小于或等于 0 的数值表示禁用</td>
<td>-1</td>
</tr>
<tr>
<td>timeBetweenEvictionRunsMillis</td>
<td>在空闲连接回收器线程运行期间休眠时间(毫秒)， 该值不应该小于 1 秒，它决定线程多久验证空闲连接或丢弃连接的频率</td>
<td>5000(5秒)</td>
</tr>
<tr>
<td>minEvictableIdleTimeMillis</td>
<td>连接在池中保持空闲而不被回收的最小时间(毫秒)</td>
<td>60000(60秒)</td>
</tr>
<tr>
<td>removeAbandoned</td>
<td>标记是否删除泄露的连接，如果连接超出removeAbandonedTimeout的限制，且该属性设置为 true，则连接被认为是被泄露并且可以被删除</td>
<td>false</td>
</tr>
<tr>
<td>removeAbandonedTimeout</td>
<td>泄露的连接可以被删除的超时时间(秒)，该值应设置为应用程序查询可能执行的最长时间</td>
<td>60</td>
</tr>
</tbody>
</table>
<p><code>application.yml</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1/spring_boot_testing_storage</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">tomcat:</span></span><br><span class="line">      <span class="attr">default-auto-commit:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">initial-size:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">max-active:</span> <span class="number">120</span></span><br><span class="line">      <span class="attr">max-wait:</span> <span class="number">10000</span></span><br><span class="line">      <span class="attr">test-on-borrow:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">test-while-idle:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">validation-query:</span> <span class="string">'SELECT 1'</span></span><br><span class="line">      <span class="attr">validation-query-timeout:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">time-between-eviction-runs-millis:</span> <span class="number">10000</span></span><br><span class="line">      <span class="attr">min-evictable-idle-time-millis:</span> <span class="number">120000</span></span><br><span class="line">      <span class="attr">remove-abandoned:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">remove-abandoned-timeout:</span> <span class="number">120</span></span><br></pre></td></tr></table></figure>
<h3 id="DBCP-连接池常用配置"><a href="#DBCP-连接池常用配置" class="headerlink" title="DBCP 连接池常用配置"></a>DBCP 连接池常用配置</h3><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>url</td>
<td>数据库连接地址</td>
<td>-</td>
</tr>
<tr>
<td>username</td>
<td>数据库账户</td>
<td>-</td>
</tr>
<tr>
<td>password</td>
<td>数据库密码</td>
<td>-</td>
</tr>
<tr>
<td>driverClassName</td>
<td>驱动类的名称</td>
<td>-</td>
</tr>
<tr>
<td>defaultAutoCommit</td>
<td>连接池中创建的连接默认是否自动提交事务</td>
<td>驱动的缺省值</td>
</tr>
<tr>
<td>defaultReadOnly</td>
<td>连接池中创建的连接默认是否为只读状态</td>
<td>驱动的缺省值</td>
</tr>
<tr>
<td>defaultCatalog</td>
<td>连接池中创建的连接默认的 catalog</td>
<td>-</td>
</tr>
<tr>
<td>initialSize</td>
<td>连接池启动时创建的初始连接数量</td>
<td>0</td>
</tr>
<tr>
<td>maxTotal</td>
<td>连接池同一时间可分配的最大活跃连接数; 负数表示不限制</td>
<td>8</td>
</tr>
<tr>
<td>maxIdle</td>
<td>可以在池中保持空闲的最大连接数，超出此值的空闲连接被释放，负数表示不限制</td>
<td>8</td>
</tr>
<tr>
<td>minIdle</td>
<td>可以在池中保持空闲的最小连接数，低于此值将创建空闲连接，若设置为 0，则不创建</td>
<td>0</td>
</tr>
<tr>
<td>maxWaitMillis</td>
<td>最大等待时间(毫秒)，如果在没有连接可用的情况下等待超过此时间，则抛出异常; -1 表示无限期等待，直到获取到连接为止</td>
<td>-</td>
</tr>
<tr>
<td>validationQuery</td>
<td>在连接池返回连接给调用者前用来对连接进行验证的查询 SQL</td>
<td>-</td>
</tr>
<tr>
<td>validationQueryTimeout</td>
<td>SQL 查询验证超时时间(秒)</td>
<td>-</td>
</tr>
<tr>
<td>testOnCreate</td>
<td>连接在创建之后是否进行验证</td>
<td>false</td>
</tr>
<tr>
<td>testOnBorrow</td>
<td>当从连接池中取出一个连接时是否进行验证，若验证失败则从池中删除该连接并尝试取出另一个连接</td>
<td>true</td>
</tr>
<tr>
<td>testOnReturn</td>
<td>当一个连接使用完归还到连接池时是否进行验证</td>
<td>false</td>
</tr>
<tr>
<td>testWhileIdle</td>
<td>对池中空闲的连接是否进行验证，验证失败则释放此连接</td>
<td>false</td>
</tr>
<tr>
<td>timeBetweenEvictionRunsMillis</td>
<td>在空闲连接回收器线程运行期间休眠时间(毫秒)，如果设置为非正数，则不运行此线程</td>
<td>-1</td>
</tr>
<tr>
<td>numTestsPerEvictionRun</td>
<td>空闲连接回收器线程运行期间检查连接的个数</td>
<td>3</td>
</tr>
<tr>
<td>minEvictableIdleTimeMillis</td>
<td>连接在池中保持空闲而不被回收的最小时间(毫秒)</td>
<td>1800000(30分钟)</td>
</tr>
<tr>
<td>removeAbandonedOnBorrow</td>
<td>标记是否删除泄露的连接，如果连接超出removeAbandonedTimeout的限制，且该属性设置为 true，则连接被认为是被泄露并且可以被删除</td>
<td>false</td>
</tr>
<tr>
<td>removeAbandonedTimeout</td>
<td>泄露的连接可以被删除的超时时间(秒)，该值应设置为应用程序查询可能执行的最长时间</td>
<td>300(5分钟)</td>
</tr>
<tr>
<td>poolPreparedStatements</td>
<td>设置该连接池的预处理语句池是否生效</td>
<td>false</td>
</tr>
</tbody>
</table>
<p><code>application.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">jmx:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1/spring_boot_testing_storage</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">dbcp2:</span></span><br><span class="line">      <span class="attr">default-auto-commit:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">initial-size:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">max-total:</span> <span class="number">120</span></span><br><span class="line">      <span class="attr">max-idle:</span> <span class="number">120</span></span><br><span class="line">      <span class="attr">min-idle:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">max-wait-millis:</span> <span class="number">10000</span></span><br><span class="line">      <span class="attr">validation-query:</span> <span class="string">'SELECT 1'</span></span><br><span class="line">      <span class="attr">validation-query-timeout:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">test-on-borrow:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">test-while-idle:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">time-between-eviction-runs-millis:</span> <span class="number">10000</span></span><br><span class="line">      <span class="attr">num-tests-per-eviction-run:</span> <span class="number">10</span></span><br><span class="line">      <span class="attr">min-evictable-idle-time-millis:</span> <span class="number">120000</span></span><br><span class="line">      <span class="attr">remove-abandoned-on-borrow:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">remove-abandoned-timeout:</span> <span class="number">120</span></span><br><span class="line">      <span class="attr">pool-prepared-statements:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>Spring Boot Data Jpa 依赖声明：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">通过application.yml: spring.datasource.type=...配置</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-dbcp2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Druid连接池配置"><a href="#Druid连接池配置" class="headerlink" title="Druid连接池配置"></a>Druid连接池配置</h3><p>参考：<strong><em><a href="https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter</a></em></strong></p>
<h2 id="JTA分布式事务数据源"><a href="#JTA分布式事务数据源" class="headerlink" title="JTA分布式事务数据源"></a>JTA分布式事务数据源</h2><p>Atomikos是一个非常流行的开源事务管理器，并且可以嵌入到Spring Boot应用中。可以使用 <code>spring-boot-starter-jta-atomikos</code> Starter去获取正确的Atomikos库。Spring Boot会自动配置Atomikos，并将合适的 <code>depends-on</code> 应用到Spring Beans上，确保它们以正确的顺序启动和关闭。</p>
<p>默认情况下，Atomikos事务日志将被记录在应用home目录(应用jar文件放置的目录)下的 <code>transaction-logs</code> 文件夹中。可以在 <code>application.properties</code> 文件中通过设置 <code>spring.jta.log-dir</code> 属性来定义该目录，以 <code>spring.jta.atomikos.properties</code> 开头的属性能用来定义Atomikos的 <code>UserTransactionServiceIml</code> 实现，具体参考<a href="http://docs.spring.io/spring-boot/docs/1.5.4.RELEASE/api/org/springframework/boot/jta/atomikos/AtomikosProperties.html" rel="external nofollow noopener noreferrer" target="_blank">AtomikosProperties javadoc</a>。</p>
<blockquote>
<p>注 为了确保多个事务管理器能够安全地和相应的资源管理器配合，每个Atomikos实例必须设置一个唯一的ID。默认情况下，该ID是Atomikos实例运行的机器上的IP地址。为了确保生产环境中该ID的唯一性，需要为应用的每个实例设置不同的 <code>spring.jta.transaction-manager-id</code> 属性值。</p>
</blockquote>
<p>依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jta-atomikos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>application.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">test-23</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">show-sql:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">jta:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">atomikos:</span></span><br><span class="line">      <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">jta-user:</span></span><br><span class="line">          <span class="attr">xa-properties.url:</span> <span class="string">jdbc:mysql://localhost:3306/jta-user</span></span><br><span class="line">          <span class="attr">xa-properties.user:</span> <span class="string">root</span></span><br><span class="line">          <span class="attr">xa-properties.password:</span> <span class="string">root</span></span><br><span class="line">          <span class="attr">xa-data-source-class-name:</span> <span class="string">com.mysql.jdbc.jdbc2.optional.MysqlXADataSource</span></span><br><span class="line">          <span class="attr">unique-resource-name:</span> <span class="string">jta-user</span></span><br><span class="line">          <span class="attr">max-pool-size:</span> <span class="number">25</span></span><br><span class="line">          <span class="attr">min-pool-size:</span> <span class="number">3</span></span><br><span class="line">          <span class="attr">max-lifetime:</span> <span class="number">20000</span></span><br><span class="line">          <span class="attr">borrow-connection-timeout:</span> <span class="number">10000</span></span><br><span class="line">        <span class="attr">jta-income:</span> </span><br><span class="line">          <span class="attr">xa-properties.url:</span> <span class="string">jdbc:mysql://localhost:3306/jta-income</span></span><br><span class="line">          <span class="attr">xa-properties.user:</span> <span class="string">root</span></span><br><span class="line">          <span class="attr">xa-properties.password:</span> <span class="string">root</span></span><br><span class="line">          <span class="attr">xa-data-source-class-name:</span> <span class="string">com.mysql.jdbc.jdbc2.optional.MysqlXADataSource</span></span><br><span class="line">          <span class="attr">unique-resource-name:</span> <span class="string">jta-income</span></span><br><span class="line">          <span class="attr">max-pool-size:</span> <span class="number">25</span></span><br><span class="line">          <span class="attr">min-pool-size:</span> <span class="number">3</span></span><br><span class="line">          <span class="attr">max-lifetime:</span> <span class="number">20000</span></span><br><span class="line">          <span class="attr">borrow-connection-timeout:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>
<p>DataSourceJTAIncomeConfig.java:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages = <span class="string">"com.freud.test.springboot.mapper.income"</span>, sqlSessionTemplateRef = <span class="string">"jtaIncomeSqlSessionTemplate"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceJTAIncomeConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.jta.atomikos.datasource.jta-income"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSourceJTAIncome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AtomikosDataSourceBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">jtaIncomeSqlSessionFactory</span><span class="params">(@Qualifier(<span class="string">"dataSourceJTAIncome"</span>)</span> DataSource dataSource)</span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSessionFactoryBean bean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        bean.setDataSource(dataSource);</span><br><span class="line">        bean.setMapperLocations(<span class="keyword">new</span> PathMatchingResourcePatternResolver().getResources(<span class="string">"classpath:mapper/*.xml"</span>));</span><br><span class="line">        bean.setTypeAliasesPackage(<span class="string">"com.freud.test.springboot.mapper.income"</span>);</span><br><span class="line">        <span class="keyword">return</span> bean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">jtaIncomeSqlSessionTemplate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @Qualifier(<span class="string">"jtaIncomeSqlSessionFactory"</span>)</span> SqlSessionFactory sqlSessionFactory) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DataSourceJTAUserConfig.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages = <span class="string">"com.freud.test.springboot.mapper.user"</span>, sqlSessionTemplateRef = <span class="string">"jtaUserSqlSessionTemplate"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceJTAUserConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.jta.atomikos.datasource.jta-user"</span>)</span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSourceJTAUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AtomikosDataSourceBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">jtaUserSqlSessionFactory</span><span class="params">(@Qualifier(<span class="string">"dataSourceJTAUser"</span>)</span> DataSource dataSource)</span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSessionFactoryBean bean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        bean.setDataSource(dataSource);</span><br><span class="line">        bean.setMapperLocations(<span class="keyword">new</span> PathMatchingResourcePatternResolver().getResources(<span class="string">"classpath:mapper/*.xml"</span>));</span><br><span class="line">        bean.setTypeAliasesPackage(<span class="string">"com.freud.test.springboot.mapper.user"</span>);</span><br><span class="line">        <span class="keyword">return</span> bean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">jtaUserSqlSessionTemplate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @Qualifier(<span class="string">"jtaUserSqlSessionFactory"</span>)</span> SqlSessionFactory sqlSessionFactory) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="表与数据初始化"><a href="#表与数据初始化" class="headerlink" title="表与数据初始化"></a>表与数据初始化</h1><h2 id="使用-Hibernate-初始化"><a href="#使用-Hibernate-初始化" class="headerlink" title="使用 Hibernate 初始化"></a>使用 Hibernate 初始化</h2><p>可以显式设置 <code>spring.jpa.hibernate.ddl-auto</code> ，标准的Hibernate属性值有 <code>none</code> ， <code>validate</code> ， <code>update</code> ， <code>create</code> ， <code>create-drop</code> 。Spring Boot根据数据库是否为内嵌数据库来选择相应的默认值，如果是内嵌型的则默认值为 <code>create-drop</code> ，否则为 <code>none</code> 。通过查看 <code>Connection</code> 类型可以检查是否为内嵌型数据库，<code>hsqldb</code>，<code>h2</code>和<code>derby</code>是内嵌的，其他都不是。当从内存数据库迁移到一个真正的数据库时，需要当心，在新的平台中不能对数据库表和数据是否存在进行臆断，也需要显式设置 <code>ddl-auto</code> ，或使用其他机制初始化数据库。</p>
<blockquote>
<p>可以通过启用<code>org.hibernate.SQL</code> 来输出Schema的创建过程。当<a href="http://docs.spring.io/spring-boot/docs/1.5.4.RELEASE/reference/htmlsingle/#boot-features-logging-console-output" rel="external nofollow noopener noreferrer" target="_blank">DEBUG MODE</a>被开启的时候，这个功能就已经被自动开启了。</p>
</blockquote>
<p>此外，启动时处于classpath根目录下的 <code>import.sql</code> 文件会被执行(前提是<code>ddl-auto</code>属性被设置为 <code>create</code> 或 <code>create-drop</code>)。这在demos或测试时很有用，但在生产环境中可能不期望这样。这是Hibernate的特性，和Spring没有一点关系。</p>
<h2 id="使用-Spring-JDBC-初始化"><a href="#使用-Spring-JDBC-初始化" class="headerlink" title="使用 Spring JDBC 初始化"></a>使用 Spring JDBC 初始化</h2><p>指定初始化脚本位置: </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">org.h2.Driver</span></span><br><span class="line">    <span class="attr">schema:</span> <span class="string">classpath:db/schema-h2.sql</span></span><br><span class="line">    <span class="attr">data:</span> <span class="string">classpath:db/data-h2.sql</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:h2:mem:test</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">test</span></span><br><span class="line">    <span class="attr">initialization-mode:</span> <span class="string">always</span> <span class="comment"># 默认为 embedded</span></span><br></pre></td></tr></table></figure>
<p>不能与Hibernate的创建表功能一起开启, 否则会报错.</p>
<h1 id="运行时SQL监控"><a href="#运行时SQL监控" class="headerlink" title="运行时SQL监控"></a>运行时SQL监控</h1><blockquote>
<p>虽然一些开源框架会自带SQL打印, 但都需要各自配置, 但我们可以通过第三方框架比如p6spy以及log4jdbc做到驱动级别拦截.</p>
</blockquote>
<h2 id="p6spy"><a href="#p6spy" class="headerlink" title="p6spy"></a>p6spy</h2><blockquote>
<p><strong><em><a href="https://p6spy.readthedocs.io" rel="external nofollow noopener noreferrer" target="_blank">https://p6spy.readthedocs.io</a></em></strong></p>
</blockquote>
<p>添加依赖:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>p6spy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>p6spy<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>应用<code>P6Spy</code>只需要</p>
<ul>
<li>1.替换你的<code>JDBC Driver</code>为<code>com.p6spy.engine.spy.P6SpyDriver</code></li>
<li>2.修改<code>JDBC Url</code>为<code>jdbc:p6spy:xxxx</code></li>
<li>3.配置<code>spy.properties</code></li>
</ul>
<p>修改<code>application.yml</code>文件,替换<code>jdbc driver</code>和<code>url</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据源</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:p6spy:mysql://127.0.0.1:3306/jpa_test?useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.p6spy.engine.spy.P6SpyDriver</span></span><br></pre></td></tr></table></figure>
<p>配置<code>spy.properties</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.log=com.p6spy.engine.logging.P6LogFactory,com.p6spy.engine.outage.P6OutageFactory</span><br><span class="line"># 自定义日志打印</span><br><span class="line">logMessageFormat=com.yangbingdong.springbootdatajpa.util.sqlformat.PrettySqlMultiLineFormat</span><br><span class="line"># 使用日志系统记录sql</span><br><span class="line">appender=com.p6spy.engine.spy.appender.Slf4JLogger</span><br><span class="line">## 配置记录Log例外</span><br><span class="line">excludecategories=info,debug,result,batc,resultset</span><br><span class="line"># 设置使用p6spy driver来做代理</span><br><span class="line">deregisterdrivers=true</span><br><span class="line"># 日期格式</span><br><span class="line">dateformat=yyyy-MM-dd HH:mm:ss</span><br><span class="line"># 实际驱动</span><br><span class="line">driverlist=com.mysql.jdbc.Driver</span><br><span class="line"># 是否开启慢SQL记录</span><br><span class="line">outagedetection=true</span><br><span class="line"># 慢SQL记录标准 秒</span><br><span class="line">outagedetectioninterval=2</span><br></pre></td></tr></table></figure>
<p>自定义日志打印 , 这里有两种方式</p>
<p>一、实现<code>MessageFormattingStrategy</code>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrettySqlMultiLineFormat</span> <span class="keyword">implements</span> <span class="title">MessageFormattingStrategy</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Formatter FORMATTER = <span class="keyword">new</span> BasicFormatterImpl();</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">formatMessage</span><span class="params">(<span class="keyword">int</span> connectionId, String now, <span class="keyword">long</span> elapsed, String category, String prepared, String sql)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"#"</span> + now + <span class="string">" | took "</span> + elapsed + <span class="string">"ms | "</span> + category + <span class="string">" | connection "</span> + connectionId + <span class="string">" | "</span> + FORMATTER.format(sql) +<span class="string">";"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二、在 <code>spy.properties</code> 中指定</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 自定义日志打印</span><br><span class="line">logMessageFormat=com.p6spy.engine.spy.appender.CustomLineFormat</span><br><span class="line">customLogMessageFormat=%(currentTime) | SQL耗时： %(executionTime) ms | 连接信息： %(category)-%(connectionId) | 执行语句： %(sql)</span><br></pre></td></tr></table></figure>
<p>附录: <code>spy.properties</code>详细说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 指定应用的日志拦截模块,默认为com.p6spy.engine.spy.P6SpyFactory </span><br><span class="line">#modulelist=com.p6spy.engine.spy.P6SpyFactory,com.p6spy.engine.logging.P6LogFactory,com.p6spy.engine.outage.P6OutageFactory</span><br><span class="line"></span><br><span class="line"># 真实JDBC driver , 多个以 逗号 分割 默认为空</span><br><span class="line">#driverlist=</span><br><span class="line"></span><br><span class="line"># 是否自动刷新 默认 flase</span><br><span class="line">#autoflush=false</span><br><span class="line"></span><br><span class="line"># 配置SimpleDateFormat日期格式 默认为空</span><br><span class="line">#dateformat=</span><br><span class="line"></span><br><span class="line"># 打印堆栈跟踪信息 默认flase</span><br><span class="line">#stacktrace=false</span><br><span class="line"></span><br><span class="line"># 如果 stacktrace=true，则可以指定具体的类名来进行过滤。</span><br><span class="line">#stacktraceclass=</span><br><span class="line"></span><br><span class="line"># 监测属性配置文件是否进行重新加载</span><br><span class="line">#reloadproperties=false</span><br><span class="line"></span><br><span class="line"># 属性配置文件重新加载的时间间隔，单位:秒 默认60s</span><br><span class="line">#reloadpropertiesinterval=60</span><br><span class="line"></span><br><span class="line"># 指定 Log 的 appender，取值：</span><br><span class="line">#appender=com.p6spy.engine.spy.appender.Slf4JLogger</span><br><span class="line">#appender=com.p6spy.engine.spy.appender.StdoutLogger</span><br><span class="line">#appender=com.p6spy.engine.spy.appender.FileLogger</span><br><span class="line"></span><br><span class="line"># 指定 Log 的文件名 默认 spy.log</span><br><span class="line">#logfile=spy.log</span><br><span class="line"></span><br><span class="line"># 指定是否每次是增加 Log，设置为 false 则每次都会先进行清空 默认true</span><br><span class="line">#append=true</span><br><span class="line"></span><br><span class="line"># 指定日志输出样式  默认为com.p6spy.engine.spy.appender.SingleLineFormat , 单行输出 不格式化语句</span><br><span class="line">#logMessageFormat=com.p6spy.engine.spy.appender.SingleLineFormat</span><br><span class="line"># 也可以采用  com.p6spy.engine.spy.appender.CustomLineFormat 来自定义输出样式, 默认值是%(currentTime)|%(executionTime)|%(category)|connection%(connectionId)|%(sqlSingleLine)</span><br><span class="line"># 可用的变量为:</span><br><span class="line">#   %(connectionId)            connection id</span><br><span class="line">#   %(currentTime)             当前时间</span><br><span class="line">#   %(executionTime)           执行耗时</span><br><span class="line">#   %(category)                执行分组</span><br><span class="line">#   %(effectiveSql)            提交的SQL 换行</span><br><span class="line">#   %(effectiveSqlSingleLine)  提交的SQL 不换行显示</span><br><span class="line">#   %(sql)                     执行的真实SQL语句，已替换占位</span><br><span class="line">#   %(sqlSingleLine)           执行的真实SQL语句，已替换占位 不换行显示</span><br><span class="line">#customLogMessageFormat=%(currentTime)|%(executionTime)|%(category)|connection%(connectionId)|%(sqlSingleLine)</span><br><span class="line"></span><br><span class="line"># date类型字段记录日志时使用的日期格式 默认dd-MMM-yy</span><br><span class="line">#databaseDialectDateFormat=dd-MMM-yy</span><br><span class="line"></span><br><span class="line"># boolean类型字段记录日志时使用的日期格式 默认boolean 可选值numeric</span><br><span class="line">#databaseDialectBooleanFormat=boolean</span><br><span class="line"></span><br><span class="line"># 是否通过jmx暴露属性 默认true</span><br><span class="line">#jmx=true</span><br><span class="line"></span><br><span class="line"># 如果jmx设置为true 指定通过jmx暴露属性时的前缀 默认为空</span><br><span class="line"># com.p6spy(.&lt;jmxPrefix&gt;)?:name=&lt;optionsClassName&gt;</span><br><span class="line">#jmxPrefix=</span><br><span class="line"></span><br><span class="line"># 是否显示纳秒 默认false</span><br><span class="line">#useNanoTime=false</span><br><span class="line"></span><br><span class="line"># 实际数据源 JNDI</span><br><span class="line">#realdatasource=/RealMySqlDS</span><br><span class="line"># 实际数据源 datasource class</span><br><span class="line">#realdatasourceclass=com.mysql.jdbc.jdbc2.optional.MysqlDataSource</span><br><span class="line"></span><br><span class="line"># 实际数据源所携带的配置参数 以 k=v 方式指定 以 分号 分割</span><br><span class="line">#realdatasourceproperties=port;3306,serverName;myhost,databaseName;jbossdb,foo;bar</span><br><span class="line"></span><br><span class="line"># jndi数据源配置 </span><br><span class="line"># 设置 JNDI 数据源的 NamingContextFactory。 </span><br><span class="line">#jndicontextfactory=org.jnp.interfaces.NamingContextFactory</span><br><span class="line"># 设置 JNDI 数据源的提供者的 URL。 </span><br><span class="line">#jndicontextproviderurl=localhost:1099</span><br><span class="line"># 设置 JNDI 数据源的一些定制信息，以分号分隔。 </span><br><span class="line">#jndicontextcustom=java.naming.factory.url.pkgs;org.jboss.naming:org.jnp.interfaces</span><br><span class="line"></span><br><span class="line"># 是否开启日志过滤 默认false， 这项配置是否生效前提是配置了 include/exclude/sqlexpression</span><br><span class="line">#filter=false</span><br><span class="line"></span><br><span class="line"># 过滤 Log 时所包含的表名列表，以逗号分隔 默认为空</span><br><span class="line">#include=</span><br><span class="line"># 过滤 Log 时所排除的表名列表，以逗号分隔 默认为空</span><br><span class="line">#exclude=</span><br><span class="line"></span><br><span class="line"># 过滤 Log 时的 SQL 正则表达式名称  默认为空</span><br><span class="line">#sqlexpression=</span><br><span class="line"></span><br><span class="line">#显示指定过滤 Log 时排队的分类列表，取值: error, info, batch, debug, statement,</span><br><span class="line">#commit, rollback, result and resultset are valid values</span><br><span class="line"># (默认 info,debug,result,resultset,batch)</span><br><span class="line">#excludecategories=info,debug,result,resultset,batch</span><br><span class="line"></span><br><span class="line"># 是否过滤二进制字段</span><br><span class="line"># (default is false)</span><br><span class="line">#excludebinary=false</span><br><span class="line"></span><br><span class="line"># P6Log 模块执行时间设置，整数值 (以毫秒为单位)，只有当超过这个时间才进行记录 Log。 默认为0</span><br><span class="line">#executionThreshold=</span><br><span class="line"></span><br><span class="line"># P6Outage 模块是否记录较长时间运行的语句 默认false</span><br><span class="line"># outagedetection=true|false</span><br><span class="line"># P6Outage 模块执行时间设置，整数值 （以秒为单位)），只有当超过这个时间才进行记录 Log。 默认30s</span><br><span class="line"># outagedetectioninterval=integer time (seconds)</span><br></pre></td></tr></table></figure>
<h2 id="log4jdbc"><a href="#log4jdbc" class="headerlink" title="log4jdbc"></a>log4jdbc</h2><p>添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.googlecode.log4jdbc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>MySQL数据源配置换成：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:log4jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">net.sf.log4jdbc.DriverSpy</span></span><br></pre></td></tr></table></figure>
<h1 id="Spring-事务监控"><a href="#Spring-事务监控" class="headerlink" title="Spring 事务监控"></a>Spring 事务监控</h1><p>某些特殊的场景下, 我们需要在事务开启时, 完成时做一些事情, 比如释放一些资源. </p>
<h2 id="方式一-TransactionSynchronization"><a href="#方式一-TransactionSynchronization" class="headerlink" title="方式一: TransactionSynchronization"></a>方式一: TransactionSynchronization</h2><p>Spring事务的核心部分在 <code>TransactionInterceptor#invoke</code>, <code>TransactionInterceptor</code> 继承了 <code>TransactionAspectSupport</code>, <code>TransactionAspectSupport</code> 使用 <code>AbstractPlatformTransactionManager</code> 的实现类操作事务. <code>AbstractPlatformTransactionManager</code> 中的 <code>processCommit</code> 以及  <code>processRollback</code> 中的几个节点会调用到 <code>TransactionSynchronizationUtils</code> 中的一些方法: </p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-orm/spring-tx01.png" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-orm/spring-tx02.png" alt></p>
<p>这些被trigger的类就是 <code>TransactionSynchronization</code> 的实现类.</p>
<p><code>TransactionSynchronizationUtils</code> 通过 <code>TransactionSynchronizationManager#getSynchronizations</code> 来获取 <code>TransactionSynchronization</code> 列表, 而 <code>TransactionSynchronizationManager</code> 是通过 <code>ThreadLocal</code> 来管理这些类的:</p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-orm/spring-tx03.png" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-orm/spring-tx04.png" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-orm/spring-tx05.png" alt></p>
<p>示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTransactionSynchronization</span> <span class="keyword">extends</span> <span class="title">TransactionSynchronizationAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">suspend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		log.info(<span class="string">"#################### suspend"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		log.info(<span class="string">"#################### resume"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		log.info(<span class="string">"#################### flush"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeCommit</span><span class="params">(<span class="keyword">boolean</span> readOnly)</span> </span>&#123;</span><br><span class="line">		log.info(<span class="string">"#################### beforeCommit"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		log.info(<span class="string">"#################### beforeCompletion"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		log.info(<span class="string">"#################### afterCommit"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(<span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">		log.info(<span class="string">"#################### afterCompletion"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这个类什么时候注册进 <code>TransactionSynchronizationManager</code> 呢? 答案是每次事务开启的时候, 因为这个是使用 <code>ThreadLocal</code> 保存的, 每次事务过后会被清空掉. 我们可以使用切面, 将打有 <code>@Transactional</code> 注解的方法增强一下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTransactionAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> TestTransactionSynchronization testTransactionSynchronization;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Before</span>(value = <span class="string">"@annotation(tx)"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterReturning</span><span class="params">(Transactional tx)</span> </span>&#123;</span><br><span class="line">		TransactionSynchronizationManager.registerSynchronization(testTransactionSynchronization);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就行了~</p>
<h2 id="方式二-继承DataSourceTransactionManager"><a href="#方式二-继承DataSourceTransactionManager" class="headerlink" title="方式二: 继承DataSourceTransactionManager"></a>方式二: 继承DataSourceTransactionManager</h2><p>上面的方法有一个缺点, 不能在事务开启时做一些事情, 可以通过继承 <code>DataSourceTransactionManager</code> 来实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomTransactionManager</span> <span class="keyword">extends</span> <span class="title">DataSourceTransactionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5831041749053502702L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CustomTransactionManager</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(dataSource);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doCleanupAfterCompletion</span><span class="params">(Object transaction)</span> </span>&#123;</span><br><span class="line">		log.info(<span class="string">"#################### doCleanupAfterCompletion"</span>);</span><br><span class="line">		<span class="keyword">super</span>.doCleanupAfterCompletion(transaction);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBegin</span><span class="params">(Object transaction, TransactionDefinition definition)</span> </span>&#123;</span><br><span class="line">		log.info(<span class="string">"#################### doBegin"</span>);</span><br><span class="line">		<span class="keyword">super</span>.doBegin(transaction, definition);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123;PlatformTransactionManager<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">@<span class="title">EnableConfigurationProperties</span>(<span class="title">DataSourceProperties</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">CustomDataSourceTransactionManagerAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> DataSourceTransactionManager <span class="title">transactionManager</span><span class="params">(DataSource dataSource,</span></span></span><br><span class="line"><span class="function"><span class="params">														   ObjectProvider&lt;TransactionManagerCustomizers&gt; transactionManagerCustomizers)</span> </span>&#123;</span><br><span class="line">		DataSourceTransactionManager transactionManager = <span class="keyword">new</span> CustomTransactionManager(dataSource);</span><br><span class="line">		transactionManagerCustomizers.ifAvailable(</span><br><span class="line">				(customizers) -&gt; customizers.customize(transactionManager));</span><br><span class="line">		<span class="keyword">return</span> transactionManager;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方式三-TransactionalEventListener"><a href="#方式三-TransactionalEventListener" class="headerlink" title="方式三: @TransactionalEventListener"></a>方式三: @TransactionalEventListener</h2><p>使用 <code>@TransactionalEventListener</code> 可以在事务的某些阶段处理 Event</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TransactionalEventListener &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定当前标注方法处理事务的类型</span></span><br><span class="line">	<span class="function">TransactionPhase <span class="title">phase</span><span class="params">()</span> <span class="keyword">default</span> TransactionPhase.AFTER_COMMIT</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于指定当前方法如果没有事务，是否执行相应的事务事件监听器</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">fallbackExecution</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与classes属性一样，指定了当前事件传入的参数类型，指定了这个参数之后就可以在监听方法上</span></span><br><span class="line">    <span class="comment">// 直接什么一个这个参数了</span></span><br><span class="line">	<span class="meta">@AliasFor</span>(annotation = EventListener<span class="class">.<span class="keyword">class</span>, <span class="title">attribute</span> </span>= <span class="string">"classes"</span>)</span><br><span class="line">	Class&lt;?&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 作用于value属性一样，用于指定当前监听方法的参数类型</span></span><br><span class="line">	<span class="meta">@AliasFor</span>(annotation = EventListener<span class="class">.<span class="keyword">class</span>, <span class="title">attribute</span> </span>= <span class="string">"classes"</span>)</span><br><span class="line">	Class&lt;?&gt;[] classes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个属性使用Spring Expression Language对目标类和方法进行匹配，对于不匹配的方法将会过滤掉</span></span><br><span class="line">	<span class="function">String <span class="title">condition</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> TransactionPhase &#123;</span><br><span class="line">    <span class="comment">// 指定目标方法在事务commit之前执行</span></span><br><span class="line">	BEFORE_COMMIT,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定目标方法在事务commit之后执行</span></span><br><span class="line">	AFTER_COMMIT,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定目标方法在事务rollback之后执行</span></span><br><span class="line">	AFTER_ROLLBACK,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指定目标方法在事务完成时执行，这里的完成是指无论事务是成功提交还是事务回滚了</span></span><br><span class="line">	AFTER_COMPLETION</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserTransactionEventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@TransactionalEventListener</span>(phase = TransactionPhase.BEFORE_COMMIT)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeCommit</span><span class="params">(PayloadApplicationEvent&lt;User&gt; event)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"before commit, id: "</span> + event.getPayload().getId());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@TransactionalEventListener</span>(phase = TransactionPhase.AFTER_COMMIT)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCommit</span><span class="params">(PayloadApplicationEvent&lt;User&gt; event)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"after commit, id: "</span> + event.getPayload().getId());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@TransactionalEventListener</span>(phase = TransactionPhase.AFTER_COMPLETION)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(PayloadApplicationEvent&lt;User&gt; event)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"after completion, id: "</span> + event.getPayload().getId());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@TransactionalEventListener</span>(phase = TransactionPhase.AFTER_ROLLBACK)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterRollback</span><span class="params">(PayloadApplicationEvent&lt;User&gt; event)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"after rollback, id: "</span> + event.getPayload().getId());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>它的原理也是利用了方式一中的 <code>TransactionSynchronization</code>. </li>
<li>贴上 <code>@TransactionalEventListener</code> 注解的方法会被 Spring 使用 <code>TransactionalEventListenerFactory</code> 包装成 <code>ApplicationListenerMethodTransactionalAdapter</code></li>
<li><code>ApplicationListenerMethodTransactionalAdapter</code> 中进一步将监听方法封装成 <code>TransactionSynchronizationEventAdapter</code>, 再通过 <code>TransactionSynchronizationManager.registerSynchronization</code> 进行注册</li>
</ul>
<h2 id="判断当前方法是否在事务环境中"><a href="#判断当前方法是否在事务环境中" class="headerlink" title="判断当前方法是否在事务环境中"></a>判断当前方法是否在事务环境中</h2><p>通过上面的 <code>TransactionSynchronizationManager</code> 可以发现定义了很多 <code>ThreadLocal</code>:</p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-orm/spring-tx05.png" alt></p>
<p>可以看到变量中有一个 <code>actualTransactionActive</code> 以及 <code>currentTransactionReadOnly</code>, 通过这两个变量可以判断当前是否在事务当中, Spring很多代码中也是通过这个来判断的, 比如 <code>RedisConnectionUtils#isActualNonReadonlyTransactionActive</code> :</p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-orm/spring-tx06.png" alt></p>
<h1 id="对象映射"><a href="#对象映射" class="headerlink" title="对象映射"></a>对象映射</h1><blockquote>
<p><strong><em><a href="https://www.baeldung.com/java-performance-mapping-frameworks" rel="external nofollow noopener noreferrer" target="_blank">https://www.baeldung.com/java-performance-mapping-frameworks</a></em></strong></p>
</blockquote>
<h1 id="ORM-对比"><a href="#ORM-对比" class="headerlink" title="ORM 对比"></a>ORM 对比</h1><ul>
<li>MyBatis：MyBatis 本是 Apache 的一个开源项目 iBatis，2010 年这个项目由 Apache Software Foundation 迁移到了 Google Code，并且改名为 MyBatis，其<strong>着力于 POJO 与 SQL 之间的映射关系</strong>，可以进行更为细致的 SQL，使用起来十分灵活、上手简单、容易掌握，所以深受开发者的喜欢，目前市场占有率最高，比较适合互联应用公司的 API 场景; 缺点就是工作量比较大，需要各种配置文件的配置和 SQL 语句。</li>
<li>Hibernate：Hibernate 是一个开放源代码的对象关系映射框架，它对 JDBC 进行了非常轻量级的对象封装，使得 Java 程序员可以随心所欲的使用对象编程思维来操纵数据库，并且对象有自己的生命周期，<strong>着力点对象与对象之间关系</strong>，有自己的 HQL 查询语言，所以数据库移植性很好。Hibernate 是完备的 ORM 框架，是符合 JPA 规范的，有自己的缓存机制，上手来说比较难，比较适合企业级的应用系统开发。</li>
<li>Spring Data JPA：可以理解为 JPA 规范的再次封装抽象，底层还是使用了 Hibernate 的 JPA 技术实现，引用 JPQL(Java Persistence Query Language)查询语言，属于 Spring 的整个生态体系的一部分。由于 Spring Boot 和 Spring Cloud 在市场上的流行，Spring Data JPA 也逐渐进入大家的视野，他们有机的整体，使用起来比较方便，加快了开发的效率，使开发者不需要关系和配置更多的东西，完全可以沉浸在 Spring 的完整生态标准的实现下，上手简单、开发效率高，又对对象的支持比较好，又有很大的灵活性，市场的认可度越来越高。</li>
</ul>
<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><p>对于MyBatis, 现已有很优秀的二次封装框架, 比如 <strong><em><a href="https://github.com/abel533/Mapper" rel="external nofollow noopener noreferrer" target="_blank">Mapper4</a></em></strong>, <strong><em><a href="https://github.com/baomidou/mybatis-plus" rel="external nofollow noopener noreferrer" target="_blank">MtBatis-Plus</a></em></strong> 等.</p>
<h1 id="Spring-Data-JPA"><a href="#Spring-Data-JPA" class="headerlink" title="Spring Data JPA"></a>Spring Data JPA</h1><blockquote>
<p>请看 <strong><em><a href="/2019/spring-boot-data-jpa-learning">Spring Data JPA 拾遗</a></em></strong></p>
</blockquote>
]]></content><categories><category>Programming</category><category>Java</category><category>Spring Boot</category></categories><tags><tag>Java</tag><tag>Spring Boot</tag></tags></entry><entry><title>VPS自搭建Ngrok内网穿透服务</title><url>/2017/self-hosted-build-ngrok-server/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/ngrok.png" alt></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>Ngrok可以干嘛？我们经常会有 “把本机开发中的 web 项目给朋友看一下” 或 “测试一下支付宝、微信的支付功能” 这种临时需求, 为此<strong>专门</strong>购买个域名然后在 VPS或云主机 上<strong>部署一遍</strong>就有点太<strong>浪费</strong>了. 那么这时候, <strong>Ngrok</strong>就是个很好的东西, 它可以实现我们的这种需求. 而且 Ngrok 官网本身还提供了公共服务, 只需要注册一个帐号, 运行它的客户端, 就可以快速把内网映射出去. 不过这么好的服务, 没多久就被<strong>墙</strong>了~幸好Ngrok是<strong>开源</strong>的, 那么我们可以自己搭建一个Ngrok！</p>
</blockquote>
<a id="more"></a>
<h1 id="域名泛解析"><a href="#域名泛解析" class="headerlink" title="域名泛解析"></a>域名泛解析</h1><p>因为内网穿透需要用到多级域名, 这里, 博主的这个域名是在<strong><em><a href="https://www.namesilo.com/" rel="external nofollow noopener noreferrer" target="_blank">Namesilo</a></em></strong>购买的, 然后转到DNSPod解析:<br><img src="https://cdn.yangbingdong.com/DNSPod.png" alt><br>如图所示, 我搞买的域名是<code>yangbingdong.com</code>,将<code>ngrok.yangbingdong.com</code>通过<code>A</code>记录解析导VPS的ip地址, 再将<code>*.ngrok.yangbingdong.com</code>通过<code>CNAME</code>解析导<code>ngrok.yangbingdong.com</code>, 完成泛解析. </p>
<h1 id="服务端安装"><a href="#服务端安装" class="headerlink" title="服务端安装"></a>服务端安装</h1><h2 id="安装GO环境"><a href="#安装GO环境" class="headerlink" title="安装GO环境"></a>安装GO环境</h2><blockquote>
<p>这里博主选择通过下载最新版解压安装. </p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get -y install build-essential mercurial git</span><br><span class="line">wget https://storage.googleapis.com/golang/go1.8.1.linux-amd64.tar.gz</span><br><span class="line">tar -C /usr/local -xzf go1.8.1.linux-amd64.tar.gz</span><br><span class="line">mkdir $HOME/go</span><br><span class="line">echo 'export GOROOT=/usr/local/go' &gt;&gt; /etc/profile.d/go.sh</span><br><span class="line">echo 'export GOPATH=$HOME/go' &gt;&gt; /etc/profile.d/go.sh</span><br><span class="line">echo 'export PATH=$PATH:$GOROOT/bin:$GOPATH/bin' &gt;&gt; /etc/profile.d/go.sh</span><br><span class="line">source /etc/profile.d/go.sh</span><br></pre></td></tr></table></figure>
<h2 id="安装Ngrok"><a href="#安装Ngrok" class="headerlink" title="安装Ngrok"></a>安装Ngrok</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/src/</span><br><span class="line">git clone https://github.com/tutumcloud/ngrok.git ngrok</span><br><span class="line">export GOPATH=/usr/local/src/ngrok/</span><br></pre></td></tr></table></figure>
<p>生成自签名SSL证书, ngrok为ssl加密连接:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ngrok</span><br><span class="line">NGROK_DOMAIN="ngrok.yangbingdong.com"</span><br><span class="line">openssl genrsa -out rootCA.key 2048</span><br><span class="line">openssl req -x509 -new -nodes -key rootCA.key -subj "/CN=$NGROK_DOMAIN" -days 5000 -out rootCA.pem</span><br><span class="line">openssl genrsa -out device.key 2048</span><br><span class="line">openssl req -new -key device.key -subj "/CN=$NGROK_DOMAIN" -out device.csr</span><br><span class="line">openssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000</span><br><span class="line">cp rootCA.pem assets/client/tls/ngrokroot.crt</span><br><span class="line">cp device.crt assets/server/tls/snakeoil.crt </span><br><span class="line">cp device.key assets/server/tls/snakeoil.key</span><br><span class="line">GOOS=linux GOARCH=amd64</span><br><span class="line">make clean</span><br><span class="line">make release-server release-client</span><br></pre></td></tr></table></figure></p>
<p>注意: <strong>上面的<code>ngrok.yangbingdong.com</code>换成自己的域名</strong>. </p>
<ul>
<li>如果是32位系统,<code>GOARCH=386</code>; 如果是64为系统, <code>GOARCH=amd64</code></li>
<li>如果要编译linux,<code>GOOS=linux</code>;如果要编译window,<code>GOOS=windows</code></li>
</ul>
<h2 id="启动server"><a href="#启动server" class="headerlink" title="启动server"></a>启动server</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/src/ngrok/bin &amp;&amp; ./ngrokd -domain="ngrok.yangbingdong.com" -httpAddr=":8002" -httpsAddr=":8003" -tunnelAddr=":4000"</span><br></pre></td></tr></table></figure>
<p><strong><code>ngrok.yangbingdong.com</code>换成自己的域名</strong>. 其他端口可自己配置.<br>顺利的话, 可以正常编译, 在<code>bin</code>下面可以看到「ngrokd」和「ngrok」, 其中「ngrokd」是服务端执行程序, 「ngrok」是客户端执行程序<br><img src="https://cdn.yangbingdong.com/ngrok-server-startup.png" alt></p>
<h2 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行:"></a>后台运行:</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/src/ngrok/bin &amp;&amp; nohup ./ngrokd -domain="ngrok.yangbingdong.com" -httpAddr=":8002" -httpsAddr=":8003" -tunnelAddr=":4000"  &gt; /dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install screen</span><br><span class="line">screen -S 任意名字（例如: keepngork）</span><br><span class="line">然后运行ngrok启动命令</span><br><span class="line">最后按快捷键</span><br><span class="line">ctrl+A+D</span><br><span class="line">既可以保持ngrok后台运行</span><br></pre></td></tr></table></figure>
<h2 id="设置开机启动"><a href="#设置开机启动" class="headerlink" title="设置开机启动"></a>设置开机启动</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/init.d/ngrok_start:</span><br><span class="line">cd /usr/local/src/ngrok/bin</span><br><span class="line">./ngrokd -domain="ngrok.yangbingdong.com" -httpAddr=":8002" -httpsAddr=":8003" -tunnelAddr=":4000"</span><br><span class="line"></span><br><span class="line">chmod 755 /etc/init.d/ngrok_start</span><br></pre></td></tr></table></figure>
<h1 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h1><h2 id="下载客户端"><a href="#下载客户端" class="headerlink" title="下载客户端"></a>下载客户端</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -P 26850 root@12.34.56.78:/usr/local/src/ngrok/bin/ngrok ~/</span><br></pre></td></tr></table></figure>
<p><strong>将<code>12.34.56.78</code>换成自己的VPS ip</strong>. </p>
<h2 id="启动客户端"><a href="#启动客户端" class="headerlink" title="启动客户端"></a>启动客户端</h2><p>写一个简单的配置文件, 随意命名如 ngrok.cfg:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server_addr: ngrok.yangbingdong.com:4000</span><br><span class="line">trust_host_root_certs: false</span><br></pre></td></tr></table></figure></p>
<p>然后启动:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./ngrok -subdomain ybd -config=ngrok.cfg 8080</span><br></pre></td></tr></table></figure></p>
<p>其中<code>ybd</code>是自定义的域名前缀, <code>ngrok.cfg</code>是上面创建的配置文件, <code>8080</code>是本地需要映射到外网的端口.<br>没有意外的话访问<code>ybd.ngrok.yangbingdong.com:8002</code>就会映射到本机的<code>8080</code>端口了.<br><img src="https://cdn.yangbingdong.com/ngrok-client-startup01.png" alt></p>
<p>控制台: </p>
<p>就是上图的<code>Web Interface</code>, 通过这个界面可以看到远端转发过来的 http 详情, 包括完整的 request/response 信息, 相当于附带了一个抓包工具. </p>
<p>另外, Ngrok支持多种协议, 启动的时候可以指定通过<code>-proto</code>指定协议, 例如: </p>
<p><strong>http协议</strong>: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./ngrok -subdomain ybd -config=ngrok.cfg -proto=http 8080</span><br></pre></td></tr></table></figure>
<p><strong>tcp协议</strong>: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./ngrok -subdomain ybd -config=ngrok.cfg -proto=tcp 8080</span><br></pre></td></tr></table></figure>
<p>应该会看到: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ngrok                                               (Ctrl+C to quit)</span><br><span class="line"></span><br><span class="line">Tunnel Status                 online</span><br><span class="line">Version                       1.7/1.7</span><br><span class="line">Forwarding                    tcp://ybd.ngrok.yangbingdong.com:8002-&gt; 127.0.0.1:8080</span><br><span class="line">Web Interface                 127.0.0.1:4040</span><br><span class="line"><span class="meta">#</span><span class="bash"> Conn                        0</span></span><br><span class="line">Avg Conn Time                 0.00ms</span><br></pre></td></tr></table></figure>
<h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><p>在ngrok目录下执行如下命令, 编译ngrokd<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ make release-server</span><br><span class="line"></span><br><span class="line">出现如下错误: </span><br><span class="line">GOOS=&quot;&quot; GOARCH=&quot;&quot; go get github.com/jteeuwen/go-bindata/go-bindata</span><br><span class="line">bin/go-bindata -nomemcopy -pkg=assets -tags=release \</span><br><span class="line">        -debug=false \</span><br><span class="line">        -o=src/ngrok/client/assets/assets_release.go \</span><br><span class="line">        assets/client/…</span><br><span class="line">make: bin/go-bindata: Command not found</span><br><span class="line">make: *** [client-assets] Error 127</span><br><span class="line">go-bindata被安装到了$GOBIN下了, go编译器找不到了. 修正方法是将$GOBIN/go-bindata拷贝到当前ngrok/bin下. </span><br><span class="line"></span><br><span class="line">$cp /home/ubuntu/.bin/go14/bin/go-bindata ./bin</span><br></pre></td></tr></table></figure></p>
<h1 id="遇到的问题-source与"><a href="#遇到的问题-source与" class="headerlink" title="遇到的问题: source与./"></a>遇到的问题: source与./</h1><p>写了一个Ngrok的<strong><em><a href="https://github.com/masteranthoneyd/about-shell/blob/master/ngrok-installation.sh" rel="external nofollow noopener noreferrer" target="_blank">安装脚本</a></em></strong>, 然后<code>chmod +x ngrok-installation.sh</code>赋权, 再<code>./ngrok-installation.sh</code>执行.<br>但是遇到了一个奇怪的问题: 在脚本里面设置了环境变量并source让其生效, 然而出现的结果是由于<strong>没有加载</strong>到环境变量导致找不到命令, 百思不得解, Google了一把, 发现了原因: </p>
<blockquote>
<p><code>source</code>命令与<code>shell scripts</code>的区别是:<br>我们在test.sh设置了AA环境变量, 它只在fork出来的这个子shell中生效, 子shell只能继承父shell的环境变量, 而不能修改父shell的环境变量, 所以test.sh结束后, 父进程的环境就覆盖回去.<br>source在当前bash环境下执行命令, 而scripts是启动一个子shell来执行命令. 这样如果把设置环境变量（或alias等等）的命令写进scripts中, 就只会影响子shell,无法改变当前的BASH,所以通过文件（命令列）设置环境变量时, 要用source 命令. </p>
</blockquote>
<p>然后直接<code>source ngrok-installation.sh</code>, 安装成功！</p>
<h1 id="Docker-搭建-Ngrok"><a href="#Docker-搭建-Ngrok" class="headerlink" title="Docker 搭建 Ngrok"></a>Docker 搭建 Ngrok</h1><blockquote>
<p>安装Docker请看<strong><em><a href="/2017/docker-learning/">这里</a></em></strong></p>
</blockquote>
<h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/hteen/docker-ngrok.git</span><br><span class="line">cd docker-ngrok</span><br><span class="line">docker build -t hteen/ngrok .</span><br></pre></td></tr></table></figure>
<h2 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -idt --name ngrok-server \</span><br><span class="line">-p 8082:80 -p 4432:443 -p 4443:4443 \</span><br><span class="line">-v /root/docker/ngrok/data:/myfiles \</span><br><span class="line">-e DOMAIN=&apos;ngrok.yangbingdong.com&apos; hteen/ngrok /bin/sh /server.sh</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-p</code>: 80端口为http端口, 433端口为https端口, 4443端口为tunnel端口</li>
<li><code>-v</code>: 生成的各种配置文件和客户端都在里面</li>
<li><code>-e</code>: 泛化的域名</li>
</ul>
<p>稍等片刻, 会在挂在的目录（<code>/root/docker/ngrok/data</code>）下面生成对应的配置文件以及客户端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin/ngrokd                  服务端</span><br><span class="line">bin/ngrok                   linux客户端</span><br><span class="line">bin/darwin_amd64/ngrok      osx客户端</span><br><span class="line">bin/windows_amd64/ngrok.exe windows客户端</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>: 大概每个星期会产生100M的日志文件.<br>查年docker日志文件位置<code>docker inspect &lt;id&gt; | grep LogPath</code><br>查看大小<code>ls -lh /var/lib/docker/containers/&lt;id&gt;/&lt;id&gt;-json.log</code></p>
<h1 id="自构-Docker-镜像"><a href="#自构-Docker-镜像" class="headerlink" title="自构 Docker 镜像"></a>自构 Docker 镜像</h1><blockquote>
<p> 最好是一台境外的服务器(下载速度快)</p>
</blockquote>
<p><code>Dockerfile</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM golang:1.14.6-alpine</span><br><span class="line">ADD build.sh /</span><br><span class="line">RUN apk add --no-cache git make openssl</span><br><span class="line">RUN git clone https://github.com/inconshreveable/ngrok.git --depth=1 /ngrok</span><br><span class="line">RUN sh /build.sh</span><br><span class="line">EXPOSE 8081</span><br><span class="line">VOLUME [ &quot;/ngrok&quot; ]</span><br><span class="line">CMD [ &quot;/ngrok/bin/ngrokd&quot;]</span><br></pre></td></tr></table></figure>
<p><code>build.sh</code>: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export NGROK_DOMAIN=&quot;xxx.yangbingdong.com&quot;</span><br><span class="line">cd /ngrok/</span><br><span class="line">openssl genrsa -out rootCA.key 2048</span><br><span class="line">openssl req -x509 -new -nodes -key rootCA.key -subj &quot;/CN=$NGROK_DOMAIN&quot; -days 5000 -out rootCA.pem</span><br><span class="line">openssl genrsa -out device.key 2048</span><br><span class="line">openssl req -new -key device.key -subj &quot;/CN=$NGROK_DOMAIN&quot; -out device.csr</span><br><span class="line">openssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000</span><br><span class="line">cp rootCA.pem assets/client/tls/ngrokroot.crt</span><br><span class="line">cp device.crt assets/server/tls/snakeoil.crt</span><br><span class="line">cp device.key assets/server/tls/snakeoil.key</span><br><span class="line"></span><br><span class="line">make release-server</span><br><span class="line">GOOS=linux GOARCH=386 make release-client</span><br><span class="line">GOOS=linux GOARCH=amd64 make release-client</span><br><span class="line">GOOS=windows GOARCH=386 make release-client</span><br><span class="line">GOOS=windows GOARCH=amd64 make release-client</span><br><span class="line">GOOS=darwin GOARCH=386 make release-client</span><br><span class="line">GOOS=darwin GOARCH=amd64 make release-client</span><br><span class="line">GOOS=linux GOARCH=arm make release-client</span><br></pre></td></tr></table></figure>
<p><strong>注意, 需要把上面的 <code>NGROK_DOMAIN</code> 修改为你自己的域名</strong></p>
<p>构建:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t ngrok .</span><br></pre></td></tr></table></figure>
<p>运行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name=ngrok -it  -p 8081:80 -p 8082:8082 -p 4443:4443  -d yangbingdong/ngrok:stable /ngrok/bin/ngrokd -domain=&quot;ngrok.yangbingdong.com&quot; -httpAddr=&quot;:80&quot; -httpsAddr=&quot;:8082&quot; -tunnelAddr=&quot;:4443&quot;</span><br></pre></td></tr></table></figure>
<p>拿到客户端:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker cp ngrok:/ngrok/bin ./</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── darwin_386</span><br><span class="line">│   └── ngrok</span><br><span class="line">├── darwin_amd64</span><br><span class="line">│   └── ngrok</span><br><span class="line">├── go-bindata</span><br><span class="line">├── linux_386</span><br><span class="line">│   └── ngrok</span><br><span class="line">├── linux_arm</span><br><span class="line">│   └── ngrok</span><br><span class="line">├── ngrok</span><br><span class="line">├── ngrokd</span><br><span class="line">├── windows_386</span><br><span class="line">│   └── ngrok.exe</span><br><span class="line">└── windows_amd64</span><br><span class="line">    └── ngrok.exe</span><br></pre></td></tr></table></figure>
<h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">     listen       80;</span><br><span class="line">     server_name  *.ngrok.yangbingdong.com;</span><br><span class="line">     location / &#123;</span><br><span class="line">             proxy_redirect off;</span><br><span class="line">             proxy_set_header Host $http_host:8081; #此处端口要跟 启动服务端 ngrok 时指定的端口一致</span><br><span class="line">             proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">             proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">             proxy_pass http://172.17.0.1:8081;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> server &#123;</span><br><span class="line">     listen       443;</span><br><span class="line">     server_name  *.ngrok.yangbingdong.com;</span><br><span class="line">     location / &#123;</span><br><span class="line">             proxy_redirect off;</span><br><span class="line">             proxy_set_header Host $host;</span><br><span class="line">             proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">             proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">             proxy_pass http://172.17.0.1:4432;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>172.17.0.1</code>为内网ip</li>
</ul>
<h2 id="Caddy"><a href="#Caddy" class="headerlink" title="Caddy"></a>Caddy</h2><p><code>Caddyfile</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://*.ngrok.yangbingdong.com &#123;</span><br><span class="line">    proxy / http://172.17.0.1:8081 &#123;</span><br><span class="line">        header_upstream Host &#123;host&#125;:8081 #此处端口要跟 启动服务端 ngrok 时指定的端口一致</span><br><span class="line">        header_upstream X-Real-IP &#123;remote&#125;</span><br><span class="line">        header_upstream X-Forwarded-For &#123;remote&#125;</span><br><span class="line">        header_upstream X-Forwarded-Proto &#123;scheme&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h1><p>另外一个内网穿透工具: <strong><em><a href="https://github.com/fatedier/frp" rel="external nofollow noopener noreferrer" target="_blank">frp</a></em></strong></p>
]]></content><categories><category>VPS</category></categories><tags><tag>VPS</tag><tag>Ngrok</tag></tags></entry><entry><title>Spring Boot学习之测试篇</title><url>/2018/spring-boot-learning-testing/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/spring-boot-testing/java-testing.png" alt></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><blockquote>
<p>测试已经是贯穿我们程序员的日常开发流程了, 无论写个main方法, 还是使用测试框架Junit、AssertJ, 或者压测, 都是我们日常开发的一部分. 也有很多互联网公司推崇TDD（测试驱动开发）的. </p>
<p>下面主要介绍<code>AssertJ</code>、<code>JMH</code>、<code>Gatling</code>以及<code>ContPerf</code>. </p>
</blockquote>
<a id="more"></a>
<h1 id="使用AssertJ"><a href="#使用AssertJ" class="headerlink" title="使用AssertJ"></a>使用AssertJ</h1><p><code>AseertJ</code>: JAVA 流式断言器, 什么是流式, 常见的断言器一条断言语句只能对实际值断言一个校验点, 而流式断言器, 支持一条断言语句对实际值同时断言多个校验点. </p>
<blockquote>
<p><a href="http://joel-costigliola.github.io/assertj/assertj-core-features-highlight.html" rel="external nofollow noopener noreferrer" target="_blank">AssertJ Core features highlight</a></p>
</blockquote>
<p>如果是Spring Boot 1.x版本, 在<code>spring-boot-starter-test</code>模块中, AssertJ的版本依然停留在<code>2.x</code>, 为了可以使用新功能, 我们可以引入新版本的AssertJ（<strong>Spring Boot 2已经是最新版的AssertJ</strong>）:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.assertj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>assertj-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.assertj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>assertj-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="字符串断言"><a href="#字符串断言" class="headerlink" title="字符串断言"></a>字符串断言</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String str = <span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">// 断言null或为空字符串</span></span><br><span class="line">	assertThat(str).isNullOrEmpty();</span><br><span class="line">	<span class="comment">// 断言空字符串</span></span><br><span class="line">	assertThat(<span class="string">""</span>).isEmpty();</span><br><span class="line">	<span class="comment">// 断言字符串相等 断言忽略大小写判断字符串相等</span></span><br><span class="line">	assertThat(<span class="string">"Frodo"</span>).isEqualTo(<span class="string">"Frodo"</span>).isEqualToIgnoringCase(<span class="string">"frodo"</span>);</span><br><span class="line">	<span class="comment">// 断言开始字符串 结束字符穿 字符串长度</span></span><br><span class="line">	assertThat(<span class="string">"Frodo"</span>).startsWith(<span class="string">"Fro"</span>).endsWith(<span class="string">"do"</span>).hasSize(<span class="number">5</span>);</span><br><span class="line">	<span class="comment">// 断言包含字符串 不包含字符串</span></span><br><span class="line">	assertThat(<span class="string">"Frodo"</span>).contains(<span class="string">"rod"</span>).doesNotContain(<span class="string">"fro"</span>);</span><br><span class="line">	<span class="comment">// 断言字符串只出现过一次</span></span><br><span class="line">	assertThat(<span class="string">"Frodo"</span>).containsOnlyOnce(<span class="string">"do"</span>);</span><br><span class="line">	<span class="comment">// 判断正则匹配</span></span><br><span class="line">	assertThat(<span class="string">"Frodo"</span>).matches(<span class="string">"..o.o"</span>).doesNotMatch(<span class="string">".*d"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数字断言"><a href="#数字断言" class="headerlink" title="数字断言"></a>数字断言</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Integer num = <span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">// 断言空</span></span><br><span class="line">	assertThat(num).isNull();</span><br><span class="line">	<span class="comment">// 断言相等</span></span><br><span class="line">	assertThat(<span class="number">42</span>).isEqualTo(<span class="number">42</span>);</span><br><span class="line">	<span class="comment">// 断言大于 大于等于</span></span><br><span class="line">	assertThat(<span class="number">42</span>).isGreaterThan(<span class="number">38</span>).isGreaterThanOrEqualTo(<span class="number">38</span>);</span><br><span class="line">	<span class="comment">// 断言小于 小于等于</span></span><br><span class="line">	assertThat(<span class="number">42</span>).isLessThan(<span class="number">58</span>).isLessThanOrEqualTo(<span class="number">58</span>);</span><br><span class="line">	<span class="comment">// 断言0</span></span><br><span class="line">	assertThat(<span class="number">0</span>).isZero();</span><br><span class="line">	<span class="comment">// 断言正数 非负数</span></span><br><span class="line">	assertThat(<span class="number">1</span>).isPositive().isNotNegative();</span><br><span class="line">	<span class="comment">// 断言负数 非正数</span></span><br><span class="line">	assertThat(-<span class="number">1</span>).isNegative().isNotPositive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="时间断言"><a href="#时间断言" class="headerlink" title="时间断言"></a>时间断言</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 断言与指定日期相同 不相同 在指定日期之后 在指定日期之钱</span></span><br><span class="line">	assertThat(parse(<span class="string">"2014-02-01"</span>)).isEqualTo(<span class="string">"2014-02-01"</span>).isNotEqualTo(<span class="string">"2014-01-01"</span>)</span><br><span class="line">								   .isAfter(<span class="string">"2014-01-01"</span>).isBefore(parse(<span class="string">"2014-03-01"</span>));</span><br><span class="line">	<span class="comment">// 断言 2014 在指定年份之前 在指定年份之后</span></span><br><span class="line">	assertThat(<span class="keyword">new</span> Date()).isBeforeYear(<span class="number">2020</span>).isAfterYear(<span class="number">2013</span>);</span><br><span class="line">	<span class="comment">// 断言时间再指定范围内 不在指定范围内</span></span><br><span class="line">	assertThat(parse(<span class="string">"2014-02-01"</span>)).isBetween(<span class="string">"2014-01-01"</span>, <span class="string">"2014-03-01"</span>).isNotBetween(</span><br><span class="line">			parse(<span class="string">"2014-02-02"</span>), parse(<span class="string">"2014-02-28"</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 断言两时间相差100毫秒</span></span><br><span class="line">	Date d1 = <span class="keyword">new</span> Date();</span><br><span class="line">	Date d2 = <span class="keyword">new</span> Date(d1.getTime() + <span class="number">100</span>);</span><br><span class="line">	assertThat(d1).isCloseTo(d2, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// sets dates differing more and more from date1</span></span><br><span class="line">	Date date1 = parseDatetimeWithMs(<span class="string">"2003-01-01T01:00:00.000"</span>);</span><br><span class="line">	Date date2 = parseDatetimeWithMs(<span class="string">"2003-01-01T01:00:00.555"</span>);</span><br><span class="line">	Date date3 = parseDatetimeWithMs(<span class="string">"2003-01-01T01:00:55.555"</span>);</span><br><span class="line">	Date date4 = parseDatetimeWithMs(<span class="string">"2003-01-01T01:55:55.555"</span>);</span><br><span class="line">	Date date5 = parseDatetimeWithMs(<span class="string">"2003-01-01T05:55:55.555"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 断言 日期忽略毫秒, 与给定的日期相等</span></span><br><span class="line">	assertThat(date1).isEqualToIgnoringMillis(date2);</span><br><span class="line">	<span class="comment">// 断言 日期与给定的日期具有相同的年月日时分秒</span></span><br><span class="line">	assertThat(date1).isInSameSecondAs(date2);</span><br><span class="line">	<span class="comment">// 断言 日期忽略秒, 与给定的日期时间相等</span></span><br><span class="line">	assertThat(date1).isEqualToIgnoringSeconds(date3);</span><br><span class="line">	<span class="comment">// 断言 日期与给定的日期具有相同的年月日时分</span></span><br><span class="line">	assertThat(date1).isInSameMinuteAs(date3);</span><br><span class="line">	<span class="comment">// 断言 日期忽略分, 与给定的日期时间相等</span></span><br><span class="line">	assertThat(date1).isEqualToIgnoringMinutes(date4);</span><br><span class="line">	<span class="comment">// 断言 日期与给定的日期具有相同的年月日时</span></span><br><span class="line">	assertThat(date1).isInSameHourAs(date4);</span><br><span class="line">	<span class="comment">// 断言 日期忽略小时, 与给定的日期时间相等</span></span><br><span class="line">	assertThat(date1).isEqualToIgnoringHours(date5);</span><br><span class="line">	<span class="comment">// 断言 日期与给定的日期具有相同的年月日</span></span><br><span class="line">	assertThat(date1).isInSameDayAs(date5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="集合断言"><a href="#集合断言" class="headerlink" title="集合断言"></a>集合断言</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 断言 列表是空的</span></span><br><span class="line">	assertThat(newArrayList()).isEmpty();</span><br><span class="line">	<span class="comment">// 断言 列表的开始 结束元素</span></span><br><span class="line">	assertThat(newArrayList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)).startsWith(<span class="number">1</span>).endsWith(<span class="number">3</span>);</span><br><span class="line">	<span class="comment">// 断言 列表包含元素 并且是排序的</span></span><br><span class="line">	assertThat(newArrayList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)).contains(<span class="number">1</span>, atIndex(<span class="number">0</span>)).contains(<span class="number">2</span>, atIndex(<span class="number">1</span>)).contains(<span class="number">3</span>)</span><br><span class="line">									 .isSorted();</span><br><span class="line">	<span class="comment">// 断言 被包含与给定列表</span></span><br><span class="line">	assertThat(newArrayList(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>)).isSubsetOf(newArrayList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">	<span class="comment">// 断言 存在唯一元素</span></span><br><span class="line">	assertThat(newArrayList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>)).containsOnlyOnce(<span class="string">"a"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Map断言"><a href="#Map断言" class="headerlink" title="Map断言"></a>Map断言</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Map&lt;String, Object&gt; foo = Maps.newHashMap(<span class="string">"A"</span>, <span class="number">1</span>);</span><br><span class="line">	foo.put(<span class="string">"B"</span>, <span class="number">2</span>);</span><br><span class="line">	foo.put(<span class="string">"C"</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 断言 map 不为空 size</span></span><br><span class="line">	assertThat(foo).isNotEmpty().hasSize(<span class="number">3</span>);</span><br><span class="line">	<span class="comment">// 断言 map 包含元素</span></span><br><span class="line">	assertThat(foo).contains(entry(<span class="string">"A"</span>, <span class="number">1</span>), entry(<span class="string">"B"</span>, <span class="number">2</span>));</span><br><span class="line">	<span class="comment">// 断言 map 包含key</span></span><br><span class="line">	assertThat(foo).containsKeys(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>);</span><br><span class="line">	<span class="comment">// 断言 map 包含value</span></span><br><span class="line">	assertThat(foo).containsValue(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类断言"><a href="#类断言" class="headerlink" title="类断言"></a>类断言</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 断言 是注解</span></span><br><span class="line">	assertThat(Magical<span class="class">.<span class="keyword">class</span>).<span class="title">isAnnotation</span>()</span>;</span><br><span class="line">	<span class="comment">// 断言 不是注解</span></span><br><span class="line">	assertThat(Ring<span class="class">.<span class="keyword">class</span>).<span class="title">isNotAnnotation</span>()</span>;</span><br><span class="line">	<span class="comment">// 断言 存在注解</span></span><br><span class="line">	assertThat(Ring<span class="class">.<span class="keyword">class</span>).<span class="title">hasAnnotation</span>(<span class="title">Magical</span>.<span class="title">class</span>)</span>;</span><br><span class="line">	<span class="comment">// 断言 不是借口</span></span><br><span class="line">	assertThat(Ring<span class="class">.<span class="keyword">class</span>).<span class="title">isNotInterface</span>()</span>;</span><br><span class="line">	<span class="comment">// 断言 是否为指定Class实例</span></span><br><span class="line">	assertThat(<span class="string">"string"</span>).isInstanceOf(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	<span class="comment">// 断言 类是给定类的父类</span></span><br><span class="line">	assertThat(Person1<span class="class">.<span class="keyword">class</span>).<span class="title">isAssignableFrom</span>(<span class="title">Employee</span>.<span class="title">class</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Magical</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Ring &#123;</span><br><span class="line">	oneRing, vilya, nenya, narya, dwarfRing, manRing;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Magical &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person1</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person1</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="异常断言"><a href="#异常断言" class="headerlink" title="异常断言"></a>异常断言</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	assertThatThrownBy(() -&gt; &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"boom!"</span>); &#125;).isInstanceOf(Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">															   .hasMessageContaining("boom");</span><br><span class="line"></span><br><span class="line">	assertThatExceptionOfType(IOException<span class="class">.<span class="keyword">class</span>).<span class="title">isThrownBy</span>(() -&gt; </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"boom!"</span>); &#125;)</span><br><span class="line">												.withMessage(<span class="string">"%s!"</span>, <span class="string">"boom"</span>)</span><br><span class="line">												.withMessageContaining(<span class="string">"boom"</span>)</span><br><span class="line">												.withNoCause();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * assertThatNullPointerException</span></span><br><span class="line"><span class="comment">	 * assertThatIllegalArgumentException</span></span><br><span class="line"><span class="comment">	 * assertThatIllegalStateException</span></span><br><span class="line"><span class="comment">	 * assertThatIOException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	assertThatIOException().isThrownBy(() -&gt; &#123; <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"boom!"</span>); &#125;)</span><br><span class="line">						   .withMessage(<span class="string">"%s!"</span>, <span class="string">"boom"</span>)</span><br><span class="line">						   .withMessageContaining(<span class="string">"boom"</span>)</span><br><span class="line">						   .withNoCause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件断言"><a href="#文件断言" class="headerlink" title="文件断言"></a>文件断言</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	File xFile = writeFile(<span class="string">"xFile"</span>, <span class="string">"The Truth Is Out There"</span>);</span><br><span class="line"></span><br><span class="line">	assertThat(xFile).exists().isFile().isRelative();</span><br><span class="line"></span><br><span class="line">	assertThat(xFile).canRead().canWrite();</span><br><span class="line"></span><br><span class="line">	assertThat(contentOf(xFile)).startsWith(<span class="string">"The Truth"</span>).contains(<span class="string">"Is Out"</span>).endsWith(<span class="string">"There"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> File <span class="title">writeFile</span><span class="params">(String fileName, String fileContent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> writeFile(fileName, fileContent, Charset.defaultCharset());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> File <span class="title">writeFile</span><span class="params">(String fileName, String fileContent, Charset charset)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	File file = <span class="keyword">new</span> File(<span class="string">"target/"</span> + fileName);</span><br><span class="line">	BufferedWriter out = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(file), charset));</span><br><span class="line">	out.write(fileContent);</span><br><span class="line">	out.close();</span><br><span class="line">	<span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对象列表断言"><a href="#对象列表断言" class="headerlink" title="对象列表断言"></a>对象列表断言</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">personListTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	List&lt;Person&gt; personList = Arrays.asList(<span class="keyword">new</span> Person(<span class="string">"A"</span>, <span class="number">1</span>), <span class="keyword">new</span> Person(<span class="string">"B"</span>, <span class="number">2</span>), <span class="keyword">new</span> Person(<span class="string">"C"</span>, <span class="number">3</span>));</span><br><span class="line">	assertThat(personList).extracting(Person::getName).contains(<span class="string">"A"</span>, <span class="string">"B"</span>).doesNotContain(<span class="string">"D"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">personListTest1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	List&lt;Person&gt; personList = Arrays.asList(<span class="keyword">new</span> Person(<span class="string">"A"</span>, <span class="number">1</span>), <span class="keyword">new</span> Person(<span class="string">"B"</span>, <span class="number">2</span>), <span class="keyword">new</span> Person(<span class="string">"C"</span>, <span class="number">3</span>));</span><br><span class="line">	assertThat(personList).flatExtracting(Person::getName).contains(<span class="string">"A"</span>, <span class="string">"B"</span>).doesNotContain(<span class="string">"D"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="断言添加描述"><a href="#断言添加描述" class="headerlink" title="断言添加描述"></a>断言添加描述</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Person person = <span class="keyword">new</span> Person(<span class="string">"ybd"</span>, <span class="number">18</span>);</span><br><span class="line">	assertThat(person.getAge()).as(<span class="string">"check %s's age"</span>, person.getName()).isEqualTo(<span class="number">18</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="官方例子"><a href="#官方例子" class="headerlink" title="官方例子"></a>官方例子</h2><p><strong><em><a href="https://github.com/joel-costigliola/assertj-examples" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/joel-costigliola/assertj-examples</a></em></strong></p>
<h1 id="JMH基准测试"><a href="#JMH基准测试" class="headerlink" title="JMH基准测试"></a>JMH基准测试</h1><blockquote>
<p>JMH 是一个由 OpenJDK/Oracle 里面那群开发了 Java 编译器的大牛们所开发的 Micro Benchmark Framework . 何谓 Micro Benchmark 呢？简单地说就是在 <strong>method</strong> 层面上的 benchmark, 精度可以精确到微秒级. 可以看出 JMH 主要使用在当你已经找出了热点函数, 而需要对热点函数进行进一步的优化时, 就可以使用 JMH 对优化的效果进行定量的分析. </p>
<p>比较典型的使用场景还有: </p>
<ul>
<li>想定量地知道某个函数需要执行多长时间, 以及执行时间和输入 n 的相关性</li>
<li>一个函数有两种不同实现（例如实现 A 使用了 <code>FixedThreadPool</code>, 实现 B 使用了 <code>ForkJoinPool</code>）, 不知道哪种实现性能更好</li>
</ul>
<p>尽管 JMH 是一个相当不错的 Micro Benchmark Framework, 但很无奈的是网上能够找到的文档比较少, 而官方也没有提供比较详细的文档, 对使用造成了一定的障碍. 但是有个好消息是官方的 <strong><em><a href="http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/" rel="external nofollow noopener noreferrer" target="_blank">Code Sample</a></em></strong> 写得非常浅显易懂, </p>
</blockquote>
<h2 id="导入Jar包"><a href="#导入Jar包" class="headerlink" title="导入Jar包"></a>导入Jar包</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-generator-annprocess<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>我们来测试一下Snowflake的性能: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BenchmarkMode</span>(Mode.Throughput)</span><br><span class="line"><span class="meta">@Warmup</span>(iterations = <span class="number">3</span>, time = <span class="number">1</span>)</span><br><span class="line"><span class="meta">@Measurement</span>(iterations = <span class="number">4</span>, time = <span class="number">2</span>)</span><br><span class="line"><span class="meta">@Threads</span>(<span class="number">10</span>)</span><br><span class="line"><span class="meta">@Fork</span>(<span class="number">1</span>)</span><br><span class="line"><span class="meta">@OutputTimeUnit</span>(TimeUnit.SECONDS)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SnowflakeTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Snowflake[] SNOWFLAKES = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">8</span>)</span><br><span class="line">														   .mapToObj(Snowflake::create)</span><br><span class="line">														   .toArray(Snowflake[]::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong ATOMIC_LONG = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Benchmark</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> SNOWFLAKES[(<span class="keyword">int</span>) (ATOMIC_LONG.incrementAndGet() &amp; (<span class="number">1</span> &lt;&lt; <span class="number">3</span>) - <span class="number">1</span>)].nextId();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException </span>&#123;</span><br><span class="line">		Options options = <span class="keyword">new</span> OptionsBuilder().include(SnowflakeTest<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>())</span></span><br><span class="line"><span class="class">											  .<span class="title">build</span>()</span>;</span><br><span class="line">		<span class="keyword">new</span> Runner(options).run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Benchmark             Mode  Cnt         Score       Error  Units</span><br><span class="line">SnowflakeTest.getId  thrpt    4  32751461.735 ± 88155.402  ops/s</span><br></pre></td></tr></table></figure>
<p>注解都可以换成方法的方式在main方法中指定, 比如这样: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Options opt = <span class="keyword">new</span> OptionsBuilder().include(SnowflakeTest<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>())</span></span><br><span class="line"><span class="class">								  .<span class="title">forks</span>(1)</span></span><br><span class="line"><span class="class">								  .<span class="title">measurementIterations</span>(3)</span></span><br><span class="line"><span class="class">								  .<span class="title">measurementTime</span>(<span class="title">TimeValue</span>.<span class="title">seconds</span>(1))</span></span><br><span class="line"><span class="class">								  .<span class="title">warmupIterations</span>(3)</span></span><br><span class="line"><span class="class">								  .<span class="title">warmupTime</span>(<span class="title">TimeValue</span>.<span class="title">seconds</span>(1))</span></span><br><span class="line"><span class="class">								  .<span class="title">build</span>()</span>;</span><br></pre></td></tr></table></figure>
<h2 id="注解分析"><a href="#注解分析" class="headerlink" title="注解分析"></a>注解分析</h2><p>下面我把一些常用的注解全部分析一遍, 看完之后你就可以得心应手的使用了. </p>
<h3 id="BenchmarkMode"><a href="#BenchmarkMode" class="headerlink" title="@BenchmarkMode"></a>@BenchmarkMode</h3><p>基准测试类型, 对应Mode选项, 可用于<strong>类或者方法</strong>上. 需要注意的是, 这个注解的<code>value</code>是一个<strong>数组</strong>, 可以把几种Mode集合在一起执行, 如: <code>@BenchmarkMode({Mode.SampleTime, Mode.AverageTime})</code></p>
<ul>
<li><code>Throughput</code>: 整体吞吐量, 每秒执行了多少次调用. </li>
<li><code>AverageTime</code>: 用的平均时间, 每次操作的平均时间. </li>
<li><code>SampleTime</code>: 随机取样, 最后输出取样结果的分布, 例如“99%的调用在xxx毫秒以内, 99.99%的调用在xxx毫秒以内”. </li>
<li><code>SingleShotTime</code>: 上模式都是默认一次 <code>iteration</code> 是 1s, 唯有 <code>SingleShotTime</code> 是只运行一次. 往往同时把 <code>warmup</code> 次数设为0, 用于测试冷启动时的性能. </li>
<li><code>All</code>: 上面的所有模式都执行一次, 适用于内部JMH测试. </li>
</ul>
<h3 id="Warmup"><a href="#Warmup" class="headerlink" title="@Warmup"></a>@Warmup</h3><p>预热所需要配置的一些基本测试参数. 可用于<strong>类或者方法</strong>上. 一般我们前几次进行程序测试的时候都会比较慢, 所以要让程序进行几轮预热, 保证测试的准确性. 为什么需要预热？因为 JVM 的 JIT 机制的存在, <strong>如果某个函数被调用多次之后</strong>, <strong>JVM 会尝试将其编译成为机器码从而提高执行速度</strong>. 所以为了让 benchmark 的结果更加接近真实情况就需要进行预热. </p>
<ul>
<li><code>iterations</code>: 预热的次数. </li>
<li><code>time</code>: 每次预热的时间. </li>
<li><code>timeUnit</code>: 时间的单位, 默认秒. </li>
<li><code>batchSize</code>: 批处理大小, 每次操作调用几次方法. </li>
</ul>
<h3 id="Measurement"><a href="#Measurement" class="headerlink" title="@Measurement"></a>@Measurement</h3><p>实际调用方法所需要配置的一些基本测试参数. 可用于<strong>类或者方法</strong>上. 参数和<strong>@Warmup</strong>一样. </p>
<h3 id="Threads"><a href="#Threads" class="headerlink" title="@Threads"></a>@Threads</h3><p>每个进程中的测试线程, 可用于<strong>类或者方法</strong>上. 一般选择为cpu乘以2. 如果配置了 <code>Threads.MAX</code> , 代表使用 <code>Runtime.getRuntime().availableProcessors()</code> 个线程. </p>
<h3 id="Fork"><a href="#Fork" class="headerlink" title="@Fork"></a>@Fork</h3><p>进行 fork 的次数. 可用于<strong>类或者方法</strong>上. 如果 fork 数是2的话, 则 JMH 会 fork 出两个进程来进行测试. </p>
<h3 id="Benchmark"><a href="#Benchmark" class="headerlink" title="@Benchmark"></a>@Benchmark</h3><p>方法级注解, 表示该方法是需要进行 benchmark 的对象, 用法和 JUnit 的 @Test 类似. </p>
<h3 id="Param"><a href="#Param" class="headerlink" title="@Param"></a>@Param</h3><p><code>@Param</code> 可以用来指定某项参数的多种情况. 只能作用在<strong>字段</strong>上. 特别适合用来测试一个函数在不同的参数输入的情况下的性能. 使用该注解必须定义 <code>@State</code> 注解. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Param</span>(value = &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;)</span><br><span class="line"><span class="keyword">private</span> String param;</span><br></pre></td></tr></table></figure>
<p>最后的结果可能是这个样子的: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Benchmark                    (param)  Mode  Cnt    Score   Error  Units</span><br><span class="line">FirstBenchMark.stringConcat        a    ss       330.752          us/op</span><br><span class="line">FirstBenchMark.stringConcat        b    ss       186.050          us/op</span><br><span class="line">FirstBenchMark.stringConcat        c    ss       222.559          us/op</span><br></pre></td></tr></table></figure>
<h3 id="Setup-amp-TearDown"><a href="#Setup-amp-TearDown" class="headerlink" title="@Setup&amp;@TearDown"></a>@Setup&amp;@TearDown</h3><p><code>@Setup</code>主要实现测试前的初始化工作, 只能作用在<strong>方法</strong>上. 用法和Junit一样. 使用该注解必须定义 <code>@State</code> 注解. </p>
<p><code>@TearDown</code>主要实现测试完成后的垃圾回收等工作, 只能作用在<strong>方法</strong>上. 用法和Junit一样. 使用该注解必须定义 <code>@State</code> 注解. </p>
<p>这两个注解都有一个 <code>Level</code> 的枚举value, 它有三个值（默认的是Trial）: </p>
<ul>
<li><code>Trial</code>: 在每次Benchmark的之前/之后执行. </li>
<li><code>Iteration</code>: 在每次Benchmark的<code>iteration</code>的之前/之后执行. </li>
<li><code>Invocation</code>: 每次调用Benchmark标记的方法之前/之后都会执行. </li>
</ul>
<p>可见, Level的粒度从<code>Trial</code>到<code>Invocation</code>越来越细. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@TearDown(Level.Iteration)</span><br><span class="line">public void check() &#123;</span><br><span class="line">    assert x &gt; Math.PI : &quot;Nothing changed?&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Benchmark</span><br><span class="line">public void measureRight() &#123;</span><br><span class="line">    x++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Benchmark</span><br><span class="line">public void measureWrong() &#123;</span><br><span class="line">    double x = 0;</span><br><span class="line">    x++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="State"><a href="#State" class="headerlink" title="@State"></a>@State</h3><p>该注解定义了给定类实例的可用范围. JMH可以在多线程同时运行的环境测试, 因此需要选择正确的状态. 只能作用在<strong>类</strong>上. 被该注解定义的类通常作为 <code>@Benchmark</code> 标记的方法的入参, JMH根据scope来进行实例化和共享操作, 当然<code>@State</code>可以被继承使用, 如果父类定义了该注解, 子类则无需定义. </p>
<p>Scope有如下3种值: </p>
<ul>
<li><code>Benchmark</code>: 同一个benchmark在多个线程之间共享实例. </li>
<li><code>Group</code>: 同一个线程在同一个group里共享实例. group定义参考注解 <code>@Group</code> . </li>
<li><code>Thread</code>: 不同线程之间的实例不共享. </li>
</ul>
<p>首先说一下<code>Benchmark</code>, 对于同一个<code>@Benchmark</code>, 所有线程共享实例, 也就是只会new Person 1次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@State</span>(Scope.Benchmark)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BenchmarkState</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="number">21</span>, <span class="string">"ben"</span>, <span class="string">"benchmark"</span>);</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">double</span> x = Math.PI;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measureShared</span><span class="params">(BenchmarkState state)</span> </span>&#123;</span><br><span class="line">    state.x++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RunnerException </span>&#123;</span><br><span class="line">    Options opt = <span class="keyword">new</span> OptionsBuilder()</span><br><span class="line">            .include(JMHSample_03_States<span class="class">.<span class="keyword">class</span>.<span class="title">getSimpleName</span>())</span></span><br><span class="line"><span class="class">            .<span class="title">threads</span>(8)</span></span><br><span class="line"><span class="class">            .<span class="title">warmupTime</span>(<span class="title">TimeValue</span>.<span class="title">seconds</span>(1))</span></span><br><span class="line"><span class="class">            .<span class="title">measurementTime</span>(<span class="title">TimeValue</span>.<span class="title">seconds</span>(1))</span></span><br><span class="line"><span class="class">            .<span class="title">forks</span>(1)</span></span><br><span class="line"><span class="class">            .<span class="title">build</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Runner(opt).run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再说一下<code>Thread</code>, 这个比较好理解, 不同线程之间的实例不共享. 对于上面我们设定的线程数为8个, 也就是会new Person 8次. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@State</span>(Scope.Thread)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadState</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="number">21</span>, <span class="string">"ben"</span>, <span class="string">"thread"</span>);</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">double</span> x = Math.PI;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measureUnshared</span><span class="params">(ThreadState state)</span> </span>&#123;</span><br><span class="line">    state.x++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而对于Group来说, 同一个group的作为一个执行单元, 所以 <code>measureGroup</code> 和 <code>measureGroup2</code> 共享8个线程, 所以一个方法也就会执行new Person 4次. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@State</span>(Scope.Group)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupState</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="number">21</span>, <span class="string">"ben"</span>, <span class="string">"group"</span>);</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">double</span> x = Math.PI;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="meta">@Group</span>(<span class="string">"ben"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measureGroup</span><span class="params">(GroupState state)</span> </span>&#123;</span><br><span class="line">    state.x++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="meta">@Group</span>(<span class="string">"ben"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measureGroup2</span><span class="params">(GroupState state)</span> </span>&#123;</span><br><span class="line">    state.x++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Group"><a href="#Group" class="headerlink" title="@Group"></a>@Group</h3><p>结合<code>@Benchmark</code>一起使用, 把多个基准方法归为一类, 只能作用在<strong>方法</strong>上. 同一个组中的所有测试设置相同的名称(否则这些测试将独立运行——没有任何警告提示！)</p>
<h3 id="GroupThreads"><a href="#GroupThreads" class="headerlink" title="@GroupThreads"></a>@GroupThreads</h3><p>定义了多少个线程参与在组中运行基准方法. 只能作用在<strong>方法</strong>上. </p>
<h3 id="OutputTimeUnit"><a href="#OutputTimeUnit" class="headerlink" title="@OutputTimeUnit"></a>@OutputTimeUnit</h3><p>这个比较简单了, 基准测试结果的时间类型. 可用于<strong>类或者方法</strong>上. 一般选择秒、毫秒、微秒. </p>
<h3 id="CompilerControl"><a href="#CompilerControl" class="headerlink" title="@CompilerControl"></a>@CompilerControl</h3><p>该注解可以控制方法编译的行为, 可用于<strong>类或者方法或者构造函数</strong>上. 它内部有6种模式, 这里我们只关心三种重要的模式: </p>
<ul>
<li><code>CompilerControl.Mode.INLINE</code>: 强制使用内联. </li>
<li><code>CompilerControl.Mode.DONT_INLINE</code>: 禁止使用内联. </li>
<li><code>CompilerControl.Mode.EXCLUDE</code>: 禁止编译方法. </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">target_blank</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CompilerControl</span>(CompilerControl.Mode.DONT_INLINE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">target_dontInline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CompilerControl</span>(CompilerControl.Mode.INLINE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">target_inline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CompilerControl</span>(CompilerControl.Mode.EXCLUDE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">target_exclude</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">baseline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">blank</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    target_blank();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dontinline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    target_dontInline();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    target_inline();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exclude</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    target_exclude();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后得出的结果也表名, 使用内联优化会影响实际的结果: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Benchmark                                Mode  Cnt   Score   Error  Units</span><br><span class="line">JMHSample_16_CompilerControl.baseline    avgt    3   0.338 ± 0.475  ns/op</span><br><span class="line">JMHSample_16_CompilerControl.blank       avgt    3   0.343 ± 0.213  ns/op</span><br><span class="line">JMHSample_16_CompilerControl.dontinline  avgt    3   2.247 ± 0.421  ns/op</span><br><span class="line">JMHSample_16_CompilerControl.exclude     avgt    3  82.814 ± 7.333  ns/op</span><br><span class="line">JMHSample_16_CompilerControl.inline      avgt    3   0.322 ± 0.023  ns/op</span><br></pre></td></tr></table></figure>
<h2 id="避免JIT优化"><a href="#避免JIT优化" class="headerlink" title="避免JIT优化"></a>避免JIT优化</h2><p>我们在测试的时候, 一定要避免JIT优化. 对于有一些代码, 编译器可以推导出一些计算是多余的, 并且完全消除它们. 如果我们的基准测试里有部分代码被清除了, 那测试的结果就不准确了. 比如下面这一段代码: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> x = Math.PI;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">baseline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do nothing, this is a baseline</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measureWrong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This is wrong: result is not used and the entire computation is optimized away.</span></span><br><span class="line">    Math.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">measureRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This is correct: the result is being used.</span></span><br><span class="line">    <span class="keyword">return</span> Math.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 <code>measureWrong</code> 方法被编译器优化了, 导致效果和 <code>baseline</code> 方法一样变成了空方法, 结果也证实了这一点: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Benchmark                           Mode  Cnt   Score   Error  Units</span><br><span class="line">JMHSample_08_DeadCode.baseline      avgt    5   0.311 ± 0.018  ns/op</span><br><span class="line">JMHSample_08_DeadCode.measureRight  avgt    5  23.702 ± 0.320  ns/op</span><br><span class="line">JMHSample_08_DeadCode.measureWrong  avgt    5   0.306 ± 0.003  ns/op</span><br></pre></td></tr></table></figure>
<p>如果我们想方法返回值还是<code>void</code>, 但是需要让<code>Math.log(x)</code>的耗时加入到基准运算中, 我们可以使用JMH提供给我们的类 <code>Blackhole</code> , 使用它的 <code>consume</code>来避免JIT的优化消除. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measureRight_2</span><span class="params">(Blackhole bh)</span> </span>&#123;</span><br><span class="line">    bh.consume(Math.log(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是有返回值的方法就不会被优化了吗？你想的太多了. . . 重新改改刚才的代码, 让字段 <code>x</code> 变成final的. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> x = Math.PI;</span><br></pre></td></tr></table></figure>
<p>运行后的结果发现 <code>measureRight</code> 被JIT进行了优化, 从 <code>23.7ns/op</code> 降到了 <code>2.5ns/op</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JMHSample_08_DeadCode.measureRight    avgt    5  2.587 ± 0.081  ns/op</span><br></pre></td></tr></table></figure>
<p>当然 <code>Math.log(Math.PI );</code> 这种返回写法和字段定义成final一样, 都会被进行优化. </p>
<p>优化的原因是因为JVM认为每次计算的结果都是相同的, 于是就会把相同代码移到了JMH的循环之外. </p>
<p><strong>结论: </strong></p>
<ol>
<li>基准测试方法一定不要返回<code>void</code>. </li>
<li>如果要使用<code>void</code>返回, 可以使用 <code>Blackhole</code> 的 <code>consume</code> 来避免JIT的优化消除. </li>
<li>计算<strong>不要引用常量</strong>, 否则会被优化到JMH的循环之外. </li>
</ol>
<h2 id="IDEA插件"><a href="#IDEA插件" class="headerlink" title="IDEA插件"></a>IDEA插件</h2><p>在插件中直接搜JMH, 该插件可以右键生成JMH方法, 不用写main方法也能执行<code>@Benchmark</code>的方法</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><strong><em><a href="http://benjaminwhx.com/2018/06/15/%E4%BD%BF%E7%94%A8JMH%E5%81%9A%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/" rel="external nofollow noopener noreferrer" target="_blank">http://benjaminwhx.com/2018/06/15/%E4%BD%BF%E7%94%A8JMH%E5%81%9A%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/</a></em></strong></p>
</blockquote>
<h1 id="Gatling性能测试"><a href="#Gatling性能测试" class="headerlink" title="Gatling性能测试"></a>Gatling性能测试</h1><blockquote>
<p>性能测试的两种类型, 负载测试和压力测试: </p>
<ul>
<li><strong>负载测试（Load Testing）: </strong>负载测试是一种主要为了测试软件系统是否达到需求文档设计的目标, 譬如软件在一定时期内, 最大支持多少并发用户数, 软件请求出错率等, 测试的主要是软件系统的性能. </li>
<li><strong>压力测试（Stress Testing）: </strong>压力测试主要是为了测试硬件系统是否达到需求文档设计的性能目标, 譬如在一定时期内, 系统的cpu利用率, 内存使用率, 磁盘I/O吞吐率, 网络吞吐量等, 压力测试和负载测试最大的差别在于测试目的不同. </li>
</ul>
</blockquote>
<h2 id="Gatling-简介"><a href="#Gatling-简介" class="headerlink" title="Gatling 简介"></a>Gatling 简介</h2><p><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/gatling-logo.png" alt></p>
<p>Gatling 是一个功能强大的负载测试工具. 它是为易用性、可维护性和高性能而设计的. </p>
<p>开箱即用, Gatling 带有对 HTTP 协议的出色支持, 使其成为负载测试任何 HTTP 服务器的首选工具. 由于核心引擎实际上是协议不可知的, 所以完全可以实现对其他协议的支持, 例如, Gatling 目前也提供JMS 支持. </p>
<p>只要底层协议（如 HTTP）能够以非阻塞的方式实现, Gatling 的架构就是异步的. 这种架构可以将虚拟用户作为消息而不是专用线程来实现. 因此, 运行数千个并发的虚拟用户不是问题. </p>
<h2 id="使用Recorder快速开始"><a href="#使用Recorder快速开始" class="headerlink" title="使用Recorder快速开始"></a>使用Recorder快速开始</h2><p>官方提供了GUI界面的录制器, 可以监听对应端口记录请求操作并转化为Scala脚本</p>
<p>1、进入 <em><a href="https://gatling.io/download/" rel="external nofollow noopener noreferrer" target="_blank">下载页面</a></em> 下载最新版本<br>2、解压并进入 <code>$GATLING_HOME/bin</code> (<code>$GATLING_HOME</code>为解压目录), 运行<code>recorder.sh</code><br><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/recorder1.png" alt></p>
<ul>
<li><p>上图监听8000端口（若被占用请更换端口）, 需要在浏览器设置代理, 以FireFox为例:<br><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/firefox-proxy.jpg" alt></p>
</li>
<li><p><code>Output folder</code>为Scala脚本输出路径, 例如设置为 <code>/home/ybd/data/application/gatling-charts-highcharts-bundle-2.3.0/user-files/simulations</code>, 会在该路经下面生成一个<code>RecordedSimulation.scala</code>的文件（上面指定的Class Name）:<br><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/scala-script-location.jpg" alt></p>
</li>
</ul>
<p>3、点击<code>record</code>并在Firefox进行相应操作, 然后点击<code>Stop</code>, 会生成类似下面的脚本: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> computerdatabase </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.gatling.core.Predef._ </span><br><span class="line"><span class="keyword">import</span> io.gatling.http.Predef._</span><br><span class="line"><span class="keyword">import</span> scala.concurrent.duration._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicSimulation</span> <span class="keyword">extends</span> <span class="title">Simulation</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">  val httpConf = http </span><br><span class="line">    .baseURL(<span class="string">"http://computer-database.gatling.io"</span>) </span><br><span class="line">    .acceptHeader(<span class="string">"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"</span>) </span><br><span class="line">    .doNotTrackHeader(<span class="string">"1"</span>)</span><br><span class="line">    .acceptLanguageHeader(<span class="string">"en-US,en;q=0.5"</span>)</span><br><span class="line">    .acceptEncodingHeader(<span class="string">"gzip, deflate"</span>)</span><br><span class="line">    .userAgentHeader(<span class="string">"Mozilla/5.0 (Windows NT 5.1; rv:31.0) Gecko/20100101 Firefox/31.0"</span>)</span><br><span class="line"></span><br><span class="line">  val scn = scenario(<span class="string">"BasicSimulation"</span>)</span><br><span class="line">    .exec(http(<span class="string">"request_1"</span>)</span><br><span class="line">    .get(<span class="string">"/"</span>))</span><br><span class="line">    .pause(<span class="number">5</span>) </span><br><span class="line"></span><br><span class="line">  setUp( </span><br><span class="line">    scn.inject(atOnceUsers(<span class="number">1</span>))</span><br><span class="line">  ).protocols(httpConf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、然后运行 <code>$GATLING_HOME/bin/gatling.sh</code>, 选择 <code>[0] RecordedSimulation</code>, 随后的几个选项直接回车即可生成测试结果: </p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/terminal-gatling-test1.jpg" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/terminal-gatling-test2.jpg" alt></p>
<p>注意看上图最下面那一行, 就是生成测试结果的入口. </p>
<p>具体请看官方文档: <em><a href="https://gatling.io/docs/current/quickstart" rel="external nofollow noopener noreferrer" target="_blank">https://gatling.io/docs/current/quickstart</a></em></p>
<h2 id="使用IDEA编写"><a href="#使用IDEA编写" class="headerlink" title="使用IDEA编写"></a>使用IDEA编写</h2><p>1、首先安装Scala插件: </p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/scala-plugin.jpg" alt></p>
<p>2、安装 scala SDK: </p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/add-scala-sdk02.jpg" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/add-scala-sdk01.jpg" alt></p>
<p>3、编写测试脚本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApiGatlingSimulationTest</span> <span class="keyword">extends</span> <span class="title">Simulation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  val scn: ScenarioBuilder = scenario(<span class="string">"AddAndFindPersons"</span>).repeat(<span class="number">100</span>, <span class="string">"n"</span>) &#123;</span><br><span class="line">    exec(</span><br><span class="line">      http(<span class="string">"AddPerson-API"</span>)</span><br><span class="line">        .post(<span class="string">"http://localhost:8080/persons"</span>)</span><br><span class="line">        .header(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">        .body(StringBody(<span class="string">""</span><span class="string">"&#123;"</span>firstName<span class="string">":"</span>John$&#123;n&#125;<span class="string">","</span>lastName<span class="string">":"</span>Smith$&#123;n&#125;<span class="string">","</span>birthDate<span class="string">":"</span><span class="number">1980</span>-<span class="number">01</span>-<span class="number">01</span><span class="string">", "</span>address<span class="string">": &#123;"</span>country<span class="string">":"</span>pl<span class="string">","</span>city<span class="string">":"</span>Warsaw<span class="string">","</span>street<span class="string">":"</span>Test$&#123;n&#125;<span class="string">","</span>postalCode<span class="string">":"</span><span class="number">02</span>-<span class="number">200</span><span class="string">","</span>houseNo<span class="string">":$&#123;n&#125;&#125;&#125;"</span><span class="string">""</span>))</span><br><span class="line">        .check(status.is(<span class="number">200</span>))</span><br><span class="line">    ).pause(Duration.apply(<span class="number">5</span>, TimeUnit.MILLISECONDS))</span><br><span class="line">  &#125;.repeat(<span class="number">1000</span>, <span class="string">"n"</span>) &#123;</span><br><span class="line">    exec(</span><br><span class="line">      http(<span class="string">"GetPerson-API"</span>)</span><br><span class="line">        .get(<span class="string">"http://localhost:8080/persons/$&#123;n&#125;"</span>)</span><br><span class="line">        .check(status.is(<span class="number">200</span>))</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setUp(scn.inject(atOnceUsers(<span class="number">30</span>))).maxDuration(FiniteDuration.apply(<span class="number">10</span>, <span class="string">"minutes"</span>))</span><br></pre></td></tr></table></figure>
<p>4、配置pom</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gatling-plugin.version</span>&gt;</span>2.2.4<span class="tag">&lt;/<span class="name">gatling-plugin.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gatling-charts-highcharts.version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">gatling-charts-highcharts.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 性能测试 Gatling --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.gatling.highcharts<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gatling-charts-highcharts<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;gatling-charts-highcharts.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 由于配置了log4j2, 运行Gatling时需要**注释**以下的 exclusions, 否则会抛异常, 但貌似不影响测试结果 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;exclusions&gt;</span></span><br><span class="line"><span class="comment">            &lt;exclusion&gt;</span></span><br><span class="line"><span class="comment">                &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">                &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">            &lt;/exclusion&gt;</span></span><br><span class="line"><span class="comment">        &lt;/exclusions&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Gatling Maven 插件, 使用: mvn gatling:execute 命令运行 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.gatling<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gatling-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;gatling-plugin.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 测试脚本 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">simulationClass</span>&gt;</span>com.yangbingdong.springbootgatling.gatling.DockerTest<span class="tag">&lt;/<span class="name">simulationClass</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 结果输出地址 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">resultsFolder</span>&gt;</span>/home/ybd/test/gatling<span class="tag">&lt;/<span class="name">resultsFolder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>5、运行 Spring Boot 应用</p>
<p>6、运行测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn gatling:execute</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/idea-gatling-test.jpg" alt></p>
<p>我们打开结果中的<code>index.html</code>: </p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/gatling-test-result1.jpg" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/gatling-test-result2.jpg" alt></p>
<h2 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h2><p>途中出现了以下错误</p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/gatling-error1.jpg" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/gatling-error2.jpg" alt></p>
<p>这是由于<strong>使用了Log4J2</strong>, 把Gatling自带的Logback排除了（同一个项目）, 把<code>&lt;exclusions&gt;</code>这一段注释掉就没问题了: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.gatling.highcharts<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gatling-charts-highcharts<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;gatling-charts-highcharts.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 由于配置了log4j2, 运行Gatling时需要**注释**以下的 exclusions, 否则会抛异常, 但貌似不影响测试结果 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>囧. . . . . . </p>
<blockquote>
<p>参考: <em><a href="http://www.spring4all.com/article/584" rel="external nofollow noopener noreferrer" target="_blank">http://www.spring4all.com/article/584</a></em></p>
<p>代码: <em><a href="https://github.com/masteranthoneyd/spring-boot-learning/tree/master/spring-boot-gatling" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/masteranthoneyd/spring-boot-learning/tree/master/spring-boot-gatling</a></em></p>
<p>官方教程: <em><a href="https://gatling.io/docs/current/advanced_tutorial/" rel="external nofollow noopener noreferrer" target="_blank">https://gatling.io/docs/current/advanced_tutorial/</a></em></p>
</blockquote>
<h1 id="ContPerf"><a href="#ContPerf" class="headerlink" title="ContPerf"></a>ContPerf</h1><p>ContiPerf是一个轻量级的<strong>测试</strong>工具, 基于<strong>JUnit</strong>4 开发, 可用于<strong>接口</strong>级的<strong>性能测试</strong>, 快速压测. </p>
<p>引入依赖:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 性能测试 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.databene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>contiperf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="ContiPerf介绍"><a href="#ContiPerf介绍" class="headerlink" title="ContiPerf介绍"></a>ContiPerf介绍</h2><p>可以指定在线程数量和执行次数, 通过限制最大时间和平均执行时间来进行效率测试, 一个简单的例子如下: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContiPerfTest</span> </span>&#123; </span><br><span class="line">    <span class="meta">@Rule</span> </span><br><span class="line">    <span class="keyword">public</span> ContiPerfRule i = <span class="keyword">new</span> ContiPerfRule(); </span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Test</span> </span><br><span class="line">    <span class="meta">@PerfTest</span>(invocations = <span class="number">1000</span>, threads = <span class="number">40</span>) </span><br><span class="line">    <span class="meta">@Required</span>(max = <span class="number">1200</span>, average = <span class="number">250</span>, totalTime = <span class="number">60000</span>) </span><br><span class="line">    publicvoidtest1() throwsException &#123; </span><br><span class="line">        Thread.sleep(<span class="number">200</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>@Rule</code>注释激活ContiPerf, 通过<code>@Test</code>指定测试方法, <code>@PerfTest</code>指定调用次数和线程数量, <code>@Required</code>指定性能要求（每次执行的最长时间, 平均时间, 总时间等）. </p>
<p>也可以通过对类指定<code>@PerfTest</code>和<code>@Required</code>, 表示类中方法的默认设置, 如下: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PerfTest</span>(invocations = <span class="number">1000</span>, threads = <span class="number">40</span>) </span><br><span class="line"><span class="meta">@Required</span>(max = <span class="number">1200</span>, average = <span class="number">250</span>, totalTime = <span class="number">60000</span>) </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContiPerfTest</span> </span>&#123; </span><br><span class="line">    <span class="meta">@Rule</span> </span><br><span class="line">    <span class="keyword">public</span> ContiPerfRule i = <span class="keyword">new</span> ContiPerfRule(); </span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Test</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">        Thread.sleep(<span class="number">200</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="主要参数介绍"><a href="#主要参数介绍" class="headerlink" title="主要参数介绍"></a>主要参数介绍</h2><p>1）PerfTest参数</p>
<p><code>@PerfTest(invocations = 300)</code>: 执行300次, 和线程数量无关, 默认值为1, 表示执行1次；</p>
<p><code>@PerfTest(threads=30)</code>: 并发执行30个线程, 默认值为1个线程；</p>
<p><code>@PerfTest(duration = 20000)</code>: 重复地执行测试至少执行20s. </p>
<p>三个属性可以组合使用, 其中<code>Threads</code>必须和其他两个属性组合才能生效. 当<code>Invocations</code>和<code>Duration</code>都有指定时, 以执行次数多的为准. </p>
<p>　　例, <code>@PerfTest(invocations = 300, threads = 2, duration = 100)</code>, 如果执行方法300次的时候执行时间还没到100ms, 则继续执行到满足执行时间等于100ms, 如果执行到50次的时候已经100ms了, 则会继续执行之100次. </p>
<p>　　如果你不想让测试连续不间断的跑完, 可以通过注释设置等待时间, 例, <code>@PerfTest(invocations = 1000, threads = 10, timer = RandomTimer.class, timerParams = { 30, 80 })</code> , 每执行完一次会等待30~80ms然后才会执行下一次调用. </p>
<p>　　在开多线程进行并发压测的时候, 如果一下子达到最大进程数有些系统可能会受不了, ContiPerf还提供了“预热”功能, 例, <code>@PerfTest(threads = 10, duration = 60000, rampUp = 1000)</code> , 启动时会先起一个线程, 然后每个1000ms起一线程, 到9000ms时10个线程同时执行, 那么这个测试实际执行了69s, 如果只想衡量全力压测的结果, 那么可以在注释中加入warmUp, 即<code>@PerfTest(threads = 10, duration = 60000, rampUp = 1000, warmUp = 9000)</code> , 那么统计结果的时候会去掉预热的9s. </p>
<p>2）Required参数</p>
<p><code>@Required(throughput = 20)</code>: 要求每秒至少执行20个测试；</p>
<p><code>@Required(average = 50)</code>: 要求平均执行时间不超过50ms；</p>
<p><code>@Required(median = 45)</code>: 要求所有执行的50%不超过45ms； </p>
<p><code>@Required(max = 2000)</code>: 要求没有测试超过2s；</p>
<p><code>@Required(totalTime = 5000)</code>: 要求总的执行时间不超过5s；</p>
<p><code>@Required(percentile90 = 3000)</code>: 要求90%的测试不超过3s；</p>
<p><code>@Required(percentile95 = 5000)</code>: 要求95%的测试不超过5s； </p>
<p><code>@Required(percentile99 = 10000)</code>: 要求99%的测试不超过10s; </p>
<p><code>@Required(percentiles = &quot;66:200,96:500&quot;)</code>: 要求66%的测试不超过200ms, 96%的测试不超过500ms. </p>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>测试结果除了会在控制台显示之外, 还会生成一个结果文件<code>target/contiperf-report/index.html</code></p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/contiperf-report.jpg" alt></p>
]]></content><categories><category>Programming</category><category>Java</category><category>Spring Boot</category></categories><tags><tag>Java</tag><tag>Spring Boot</tag><tag>AssertJ</tag><tag>JMH</tag><tag>Gatling</tag><tag>ContPerf</tag></tags></entry><entry><title>Rabbit &amp; Spring AMQP 入门</title><url>/2019/rabbitmq-and-spring-amqp-learning/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/rabbitmq-learning/spring-rabbitmq-banner.png" alt></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><blockquote>
<p>MQ(Message Queue, 消息队列)是一种应用系统之间的通信方法. 是通过读写出入队列的消息来通信(RPC则是通过直接调用彼此来通信的). </p>
<p>AMQP, 即Advanced Message Queuing Protocol, 高级消息队列协议, 是应用层协议的一个开放标准, 为面向消息的中间件设计. 消息中间件主要用于组件之间的解耦, 消息的发送者无需知道消息使用者的存在, 反之亦然.<br>AMQP的主要特征是面向消息, 队列, 路由(包括点对点和发布/订阅), 可靠性, 安全. </p>
<p>RabbitMQ是一个开源的AMQP<strong>实现</strong>, 服务器端用Erlang语言编写. </p>
</blockquote>
<a id="more"></a>
<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>这里使用Docker启动.</p>
<p>docker-compose:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.7'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">my-rabbitmq:latest</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"5672:5672"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"15672:15672"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/var/lib/rabbitmq</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">RABBITMQ_DEFAULT_USER:</span> <span class="string">rabbitmq</span></span><br><span class="line">      <span class="attr">RABBITMQ_DEFAULT_PASS:</span> <span class="string">rabbitmq</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">backend:</span></span><br><span class="line">        <span class="attr">aliases:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">rabbitmq</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">backend:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>先来利用原生的 RabbitMQ Java Client 来运行一个 Hello World 程序:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangbingdong.rabbitmq.basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.AMQP;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Consumer;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.DefaultConsumer;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Envelope;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.yangbingdong.rabbitmq.basic.ConnectionUtil.getConnection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicSingleSendAndReceive</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello0"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicSingleSendAndReceive</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		send();</span><br><span class="line">		receive();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Connection connection = getConnection();</span><br><span class="line">		Channel channel = connection.createChannel();</span><br><span class="line">		channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">		String message = <span class="string">"Hello World!"</span>;</span><br><span class="line">		channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">		System.out.println(<span class="string">"Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line">		channel.close();</span><br><span class="line">		connection.close();</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Connection connection = getConnection();</span><br><span class="line">		Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 声明队列, 主要为了防止消息接收者先运行此程序, 队列还不存在时创建队列.</span></span><br><span class="line">		channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">		Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"consumerTag: "</span> + consumerTag);</span><br><span class="line">				System.out.println(<span class="string">"envelope: "</span> + envelope);</span><br><span class="line">				System.out.println(<span class="string">"properties: "</span> + properties);</span><br><span class="line">				System.out.println(<span class="string">"body: "</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		System.out.println(<span class="string">"Waiting for messages."</span>);</span><br><span class="line">		<span class="comment">// 指定消费队列</span></span><br><span class="line">		channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">		Thread.sleep(<span class="number">100L</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>工具类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yangbingdong.rabbitmq.basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionUtil</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOST = <span class="string">"127.0.0.1"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME_PASS = <span class="string">"rabbitmq"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">		ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">		factory.setHost(HOST);</span><br><span class="line">		factory.setUsername(NAME_PASS);</span><br><span class="line">		factory.setPassword(NAME_PASS);</span><br><span class="line">		<span class="keyword">return</span> factory.newConnection();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<p><img src="https://cdn.yangbingdong.com/img/rabbitmq-learning/basic-single-send-and-receive.png" alt></p>
<h2 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h2><p><code>ConnectionFactory</code>, <code>Connection</code>, <code>Channel</code> 这三个都是RabbitMQ对外提供的API中最基本的对象, 不管是服务器端还是客户端都会首先创建这三类对象.<br><code>ConnectionFactory</code>为<code>Connection</code>的制造工厂.<br><code>Connection</code>是与RabbitMQ服务器的socket链接, 它封装了socket协议及身份验证相关部分逻辑.<br><code>Channel</code>是我们与RabbitMQ打交道的最重要的一个接口, 大部分的业务操作是在Channel这个接口中完成的, 包括定义Queue, 定义Exchange, 绑定Queue与Exchange, 发布消息等.</p>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p>Queue是RabbitMQ的内部对象, 用于存储消息, RabbitMQ中的消息都只能存储在Queue中, 生产者生产消息并最终投递到Queue中, 消费者可以从Queue中获取消息并消费. 队列是有Channel声明的, 而且这个操作是幂等的, 同名的队列多次声明也只会创建一次.</p>
<h2 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h2><blockquote>
<p>RabbitMQ消息模式的核心理念是: 生产者没有直接发送任何消费到队列. 实际上, 生产者都不知道这个消费是发送给哪个队列的.</p>
<p>相反, 生产者只能发送消息给转发器, 转发器是非常简单的. 一方面它接受生产者的消息, 另一方面向队列推送消息. 转发器必须清楚的知道如何处理接收到的消息. 附加一个特定的队列吗? 附加多个队列? 或者是否丢弃? 这些规则通过转发器的类型进行定义.</p>
<p>类型有: <code>Direct</code>, <code>Topic</code>, <code>Headers</code>和<code>Fanout</code></p>
</blockquote>
<h3 id="fanout-exchange"><a href="#fanout-exchange" class="headerlink" title="fanout exchange"></a>fanout exchange</h3><p>发送到该交换器的所有消息, 会被路由到其绑定的所有队列. 该交换器不需要指定routingKey.</p>
<h3 id="direct-exchange"><a href="#direct-exchange" class="headerlink" title="direct exchange"></a>direct exchange</h3><p>发送到该交换器的消息, 会通过路由键完全匹配, 匹配成功就会路由到指定队列.</p>
<p>发送到 <code>direct exchange</code> 的消息, 会通过消息的 <code>routing key</code> 路由:</p>
<ul>
<li>如果 <code>routing key</code> 值为 <code>queue.direct.key1</code>, 会路由到 <code>QUEUE-1</code></li>
<li>如果 <code>routing key</code> 值为 <code>queue.direct.key2</code>, 会路由到 <code>QUEUE-2</code></li>
<li>如果 <code>routing key</code> 值为其他, 不会路由到任何队列</li>
</ul>
<h3 id="topic-exchange"><a href="#topic-exchange" class="headerlink" title="topic exchange"></a>topic exchange</h3><p>发送到该交换器的消息, 会通过路由键模糊匹配, 匹配成功就会路由到指定队列, 路由键通过 <code>.</code> 来划分为多个单词,  <code>*</code> 匹配一个单词,  <code>#</code> 匹配零个或多个单词.</p>
<p>发送到 <code>topic exchange</code> 的消息, 会通过消息的 <code>routing key</code> 模糊匹配再路由:</p>
<ul>
<li>如果 <code>routing key</code> 值为 <code>queue.topic.key1</code>, 会路由到 <code>QUEUE-1</code> 和 <code>QUEUE-2</code></li>
<li>如果 <code>routing key</code> 值为 <code>test.topic.key2</code>, 会路由到 <code>QUEUE-1</code></li>
<li>如果 <code>routing key</code> 值为 <code>queue</code>, 会路由到 <code>QUEUE-2</code></li>
<li>如果 <code>routing key</code> 值为 <code>queue.hello</code>, 会路由到 <code>QUEUE-2</code></li>
<li>如果 <code>routing key</code> 值为 <code>test.test.test</code>, 不会路由到任何队列</li>
</ul>
<h3 id="header-exchange"><a href="#header-exchange" class="headerlink" title="header exchange"></a>header exchange</h3><p>发送到该交换器的消息, 会通过消息的 <code>header</code> 信息匹配, 匹配成功就会路由到指定队列.</p>
<p>消息的 <code>header</code> 信息是 <code>key-value</code> 的形式, 每条消息可以包含多条 <code>header</code> 信息, 路由规则是通过 <code>header</code> 信息的 <code>key</code> 来匹配的, Spring Boot 封装的匹配规则有三种:</p>
<ul>
<li><code>where(key).exists()</code> :匹配单个 <code>key</code></li>
<li><code>whereAll(keys).exist()</code> :同时匹配多个 <code>key</code></li>
<li><code>whereAny(keys).exist()</code> :匹配多个 <code>key</code> 中的一个或多个</li>
</ul>
<p>发送到 <code>headers exchange</code> 的消息, 会通过消息的 <code>header</code> 匹配:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">Binding <span class="title">bindingHeadersQueue1</span><span class="params">(Queue headersQueue1, HeadersExchange headersExchange)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> BindingBuilder.bind(headersQueue1).to(headersExchange).where(<span class="string">"one"</span>).exists();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">Binding <span class="title">bindingHeadersQueue2</span><span class="params">(Queue headersQueue1, HeadersExchange headersExchange)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> BindingBuilder.bind(headersQueue1).to(headersExchange).whereAll(<span class="string">"all1"</span>, <span class="string">"all2"</span>).exist();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">Binding <span class="title">bindingHeadersQueue3</span><span class="params">(Queue headersQueue3, HeadersExchange headersExchange)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> BindingBuilder.bind(headersQueue3).to(headersExchange).whereAny(<span class="string">"any1"</span>, <span class="string">"any2"</span>).exist();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果 <code>header</code> 信息存在 <code>one=XXXX</code>, 会路由到 <code>QUEUE-1</code></li>
<li>如果 <code>header</code> 信息存在 <code>all1=XXXX</code> 和 <code>all2=XXXX</code>, 会路由到 <code>QUEUE-2</code></li>
<li>如果 <code>header</code> 信息存在 <code>any1=XXXX</code> 或 <code>any2=XXXX</code>, 会路由到 <code>QUEUE-3</code></li>
</ul>
<blockquote>
<p><code>header</code> 不能以 <code>x-</code> 开头, 参考官方文档:<a href="https://www.rabbitmq.com/tutorials/amqp-concepts.html#exchange-headers" rel="external nofollow noopener noreferrer" target="_blank">https://www.rabbitmq.com/tutorials/amqp-concepts.html#exchange-headers</a></p>
</blockquote>
<h1 id="Spring-AMQP的几个参数说明"><a href="#Spring-AMQP的几个参数说明" class="headerlink" title="Spring AMQP的几个参数说明"></a>Spring AMQP的几个参数说明</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    addresses: 127.0.0.1:5672</span><br><span class="line">    username: rabbitmq</span><br><span class="line">    password: rabbitmq</span><br><span class="line">    virtual-host: /</span><br><span class="line">    connection-timeout: 15000</span><br><span class="line"></span><br><span class="line">    ## 生产者配置</span><br><span class="line">    # 消息到达 exchange ack</span><br><span class="line">    publisher-confirm-type: correlated</span><br><span class="line">    # 消息被路由到队列 ack</span><br><span class="line">    publisher-returns: true</span><br><span class="line">    template:</span><br><span class="line">      # 必须开启这个才会触发 return callback</span><br><span class="line">      mandatory: true</span><br><span class="line"></span><br><span class="line">    ## 消费端配置</span><br><span class="line">    listener:</span><br><span class="line">      simple:</span><br><span class="line">        #消费并发消费数量, 默认为1</span><br><span class="line">        concurrency: 1</span><br><span class="line">        #最大消费端数</span><br><span class="line">        max-concurrency: 1</span><br><span class="line">        #自动签收auto  手动 manual</span><br><span class="line">        acknowledge-mode: manual</span><br><span class="line">        #限流（海量数据，同时只能过来一条）</span><br><span class="line">        prefetch: 1</span><br></pre></td></tr></table></figure>
<h1 id="ListenerContainer线程池配置"><a href="#ListenerContainer线程池配置" class="headerlink" title="ListenerContainer线程池配置"></a>ListenerContainer线程池配置</h1><p>默认一个消费者对应一个新的线程, 可配置共享线程池节约线程.</p>
<h2 id="Spring-AMQP"><a href="#Spring-AMQP" class="headerlink" title="Spring AMQP"></a>Spring AMQP</h2><p>Spring Boot 的相关配置在 <code>RabbitAutoConfiguration</code> -&gt; <code>RabbitAnnotationDrivenConfiguration</code>.</p>
<p>ListernContainer的线程池可以配置在 <code>SimpleRabbitListenerContainerFactory</code> 中:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = <span class="string">"rabbitListenerContainerFactory"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleRabbitListenerContainerFactory <span class="title">simpleRabbitListenerContainerFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        SimpleRabbitListenerContainerFactoryConfigurer configurer,</span></span></span><br><span class="line"><span class="function"><span class="params">        ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">    SimpleRabbitListenerContainerFactory factory = <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line">    ThreadPoolTaskExecutor taskExecutor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">    taskExecutor.setCorePoolSize(<span class="number">16</span>);</span><br><span class="line">    taskExecutor.setMaxPoolSize(<span class="number">16</span>);</span><br><span class="line">    taskExecutor.setQueueCapacity(<span class="number">500</span>);</span><br><span class="line">    taskExecutor.setKeepAliveSeconds(<span class="number">60</span>);</span><br><span class="line">    taskExecutor.setWaitForTasksToCompleteOnShutdown(<span class="keyword">true</span>);</span><br><span class="line">    taskExecutor.setThreadNamePrefix(<span class="string">"rabbitExecutor-"</span>);</span><br><span class="line">    taskExecutor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">    taskExecutor.initialize();</span><br><span class="line">    factory.setTaskExecutor(taskExecutor);</span><br><span class="line">    configurer.configure(factory, connectionFactory);</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Spring-Cloud-Stream"><a href="#Spring-Cloud-Stream" class="headerlink" title="Spring Cloud Stream"></a>Spring Cloud Stream</h2><p>对于 Spring Cloud Stream, 可以实现 <code>ListenerContainerCustomizer</code> 接口定制化配置:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomListenerContainerCustomizer</span> <span class="keyword">implements</span> <span class="title">ListenerContainerCustomizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Object container, String destinationName, String group)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (container <span class="keyword">instanceof</span> SimpleMessageListenerContainer) &#123;</span><br><span class="line">			<span class="keyword">if</span> (destinationName.equals(MEIYA_QUEUE_ANALIFEBANK_QUEUE)) &#123;</span><br><span class="line">				SimpleMessageListenerContainer simpleMessageListenerContainer = (SimpleMessageListenerContainer) container;</span><br><span class="line">                ThreadPoolTaskExecutor taskExecutor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">                taskExecutor.setCorePoolSize(<span class="number">16</span>);</span><br><span class="line">                taskExecutor.setMaxPoolSize(<span class="number">16</span>);</span><br><span class="line">                taskExecutor.setQueueCapacity(<span class="number">500</span>);</span><br><span class="line">                taskExecutor.setKeepAliveSeconds(<span class="number">60</span>);</span><br><span class="line">                taskExecutor.setWaitForTasksToCompleteOnShutdown(<span class="keyword">true</span>);</span><br><span class="line">                taskExecutor.setThreadNamePrefix(<span class="string">"rabbitExecutor-"</span>);</span><br><span class="line">                taskExecutor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">                taskExecutor.initialize();</span><br><span class="line">                simpleMessageListenerContainer.setTaskExecutor(taskExecutor);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>开启消息持久化可在RabbitMQ重启后不丢失消息.</p>
<blockquote>
<p>在Docker中, 数据存放在 <code>/var/lib/rabbitmq</code> .</p>
</blockquote>
<h2 id="Spring-AMQP-1"><a href="#Spring-AMQP-1" class="headerlink" title="Spring AMQP"></a>Spring AMQP</h2><p>在Spring AMQP中, 通过Queue构造器可指定持久化是否开启:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">delayQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Queue(DELAY_QUEUE, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个参数指的是是否开启持久化:</p>
<p><img src="https://cdn.yangbingdong.com/img/rabbitmq-learning/queue-constructor01.png" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/rabbitmq-learning/queue-constructor02.png" alt></p>
<p>ExChange 指定持久化也一样:</p>
<p><img src="https://cdn.yangbingdong.com/img/rabbitmq-learning/exchange-constructor.png" alt></p>
<h2 id="Spring-Cloud-Stream-1"><a href="#Spring-Cloud-Stream-1" class="headerlink" title="Spring Cloud Stream"></a>Spring Cloud Stream</h2><p>在Spring Cloud Stream中指定Queue与Exchange持久化只需要通过以下两个参数配置, 默认值都为 <code>true</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.cloud.stream.rabbit.bindings.&lt;channelName&gt;.consumer.durableSubscription=</span><br><span class="line">spring.cloud.stream.rabbit.bindings.&lt;channelName&gt;.consumer.exchangeDurable=</span><br></pre></td></tr></table></figure>
<h1 id="手动ACK"><a href="#手动ACK" class="headerlink" title="手动ACK"></a>手动ACK</h1><p>在Spring AMQP中ACK是自动完成的, 如果报错了, 消息不会丢失, 但是会无限循环消费, 一直报错, 如果开启了错误日志很容易就把磁盘空间耗完.</p>
<p>在Spring Cloud Stream中默认情况下会自动重试3次, 再自动ACK. 可通过 <code>maxAttempts</code> 参数指定重试次数. </p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="Spring-Cloud-Stream-2"><a href="#Spring-Cloud-Stream-2" class="headerlink" title="Spring Cloud Stream"></a>Spring Cloud Stream</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.cloud.stream.rabbit.bindings.&lt;channelName&gt;.consumer.acknowledgeMode=MANUAL</span><br></pre></td></tr></table></figure>
<h3 id="Spring-AMQP-2"><a href="#Spring-AMQP-2" class="headerlink" title="Spring AMQP"></a>Spring AMQP</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.rabbitmq.listener.simple.acknowledge-mode=MANUAL</span><br></pre></td></tr></table></figure>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><h3 id="Spring-Cloud-Stream-3"><a href="#Spring-Cloud-Stream-3" class="headerlink" title="Spring Cloud Stream"></a>Spring Cloud Stream</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableBinding</span>(AckTopic<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Component</span></span></span><br><span class="line"><span class="class">@<span class="title">Slf4j</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">AckTopicListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@StreamListener</span>(AckTopic.INPUT)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Message&lt;String&gt; message, @Header(AmqpHeaders.CHANNEL)</span> Channel channel,</span></span><br><span class="line"><span class="function">						@<span class="title">Header</span><span class="params">(AmqpHeaders.DELIVERY_TAG)</span> Long deliveryTag) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		log.info(<span class="string">"Received: "</span> + message.getPayload());</span><br><span class="line">		channel.basicAck(deliveryTag, <span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 <code>channel.basicAck(deliveryTag, false)</code> 进行ACK.</li>
<li><code>Channel</code> 也可以通过 <code>message.getHeaders().get(AmqpHeaders.CHANNEL, Channel.class)</code> 获取, <code>deliveryTag</code> 也一样.</li>
</ul>
<h3 id="Spring-AMQP-3"><a href="#Spring-AMQP-3" class="headerlink" title="Spring AMQP"></a>Spring AMQP</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"ack_queue"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(List&lt;Integer&gt; list, Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            dosomething.....</span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"============消费失败,尝试消息补发再次消费!=============="</span>);</span><br><span class="line">            log.error(e.getMessage());</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * basicRecover方法是进行补发操作, </span></span><br><span class="line"><span class="comment">             * 其中的参数如果为true是把消息退回到queue但是有可能被其它的consumer(集群)接收到, </span></span><br><span class="line"><span class="comment">             * 设置为false是只补发给当前的consumer</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            channel.basicRecover(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Spring-Boot-中使用方式"><a href="#Spring-Boot-中使用方式" class="headerlink" title="Spring Boot 中使用方式"></a>Spring Boot 中使用方式</h1><h2 id="创建队列交换机"><a href="#创建队列交换机" class="headerlink" title="创建队列交换机"></a>创建队列交换机</h2><h3 id="通过-RabbitListener创建"><a href="#通过-RabbitListener创建" class="headerlink" title="通过@RabbitListener创建"></a>通过@RabbitListener创建</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(</span><br><span class="line">        bindings = <span class="meta">@QueueBinding</span>(</span><br><span class="line">                value = <span class="meta">@Queue</span>(value = <span class="string">"test-topic"</span>,durable = <span class="string">"true"</span>),</span><br><span class="line">                exchange = <span class="meta">@Exchange</span>(name = <span class="string">"test-topic"</span>),</span><br><span class="line">                key=<span class="string">"test-topic"</span></span><br><span class="line">        )</span><br><span class="line">)</span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(@Payload TestMessage testMessage, @Headers Map&lt;String,Object&gt; headers, Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.info(<span class="string">"收到消息, 当前线程: &#123;&#125;, 消息内容: &#123;&#125;"</span>, Thread.currentThread().getId(), testMessage);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 更新为消费失败</span></span><br><span class="line">        log.error(<span class="string">"消费异常"</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// multiple 为 true 代表批量确认</span></span><br><span class="line">        channel.basicAck((Long) headers.get(AmqpHeaders.DELIVERY_TAG),<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通过声明Bean创建"><a href="#通过声明Bean创建" class="headerlink" title="通过声明Bean创建"></a>通过声明Bean创建</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">delayQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Queue(DELAY_QUEUE, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通过RabbitAdmin动态注册"><a href="#通过RabbitAdmin动态注册" class="headerlink" title="通过RabbitAdmin动态注册"></a>通过RabbitAdmin动态注册</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RabbitAdmin <span class="title">rabbitAdmin</span><span class="params">(ConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RabbitAdmin(connectionFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource</span>(factory = YamlPropertySourceFactory<span class="class">.<span class="keyword">class</span>, <span class="title">value</span> </span>= <span class="string">"classpath:MQ-CONF/topic.yml"</span>)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(MessagingProperty<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MessagingConfiguration</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessagingProperty messagingProperty;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RabbitAdmin rabbitAdmin;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessagingConfiguration</span><span class="params">(MessagingProperty messagingProperty, RabbitAdmin rabbitAdmin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.messagingProperty = messagingProperty;</span><br><span class="line">        <span class="keyword">this</span>.rabbitAdmin = rabbitAdmin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (MqType.RABBIT.equals(messagingProperty.getMqType())) &#123;</span><br><span class="line">            registryRabbit(messagingProperty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registryRabbit</span><span class="params">(MessagingProperty messagingProperty)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (MessagingProperty.Topic topic : messagingProperty.getTopics()) &#123;</span><br><span class="line">            String topicName = topic.getName();</span><br><span class="line">            Queue queue = <span class="keyword">new</span> Queue(topicName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">            DirectExchange exchange = <span class="keyword">new</span> DirectExchange(topicName, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">            exchange.setDelayed(parseBoolean(topic.getProperties().getOrDefault(<span class="string">"delayed"</span>, <span class="string">"false"</span>)));</span><br><span class="line">            Binding binding = BindingBuilder.bind(queue).to(exchange).with(topicName);</span><br><span class="line">            rabbitAdmin.declareQueue(queue);</span><br><span class="line">            rabbitAdmin.declareExchange(exchange);</span><br><span class="line">            rabbitAdmin.declareBinding(binding);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>topic.yml</code>:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">messaging:</span></span><br><span class="line">  <span class="attr">mqType:</span> <span class="string">rabbit</span></span><br><span class="line">  <span class="attr">topics:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-topic</span></span><br><span class="line">      <span class="attr">properties:</span></span><br><span class="line">        <span class="attr">delayed:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMqConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"test-topic"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOrderMessage</span><span class="params">(@Payload TestMessage testMessage, @Headers Map&lt;String,Object&gt; headers, Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">"收到消息, 当前线程: &#123;&#125;, 消息内容: &#123;&#125;"</span>, Thread.currentThread().getId(), testMessage);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 更新为消费失败</span></span><br><span class="line">            log.error(<span class="string">"消费异常"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// multiple 为 true 代表批量确认</span></span><br><span class="line">            channel.basicAck((Long) headers.get(AmqpHeaders.DELIVERY_TAG),<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@RabbitListener</code>注解的消费者监听方法, 默认有几个可以自动注入的参数对象:</p>
<ul>
<li><code>org.springframework.amqp.core.Message</code> 消息原始对象</li>
<li><code>com.rabbitmq.client.Channel</code> 接收消息所所在的<code>channel</code></li>
<li><code>org.springframework.messaging.Message</code> amqp的原始消息对象转换为messaging后的消息对象, 该消息包含自定义消息头和标准的amqp消息头</li>
</ul>
<p>此外, 非以上参数, 自定义参数对象可以通过<code>@Header</code>/<code>@Headers</code>/<code>@Payload</code>标注为消息头或消息体接受对象.</p>
<h1 id="DLQ队列"><a href="#DLQ队列" class="headerlink" title="DLQ队列"></a>DLQ队列</h1><p>通过下面参数开启DLQ转发:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.cloud.stream.rabbit.bindings.&lt;channelName&gt;.consumer.auto-bind-dlq=true</span><br></pre></td></tr></table></figure>
<p>当消息消费失败后, 消息会原封不动地转发到 <code>error-topic.test.dlq</code> 这个死信队列中.</p>
<p><img src="https://cdn.yangbingdong.com/img/rabbitmq-learning/rabbit-error-dlq01.png" alt></p>
<p>点击进入死信队列, 可以使用 <code>Get Message</code> 查看消息, <code>Move message</code> 可以将消息移动到原先的队列中继续消费.</p>
<p><img src="https://cdn.yangbingdong.com/img/rabbitmq-learning/rabbit-error-dlq02.png" alt></p>
<p><strong>设置死信队列消息过期时间</strong>:</p>
<p>如果某些消息存在时效性, 可通过一下参数配置过期时间, 超过时间后, 消息会自动移除掉:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.cloud.stream.rabbit.bindings.&lt;channelName&gt;.consumer.dlq-ttl=10000</span><br></pre></td></tr></table></figure>
<p>将异常信息放到消息header中:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.cloud.stream.rabbit.bindings.&lt;channelName&gt;.consumer.republish-to-dlq=true</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.yangbingdong.com/img/rabbitmq-learning/rabbit-error-dlq03.png" alt></p>
<h1 id="重新入队"><a href="#重新入队" class="headerlink" title="重新入队"></a>重新入队</h1><p>重新入队是指消息消费失败了之后, 消息将不会被抛弃, 而是重新放入队列中. </p>
<p>可以通过以下参数开启:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.cloud.stream.rabbit.bindings.&lt;channelName&gt;.consumer.requeue-rejected=true</span><br></pre></td></tr></table></figure>
<p>这样会导致一个问题就是, 业务代码的缺陷导致的异常, 无论消费多少次, 这个消息总是失败的. 那么会导致消息堆积越来越大, 那么可以通过配合DLQ来避免这个情况:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.cloud.stream.rabbit.bindings.&lt;channelName&gt;.consumer.auto-bind-dlq=true</span><br></pre></td></tr></table></figure>
<p>然后到达一定重试次数之后抛出 <code>AmqpRejectAndDontRequeueException</code> 这个指定的异常, 消息就会被推到死信队列中了:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@StreamListener</span>(TestTopic.INPUT)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String payload)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"Received payload : "</span> + payload + <span class="string">", "</span> + count);</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">3</span>) &#123;</span><br><span class="line">        count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AmqpRejectAndDontRequeueException(<span class="string">"tried 3 times failed, send to dlq!"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        count ++;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Message consumer failed!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong>:</p>
<p>上面介绍了几种Spring Cloud Stream RabbitMQ中的重试策略, 个人认为比较适合实际业务场景的做法是, 失败后, 将消息持久化到数据库中, 后续再通过邮件或钉钉等方式通知开发人员进行处理. 因为一般场景下 , 绝大部分的异常消息都是由于业务代码的缺陷导致的, 所以怎么重试都会失败, 并且消费逻辑中一定要做好<strong>幂等</strong>校验.</p>
<h1 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h1><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>RabbitMQ的延迟队列可以通过<strong>死信队列</strong>来实现, 但这种方式显得比较臃肿并且有致命的缺陷(设置了不同的过期时间, 队列并不会按照这些过期时间来顺序消费), 具体请参考:  <strong><em><a href="https://blog.csdn.net/eumenides_/article/details/86025773" rel="external nofollow noopener noreferrer" target="_blank">springboot整合rabbitmq实现延时队列之TTL方式</a></em></strong> </p>
<p>比较优雅的方式是通过 <code>rabbitmq_delayed_message_exchange</code> 插件来实现延迟队列. 插件介绍可查看官网: <strong><em><a href="https://www.rabbitmq.com/blog/2015/04/16/scheduling-messages-with-rabbitmq/" rel="external nofollow noopener noreferrer" target="_blank">https://www.rabbitmq.com/blog/2015/04/16/scheduling-messages-with-rabbitmq/</a></em></strong></p>
<p>流程大概是这样的:</p>
<p>1: 生产者将消息(msg)和路由键(routekey)发送指定的延时交换机(exchange)上</p>
<p>2: 延时交换机(exchange)存储消息等待消息到期根据路由键(routekey)找到绑定自己的队列(queue)并把消息给它</p>
<p>3: 队列(queue)再把消息发送给监听它的消费者(customer）</p>
<h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><blockquote>
<p>只有RabbitMQ 3.6.x以上才支持</p>
</blockquote>
<p>这里使用Docker部署, <code>rabbitmq_delayed_message_exchange</code>插件需要到 <strong><em><a href="https://www.rabbitmq.com/community-plugins.html" rel="external nofollow noopener noreferrer" target="_blank">官网下载</a></em></strong>.</p>
<p><img src="https://cdn.yangbingdong.com/img/rabbitmq-learning/rabbitmq-x-delay-plugin.png" alt></p>
<p>Dockerfile:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM rabbitmq:3.7-management</span><br><span class="line">COPY --chown=rabbitmq:rabbitmq rabbitmq_delayed_message_exchange-20171201-3.7.x.ez /opt/rabbitmq/plugins/</span><br><span class="line">COPY --chown=rabbitmq:rabbitmq enabled_plugins /etc/rabbitmq/enabled_plugins</span><br></pre></td></tr></table></figure>
<p>enable_plugins:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[rabbitmq_delayed_message_exchange,rabbitmq_management].</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>: 插件需要解压放到Dockerfile根目录.</p>
</blockquote>
<p>或者这个Dockerfile也可以:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM rabbitmq:3.7-management</span><br><span class="line">COPY --chown=rabbitmq:rabbitmq rabbitmq_delayed_message_exchange-20171201-3.7.x.ez /opt/rabbitmq/plugins/</span><br><span class="line">RUN rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure>
<p>构建:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t my-rabbitmq .</span><br></pre></td></tr></table></figure>
<h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><h3 id="Spring-Cloud-Stream-4"><a href="#Spring-Cloud-Stream-4" class="headerlink" title="Spring Cloud Stream"></a>Spring Cloud Stream</h3><p><code>application.yml</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">rabbitmq-learning</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.6</span><span class="number">.113</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">rabbitmq</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">rabbitmq</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">include:</span> <span class="string">stream-rabbitmq-delay</span></span><br></pre></td></tr></table></figure>
<p><code>application-stream-rabbitmq-delay.yml</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">contentType:</span> <span class="string">application/json</span></span><br><span class="line">        <span class="attr">consumer:</span></span><br><span class="line">          <span class="attr">maxAttempts:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">bindings:</span></span><br><span class="line">        <span class="attr">delay-topic-output:</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">delay-topic</span></span><br><span class="line">        <span class="attr">delay-topic-input:</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">delay-topic</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">test</span></span><br><span class="line">      <span class="attr">rabbit:</span></span><br><span class="line">        <span class="attr">bindings:</span></span><br><span class="line">          <span class="attr">delay-topic-output:</span></span><br><span class="line">            <span class="attr">producer:</span></span><br><span class="line">              <span class="attr">delayedExchange:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">delay-topic-input:</span></span><br><span class="line">            <span class="attr">consumer:</span></span><br><span class="line">              <span class="attr">delayedExchange:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>delayedExchange</code> 设置为<code>true</code>表示将 <code>exchange</code> 声明为 <code>Delayed Message Exchange</code>. <strong>生产者以及消费者都需要配置</strong>这个, 否则会报以下错误:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Channel shutdown: channel error; protocol method: #method&lt;channel.close&gt;(reply-code=406, reply-text=PRECONDITION_FAILED - inequivalent arg &apos;type&apos; for exchange &apos;delay-topic&apos; in vhost &apos;/&apos;: received &apos;topic&apos; but current is &apos;&apos;x-delayed-message&apos;&apos;, class-id=40, method-id=10)</span><br></pre></td></tr></table></figure>
<p>代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DelayTopic</span> </span>&#123;</span><br><span class="line">	String OUTPUT = <span class="string">"delay-topic-output"</span>;</span><br><span class="line">	String INPUT = <span class="string">"delay-topic-input"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Output</span>(OUTPUT)</span><br><span class="line">	<span class="function">MessageChannel <span class="title">output</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Input</span>(INPUT)</span><br><span class="line">	<span class="function">SubscribableChannel <span class="title">input</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableBinding</span>(DelayTopic<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Component</span></span></span><br><span class="line"><span class="class">@<span class="title">Slf4j</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">DelayTopicListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@StreamListener</span>(DelayTopic.INPUT)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String payload)</span> </span>&#123;</span><br><span class="line">		log.info(<span class="string">"Received: "</span> + payload);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发送延迟消息:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XDelaySender</span> <span class="keyword">extends</span> <span class="title">SpringBootRabbitmqApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> DelayTopic delayTopic;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendDelay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		delayTopic.output().send(MessageBuilder.withPayload(<span class="string">"Hello World "</span>).setHeader(<span class="string">"x-delay"</span>, <span class="number">5000</span>).build());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果, 可以看到发送与接受之间差了5秒:</p>
<p><img src="https://cdn.yangbingdong.com/img/rabbitmq-learning/stream-rabbit-delay01.png" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/rabbitmq-learning/stream-rabbit-delay02.png" alt></p>
<h3 id="Spring-AMQP-4"><a href="#Spring-AMQP-4" class="headerlink" title="Spring AMQP"></a>Spring AMQP</h3><p>Configuration:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMqConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> DirectExchange <span class="title">delayExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DirectExchange exchange = <span class="keyword">new</span> DirectExchange(topicName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        exchange.setDelayed(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Queue <span class="title">delayQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Queue(DELAY_QUEUE, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Binding <span class="title">delayBinging</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> BindingBuilder.bind(delayQueue()).to(delayExchange()).with(DELAY_ROUTING_KEY);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常量类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MqConstant</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAY_EXCHANGE = <span class="string">"delay_exchange"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAY_QUEUE = <span class="string">"delay_queue.ybd"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DELAY_ROUTING_KEY = <span class="string">"delay_routing_key"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生产者:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitProduct</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendDelayMessage</span><span class="params">(User user, Integer delay)</span> </span>&#123;</span><br><span class="line">		log.info(<span class="string">"发送时间:&#123;&#125;,发送内容:&#123;&#125;"</span>, LocalDateTime.now(), user);</span><br><span class="line">		rabbitTemplate.convertAndSend(</span><br><span class="line">				DELAY_EXCHANGE,</span><br><span class="line">				DELAY_ROUTING_KEY,</span><br><span class="line">				user,</span><br><span class="line">				message -&gt; &#123;</span><br><span class="line">					message.getMessageProperties().setDelay(delay);</span><br><span class="line">					<span class="keyword">return</span> message;</span><br><span class="line">				&#125;</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费者:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RabbitListener</span>(queues = MqConstant.DELAY_QUEUE)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delayQueueListener</span><span class="params">(User user, Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		log.info(<span class="string">"接收时间:&#123;&#125;,接受内容:&#123;&#125;"</span>, LocalDateTime.now(), user);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"处理业务逻辑中"</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查看延迟消息数量"><a href="#查看延迟消息数量" class="headerlink" title="查看延迟消息数量"></a>查看延迟消息数量</h2><p>这个可以通过RabbitMQ的管理页面查看:</p>
<p><img src="https://cdn.yangbingdong.com/img/rabbitmq-learning/x-dalay-admin01.png" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/rabbitmq-learning/x-dalay-admin02.png" alt></p>
<h1 id="独占队列"><a href="#独占队列" class="headerlink" title="独占队列"></a>独占队列</h1><p>某些场景下, 我们对消息的处理具有<strong>严格的顺序</strong>依赖性, 比如下一个消息的处理需要基于上一个消息的处理结果.</p>
<p>这时候, 一般比较暴力的做法就是只部署一台消费者. 还有另外一种做法便是独占队列.</p>
<p>以RabbitMQ为例, 使用注解的话只需要多加一个 <code>exclusive = true</code> 的参数:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"$&#123;items.updated.queue&#125;"</span>, exclusive = <span class="keyword">true</span>)</span><br></pre></td></tr></table></figure>
<p>Spring Cloud Stream 配置:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">stream:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">contentType:</span> <span class="string">application/json</span></span><br><span class="line">        <span class="attr">consumer:</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">bindings:</span></span><br><span class="line">        <span class="attr">input:</span></span><br><span class="line">          <span class="attr">binder:</span> <span class="string">rabbit</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">test_queue</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">test_group</span></span><br><span class="line">        <span class="attr">output :</span></span><br><span class="line">          <span class="attr">binder:</span> <span class="string">rabbit</span></span><br><span class="line">          <span class="attr">destination:</span> <span class="string">test_queue</span></span><br><span class="line">      <span class="attr">rabbit:</span></span><br><span class="line">        <span class="attr">bindings:</span></span><br><span class="line">          <span class="attr">input:</span></span><br><span class="line">            <span class="attr">consumer:</span></span><br><span class="line">              <span class="comment"># 消费者启用独占模式</span></span><br><span class="line">              <span class="attr">exclusive:</span> <span class="literal">true</span></span><br><span class="line">              <span class="comment"># 如果多个消费者则只有一个成功, 其他的消费者会不断地进行重试, 默认间隔为 5000ms</span></span><br><span class="line">              <span class="attr">recoveryInterval:</span> <span class="number">600000</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>recoveryInterval</code>: 由于RabbitMq的独占队列只有一个消费者能成功订阅, 后面的消费者都会失败并不断地重试, 我们可以将重试时间调大一点(默认为5000ms).</li>
</ul>
<p>并且会有一个 WARN 级别的日志打印出来, 我们可以自己实现 <code>ConditionalExceptionLogger</code> 接口将日志改为 INFO 级别:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomConditionalExceptionLogger</span> <span class="keyword">implements</span> <span class="title">ConditionalExceptionLogger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(Log logger, String message, Throwable t)</span> </span>&#123;</span><br><span class="line">		logger.info(<span class="string">"Exclusive fail"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注入到 <code>SimpleMessageListenerContainer</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomListenerContainerCustomizer</span> <span class="keyword">implements</span> <span class="title">ListenerContainerCustomizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Object container, String destinationName, String group)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (container <span class="keyword">instanceof</span> SimpleMessageListenerContainer) &#123;</span><br><span class="line">			<span class="keyword">if</span> (destinationName.equals(TEST_QUEUE)) &#123;</span><br><span class="line">				SimpleMessageListenerContainer simpleMessageListenerContainer = (SimpleMessageListenerContainer) container;</span><br><span class="line">				simpleMessageListenerContainer.setExclusiveConsumerExceptionLogger(<span class="keyword">new</span> CustomConditionalExceptionLogger());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册到Spring容器:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListenerContainerCustomizer <span class="title">customListenerContainerCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> CustomListenerContainerCustomizer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启用了独占模式的队列中, 可以看到这个:</p>
<p><img src="https://cdn.yangbingdong.com/img/rabbitmq-learning/rabbitmq-exclusive.png" alt></p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="多Binder配置"><a href="#多Binder配置" class="headerlink" title="多Binder配置"></a>多Binder配置</h2><p><code>spring.cloud.stream.bindings.{channel-name}.binder</code>:设定指定通道binder名称，完全自定义；<br><code>spring.cloud.stream.binders.{binder-name}.type</code>：对自定义的binder设定其类型，rabbit或者kafka；<br><code>spring.cloud.stream.binders.{binder-name}.environment.{*}</code>：对自定义的binder设定其配置项，如host等；<br><code>spring.cloud.stream.default-binder</code>：除了特殊的通道需要设定binder，其他的channel需要从所有自定义的binder选择一个作为默认binder，即所有非指定binder的通道均采用此<code>default-binder</code></p>
<h1 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h1><blockquote>
<p>参考:</p>
<p><strong><em><a href="https://www.kancloud.cn/longxuan/rabbitmq-arron" rel="external nofollow noopener noreferrer" target="_blank">https://www.kancloud.cn/longxuan/rabbitmq-arron</a></em></strong></p>
<p><strong><em><a href="http://blog.didispace.com/spring-cloud-starter-finchley-7-7/" rel="external nofollow noopener noreferrer" target="_blank">http://blog.didispace.com/spring-cloud-starter-finchley-7-7/</a></em></strong></p>
<p><strong><em><a href="https://blog.csdn.net/eumenides_/article/details/86025773" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/eumenides_/article/details/86025773</a></em></strong></p>
<p><strong><em><a href="https://blog.csdn.net/songhaifengshuaige/article/details/79266444" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/songhaifengshuaige/article/details/79266444</a></em></strong></p>
</blockquote>
]]></content><categories><category>Programming</category><category>Java</category></categories><tags><tag>Java</tag><tag>Spring Boot</tag><tag>Spring Cloud</tag><tag>RabbitMQ</tag></tags></entry><entry><title>Spring Data JPA 拾遗</title><url>/2019/spring-boot-data-jpa-learning/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/spring-boot-orm/jpa-logo.png" alt></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><blockquote>
<p> JPA在国内的使用频率较小, 但也是一个值得学习的极为优秀的ORM框架, DDD的思想在里面体现得淋漓尽致.</p>
</blockquote>
<a id="more"></a>
<h1 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h1><p><img src="https://cdn.yangbingdong.com/img/spring-boot-orm/jpa-struct.png" alt></p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">generate-ddl:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">show-sql:</span> <span class="literal">true</span> <span class="comment"># 打印SQL</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">create</span> <span class="comment"># create、create-drop、update、validate、none</span></span><br><span class="line">      <span class="attr">naming:</span></span><br><span class="line"><span class="comment">#        physical-strategy: com.example.MyPhysicalNamingStrategy</span></span><br><span class="line"><span class="comment">#    properties:</span></span><br><span class="line"><span class="comment">#      hibernate:</span></span><br><span class="line"><span class="comment">#        dialect: org.hibernate.dialect.MySQL5Dialect  # 方言设置，默认就为MySQL5Dialect，或者MySQL5InnoDBDialect使用InnoDB引擎</span></span><br></pre></td></tr></table></figure>
<h2 id="默认驼峰模式"><a href="#默认驼峰模式" class="headerlink" title="默认驼峰模式"></a>默认驼峰模式</h2><p>Spring Data Jpa 使用的默认策略是 <code>SpringPhysicalNamingStrategy</code> 与 <code>SpringImplicitNamingStrategy</code>, 就是驼峰模式的实现.</p>
<p>可以这样修改命名策略：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#PhysicalNamingStrategyStandardImpl</span><br><span class="line">spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl</span><br></pre></td></tr></table></figure>
<p>如果需要指定某个字段不使用驼峰模式可以直接使用<code>@Column(name = &quot;aaa&quot;)</code></p>
<h1 id="基础CRUD操作"><a href="#基础CRUD操作" class="headerlink" title="基础CRUD操作"></a>基础CRUD操作</h1><p>集成 <code>JpaRepository&lt;T, ID&gt;</code> , T为实体, ID为实体id:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function">Page&lt;User&gt; <span class="title">findByName</span><span class="params">(String name, Pageable pageable)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Controller:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterable&lt;User&gt; <span class="title">getAllUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> userRepository.findAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNewUser</span><span class="params">(@Valid @RequestBody User user)</span> </span>&#123;</span><br><span class="line">	userRepository.save(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证排序和分页查询方法，Pageable的默认实现类：PageRequest</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(path = <span class="string">"/page"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Page&lt;User&gt; <span class="title">getAllUserByPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> userRepository.findAll(PageRequest.of(<span class="number">0</span>, <span class="number">2</span>, Sort.by(<span class="keyword">new</span> Sort.Order(Sort.Direction.ASC,<span class="string">"name"</span>))));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 排序查询方法，使用Sort对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(path = <span class="string">"/sort"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterable&lt;User&gt; <span class="title">getAllUsersWithSort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> userRepository.findAll(Sort.by(<span class="keyword">new</span> Sort.Order(Sort.Direction.ASC,<span class="string">"name"</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-orm/simple-jpa-repository-method.png" alt></p>
<p><code>JpaRepository</code> 的默认实现类是 <code>SimpleJpaRepository</code>, 可以看到提供了大部分通用的方法.</p>
<h1 id="定义查询方法"><a href="#定义查询方法" class="headerlink" title="定义查询方法"></a>定义查询方法</h1><h2 id="方法的查询策略设置"><a href="#方法的查询策略设置" class="headerlink" title="方法的查询策略设置"></a>方法的查询策略设置</h2><p>通过下面的命令来配置方法的查询策略(在<code>JpaRepositoriesAutoConfigureRegistrar</code>中已经自动配置, 实际Spring Boot项目中我们只需要引入JPA依赖即可, 不需要手动显示配置)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableJpaRepositories</span>(queryLookupStrategy= QueryLookupStrategy.Key.CREATE_IF_NOT_FOUND)</span><br></pre></td></tr></table></figure>
<p><code>QueryLookupStrategy.Key</code> 的值一共就三个：</p>
<ul>
<li><code>Create</code>：直接根据方法名进行创建，规则是根据方法名称的构造进行尝试，一般的方法是从方法名中删除给定的一组已知前缀，并解析该方法的其余部分。如果方法名不符合规则，启动的时候会报异常。</li>
<li><code>USE_DECLARED_QUERY</code>：声明方式创建，即本书说的注解的方式。启动的时候会尝试找到一个声明的查询，如果没有找到将抛出一个异常，查询可以由某处注释或其他方法声明。</li>
<li><code>CREATE_IF_NOT_FOUND</code>：这个是默认的，以上两种方式的结合版。先用声明方式进行查找，如果没有找到与方法相匹配的查询，那用 Create 的方法名创建规则创建一个查询。</li>
</ul>
<h2 id="查询方法的创建"><a href="#查询方法的创建" class="headerlink" title="查询方法的创建"></a>查询方法的创建</h2><p>Spring Data 中有一套自己的方法命名查询规范, 一般是前缀 find…By、read…By、query…By、count…By 和 get…By等, <code>org.springframework.data.repository.query.parser.PartTree</code>:</p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-orm/part-tree-class.png" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-orm/subject-class.png" alt></p>
<p>Ex:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">   <span class="comment">// and的查询关系</span></span><br><span class="line">   <span class="function">List&lt;User&gt; <span class="title">findByEmailAddressAndLastname</span><span class="params">(EmailAddress emailAddress, String lastname)</span></span>;</span><br><span class="line">   <span class="comment">// 包含distinct去重，or的sql语法</span></span><br><span class="line">   <span class="function">List&lt;User&gt; <span class="title">findDistinctPeopleByLastnameOrFirstname</span><span class="params">(String lastname, String firstname)</span></span>;</span><br><span class="line">   <span class="function">List&lt;User&gt; <span class="title">findPeopleDistinctByLastnameOrFirstname</span><span class="params">(String lastname, String firstname)</span></span>;</span><br><span class="line">   <span class="comment">// 根据lastname字段查询忽略大小写</span></span><br><span class="line">   <span class="function">List&lt;User&gt; <span class="title">findByLastnameIgnoreCase</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">   <span class="comment">// 根据lastname和firstname查询equal并且忽略大小写</span></span><br><span class="line">   <span class="function">List&lt;User&gt; <span class="title">findByLastnameAndFirstnameAllIgnoreCase</span><span class="params">(String lastname, String firstname)</span></span>; </span><br><span class="line">  <span class="comment">// 对查询结果根据lastname排序</span></span><br><span class="line">   <span class="function">List&lt;User&gt; <span class="title">findByLastnameOrderByFirstnameAsc</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">   <span class="function">List&lt;User&gt; <span class="title">findByLastnameOrderByFirstnameDesc</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用的时候要配合不同的返回结果进行使用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">long</span> <span class="title">countByLastname</span><span class="params">(String lastname)</span></span>;<span class="comment">//查询总数</span></span><br><span class="line">     <span class="function"><span class="keyword">long</span> <span class="title">deleteByLastname</span><span class="params">(String lastname)</span></span>;<span class="comment">//根据一个字段进行删除操作</span></span><br><span class="line">     <span class="function">List&lt;User&gt; <span class="title">removeByLastname</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##方法命名查询关键字列表</p>
<table>
<thead>
<tr>
<th>Keyword</th>
<th>Sample</th>
<th>JPQL snippet</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>And</code></td>
<td><code>findByLastnameAndFirstname</code></td>
<td><code>… where x.lastname = ?1 and x.firstname = ?2</code></td>
</tr>
<tr>
<td><code>Or</code></td>
<td><code>findByLastnameOrFirstname</code></td>
<td><code>… where x.lastname = ?1 or x.firstname = ?2</code></td>
</tr>
<tr>
<td><code>Is,Equals</code></td>
<td><code>findByFirstname</code>,<code>findByFirstnameIs</code>,<code>findByFirstnameEquals</code></td>
<td><code>… where x.firstname = ?1</code></td>
</tr>
<tr>
<td><code>Between</code></td>
<td><code>findByStartDateBetween</code></td>
<td><code>… where x.startDate between ?1 and ?2</code></td>
</tr>
<tr>
<td><code>LessThan</code></td>
<td><code>findByAgeLessThan</code></td>
<td><code>… where x.age &lt; ?1</code></td>
</tr>
<tr>
<td><code>LessThanEqual</code></td>
<td><code>findByAgeLessThanEqual</code></td>
<td><code>… where x.age &lt;= ?1</code></td>
</tr>
<tr>
<td><code>GreaterThan</code></td>
<td><code>findByAgeGreaterThan</code></td>
<td><code>… where x.age &gt; ?1</code></td>
</tr>
<tr>
<td><code>GreaterThanEqual</code></td>
<td><code>findByAgeGreaterThanEqual</code></td>
<td><code>… where x.age &gt;= ?1</code></td>
</tr>
<tr>
<td><code>After</code></td>
<td><code>findByStartDateAfter</code></td>
<td><code>… where x.startDate &gt; ?1</code></td>
</tr>
<tr>
<td><code>Before</code></td>
<td><code>findByStartDateBefore</code></td>
<td><code>… where x.startDate &lt; ?1</code></td>
</tr>
<tr>
<td><code>IsNull</code></td>
<td><code>findByAgeIsNull</code></td>
<td><code>… where x.age is null</code></td>
</tr>
<tr>
<td><code>IsNotNull,NotNull</code></td>
<td><code>findByAge(Is)NotNull</code></td>
<td><code>… where x.age not null</code></td>
</tr>
<tr>
<td><code>Like</code></td>
<td><code>findByFirstnameLike</code></td>
<td><code>… where x.firstname like ?1</code></td>
</tr>
<tr>
<td><code>NotLike</code></td>
<td><code>findByFirstnameNotLike</code></td>
<td><code>… where x.firstname not like ?1</code></td>
</tr>
<tr>
<td><code>StartingWith</code></td>
<td><code>findByFirstnameStartingWith</code></td>
<td><code>… where x.firstname like ?1</code>(parameter bound with appended <code>%</code>)</td>
</tr>
<tr>
<td><code>EndingWith</code></td>
<td><code>findByFirstnameEndingWith</code></td>
<td><code>… where x.firstname like ?1</code>(parameter bound with prepended <code>%</code>)</td>
</tr>
<tr>
<td><code>Containing</code></td>
<td><code>findByFirstnameContaining</code></td>
<td><code>… where x.firstname like ?1</code>(parameter bound wrapped in <code>%</code>)</td>
</tr>
<tr>
<td><code>OrderBy</code></td>
<td><code>findByAgeOrderByLastnameDesc</code></td>
<td><code>… where x.age = ?1 order by x.lastname desc</code></td>
</tr>
<tr>
<td><code>Not</code></td>
<td><code>findByLastnameNot</code></td>
<td><code>… where x.lastname &lt;&gt; ?1</code></td>
</tr>
<tr>
<td><code>In</code></td>
<td><code>findByAgeIn(Collection&lt;Age&gt; ages)</code></td>
<td><code>… where x.age in ?1</code></td>
</tr>
<tr>
<td><code>NotIn</code></td>
<td><code>findByAgeNotIn(Collection&lt;Age&gt; ages)</code></td>
<td><code>… where x.age not in ?1</code></td>
</tr>
<tr>
<td><code>True</code></td>
<td><code>findByActiveTrue()</code></td>
<td><code>… where x.active = true</code></td>
</tr>
<tr>
<td><code>False</code></td>
<td><code>findByActiveFalse()</code></td>
<td><code>… where x.active = false</code></td>
</tr>
<tr>
<td><code>IgnoreCase</code></td>
<td><code>findByFirstnameIgnoreCase</code></td>
<td><code>… where UPPER(x.firstame) = UPPER(?1)</code></td>
</tr>
</tbody>
</table>
<p>最全支持关键字可查看: <code>org.springframework.data.repository.query.parser.Type</code></p>
<h2 id="查询结果的处理"><a href="#查询结果的处理" class="headerlink" title="查询结果的处理"></a>查询结果的处理</h2><h3 id="参数选择（Sort-Pageable）分页和排序"><a href="#参数选择（Sort-Pageable）分页和排序" class="headerlink" title="参数选择（Sort/Pageable）分页和排序"></a>参数选择（Sort/Pageable）分页和排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Page&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br><span class="line"><span class="function">Slice&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Sort sort)</span></span>;</span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="限制查询结果"><a href="#限制查询结果" class="headerlink" title="限制查询结果"></a>限制查询结果</h3><p>在查询方法上加限制查询结果的关键字 First 和 Top:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">User <span class="title">findFirstByOrderByLastnameAsc</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">User <span class="title">findTopByOrderByAgeDesc</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Page&lt;User&gt; <span class="title">queryFirst10ByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br><span class="line"><span class="function">Slice&lt;User&gt; <span class="title">findTop3ByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findFirst10ByLastname</span><span class="params">(String lastname, Sort sort)</span></span>;</span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findTop10ByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="查询结果的不同形式（List-Stream-Page-Future）"><a href="#查询结果的不同形式（List-Stream-Page-Future）" class="headerlink" title="查询结果的不同形式（List/Stream/Page/Future）"></a>查询结果的不同形式（List/Stream/Page/Future）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Query</span>(<span class="string">"select u from User u"</span>)</span><br><span class="line"><span class="function">Stream&lt;User&gt; <span class="title">findAllByCustomQueryAndStream</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Stream&lt;User&gt; <span class="title">readAllByFirstnameNotNull</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">@Query</span>(<span class="string">"select u from User u"</span>)</span><br><span class="line"><span class="function">Stream&lt;User&gt; <span class="title">streamAllPaged</span><span class="params">(Pageable pageable)</span></span>;</span><br></pre></td></tr></table></figure>
<p>关闭流:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;User&gt; stream;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   stream = repository.findAllByCustomQueryAndStream()</span><br><span class="line">   stream.forEach(…);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (stream!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      stream.close();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异步结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="function">Future&lt;User&gt; <span class="title">findByFirstname</span><span class="params">(String firstname)</span></span>; </span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="function">CompletableFuture&lt;User&gt; <span class="title">findOneByFirstname</span><span class="params">(String firstname)</span></span>; </span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="function">ListenableFuture&lt;User&gt; <span class="title">findOneByLastname</span><span class="params">(String lastname)</span></span>;</span><br></pre></td></tr></table></figure>
<p>支持的返回结果:</p>
<table>
<thead>
<tr>
<th>返回值类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>void</code></td>
<td>不返回结果，一般是更新操作</td>
</tr>
<tr>
<td><code>Primitives</code></td>
<td>Java 的基本类型，一般常见的是统计操作（如 <code>long</code>、<code>boolean</code> 等）Wrapper types Java 的包装类</td>
</tr>
<tr>
<td><code>T</code></td>
<td>最多只返回一个实体，没有查询结果时返回 null。如果超过了一个结果会抛出 <code>IncorrectResultSizeDataAccessException</code> 的异常。</td>
</tr>
<tr>
<td><code>Iterator</code></td>
<td>一个迭代器</td>
</tr>
<tr>
<td><code>Collection</code></td>
<td>集合</td>
</tr>
<tr>
<td><code>List</code></td>
<td><code>List</code> 及其任何子类</td>
</tr>
<tr>
<td><code>Optional</code></td>
<td>返回 Java 8 或 Guava 中的 <code>Optional</code> 类。查询方法的返回结果最多只能有一个，如果超过了一个结果会抛出 <code>IncorrectResultSizeDataAccessException</code> 的异常</td>
</tr>
<tr>
<td><code>Option</code></td>
<td>Scala 或者 javaslang 选项类型</td>
</tr>
<tr>
<td><code>Stream</code></td>
<td>Java 8 Stream</td>
</tr>
<tr>
<td><code>Future</code></td>
<td>Future，查询方法需要带有 <code>@Async</code> 注解，并<strong>开启 Spring 异步执行方法的功能</strong>。一般配合多线程使用。关系数据库，实际工作很少有用到.</td>
</tr>
<tr>
<td><code>CompletableFuture</code></td>
<td>返回 Java8 中新引入的 <code>CompletableFuture</code> 类，查询方法需要带有 <code>@Async</code> 注解，并开启 Spring 异步执行方法的功能</td>
</tr>
<tr>
<td><code>ListenableFuture</code></td>
<td>返回 <code>org.springframework.util.concurrent.ListenableFuture</code> 类，查询方法需要带有 <code>@Async</code> 注解，并开启 Spring 异步执行方法的功能</td>
</tr>
<tr>
<td><code>Slice</code></td>
<td>返回指定大小的数据和是否还有可用数据的信息。需要方法带有 <code>Pageable</code> 类型的参数</td>
</tr>
<tr>
<td><code>Page</code></td>
<td>在 <code>Slice</code> 的基础上附加返回分页总数等信息。需要方法带有 <code>Pageable</code> 类型的参数</td>
</tr>
<tr>
<td><code>GeoResult</code></td>
<td>返回结果会附带诸如到相关地点距离等信息</td>
</tr>
<tr>
<td><code>GeoResults</code></td>
<td>返回 <code>GeoResult</code> 的列表，并附带到相关地点平均距离等信息</td>
</tr>
<tr>
<td><code>GeoPage</code></td>
<td>分页返回 <code>GeoResult</code>，并附带到相关地点平均距离等信息</td>
</tr>
</tbody>
</table>
<h3 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h3><p>通过 <code>QueryExecutorMethodInterceptor</code> 这个类的源代码，我们发现，该类实现了 MethodInterceptor 接口，也就是说它是一个方法调用的拦截器， 当一个 Repository 上的查询方法，譬如说 findByEmailAndLastname 方法被调用，Advice 拦截器会在方法真正的实现调用前，先执行这个 MethodInterceptor 的 invoke 方法。这样我们就有机会在真正方法实现执行前执行其他的代码了。</p>
<p>然而对于 <code>QueryExecutorMethodInterceptor</code> 来说，最重要的代码并不在 invoke 方法中，而是在它的构造器 <code>QueryExecutorMethodInterceptor(RepositoryInformationr、Object customImplementation、Object target)</code> 中。</p>
<p>最重要的一段代码是这段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Method method : queryMethods) &#123; </span><br><span class="line">     <span class="comment">// 使用lookupStrategy，针对Repository接口上的方法查询Query</span></span><br><span class="line">     RepositoryQuery query = lookupStrategy.resolveQuery(method, repositoryInformation, factory, namedQueries); invokeListeners(query);</span><br><span class="line">     queries.put(method, query);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-orm/jpa-defining-query-method-processing.png" alt></p>
<h1 id="注解查询"><a href="#注解查询" class="headerlink" title="注解查询"></a>注解查询</h1><h2 id="Query"><a href="#Query" class="headerlink" title="@Query"></a>@Query</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Query &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 指定JPQL的查询语句。（nativeQuery=true的时候，是原生的Sql语句）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 指定count的JPQL语句，如果不指定将根据query自动生成。</span></span><br><span class="line"><span class="comment">    * （如果当nativeQuery=true的时候，指的是原生的Sql语句）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">String <span class="title">countQuery</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据哪个字段来count，一般默认即可。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">String <span class="title">countProjection</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 默认是false，表示value里面是不是原生的sql语句</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">nativeQuery</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 可以指定一个query的名字，必须唯一的。</span></span><br><span class="line"><span class="comment">    * 如果不指定，默认的生成规则是：</span></span><br><span class="line"><span class="comment">    * &#123;$domainClass&#125;.$&#123;queryMethodName&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 可以指定一个count的query的名字，必须唯一的。</span></span><br><span class="line"><span class="comment">    * 如果不指定，默认的生成规则是：</span></span><br><span class="line"><span class="comment">    * &#123;$domainClass&#125;.$&#123;queryMethodName&#125;.count</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">String <span class="title">countName</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt;</span>&#123;</span><br><span class="line">  <span class="meta">@Query</span>(<span class="string">"select u from User u where u.emailAddress = ?1"</span>)</span><br><span class="line">  <span class="function">User <span class="title">findByEmailAddress</span><span class="params">(String emailAddress)</span></span>;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Query</span>(<span class="string">"select u from User u where u.firstname like %?1"</span>)</span><br><span class="line">  <span class="function">List&lt;User&gt; <span class="title">findByFirstnameEndsWith</span><span class="params">(String firstname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原生SQL:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Query</span>(value = <span class="string">"SELECT * FROM USERS WHERE EMAIL_ADDRESS = ?1"</span>, nativeQuery = <span class="keyword">true</span>)</span><br><span class="line">  <span class="function">User <span class="title">findByEmailAddress</span><span class="params">(String emailAddress)</span></span>;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Query</span>(value = <span class="string">"select * from user_info where first_name=?1 order by ?2"</span>,nativeQuery = <span class="keyword">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong> <code>nativeQuery</code> 不支持直接 <code>Sort</code> 的参数查询, 需要类似上面一样使用原生的<code>order by</code>。</p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><code>@Query</code> 的 JPQL 情况下，想实现排序，方法上面直接用 <code>PageRequest</code> 或者直接用 <code>Sort</code> 参数都可以做到。</p>
<p>在排序实例中实际使用的属性需要与<strong>实体模型里面的字段相匹配</strong>，这意味着它们需要解析为查询中使用的属性或别名。这是一个<code>state_field_path_expression JPQL</code>定义，并且 Sort 的对象支持一些特定的函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Query</span>(<span class="string">"select u from User u where u.lastname like ?1%"</span>)</span><br><span class="line">  <span class="function">List&lt;User&gt; <span class="title">findByAndSort</span><span class="params">(String lastname, Sort sort)</span></span>;</span><br><span class="line">  <span class="meta">@Query</span>(<span class="string">"select u.id, LENGTH(u.firstname) as fn_len from User u where u.lastname like ?1%"</span>)</span><br><span class="line">  List&lt;Object[]&gt; findByAsArrayAndSort(String lastname, Sort sort);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用方的写法，如下：</span></span><br><span class="line">repo.findByAndSort(<span class="string">"lannister"</span>, <span class="keyword">new</span> Sort(<span class="string">"firstname"</span>));               </span><br><span class="line">repo.findByAndSort(<span class="string">"stark"</span>, <span class="keyword">new</span> Sort(<span class="string">"LENGTH(firstname)"</span>));          </span><br><span class="line">repo.findByAndSort(<span class="string">"targaryen"</span>, JpaSort.unsafe(<span class="string">"LENGTH(firstname)"</span>));</span><br><span class="line">repo.findByAsArrayAndSort(<span class="string">"bolton"</span>, <span class="keyword">new</span> Sort(<span class="string">"fn_len"</span>));</span><br></pre></td></tr></table></figure>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>直接用 Page 对象接受接口，参数直接用 <code>Pageable</code> 的实现类即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Query</span>(value = <span class="string">"select u from User u where u.lastname = ?1"</span>)</span><br><span class="line">  <span class="function">Page&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用者的写法</span></span><br><span class="line">repository.findByFirstName(<span class="string">"jackzhang"</span>,<span class="keyword">new</span> PageRequest(<span class="number">1</span>,<span class="number">10</span>));</span><br></pre></td></tr></table></figure>
<p>对原生 SQL 的分页支持，案例如下，但是支持的不是特别友好，以 MySQL 为例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">UserInfoEntity</span>, <span class="title">Integer</span>&gt;, <span class="title">JpaSpecificationExecutor</span>&lt;<span class="title">UserInfoEntity</span>&gt; </span>&#123;</span><br><span class="line">   <span class="meta">@Query</span>(value = <span class="string">"select * from user_info where first_name=?1 /* #pageable# */"</span>,</span><br><span class="line">         countQuery = <span class="string">"select count(*) from user_info where first_name=?1"</span>,</span><br><span class="line">         nativeQuery = <span class="keyword">true</span>)</span><br><span class="line">   <span class="function">Page&lt;UserInfoEntity&gt; <span class="title">findByFirstName</span><span class="params">(String firstName, Pageable pageable)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用者的写法</span></span><br><span class="line"><span class="keyword">return</span> userRepository.findByFirstName(<span class="string">"jackzhang"</span>,<span class="keyword">new</span> PageRequest(<span class="number">1</span>,<span class="number">10</span>, Sort.Direction.DESC,<span class="string">"last_name"</span>));</span><br><span class="line"><span class="comment">//打印出来的sql</span></span><br><span class="line">select  *   from  user_info  where  first_name=? <span class="comment">/* #pageable# */</span>  order by  last_name desc limit ?, ?</span><br></pre></td></tr></table></figure>
<h2 id="Param"><a href="#Param" class="headerlink" title="@Param"></a>@Param</h2><p>默认情况下，参数是<strong>通过顺序</strong>绑定在查询语句上的，这使得查询方法<strong>对参数位置的重构</strong>容易出错。为了解决这个问题，可以使用 <code>@Param</code> 注解指定方法参数的具体名称，通过绑定的参数名字做查询条件，这样不需要关心参数的顺序，推荐这种做法，比较利于代码重构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Query</span>(<span class="string">"select u from User u where u.firstname = :firstname or u.lastname = :lastname"</span>)</span><br><span class="line">  <span class="function">User <span class="title">findByLastnameOrFirstname</span><span class="params">(@Param(<span class="string">"lastname"</span>)</span> String lastname,</span></span><br><span class="line"><span class="function">                                 @<span class="title">Param</span><span class="params">(<span class="string">"firstname"</span>)</span> String firstname)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据参数进行查询，top 10 前面说的 query method 关键字照样有用，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Query</span>(<span class="string">"select u from User u where u.firstname = :firstname or u.lastname = :lastname"</span>)</span><br><span class="line">  <span class="function">User <span class="title">findTop10ByLastnameOrFirstname</span><span class="params">(@Param(<span class="string">"lastname"</span>)</span> String lastname,</span></span><br><span class="line"><span class="function">                                 @<span class="title">Param</span><span class="params">(<span class="string">"firstname"</span>)</span> String firstname)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>提醒：大家通过 @Query 定义自己的查询方法时，建议也用 Spring Data JPA 的 name query 的命名方法，这样下来风格就比较统一了。</p>
</blockquote>
<h2 id="Spel-表达式的支持"><a href="#Spel-表达式的支持" class="headerlink" title="Spel 表达式的支持"></a>Spel 表达式的支持</h2><p>在 Spring Data JPA 1.4 以后，支持在 <code>@Query</code> 中使用 SpEL 表达式（简介）来接收变量。</p>
<p>SpEL 支持的变量</p>
<blockquote>
<p>有两种方式能被解析出来：</p>
<ul>
<li>如果定了 <code>@Entity</code> 注解，直接用其属性名。</li>
<li>如果没定义，直接用实体的类的名称。</li>
</ul>
</blockquote>
<p>在以下的例子中，我们在查询语句中插入表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span>(<span class="string">"User"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Id</span></span><br><span class="line">   <span class="meta">@GeneratedValue</span></span><br><span class="line">   Long id;</span><br><span class="line">   String lastname;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Repository写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">   <span class="meta">@Query</span>(<span class="string">"select u from #&#123;#entityName&#125; u where u.lastname = ?1"</span>)</span><br><span class="line">   <span class="function">List&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 SPEL 的支持，比较适合自定义的 Repository，如果想写一个通用的 Repository 接口，那么可以用这个表达式来处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MappedSuperclass</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractMappedType</span> </span>&#123;</span><br><span class="line">   …</span><br><span class="line">   String attribute;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteType</span> <span class="keyword">extends</span> <span class="title">AbstractMappedType</span> </span>&#123; …</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MappedTypeRepository</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">AbstractMappedType</span>&gt; <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">T</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">   <span class="meta">@Query</span>(<span class="string">"select t from #&#123;#entityName&#125; t where t.attribute = ?1"</span>)</span><br><span class="line">   <span class="function">List&lt;T&gt; <span class="title">findAllByAttribute</span><span class="params">(String attribute)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConcreteRepository</span> <span class="keyword">extends</span> <span class="title">MappedTypeRepository</span>&lt;<span class="title">ConcreteType</span>&gt; </span>&#123; …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MappedTypeRepository</code> 作为一个公用的父类，自己的 Repository 可以继承它，当调用 <code>ConcreteRepository</code> 执行 <code>findAllByAttribute</code> 方法的时候执行结果如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> t <span class="keyword">from</span> ConcreteType t <span class="keyword">where</span> t.attribute = ?<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="Modifying-修改查询"><a href="#Modifying-修改查询" class="headerlink" title="@Modifying 修改查询"></a>@Modifying 修改查询</h2><p>可以通过在 <code>@Modifying</code> 注解实现只需要参数绑定的 update 查询的执行，我们来看个例子根据 lastName 更新 firstname 并且返回更新条数如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Modifying</span></span><br><span class="line"><span class="meta">@Query</span>(<span class="string">"update User u set u.firstname = ?1 where u.lastname = ?2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setFixedFirstnameFor</span><span class="params">(String firstname, String lastname)</span></span>;</span><br></pre></td></tr></table></figure>
<p>简单的针对某些特定属性的更新，也可以直接用基类里面提供的通用 save 来做更新（即继承 <code>CrudRepository</code> 接口）。</p>
<p><strong>还有第三种方法就是自定义 Repository 使用 EntityManager 来进行更新操作。</strong></p>
<p>对删除操作的支持如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deleteByRoleId</span><span class="params">(<span class="keyword">long</span> roleId)</span></span>;</span><br><span class="line">  <span class="meta">@Modifying</span></span><br><span class="line">  <span class="meta">@Query</span>(<span class="string">"delete from User u where user.role.id = ?1"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deleteInBulkByRoleId</span><span class="params">(<span class="keyword">long</span> roleId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以现在我们一共有四种方式来做更新操作：</p>
<ul>
<li>通过方法表达式；</li>
<li>还有一种就是 <code>@Modifying</code> 注解；</li>
<li><code>@Query</code> 注解也可以做到；</li>
<li>继承 <code>CrudRepository</code> 接口。</li>
</ul>
<h2 id="Query-的优缺点与实践"><a href="#Query-的优缺点与实践" class="headerlink" title="@Query 的优缺点与实践"></a>@Query 的优缺点与实践</h2><table>
<thead>
<tr>
<th>分类</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>优点</td>
<td>（1）可以灵活快速的使用 JPQL 和 SQL</td>
</tr>
<tr>
<td></td>
<td>（2）对返回的结果和字段记性自定义</td>
</tr>
<tr>
<td></td>
<td>（3）支持连表查询和对象关联查询，可以组合出来复杂的 SQL 或者 JPQL</td>
</tr>
<tr>
<td></td>
<td>（4）可以很好的表达你的查询思路</td>
</tr>
<tr>
<td></td>
<td>（5）灵活性非常强，快捷方便</td>
</tr>
<tr>
<td>缺点</td>
<td>（1）不支持动态查询条件，参数个数如果是不固定的不支持</td>
</tr>
<tr>
<td></td>
<td>（2）有些读者会将返回结果用 Map 或者 Object[] 数组接收结果，会导致调用此方法的开发人员不知道返回结果里面到底有些什么数据</td>
</tr>
<tr>
<td>最佳实践</td>
<td>（1）当出现很复杂的 SQL 或者 JPQL 的时候建议用视图</td>
</tr>
<tr>
<td></td>
<td>（2）返回结果一定要用对象接收，最好每个对象里面的字段和你返回的结果一一对应</td>
</tr>
<tr>
<td></td>
<td>（3）动态的 Query Param 会在后面的章节中讲到</td>
</tr>
<tr>
<td></td>
<td>（4）能用 JPQL 的就不要用 SQL</td>
</tr>
</tbody>
</table>
<h1 id="实例中的常用注解"><a href="#实例中的常用注解" class="headerlink" title="实例中的常用注解"></a>实例中的常用注解</h1><blockquote>
<p>更多注解请查看 <code>javax.persist</code> 包.</p>
</blockquote>
<h2 id="Entity"><a href="#Entity" class="headerlink" title="@Entity"></a>@Entity</h2><p><code>@Entity</code> 用于定义对象将会成为被 JPA 管理的实体，将字段映射到指定的数据库表中</p>
<h2 id="Table"><a href="#Table" class="headerlink" title="@Table"></a>@Table</h2><p><code>@Table</code> 用于指定数据库的表名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Table &#123;</span><br><span class="line">   <span class="comment">//表的名字，可选。如果不填写，系统认为好实体的名字一样为表名。</span></span><br><span class="line">   <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">   <span class="comment">//此表的catalog，可选</span></span><br><span class="line">   <span class="function">String <span class="title">catalog</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">   <span class="comment">//此表所在schema，可选</span></span><br><span class="line">   <span class="function">String <span class="title">schema</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">   <span class="comment">//唯一性约束，只有创建表的时候有用，默认不需要。</span></span><br><span class="line">   UniqueConstraint[] uniqueConstraints() <span class="keyword">default</span> &#123; &#125;;</span><br><span class="line">   <span class="comment">//索引，只有创建表的时候使用，默认不需要。</span></span><br><span class="line">   Index[] indexes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Id"><a href="#Id" class="headerlink" title="@Id"></a>@Id</h2><p><code>@Id</code> 定义属性为数据库的主键，一个实体里面必须有一个，并且必须和 <code>@GeneratedValue</code> 配合使用和成对出现.</p>
<h2 id="IdClass"><a href="#IdClass" class="headerlink" title="@IdClass"></a>@IdClass</h2><p><code>@IdClass</code> 利用外部类的联合主键。</p>
<h2 id="Basic-amp-Transient"><a href="#Basic-amp-Transient" class="headerlink" title="@Basic &amp; @Transient"></a>@Basic &amp; @Transient</h2><p><code>@Basic</code> 表示属性是到数据库表的字段的映射。如果实体的字段上没有任何注解，默认即为 <code>@Basic</code>。<code>@Transient</code> 表示该属性并非一个到数据库表的字段的映射，表示非持久化属性。JPA 映射数据库的时候忽略它，与 <code>@Basic</code> 相反的作用。</p>
<h2 id="Column"><a href="#Column" class="headerlink" title="@Column"></a>@Column</h2><p><code>@Column</code> 定义该属性对应数据库中的列名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Column &#123;</span><br><span class="line">    <span class="comment">//数据库中的表的列名；可选，如果不填写认为字段名和实体属性名一样。</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">//是否唯一。默认flase，可选。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">unique</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="comment">//数据字段是否允许空。可选，默认true。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">nullable</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    <span class="comment">//执行insert操作的时候是否包含此字段，默认，true，可选。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">insertable</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    <span class="comment">//执行update的时候是否包含此字段，默认，true，可选。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">updatable</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    <span class="comment">//表示该字段在数据库中的实际类型。</span></span><br><span class="line">    <span class="function">String <span class="title">columnDefinition</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">   <span class="comment">//数据库字段的长度，可选，默认255</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">default</span> 255</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Temporal"><a href="#Temporal" class="headerlink" title="@Temporal"></a>@Temporal</h2><p><code>@Temporal</code> 用来设置 <code>Date</code> 类型的属性映射到对应精度的字段。</p>
<ul>
<li><code>@Temporal(TemporalType.DATE)</code>映射为日期 // date （只有日期）</li>
<li><code>@Temporal(TemporalType.TIME)</code>映射为日期 // time （是有时间）</li>
<li><code>@Temporal(TemporalType.TIMESTAMP)</code>映射为日期 // date time （日期+时间）</li>
</ul>
<h2 id="Enumerated"><a href="#Enumerated" class="headerlink" title="@Enumerated"></a>@Enumerated</h2><p><code>@Enumerated</code> 这个注解很好用，直接映射 <code>enum</code> 枚举类型的字段。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Enumerated &#123;</span><br><span class="line"><span class="comment">//枚举映射的类型，默认是ORDINAL（即枚举字段的下标）。</span></span><br><span class="line">    <span class="function">EnumType <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ORDINAL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumType &#123;</span><br><span class="line">    <span class="comment">//映射枚举字段的下标</span></span><br><span class="line">    ORDINAL,</span><br><span class="line">    <span class="comment">//映射枚举的Name</span></span><br><span class="line">    STRING</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="MappedSuperclass"><a href="#MappedSuperclass" class="headerlink" title="@MappedSuperclass"></a>@MappedSuperclass</h2><p><code>@MappedSuperclass</code>注解使用在父类上面, 是用来标识父类的, <code>@MappedSuperclass</code>标识的类表示其不能映射到数据库表，因为其不是一个完整的实体类，但是它所拥有的属性能够隐射在其子类对用的数据库表中.</p>
<h2 id="PrePersist…-amp-PostPersist…"><a href="#PrePersist…-amp-PostPersist…" class="headerlink" title="@PrePersist… &amp; @PostPersist…"></a>@PrePersist… &amp; @PostPersist…</h2><p><code>@PrePersist</code>, <code>@PreUpdate</code>, <code>@PreRemove</code>, <code>@PostLoad</code>, <code>@PostPersist</code>, <code>@PostRemove</code>, <code>PostUpdate</code>: 如字面理解的都是更新前, 更新后等回调的方法.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MappedSuperclass</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors</span>(chain = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Id</span></span><br><span class="line">	<span class="meta">@GenericGenerator</span>(name = SnowflakeIdentifierGenerator.NAME, strategy = SnowflakeIdentifierGenerator.CLASS_NAME)</span><br><span class="line">	<span class="meta">@GeneratedValue</span>(generator = SnowflakeIdentifierGenerator.NAME)</span><br><span class="line">	<span class="keyword">protected</span> Long id;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@PrePersist</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prePersist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.createTime == <span class="keyword">null</span>) &#123;</span><br><span class="line">			createTime = LocalDateTime.now();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以配合Auditing实现一些审计功能, 参考<code>AuditingEntityListener</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"user_customer"</span>, schema = <span class="string">"test"</span>, catalog = <span class="string">""</span>)</span><br><span class="line"><span class="meta">@EntityListeners</span>(CustomAuditingEntityListener<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">UserCustomerEntity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configurable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomAuditingEntityListener</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@PrePersist</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">touchForCreate</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// if(target.getCreateTime == null)&#123; set createTime hear &#125;</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@PreUpdate</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">touchForUpdate</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// inject update time</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JoinColumn"><a href="#JoinColumn" class="headerlink" title="@JoinColumn"></a>@JoinColumn</h2><p><code>@JoinColumn</code> 主要配合 <code>@OneToOne</code>、<code>@ManyToOne</code>、<code>@OneToMany</code> 一起使用，单独使用没有意义, 用来定义多个字段的关联关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> JoinColumn &#123;</span><br><span class="line">    <span class="comment">//目标表的字段名,必填</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">//本实体的字段名，非必填，默认是本表ID</span></span><br><span class="line">    <span class="function">String <span class="title">referencedColumnName</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">//外键字段是否唯一</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">unique</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="comment">//外键字段是否允许为空</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">nullable</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    <span class="comment">//是否跟随一起新增</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">insertable</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    <span class="comment">//是否跟随一起更新</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">updatable</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="OneToOne"><a href="#OneToOne" class="headerlink" title="@OneToOne"></a>@OneToOne</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> OneToOne &#123;</span><br><span class="line">    <span class="comment">//关系目标实体，非必填，默认该字段的类型。</span></span><br><span class="line">    <span class="function">Class <span class="title">targetEntity</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">void</span>.class</span>;</span><br><span class="line">    <span class="comment">//cascade 级联操作策略</span></span><br><span class="line">  <span class="number">1</span>. CascadeType.PERSIST 级联新建</span><br><span class="line">  <span class="number">2</span>. CascadeType.REMOVE 级联删除</span><br><span class="line">  <span class="number">3</span>. CascadeType.REFRESH 级联刷新</span><br><span class="line">  <span class="number">4</span>. CascadeType.MERGE 级联更新</span><br><span class="line">  <span class="number">5</span>. CascadeType.ALL 四项全选</span><br><span class="line">  <span class="number">6</span>. 默认，关系表不会产生任何影响</span><br><span class="line">    CascadeType[] cascade() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">//数据获取方式EAGER(立即加载)/LAZY(延迟加载)</span></span><br><span class="line">    <span class="function">FetchType <span class="title">fetch</span><span class="params">()</span> <span class="keyword">default</span> EAGER</span>;</span><br><span class="line">    <span class="comment">//是否允许为空</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">optional</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    <span class="comment">//关联关系被谁维护的。 非必填，一般不需要特别指定。   </span></span><br><span class="line"><span class="comment">//注意：只有关系维护方才能操作两者的关系。被维护方即使设置了维护方属性进行存储也不会更新外键关联。1）mappedBy不能与@JoinColumn或者@JoinTable同时使用。2）mappedBy的值是指另一方的实体里面属性的字段，而不是数据库字段，也不是实体的对象的名字。既是另一方配置了@JoinColumn或者@JoinTable注解的属性的字段名称。</span></span><br><span class="line">    <span class="function">String <span class="title">mappedBy</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">//是否级联删除。和CascadeType.REMOVE的效果一样。两种配置了一个就会自动级联删除</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">orphanRemoval</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@OneToOne</code> 需要配合 <code>@JoinColumn</code> 一起使用。注意：可以双向关联，也可以只配置一方，看实际需求。</p>
<p>案例：假设一个部门只有一个员工，Department 的内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@OneToOne</span></span><br><span class="line"><span class="meta">@JoinColumn</span>(name=<span class="string">"employee_id"</span>,referencedColumnName=<span class="string">"id"</span>)</span><br><span class="line"><span class="keyword">private</span> Employee employeeAttribute = <span class="keyword">new</span> Employee();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<code>employee_id</code>指的是 Department 里面的字段，而 referencedColumnName=”id” 指的是 Employee 表里面的字段。</p>
</blockquote>
<p>如果需要双向关联，Employee 的内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@OneToOne</span>(mappedBy=<span class="string">"employeeAttribute"</span>)</span><br><span class="line"><span class="keyword">private</span> Department department;</span><br></pre></td></tr></table></figure>
<p>当然了也可以不选用 mappedBy 和下面效果是一样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@OneToOne</span></span><br><span class="line"><span class="meta">@JoinColumn</span>(name=<span class="string">"id"</span>,referencedColumnName=<span class="string">"employee_id"</span>)</span><br><span class="line"><span class="keyword">private</span> Department department;</span><br></pre></td></tr></table></figure>
<h2 id="OneToMany-amp-ManyToOne"><a href="#OneToMany-amp-ManyToOne" class="headerlink" title="@OneToMany &amp; @ManyToOne"></a>@OneToMany &amp; @ManyToOne</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> OneToMany &#123;</span><br><span class="line">    <span class="function">Class <span class="title">targetEntity</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">void</span>.class</span>;</span><br><span class="line"> <span class="comment">//cascade 级联操作策略：(CascadeType.PERSIST、CascadeType.REMOVE、CascadeType.REFRESH、CascadeType.MERGE、CascadeType.ALL)</span></span><br><span class="line">如果不填，默认关系表不会产生任何影响。</span><br><span class="line">    CascadeType[] cascade() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="comment">//数据获取方式EAGER(立即加载)/LAZY(延迟加载)</span></span><br><span class="line">    <span class="function">FetchType <span class="title">fetch</span><span class="params">()</span> <span class="keyword">default</span> LAZY</span>;</span><br><span class="line">    <span class="comment">//关系被谁维护，单项的。注意：只有关系维护方才能操作两者的关系。</span></span><br><span class="line">    <span class="function">String <span class="title">mappedBy</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"><span class="comment">//是否级联删除。和CascadeType.REMOVE的效果一样。两种配置了一个就会自动级联删除</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">orphanRemoval</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ManyToOne &#123;</span><br><span class="line">    <span class="function">Class <span class="title">targetEntity</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">void</span>.class</span>;</span><br><span class="line">    CascadeType[] cascade() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="function">FetchType <span class="title">fetch</span><span class="params">()</span> <span class="keyword">default</span> EAGER</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">optional</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"><span class="meta">@OneToMany</span>(cascade=CascadeType.ALL,fetch=FetchType.LAZY,mappedBy=<span class="string">"user"</span>)</span><br><span class="line">    <span class="keyword">private</span> Set&lt;role&gt; setRole; </span><br><span class="line">......&#125;</span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"role"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line"><span class="meta">@ManyToOne</span>(cascade=CascadeType.ALL,fetch=FetchType.EAGER)</span><br><span class="line">    <span class="meta">@JoinColumn</span>(name=<span class="string">"user_id"</span>)<span class="comment">//user_id字段作为外键</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">......&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ManyToMany-amp-JoinTable"><a href="#ManyToMany-amp-JoinTable" class="headerlink" title="@ManyToMany &amp; @JoinTable"></a>@ManyToMany &amp; @JoinTable</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ManyToMany &#123;</span><br><span class="line">    <span class="function">Class <span class="title">targetEntity</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">void</span>.class</span>;</span><br><span class="line">    CascadeType[] cascade() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="function">FetchType <span class="title">fetch</span><span class="params">()</span> <span class="keyword">default</span> LAZY</span>;</span><br><span class="line">    <span class="function">String <span class="title">mappedBy</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> JoinTable &#123;</span><br><span class="line">    <span class="comment">//中间关联关系表明</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">//表的catalog</span></span><br><span class="line">    <span class="function">String <span class="title">catalog</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">//表的schema</span></span><br><span class="line">    <span class="function">String <span class="title">schema</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">//主链接表的字段</span></span><br><span class="line">    JoinColumn[] joinColumns() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">//被联机的表外键字段</span></span><br><span class="line">    JoinColumn[] inverseJoinColumns() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@NotBlank</span>(message = <span class="string">"姓名不能为空"</span>)</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@ManyToMany</span></span><br><span class="line">	<span class="meta">@JoinTable</span>(</span><br><span class="line">			name = <span class="string">"userRole"</span>,</span><br><span class="line">			joinColumns = <span class="meta">@JoinColumn</span>(name = <span class="string">"userId"</span>, referencedColumnName=<span class="string">"id"</span>),</span><br><span class="line">			inverseJoinColumns=<span class="meta">@JoinColumn</span>(name=<span class="string">"roleId"</span>,referencedColumnName=<span class="string">"id"</span>)</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">private</span> List&lt;Role&gt; roles;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Id</span></span><br><span class="line">	<span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRole</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Id</span></span><br><span class="line">	<span class="keyword">protected</span> Long id;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Long roleId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SQLDelete-amp-Where"><a href="#SQLDelete-amp-Where" class="headerlink" title="@SQLDelete&amp;@Where"></a>@SQLDelete&amp;@Where</h2><p>这两个注解可以配合完成逻辑删除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SQLDelete</span>(sql = <span class="string">"update user set delete_flag = 1 where id = ?"</span>)</span><br><span class="line"><span class="meta">@Where</span>(clause = <span class="string">"delete_flag = 0"</span>)</span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@NotBlank</span>(message = <span class="string">"姓名不能为空"</span>)</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@ManyToMany</span></span><br><span class="line">	<span class="meta">@JoinTable</span>(</span><br><span class="line">			name = <span class="string">"userRole"</span>,</span><br><span class="line">			joinColumns = <span class="meta">@JoinColumn</span>(name = <span class="string">"userId"</span>, referencedColumnName=<span class="string">"id"</span>),</span><br><span class="line">			inverseJoinColumns=<span class="meta">@JoinColumn</span>(name=<span class="string">"roleId"</span>,referencedColumnName=<span class="string">"id"</span>)</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">private</span> List&lt;Role&gt; roles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="QueryByExampleExecutor基本用法"><a href="#QueryByExampleExecutor基本用法" class="headerlink" title="QueryByExampleExecutor基本用法"></a>QueryByExampleExecutor基本用法</h1><blockquote>
<p>这个使用比较少</p>
</blockquote>
<p>多种条件组合:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建查询条件数据对象</span></span><br><span class="line">Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">customer.setName(<span class="string">"zhang"</span>);</span><br><span class="line">customer.setAddress(<span class="string">"河南省"</span>);</span><br><span class="line">customer.setRemark(<span class="string">"BB"</span>);</span><br><span class="line"><span class="comment">//虽然有值，但是不参与过滤条件</span></span><br><span class="line">customer.setFocus(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//创建匹配器，即如何使用查询条件</span></span><br><span class="line">ExampleMatcher matcher = ExampleMatcher.matching() <span class="comment">//构建对象</span></span><br><span class="line">        .withStringMatcher(StringMatcher.CONTAINING) <span class="comment">//改变默认字符串匹配方式：模糊查询</span></span><br><span class="line">        .withIgnoreCase(<span class="keyword">true</span>) <span class="comment">//改变默认大小写忽略方式：忽略大小写</span></span><br><span class="line">        .withMatcher(<span class="string">"address"</span>, GenericPropertyMatchers.startsWith()) <span class="comment">//地址采用“开始匹配”的方式查询</span></span><br><span class="line">        .withIgnorePaths(<span class="string">"focus"</span>);  <span class="comment">//忽略属性：是否关注。因为是基本类型，需要忽略掉</span></span><br><span class="line"><span class="comment">//创建实例</span></span><br><span class="line">Example&lt;Customer&gt; ex = Example.of(customer, matcher); </span><br><span class="line"><span class="comment">//查询</span></span><br><span class="line">List&lt;Customer&gt; ls = dao.findAll(ex);</span><br></pre></td></tr></table></figure>
<p>查询 Null 值:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建查询条件数据对象</span></span><br><span class="line">Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line"><span class="comment">//创建匹配器，即如何使用查询条件</span></span><br><span class="line">ExampleMatcher matcher = ExampleMatcher.matching() <span class="comment">//构建对象</span></span><br><span class="line">        <span class="comment">//改变“Null值处理方式”：包括。</span></span><br><span class="line">      .withIncludeNullValues() </span><br><span class="line">       <span class="comment">//忽略其他属性</span></span><br><span class="line">      .withIgnorePaths(<span class="string">"id"</span>, <span class="string">"name"</span>, <span class="string">"sex"</span>, <span class="string">"age"</span>, <span class="string">"focus"</span>, <span class="string">"addTime"</span>, <span class="string">"remark"</span>, <span class="string">"customerType"</span>); </span><br><span class="line"><span class="comment">//创建实例</span></span><br><span class="line">Example&lt;Customer&gt; ex = Example.of(customer, matcher);</span><br><span class="line"><span class="comment">//查询</span></span><br><span class="line">List&lt;Customer&gt; ls = dao.findAll(ex);</span><br></pre></td></tr></table></figure>
<h1 id="JpaSpecificationExecutor使用"><a href="#JpaSpecificationExecutor使用" class="headerlink" title="JpaSpecificationExecutor使用"></a>JpaSpecificationExecutor使用</h1><p><code>JpaSpecificationExecutor</code> 是 <code>Repository</code> 要继承的接口，而 <code>SimpleJpaRepository</code> 是其默认实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JpaSpecificationExecutor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   <span class="comment">//根据 Specification 条件查询单个对象，注意的是，如果条件能查出来多个会报错</span></span><br><span class="line">   <span class="function">T <span class="title">findOne</span><span class="params">(@Nullable Specification&lt;T&gt; spec)</span></span>;</span><br><span class="line">   <span class="comment">//根据 Specification 条件查询 List 结果</span></span><br><span class="line">   <span class="function">List&lt;T&gt; <span class="title">findAll</span><span class="params">(@Nullable Specification&lt;T&gt; spec)</span></span>;</span><br><span class="line">   <span class="comment">//根据 Specification 条件，分页查询</span></span><br><span class="line">   <span class="function">Page&lt;T&gt; <span class="title">findAll</span><span class="params">(@Nullable Specification&lt;T&gt; spec, Pageable pageable)</span></span>;</span><br><span class="line">   <span class="comment">//根据 Specification 条件，带排序的查询结果</span></span><br><span class="line">   <span class="function">List&lt;T&gt; <span class="title">findAll</span><span class="params">(@Nullable Specification&lt;T&gt; spec, Sort sort)</span></span>;</span><br><span class="line">   <span class="comment">//根据 Specification 条件，查询数量</span></span><br><span class="line">   <span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">(@Nullable Specification&lt;T&gt; spec)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个接口基本是围绕着 <code>Specification</code> 接口来定义的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Specification</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   <span class="function">Predicate <span class="title">toPredicate</span><span class="params">(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Criteria 的概念简单介绍:</p>
<p><strong>（1）Root root</strong></p>
<p>代表了可以查询和操作的实体对象的根，如果将实体对象比喻成表名，那 root 里面就是这张表里面的字段，这不过是 JPQL 的实体字段而已。通过里面的 Path get(String attributeName)，来获得我们想操作的字段。</p>
<p><strong>（2）CriteriaQuery query</strong></p>
<p>代表一个 specific 的顶层查询对象，它包含着查询的各个部分，比如 select 、from、where、group by、order by 等。CriteriaQuery 对象只对实体类型或嵌入式类型的 Criteria 查询起作用，简单理解，它提供了查询 ROOT 的方法。常用的方法有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CriteriaQuery&lt;T&gt; where(Predicate... restrictions);</span><br><span class="line">CriteriaQuery&lt;T&gt; select(Selection&lt;? extends T&gt; selection);</span><br><span class="line">CriteriaQuery&lt;T&gt; having(Predicate... restrictions);</span><br></pre></td></tr></table></figure>
<p><strong>（3）CriteriaBuilder cb</strong></p>
<p>用来构建 CritiaQuery 的构建器对象，其实就相当于条件或者是条件组合，并以 Predicate 的形式返回。下面是构建简单的 Predicate 示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Predicate p1=cb.like(root.get(“name”).as(String.class), “%”+uqm.getName()+“%”);</span><br><span class="line">Predicate p2=cb.equal(root.get(&quot;uuid&quot;).as(Integer.class), uqm.getUuid());</span><br><span class="line">Predicate p3=cb.gt(root.get(&quot;age&quot;).as(Integer.class), uqm.getAge());</span><br></pre></td></tr></table></figure>
<p>构建组合的 Predicate 示例：</p>
<p><code>Predicate p = cb.and(p3,cb.or(p1,p2));</code></p>
<p><strong>用法</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfoManager</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Page&lt;UserInfoEntity&gt; <span class="title">findByCondition</span><span class="params">(UserInfoRequest userParam,Pageable pageable)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> userRepository.findAll((root, query, cb) -&gt; &#123;</span><br><span class="line">         List&lt;Predicate&gt; predicates = <span class="keyword">new</span> ArrayList&lt;Predicate&gt;();</span><br><span class="line">         <span class="keyword">if</span> (StringUtils.isNoneBlank(userParam.getFirstName()))&#123;</span><br><span class="line">            <span class="comment">//liked的查询条件</span></span><br><span class="line">            predicates.add(cb.like(root.get(<span class="string">"firstName"</span>),<span class="string">"%"</span>+userParam.getFirstName()+<span class="string">"%"</span>));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (StringUtils.isNoneBlank(userParam.getTelephone()))&#123;</span><br><span class="line">            <span class="comment">//equal查询条件</span></span><br><span class="line">            predicates.add(cb.equal(root.get(<span class="string">"telephone"</span>),userParam.getTelephone()));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (StringUtils.isNoneBlank(userParam.getVersion()))&#123;</span><br><span class="line">            <span class="comment">//greaterThan大于等于查询条件</span></span><br><span class="line">            predicates.add(cb.greaterThan(root.get(<span class="string">"version"</span>),userParam.getVersion()));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (userParam.getBeginCreateTime()!=<span class="keyword">null</span>&amp;&amp;userParam.getEndCreateTime()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//根据时间区间去查询   predicates.add(cb.between(root.get("createTime"),userParam.getBeginCreateTime(),userParam.getEndCreateTime()));</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (StringUtils.isNotBlank(userParam.getAddressCity())) &#123;</span><br><span class="line">            <span class="comment">//联表查询，利用root的join方法，根据关联关系表里面的字段进行查询。</span></span><br><span class="line">            predicates.add(cb.equal(root.join(<span class="string">"addressEntityList"</span>).get(<span class="string">"addressCity"</span>), userParam.getAddressCity()));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> query.where(predicates.toArray(<span class="keyword">new</span> Predicate[predicates.size()])).getRestriction();</span><br><span class="line">      &#125;, pageable);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以仔细体会上面这个案例，实际工作中应该大部分都是这种写法，就算扩展也是百变不离其中。</span></span><br></pre></td></tr></table></figure>
<h1 id="JPA-Spec封装"><a href="#JPA-Spec封装" class="headerlink" title="JPA Spec封装"></a>JPA Spec封装</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SpecificationFactory</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 模糊查询，匹配对应字段</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Specification <span class="title">containsLike</span><span class="params">(String attribute, String value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (root, query, cb)-&gt; cb.like(root.get(attribute), <span class="string">"%"</span> + value + <span class="string">"%"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 某字段的值等于 value 的查询条件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Specification <span class="title">equal</span><span class="params">(String attribute, Object value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (root, query, cb) -&gt; cb.equal(root.get(attribute),value);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取对应属性的值所在区间</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Specification <span class="title">isBetween</span><span class="params">(String attribute, <span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (root, query, cb) -&gt; cb.between(root.get(attribute), min, max);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Specification <span class="title">isBetween</span><span class="params">(String attribute, <span class="keyword">double</span> min, <span class="keyword">double</span> max)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (root, query, cb) -&gt; cb.between(root.get(attribute), min, max);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Specification <span class="title">isBetween</span><span class="params">(String attribute, Date min, Date max)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (root, query, cb) -&gt; cb.between(root.get(attribute), min, max);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 通过属性名和集合实现 in 查询</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Specification <span class="title">in</span><span class="params">(String attribute, Collection c)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (root, query, cb) -&gt;root.get(attribute).in(c);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 通过属性名构建大于等于 Value 的查询条件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Specification <span class="title">greaterThan</span><span class="params">(String attribute, BigDecimal value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (root, query, cb) -&gt;cb.greaterThan(root.get(attribute),value);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Specification <span class="title">greaterThan</span><span class="params">(String attribute, Long value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (root, query, cb) -&gt;cb.greaterThan(root.get(attribute),value);</span><br><span class="line">   &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">userRepository.findAll(</span><br><span class="line">      SpecificationFactory.containsLike(<span class="string">"firstName"</span>, userParam.getLastName()),</span><br><span class="line">      pageable);</span><br><span class="line">      </span><br><span class="line">userRepository.findAll(Specifications.where(</span><br><span class="line">      SpecificationFactory.containsLike(<span class="string">"firstName"</span>, userParam.getLastName()))</span><br><span class="line">            .and(SpecificationFactory.greaterThan(<span class="string">"version"</span>,userParam.getVersion())),</span><br><span class="line">      pageable);</span><br></pre></td></tr></table></figure>
<p>这样一来可读性以及代码优雅度都提高了.</p>
<p>推荐一个对Specification的封装库: <strong><em><a href="https://github.com/wenhao/jpa-spec" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wenhao/jpa-spec</a></em></strong></p>
<h1 id="EntityManager与自定义Repository"><a href="#EntityManager与自定义Repository" class="headerlink" title="EntityManager与自定义Repository"></a>EntityManager与自定义Repository</h1><h2 id="EntityManager的两种获取方式"><a href="#EntityManager的两种获取方式" class="headerlink" title="EntityManager的两种获取方式"></a>EntityManager的两种获取方式</h2><p>获取<code>EntityManager</code>有两种方式.</p>
<p>方式一: <code>@PersistenceContext</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="meta">@Transactional</span>(readOnly = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">UserRepositoryCustom</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PersistenceContext</span>  <span class="comment">//获得entityManager的实例</span></span><br><span class="line">    EntityManager entityManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方式二:  继承 <code>SimpleJpaRepository</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseRepositoryCustom</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; <span class="keyword">extends</span> <span class="title">SimpleJpaRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseRepositoryCustom</span><span class="params">(JpaEntityInformation&lt;T, ?&gt; entityInformation, EntityManager entityManager)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(entityInformation, entityManager);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseRepositoryCustom</span><span class="params">(Class&lt;T&gt; domainClass, EntityManager em)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(domainClass, em);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义-Repository"><a href="#自定义-Repository" class="headerlink" title="自定义 Repository"></a>自定义 Repository</h2><h3 id="自定义个别的特殊场景私有的-Repository"><a href="#自定义个别的特殊场景私有的-Repository" class="headerlink" title="自定义个别的特殊场景私有的 Repository"></a>自定义个别的特殊场景私有的 Repository</h3><p>定义接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepositoryCustom</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">customerMethodNamesLike</span><span class="params">(String firstName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用<span class="doctag">@Repository</span> 将此实现交个Spring bean加载</span></span><br><span class="line"><span class="comment"> * 咱们模仿SimpleJpaRepository 默认将所有方法都开启一个事务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="meta">@Transactional</span>(readOnly = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryCustomImpl</span> <span class="keyword">implements</span> <span class="title">UserRepositoryCustom</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PersistenceContext</span></span><br><span class="line">    EntityManager entityManager;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">customerMethodNamesLike</span><span class="params">(String firstName)</span> </span>&#123;</span><br><span class="line">        Query query = entityManager.createNativeQuery(<span class="string">"SELECT u.* FROM user as u "</span> +</span><br><span class="line">                <span class="string">"WHERE u.name LIKE ?"</span>, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        query.setParameter(<span class="number">1</span>, firstName + <span class="string">"%"</span>);</span><br><span class="line">        <span class="keyword">return</span> query.getResultList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面除了entityManager, 也可以使用JdbcTemplate来自己实现逻辑</p>
</blockquote>
<p>继承接口:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt;,<span class="title">UserRepositoryCustom</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后直接调用就行了:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">userRepository.customerMethodNamesLike(<span class="string">"jack"</span>);</span><br></pre></td></tr></table></figure>
<p>我们还可以覆盖 JPA 里面的默认实现方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设我们要覆盖默认的save方法的逻辑</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CustomizedSave</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  &lt;S extends T&gt; <span class="function">S <span class="title">save</span><span class="params">(S entity)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomizedSaveImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">CustomizedSave</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> &lt;S extends T&gt; <span class="function">S <span class="title">save</span><span class="params">(S entity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Your custom implementation</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用法保持不变，如下：</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt;, <span class="title">CustomizedSave</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//CustomizedSave通过泛化可以被多个Repository使用</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">Person</span>, <span class="title">Long</span>&gt;, <span class="title">CustomizedSave</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实际工作中应用于逻辑删除场景：</strong></p>
<blockquote>
<p>在实际工作的生产环境中，我们可能经常会用到逻辑删除，所以做法是一般自定义覆盖 Data JPA 帮我们提供 remove 方法，然后实现逻辑删除的逻辑即可。</p>
</blockquote>
<h3 id="公用的通用的场景替代默认的-SimpleJpaRepository"><a href="#公用的通用的场景替代默认的-SimpleJpaRepository" class="headerlink" title="公用的通用的场景替代默认的 SimpleJpaRepository"></a>公用的通用的场景替代默认的 SimpleJpaRepository</h3><p>声明定制共享行为的接口，用 <code>@NoRepositoryBean</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt; <span class="keyword">extends</span> <span class="title">PagingAndSortingRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sharedCustomMethod</span><span class="params">(ID id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承 SimpleJpaRepository 扩展自己的方法实现逻辑:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRepositoryImpl</span>&lt;<span class="title">T</span>, <span class="title">ID</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">SimpleJpaRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; <span class="keyword">implements</span> <span class="title">MyRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> EntityManager entityManager;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyRepositoryImpl</span><span class="params">(JpaEntityInformation entityInformation, EntityManager entityManager)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(entityInformation, entityManager);</span><br><span class="line">    <span class="comment">// Keep the EntityManager around to used from the newly introduced methods.</span></span><br><span class="line">    <span class="keyword">this</span>.entityManager = entityManager;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sharedCustomMethod</span><span class="params">(ID id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过entityManager实现自己的额外方法的实现逻辑。这里不多说了</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 JavaConfig 配置自定义 MyRepositoryImpl 作为其他接口的动态代理的实现基类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories</span>(repositoryBaseClass = MyRepositoryImpl<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">ApplicationConfiguration</span> </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>具有全局的性质，即使没有继承它所有的动态代理类也会变成它.</p>
</blockquote>
<h1 id="使用Tips"><a href="#使用Tips" class="headerlink" title="使用Tips"></a>使用Tips</h1><h2 id="使用-Embedded-关联一对一的值对象"><a href="#使用-Embedded-关联一对一的值对象" class="headerlink" title="使用 @Embedded 关联一对一的值对象"></a>使用 @Embedded 关联一对一的值对象</h2><p>可理解为DDD中的值对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Embedded</span></span><br><span class="line">    <span class="keyword">private</span> CustomerVo customerVo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Embeddable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerVo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> customerId;</span><br><span class="line">    <span class="keyword">private</span> String customerName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用-Convert-关联一对多的值对象"><a href="#使用-Convert-关联一对多的值对象" class="headerlink" title="使用 @Convert 关联一对多的值对象"></a>使用 @Convert 关联一对多的值对象</h2><p>有时候在实体当中有某些字段是一个<strong>值对象的集合</strong>，我们又不想(也没必要)为其另起一张表，打个比方：订单里面的商品列表(只是打个比方，实际上应该是一张独立的表)。</p>
<p>例如设计一个访问日志对象，我们需要记录访问方法的行参与接收值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors</span>(chain = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"access_log"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessLog</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6911021075718017305L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Id</span></span><br><span class="line">	<span class="meta">@GeneratedValue</span>(generator = <span class="string">"snowflakeIdentifierGenerator"</span>)</span><br><span class="line">	<span class="meta">@GenericGenerator</span>(name = <span class="string">"snowflakeIdentifierGenerator"</span>, strategy = <span class="string">"com.yangbingdong.docker.domain.core.vo.SnowflakeIdentifierGenerator"</span>)</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Column</span>(columnDefinition = <span class="string">"text"</span>)</span><br><span class="line">	<span class="meta">@Convert</span>(converter = ReqReceiveDataConverter<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">	<span class="title">private</span> <span class="title">List</span>&lt;<span class="title">ReqReceiveData</span>&gt; <span class="title">reqReceiveDatas</span></span>;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>属性转换器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@Converter(autoApply = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReqReceiveDataConverter</span> <span class="keyword">implements</span> <span class="title">AttributeConverter</span>&lt;<span class="title">List</span>&lt;<span class="title">ReqReceiveData</span>&gt;, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">convertToDatabaseColumn</span><span class="params">(List&lt;ReqReceiveData&gt; attribute)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> JSONObject.toJSONString(attribute);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;ReqReceiveData&gt; <span class="title">convertToEntityAttribute</span><span class="params">(String dbData)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> JSONObject.parseArray(dbData, ReqReceiveData<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>@Convert</code>声明使用某个属性转换器(<code>ReqReceiveDataConverter</code>)</li>
<li><code>ReqReceiveDataConverter</code>需要实现<code>AttributeConverter&lt;X,Y&gt;</code>，<code>X</code>为实体的字段类型，<code>Y</code>对应需要持久化到DB的类型</li>
<li><code>@Converter(autoApply = true)</code>注解作用，如果有多个实体需要用到此属性转换器，不需要每个实体都的字段加上<code>@Convert</code>注解，自动对全部实体生效</li>
</ul>
<h2 id="发布领域事件"><a href="#发布领域事件" class="headerlink" title="发布领域事件"></a>发布领域事件</h2><p>一般基于DDD的设计，在实体状态改变时(保存或更新实体)，为了保证其他边缘服务与之状态的统一，我们需要通过发布实体保存或更新事件，其他服务监听后做出相应的处理，大概像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="meta">@NonNull</span> MyRepository repository;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="meta">@NonNull</span> ApplicationEventPublisher publisher;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(MyAggregateRoot entity)</span> </span>&#123;</span><br><span class="line">    MyDomainEvent event = entity.someBusinessFunctionality();</span><br><span class="line">    publisher.publishEvent(event);</span><br><span class="line">    repository.save(entity);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过JPA我们可以优雅地发布领域事件，有以下两种实现方式：</p>
<ul>
<li><p>继承<code>AbstractAggregateRoot</code>，并使用其<code>registerEvent()</code>方法注册发布事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankTransfer</span> <span class="keyword">extends</span> <span class="title">AbstractAggregateRoot</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BankTransfer <span class="title">complete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        id = UUID.randomUUID().toString();</span><br><span class="line">        registerEvent(<span class="keyword">new</span> BankTransferCompletedEvent(id));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankTransferService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">completeTransfer</span><span class="params">(BankTransfer bankTransfer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> repository.save(bankTransfer.complete()).getId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>但此方式拿不到实体id，因为是在生成id之前生成的event</strong></p>
</li>
<li><p>使用<code>@DomainEvents</code>注解方法发布事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageEvent</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3843381578126175380L</span>;</span><br><span class="line">    ....</span><br><span class="line">    </span><br><span class="line">	<span class="meta">@Transient</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> List&lt;Object&gt; domainEvents = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">	<span class="meta">@DomainEvents</span></span><br><span class="line">	<span class="function">Collection&lt;Object&gt; <span class="title">domainEvents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		log.info(<span class="string">"publish domainEvents......"</span>);</span><br><span class="line">		domainEvents.add(<span class="keyword">new</span> SaveMsgEvent().setId(<span class="keyword">this</span>.id));</span><br><span class="line">		<span class="keyword">return</span> Collections.unmodifiableList(domainEvents);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@AfterDomainEventPublication</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">callbackMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		log.info(<span class="string">"AfterDomainEventPublication.........."</span>);</span><br><span class="line">		domainEvents.clear();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式可以拿到实体id</p>
<p>监听：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DomainEventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Async</span></span><br><span class="line">	<span class="meta">@TransactionalEventListener</span>(SaveMsgEvent<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">	<span class="title">public</span> <span class="title">void</span> <span class="title">processSaveMsgEvent</span>(<span class="title">SaveMsgEvent</span> <span class="title">saveMsgEvent</span>) <span class="title">throws</span> <span class="title">InterruptedException</span> </span>&#123;</span><br><span class="line">		TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">		log.info(<span class="string">"Listening SaveMsgEvent..................saveMsgEvent id: &#123;&#125;"</span>, saveMsgEvent);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用<code>@EventListener</code>也可以，但是<code>@TransactionalEventListener</code>可以在<strong>事务之后</strong>执行。使用前者的话，程序异常事务会滚监听器照样会执行，而后者必须等事务正确提交之后才会执行。</p>
</li>
</ul>
<h1 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h1><h2 id="索引超长"><a href="#索引超长" class="headerlink" title="索引超长"></a>索引超长</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: Specified key was too long; max key length is 1000 bytes</span><br><span class="line">	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) ~[?:1.8.0_162]</span><br><span class="line">	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) ~[?:1.8.0_162]</span><br><span class="line">	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) ~[?:1.8.0_162]</span><br><span class="line">	at java.lang.reflect.Constructor.newInstance(Constructor.java:423) ~[?:1.8.0_162]</span><br><span class="line">	at com.mysql.jdbc.Util.handleNewInstance(Util.java:425) ~[mysql-connector-java-5.1.45.jar:5.1.45]</span><br><span class="line">	at com.mysql.jdbc.Util.getInstance(Util.java:408) ~[mysql-connector-java-5.1.45.jar:5.1.45]</span><br><span class="line">	at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:944) ~[mysql-connector-java-5.1.45.jar:5.1.45]</span><br><span class="line">	at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:3973) ~[mysql-connector-java-5.1.45.jar:5.1.45]</span><br><span class="line">	at com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:3909) ~[mysql-connector-java-5.1.45.jar:5.1.45]</span><br><span class="line">	at com.mysql.jdbc.MysqlIO.sendCommand(MysqlIO.java:2527) ~[mysql-connector-java-5.1.45.jar:5.1.45]</span><br><span class="line">	at com.mysql.jdbc.MysqlIO.sqlQueryDirect(MysqlIO.java:2680) ~[mysql-connector-java-5.1.45.jar:5.1.45]</span><br><span class="line">	at com.mysql.jdbc.ConnectionImpl.execSQL(ConnectionImpl.java:2480) ~[mysql-connector-java-5.1.45.jar:5.1.45]</span><br><span class="line">	at com.mysql.jdbc.ConnectionImpl.execSQL(ConnectionImpl.java:2438) ~[mysql-connector-java-5.1.45.jar:5.1.45]</span><br></pre></td></tr></table></figure>
<p>如果设置了索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Table(indexes = &#123;@Index(name = &quot;idx_server_name&quot;, columnList = &quot;serverName&quot;)&#125;)</span><br></pre></td></tr></table></figure>
<p>上面注解指定了<code>serverName</code>这一列为普通索引，如果此列不做限制，默认的长度是为255，默认的字符编码为<code>utf8mb4</code>，最大字符长度为4字节，255 * 4 = 1020，所以超过了索引长度。</p>
<p>在<code>MyISAM</code>表中，创建索引时，创建的索引长度不能超过<strong>1000</strong>bytes，在<code>InnoDB</code>表中，创建索引时，索引的长度不成超过<strong>767</strong>byts 。</p>
<p>建立索引时，数据库计算key的长度是累加所有Index用到的字段的char长度后再按下面比例乘起来不能超过限定的key长度：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">latin1 = 1 byte = 1 character </span><br><span class="line">uft8 = 3 byte = 1 character </span><br><span class="line">gbk = 2 byte = 1 character </span><br><span class="line">utf8mb4 = 4 byte = 1 character</span><br></pre></td></tr></table></figure>
<h2 id="insert后update"><a href="#insert后update" class="headerlink" title="insert后update"></a>insert后update</h2><p>使用AttributeConverter转换JSON字符串时，Hibernate执行insert之后再执行update</p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-data/jpa-dirty01.png" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-data/jpa-dirty02.png" alt></p>
<p>如上图，这是利用AOP实现的操作日志记录，使用<code>AttributeConverter</code>与Fastjson实现<code>ReqReceiveData</code>转换成JSON字符串，可以看到在执行insert之后接着执行了一次update，那是因为JSON字符串字段顺序居然发生了变化！</p>
<p>不过后来折腾一下把顺序统一了，但还是会出现这种问题，百思不得其解，一样的字符串Hibernate也会认为这是Dirty的数据？</p>
<p>百般折腾得以解决(但还是搞不懂原因)：</p>
<p>value是Object类型，在set的时候调用<code>JSONObject.toJSON(value)</code>转成Object再set进去…</p>
]]></content><categories><category>Programming</category><category>Java</category><category>Spring Boot</category></categories><tags><tag>Java</tag><tag>Spring Boot</tag></tags></entry><entry><title>Spring Boot学习之MVC与Validation</title><url>/2018/spring-boot-mvc-validation/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/spring-boot.png" alt></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><blockquote>
<p>此篇大部分是对Spring MVC的一个回顾以及JSR303中bean validation规范的学习</p>
</blockquote>
<a id="more"></a>
<h1 id="Spring-MVC-相关"><a href="#Spring-MVC-相关" class="headerlink" title="Spring MVC 相关"></a>Spring MVC 相关</h1><h2 id="Spring-MVC-流程"><a href="#Spring-MVC-流程" class="headerlink" title="Spring MVC 流程"></a>Spring MVC 流程</h2><p><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/spring-mvc-process-new.png" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/spring-mvc-convert-processing.png" alt></p>
<p>1、  用户发送请求至前端控制器<code>DispatcherServlet</code>. </p>
<p>2、  <code>DispatcherServlet</code>收到请求调用<code>HandlerMapping</code>处理器映射器. </p>
<p>3、  处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找), 生成处理器对象及处理器拦截器(如果有则生成)一并返回给<code>DispatcherServlet</code>. </p>
<p>4、  <code>DispatcherServlet</code>调用<code>HandlerAdapter</code>处理器适配器. </p>
<p>5、  <code>HandlerAdapter</code>经过适配调用具体的处理器(<code>Controller</code>, 也叫后端控制器). </p>
<p>6、  <code>Controller</code>执行完成返回<code>ModelAndView</code>. </p>
<p>7、  <code>HandlerAdapter</code>将<code>controller</code>执行结果<code>ModelAndView</code>返回给<code>DispatcherServlet</code>. </p>
<p>8、  <code>DispatcherServlet</code>将<code>ModelAndView</code>传给<code>ViewReslover</code>视图解析器. </p>
<p>9、  <code>ViewReslover</code>解析后返回具体<code>View</code>. </p>
<p>10、<code>DispatcherServlet</code>根据<code>View</code>进行渲染视图（即将模型数据填充至视图中）. </p>
<p>11、 <code>DispatcherServlet</code>响应用户. </p>
<blockquote>
<p>更多源码解析请参考: <strong><em><a href="https://segmentfault.com/a/1190000013816079" rel="external nofollow noopener noreferrer" target="_blank">【深入浅出spring】Spring MVC 流程解析</a></em></strong></p>
</blockquote>
<h2 id="Spring-MVC集成FastJson"><a href="#Spring-MVC集成FastJson" class="headerlink" title="Spring MVC集成FastJson"></a>Spring MVC集成FastJson</h2><p><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/web-mvc-configurer.png" alt></p>
<blockquote>
<p><strong><em><a href="https://github.com/alibaba/fastjson/wiki/%E5%9C%A8-Spring-%E4%B8%AD%E9%9B%86%E6%88%90-Fastjson" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/alibaba/fastjson/wiki/%E5%9C%A8-Spring-%E4%B8%AD%E9%9B%86%E6%88%90-Fastjson</a></em></strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.54&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcMessageConvertConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	StringHttpMessageConverter stringHttpMessageConverter;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;</span><br><span class="line">		FastJsonHttpMessageConverter fastConverter = <span class="keyword">new</span> FastJsonHttpMessageConverter();</span><br><span class="line"></span><br><span class="line">		SerializeConfig serializeConfig = SerializeConfig.globalInstance;</span><br><span class="line">		serializeConfig.put(BigInteger<span class="class">.<span class="keyword">class</span>, <span class="title">ToStringSerializer</span>.<span class="title">instance</span>)</span>;</span><br><span class="line">		serializeConfig.put(Long<span class="class">.<span class="keyword">class</span>, <span class="title">ToStringSerializer</span>.<span class="title">instance</span>)</span>;</span><br><span class="line">		serializeConfig.put(Long.TYPE, ToStringSerializer.instance);</span><br><span class="line"></span><br><span class="line">		FastJsonConfig fastJsonConfig = <span class="keyword">new</span> FastJsonConfig();</span><br><span class="line">		fastJsonConfig.setCharset(StandardCharsets.UTF_8);</span><br><span class="line">		fastJsonConfig.setSerializeConfig(serializeConfig);</span><br><span class="line"><span class="comment">//		fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat);</span></span><br><span class="line">		fastJsonConfig.setDateFormat(Constant.DATE_FORMAT);</span><br><span class="line"></span><br><span class="line">		fastConverter.setFastJsonConfig(fastJsonConfig);</span><br><span class="line">		fastConverter.setSupportedMediaTypes(Collections.singletonList(MediaType.APPLICATION_JSON_UTF8));</span><br><span class="line">		converters.add(<span class="number">0</span>, stringHttpMessageConverter);</span><br><span class="line">		converters.add(<span class="number">1</span>, fastConverter);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>:</p>
<ul>
<li>SpringBoot 2.0.1版本中加载<code>WebMvcConfigurer</code>的顺序发生了变动, 故需使用<code>converters.add(0, converter);</code>指定<code>FastJsonHttpMessageConverter</code>在converters内的顺序, 否则在SpringBoot 2.0.1及之后的版本中将优先使用Jackson处理。详情：<strong><em><a href="https://github.com/spring-projects/spring-boot/issues/12389" rel="external nofollow noopener noreferrer" target="_blank">WebMvcConfigurer is overridden by WebMvcAutoConfiguration #12389</a></em></strong></li>
<li>在<code>FastJsonHttpMessageConverter</code>之前插入一个<code>StringHttpMessageConverter</code>是为了在Controller层返回String类型不会再次被FastJson序列化.</li>
</ul>
<h3 id="FastJson枚举映射"><a href="#FastJson枚举映射" class="headerlink" title="FastJson枚举映射"></a>FastJson枚举映射</h3><p>实现 <code>ObjectSerializer,</code> 以及 <code>ObjectDeserializer</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumCodec</span> <span class="keyword">implements</span> <span class="title">ObjectSerializer</span>, <span class="title">ObjectDeserializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;Class&lt;?&gt;, Method&gt; methodCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deserialze</span><span class="params">(DefaultJSONParser parser, Type type, Object fieldName)</span> </span>&#123;</span><br><span class="line">        Object value = parser.parse();</span><br><span class="line">        Class enumClass = (Class) type;</span><br><span class="line">        Method getValueMethod = getMethod(enumClass);</span><br><span class="line">        Enum enumeration = EnumUtils.valueOf(enumClass, value, getValueMethod);</span><br><span class="line">        <span class="keyword">return</span> (T) enumeration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFastMatchToken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JSONToken.LITERAL_INT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(JSONSerializer serializer, Object object, Object fieldName, Type fieldType, <span class="keyword">int</span> features)</span> </span>&#123;</span><br><span class="line">        SerializeWriter out = serializer.getWriter();</span><br><span class="line">        <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">            serializer.getWriter().writeNull();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        IEnum enumeration = (IEnum) object;</span><br><span class="line">        out.write(enumeration.getValue().toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Method <span class="title">getMethod</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">        Method method = methodCache.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (method != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> method;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method = clazz.getDeclaredMethod(<span class="string">"getValue"</span>);</span><br><span class="line">            methodCache.put(clazz, method);</span><br><span class="line">            <span class="keyword">return</span> method;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="方式一-字段上加注解"><a href="#方式一-字段上加注解" class="headerlink" title="方式一: 字段上加注解"></a>方式一: 字段上加注解</h4><p>在枚举字段上添加注解:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JSONField</span>(serializeUsing = EnumCodec<span class="class">.<span class="keyword">class</span>, <span class="title">deserializeUsing</span> </span>= EnumCodec<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">private</span> <span class="title">AgeEnum</span> <span class="title">age</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="方式二-类上加注解"><a href="#方式二-类上加注解" class="headerlink" title="方式二: 类上加注解"></a>方式二: 类上加注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JSONType</span>(serializeEnumAsJavaBean = <span class="keyword">true</span>, serializer = EnumCodec<span class="class">.<span class="keyword">class</span>, <span class="title">deserializer</span> </span>= EnumCodec<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">enum</span> <span class="title">AgeEnum</span> <span class="keyword">implements</span> <span class="title">EnumValueProvider</span> </span>&#123;</span><br><span class="line">  ONE(<span class="number">1</span>, <span class="string">"一岁"</span>),</span><br><span class="line">  TWO(<span class="number">2</span>, <span class="string">"二岁"</span>),</span><br><span class="line">  THREE(<span class="number">3</span>, <span class="string">"三岁"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">  <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">  AgeEnum(<span class="keyword">final</span> <span class="keyword">int</span> value, <span class="keyword">final</span> String desc) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="WebFlux"><a href="#WebFlux" class="headerlink" title="WebFlux"></a>WebFlux</h3><p>上面针对的是Web MVC, <strong>对于Webflux目前不支持这种方式</strong>.</p>
<h2 id="Spring-Boot-JSON-（Date类型入参、格式化-以及如何处理null）"><a href="#Spring-Boot-JSON-（Date类型入参、格式化-以及如何处理null）" class="headerlink" title="Spring Boot JSON （Date类型入参、格式化, 以及如何处理null）"></a>Spring Boot JSON （Date类型入参、格式化, 以及如何处理null）</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">jackson:</span></span><br><span class="line">    <span class="attr">default-property-inclusion:</span> <span class="string">non_null</span> <span class="comment"># 忽略 json 中值为null的属性</span></span><br><span class="line">    <span class="attr">date-format:</span> <span class="string">"yyyy-MM-dd HH:mm:ss"</span> <span class="comment"># 设置 pattern</span></span><br><span class="line">    <span class="attr">time-zone:</span> <span class="string">GMT+8</span> <span class="comment"># 修正时区</span></span><br></pre></td></tr></table></figure>
<ul>
<li>时间格式可以在实体上使用该注解: <code>@JsonFormat(timezone = &quot;GMT+8&quot;,pattern = &quot;yyyy-MM-dd&quot;)</code></li>
<li>忽略null属性可以在实体上使用: <code>@JsonInclude(JsonInclude.Include.NON_NULL)</code></li>
</ul>
<h2 id="Spring-Boot-MVC特性"><a href="#Spring-Boot-MVC特性" class="headerlink" title="Spring Boot MVC特性"></a>Spring Boot MVC特性</h2><p>Spring boot 在spring默认基础上, 自动配置添加了以下特性</p>
<ul>
<li>包含了<code>ContentNegotiatingViewResolver</code>和<code>BeanNameViewResolver</code> beans. </li>
<li>对静态资源的支持, 包括对WebJars的支持. </li>
<li>自动注册<code>Converter</code>, <code>GenericConverter</code>, <code>Formatter</code> beans. </li>
<li>对<code>HttpMessageConverters</code>的支持. </li>
<li>自动注册<code>MessageCodeResolver</code>. </li>
<li>对静态<code>index.html</code>的支持. </li>
<li>对自定义<code>Favicon</code>的支持. </li>
<li>主动使用<code>ConfigurableWebBindingInitializer</code> bean</li>
</ul>
<h2 id="RequestBody与-ModelAttribute"><a href="#RequestBody与-ModelAttribute" class="headerlink" title="@RequestBody与@ModelAttribute"></a>@RequestBody与@ModelAttribute</h2><p><code>@RequestBody</code>: 用于接收http请求中body的字符串信息, 可在直接接收转换到Pojo. </p>
<p><code>@ModelAttribute</code>: 用于直接接受<code>url?</code>后面的参数 如<code>url?id=123&amp;name=456</code>, 可在直接接收转换到Pojo. </p>
<h2 id="模板引擎的选择"><a href="#模板引擎的选择" class="headerlink" title="模板引擎的选择"></a>模板引擎的选择</h2><ul>
<li><code>FreeMarker</code></li>
<li><code>Thymeleaf</code></li>
<li><code>Velocity</code> (1.4版本之后弃用, Spring Framework 4.3版本之后弃用)</li>
<li><code>Groovy</code></li>
<li><code>Mustache</code></li>
</ul>
<p>注: <strong>jsp应该尽量避免使用</strong>, 原因如下: </p>
<ul>
<li>jsp只能打包为: war格式, <strong>不支持jar格式</strong>, 只能在标准的容器里面跑（tomcat, jetty都可以）</li>
<li>内嵌的Jetty目前不支持JSP</li>
<li>Undertow不支持jsp</li>
<li>jsp自定义错误页面不能覆盖spring boot 默认的错误页面</li>
</ul>
<h2 id="开启GZIP算法压缩响应流"><a href="#开启GZIP算法压缩响应流" class="headerlink" title="开启GZIP算法压缩响应流"></a>开启GZIP算法压缩响应流</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">compression:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 启用压缩</span></span><br><span class="line">    <span class="attr">min-response-size:</span> <span class="number">2048</span> <span class="comment"># 对应Content-Length, 超过这个值才会压缩</span></span><br></pre></td></tr></table></figure>
<h2 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h2><p>在Spring Boot 2.X 中, 对于MVC抛出的异常, 默认会映射到 <code>/error</code>:  </p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/spring-boot-mvc-error.png" alt></p>
<blockquote>
<p>参考: <strong><em><a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-error-handling" rel="external nofollow noopener noreferrer" target="_blank">https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-error-handling</a></em></strong></p>
</blockquote>
<p>由于默认情况下, Spring MVC 将报错转发到 <code>/error</code> 接口, 所以对应的Spring中也会有默认的异常处理类 <code>BasicErrorController</code>:</p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/spring-boot-mvc-defalue-error01.png" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/spring-boot-mvc-defalue-error02.png" alt></p>
<h3 id="添加自定义的错误页面"><a href="#添加自定义的错误页面" class="headerlink" title="添加自定义的错误页面"></a>添加自定义的错误页面</h3><ul>
<li><code>html</code>静态页面: 在<code>resources/public/error/</code> 下定义. 如添加404页面: <code>resources/public/error/404.html</code>页面, 中文注意页面编码</li>
<li>模板引擎页面: 在<code>templates/error/</code>下定义. 如添加5xx页面: <code>templates/error/5xx.ftl</code></li>
</ul>
<blockquote>
<p>注: <code>templates/error/</code> 这个的优先级比较<code>resources/public/error/</code>高</p>
</blockquote>
<h3 id="通过-ControllerAdvice"><a href="#通过-ControllerAdvice" class="headerlink" title="通过@ControllerAdvice"></a>通过@ControllerAdvice</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@SuppressWarnings</span>(<span class="string">"ConstantConditions"</span>)</span><br><span class="line">	<span class="meta">@ExceptionHandler</span>(value = &#123;</span><br><span class="line">			MethodArgumentNotValidException<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">			<span class="title">BindException</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">			<span class="title">ConstraintViolationException</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">	@<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">INTERNAL_SERVER_ERROR</span>)</span></span><br><span class="line"><span class="class">	<span class="title">public</span> <span class="title">Response</span>&lt;<span class="title">Void</span>&gt; <span class="title">validExceptionHandler</span>(<span class="title">Exception</span> <span class="title">ex</span>) </span>&#123;</span><br><span class="line">		String validateFailReason;</span><br><span class="line">		<span class="keyword">if</span> (ex <span class="keyword">instanceof</span> MethodArgumentNotValidException) &#123;</span><br><span class="line">			validateFailReason = ((MethodArgumentNotValidException) ex).getBindingResult()</span><br><span class="line">																	   .getFieldError()</span><br><span class="line">																	   .getDefaultMessage();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BindException) &#123;</span><br><span class="line">			validateFailReason = ((BindException) ex).getFieldError().getDefaultMessage();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> ConstraintViolationException) &#123;</span><br><span class="line">			validateFailReason = ((ConstraintViolationException) ex).getConstraintViolations().stream()</span><br><span class="line">																	.findAny()</span><br><span class="line">																	.map(ConstraintViolation::getMessage)</span><br><span class="line">																	.orElse(<span class="string">"Unknown error message"</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			validateFailReason = <span class="string">"Unknown error message"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> Response.error(validateFailReason);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@ExceptionHandler</span>(value = BusiException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">	@<span class="title">ResponseStatus</span>(<span class="title">INTERNAL_SERVER_ERROR</span>)</span></span><br><span class="line"><span class="class">	<span class="title">public</span> <span class="title">Response</span>&lt;<span class="title">Void</span>&gt; <span class="title">busiExceptionHandler</span>(<span class="title">BusiException</span> <span class="title">ex</span>) </span>&#123;</span><br><span class="line">		log.error(<span class="string">"业务异常捕获: "</span> + ex.getMessage());</span><br><span class="line">		<span class="keyword">return</span> Response.error(ex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@ExceptionHandler</span>(value = NoHandlerFoundException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">	@<span class="title">ResponseStatus</span>(<span class="title">NOT_FOUND</span>)</span></span><br><span class="line"><span class="class">	<span class="title">public</span> <span class="title">Response</span>&lt;<span class="title">Void</span>&gt; <span class="title">notFoundExceptionHandler</span>(<span class="title">NoHandlerFoundException</span> <span class="title">ex</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Response.error(ex, NOT_FOUND.value());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@ExceptionHandler</span>(value = TokenException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">	@<span class="title">ResponseStatus</span>(<span class="title">FORBIDDEN</span>)</span></span><br><span class="line"><span class="class">	<span class="title">public</span> <span class="title">Response</span>&lt;<span class="title">Void</span>&gt; <span class="title">tokenExceptionHandler</span>(<span class="title">TokenException</span> <span class="title">ex</span>) </span>&#123;</span><br><span class="line">		log.error(<span class="string">"Token校验异常捕获: "</span> + ex.getMessage());</span><br><span class="line">		<span class="keyword">return</span> Response.error(ex.getMessage(), FORBIDDEN.value());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@ExceptionHandler</span>(value = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">	@<span class="title">ResponseStatus</span>(<span class="title">INTERNAL_SERVER_ERROR</span>)</span></span><br><span class="line"><span class="class">	<span class="title">public</span> <span class="title">Response</span>&lt;<span class="title">Void</span>&gt; <span class="title">defaultErrorHandler</span>(<span class="title">Exception</span> <span class="title">ex</span>) </span>&#123;</span><br><span class="line">		log.error(<span class="string">"全局异常捕获: "</span>, ex);</span><br><span class="line">		<span class="keyword">return</span> Response.error(ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>@RestControllerAdvice</code> 可用于返回JSON格式报文.</li>
</ul>
<p>或者继承<code>ResponseEntityExceptionHandler</code>更灵活地控制状态码、<code>Header</code>等信息: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestResponseEntityExceptionHandler</span> <span class="keyword">extends</span> <span class="title">ResponseEntityExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	@ResponseStatus(HttpStatus.OK)</span></span><br><span class="line">	<span class="meta">@ExceptionHandler</span>(value = &#123; Exception<span class="class">.<span class="keyword">class</span> &#125;)</span></span><br><span class="line"><span class="class">	@<span class="title">Nullable</span></span></span><br><span class="line"><span class="class">	<span class="title">protected</span> <span class="title">ResponseEntity</span>&lt;<span class="title">Object</span>&gt; <span class="title">handleConflict</span>(<span class="title">Exception</span> <span class="title">ex</span>, <span class="title">WebRequest</span> <span class="title">request</span>) </span>&#123;</span><br><span class="line">		String bodyOfResponse = ex.getMessage();</span><br><span class="line">		HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">		headers.set(CONTENT_TYPE, MediaType.APPLICATION_JSON_UTF8_VALUE);</span><br><span class="line">		<span class="keyword">return</span> handleExceptionInternal(ex, bodyOfResponse, headers, HttpStatus.INTERNAL_SERVER_ERROR, request);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多方式请看: <strong><em><a href="http://www.baeldung.com/exception-handling-for-rest-with-spring" rel="external nofollow noopener noreferrer" target="_blank">http://www.baeldung.com/exception-handling-for-rest-with-spring</a></em></strong></p>
<h3 id="异常处理性能优化"><a href="#异常处理性能优化" class="headerlink" title="异常处理性能优化"></a>异常处理性能优化</h3><p>Java 异常对象的构造是十分耗时的, 原因是创建异常对象时会调用父类 <code>Throwable</code> 的 <code>fillInStackTrace()</code> 方法生成栈追踪信息, 对于一般的<strong>业务异常</strong>, 我们可以适当优化, 先看一下 <code>RuntimeException</code> 的构造器:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">RuntimeException</span><span class="params">(String message, Throwable cause,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> enableSuppression,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> writableStackTrace)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message, cause, enableSuppression, writableStackTrace);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这几个参数的意义如下：</p>
<ul>
<li><code>message</code><br>异常的描述信息, 也就是在打印栈追踪信息时异常类名后面紧跟着的描述字符串</li>
<li><code>cause</code><br>导致此异常发生的父异常, 即追踪信息里的<code>caused by</code></li>
<li><code>enableSuppress</code><br>关于异常挂起的参数, 这里我们永远设为 <code>false</code> 即可</li>
<li><code>writableStackTrace</code><br>表示是否生成栈追踪信息, 只要将此参数设为 <code>false</code>, 则在构造异常对象时就不会调用 f<code>illInStackTrace()</code></li>
</ul>
<p>业务异常可以这样定义:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XXXException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 仅包含message, 没有cause, 也不记录栈异常, 性能最高</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XXXException</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(msg, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 包含message, 可指定是否记录异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> recordStackTrace</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EngineException</span><span class="params">(String msg, <span class="keyword">boolean</span> recordStackTrace)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg, <span class="keyword">null</span>, <span class="keyword">false</span>, recordStackTrace);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 包含message和cause, 会记录栈异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EngineException</span><span class="params">(String msg, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg, cause, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般情况用第一个构造参数, 比较轻量级, 想要精准跟踪异常可以使用第三个构造参数.</p>
<h2 id="404处理"><a href="#404处理" class="headerlink" title="404处理"></a>404处理</h2><p>Spring Boot 2.X 中会有一个Resouce的Mapping来处理静态资源, 当输入一个不存在的请求时, 总会匹配到这个Mapping:</p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/spring-mvc-resource-mapping.png" alt></p>
<p>此时的404错误是 <code>ResourceHttpRequestHandler#handleRequest</code> 中因为找不到resource从而调用<code>response#sendError</code> 发出的:</p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/spring-mvc-resource-not-found.png" alt></p>
<p>一般地如果是前后分离的项目, 都不要将资源放在后端, 所以可以用过以下配置关闭这个万能的Mapping:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">add-mappings:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>通过以上配置后, 将加载不了静态资源, 如果需要加载, 需要自定义配置, 比如Swagger:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">	registry.addResourceHandler(<span class="string">"/swagger-ui.html"</span>)</span><br><span class="line">			.addResourceLocations(<span class="string">"classpath:/META-INF/resources/"</span>, <span class="string">"/static"</span>, <span class="string">"/public"</span>);</span><br><span class="line"></span><br><span class="line">	registry.addResourceHandler(<span class="string">"/webjars/**"</span>)</span><br><span class="line">			.addResourceLocations(<span class="string">"classpath:/META-INF/resources/webjars/"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要通过抛异常的方式捕获404这个异常, 需要通过以下配置:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">throw-exception-if-no-handler-found:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/spring-mvc-throw-not-found.png" alt></p>
<p>之后可以通过 <code>@ExceptionHandler(value = NoHandlerFoundException.class)</code> 处理这个404了, 而不是转发到 <code>/error</code>.</p>
<h2 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h2><p>设置静态资源放到指定路径下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.resources.static-locations=classpath:/META-INF/resources/,classpath:/static/</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong><em><a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-spring-mvc-static-content" rel="external nofollow noopener noreferrer" target="_blank">https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-spring-mvc-static-content</a></em></strong></p>
</blockquote>
<h2 id="自定义消息转化器"><a href="#自定义消息转化器" class="headerlink" title="自定义消息转化器"></a>自定义消息转化器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> StringHttpMessageConverter <span class="title">stringHttpMessageConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       StringHttpMessageConverter converter = <span class="keyword">new</span> StringHttpMessageConverter(Charset.forName(<span class="string">"UTF-8"</span>));</span><br><span class="line">       <span class="keyword">return</span> converter;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义SpringMVC的拦截器"><a href="#自定义SpringMVC的拦截器" class="headerlink" title="自定义SpringMVC的拦截器"></a>自定义SpringMVC的拦截器</h2><p>有些时候我们需要自己配置SpringMVC而不是采用默认, 比如增加一个拦截器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"拦截器MyInterceptor-------&gt;3、请求结束之后被调用, 主要用于清理工作. "</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"拦截器MyInterceptor-------&gt;2、请求之后调用, 在视图渲染之前, 也就是Controller方法调用之后"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"拦截器MyInterceptor-------&gt;1、请求之前调用, 也就是Controller方法调用之前. "</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//返回true则继续向下执行, 返回false则取消当前请求</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorConfigurerAdapter</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法用于注册拦截器</span></span><br><span class="line"><span class="comment">     * 可注册多个拦截器, 多个拦截器组成一个拦截器链</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// addPathPatterns 添加路径</span></span><br><span class="line">        <span class="comment">// excludePathPatterns 排除路径</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> MyInterceptor()).addPathPatterns(<span class="string">"/*.*"</span>);</span><br><span class="line">        <span class="keyword">super</span>.addInterceptors(registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者可以使用继承<code>HandlerInterceptorAdapter</code>的方式, 这种方式可以<strong>按需覆盖父类方法</strong>. </p>
<h2 id="创建-Servlet、-Filter、Listener"><a href="#创建-Servlet、-Filter、Listener" class="headerlink" title="创建 Servlet、 Filter、Listener"></a>创建 Servlet、 Filter、Listener</h2><h3 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h3><blockquote>
<p>直接通过<code>@WebServlet</code>、<code>@WebFilter</code>、<code>@WebListener</code> 注解自动注册</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(filterName = <span class="string">"customFilter"</span>, urlPatterns = <span class="string">"/*"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(name = <span class="string">"customServlet"</span>, urlPatterns = <span class="string">"/roncoo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后需要在<code>**Application.java</code> 加上<code>@ServletComponentScan</code>注解, 否则不会生效. </p>
<p><strong>注意: 如果同时添加了<code>@WebFilter</code>以及<code>@Component</code>, 那么会初始化两次Filter, 并且会过滤所有路径+自己指定的路径 , 便会出现对没有指定的URL也会进行过滤</strong></p>
<h3 id="通过编码注册"><a href="#通过编码注册" class="headerlink" title="通过编码注册"></a>通过编码注册</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">myFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        FilterRegistrationBean registrationBean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">        MyFilter filter = <span class="keyword">new</span> MyFilter();</span><br><span class="line">        registrationBean.setFilter(filter);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; urlPatterns = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        urlPatterns.add(<span class="string">"/*"</span>);</span><br><span class="line">        registrationBean.setUrlPatterns(urlPatterns);</span><br><span class="line">        registrationBean.setOrder(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">myServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MyServlet demoServlet = <span class="keyword">new</span> MyServlet();</span><br><span class="line">        ServletRegistrationBean registrationBean = <span class="keyword">new</span> ServletRegistrationBean();</span><br><span class="line">        registrationBean.setServlet(demoServlet);</span><br><span class="line">        List&lt;String&gt; urlMappings = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        urlMappings.add(<span class="string">"/myServlet"</span>);<span class="comment">////访问, 可以添加多个</span></span><br><span class="line">        registrationBean.setUrlMappings(urlMappings);</span><br><span class="line">        registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletListenerRegistrationBean <span class="title">myListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServletListenerRegistrationBean registrationBean</span><br><span class="line">                = <span class="keyword">new</span> ServletListenerRegistrationBean&lt;&gt;();</span><br><span class="line">        registrationBean.setListener(<span class="keyword">new</span> MyListener());</span><br><span class="line">        registrationBean.setOrder(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Spring-Interceptor与Servlet-Filter的区别"><a href="#Spring-Interceptor与Servlet-Filter的区别" class="headerlink" title="Spring Interceptor与Servlet Filter的区别"></a>Spring Interceptor与Servlet Filter的区别</h2><ul>
<li><code>Filter</code>是基于函数回调的, 而<code>Interceptor</code>则是基于Java反射的. </li>
<li><code>Filter</code>依赖于Servlet容器, 而<code>Interceptor</code>不依赖于Servlet容器. </li>
<li><code>Filter</code>对几乎所有的请求起作用, 而<code>Interceptor</code>只能对<code>action</code>请求起作用. </li>
<li><code>Interceptor</code>可以访问<code>Action</code>的上下文, 值栈里的对象, 而<code>Filter</code>不能. </li>
<li>在<code>action</code>的生命周期里, <code>Interceptor</code>可以被多次调用, 而Filter只能在容器初始化时调用一次. </li>
</ul>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-learning/mvc-process.png" alt></p>
<h2 id="RequestBodyAdvice和ResponseBodyAdvice"><a href="#RequestBodyAdvice和ResponseBodyAdvice" class="headerlink" title="RequestBodyAdvice和ResponseBodyAdvice"></a>RequestBodyAdvice和ResponseBodyAdvice</h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>对Request请求参数解密, 对Response返回参数进行加密</li>
<li>自定义返回信息（业务无关性的）</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>先看一下<code>ResponseBodyAdvice</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResponseBodyAdvice</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Whether this component supports the given controller method return type</span></span><br><span class="line"><span class="comment">	 * and the selected &#123;<span class="doctag">@code</span> HttpMessageConverter&#125; type.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> returnType the return type</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> converterType the selected converter type</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if &#123;<span class="doctag">@link</span> #beforeBodyWrite&#125; should be invoked;</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Invoked after an &#123;<span class="doctag">@code</span> HttpMessageConverter&#125; is selected and just before</span></span><br><span class="line"><span class="comment">	 * its write method is invoked.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> body the body to be written</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> returnType the return type of the controller method</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> selectedContentType the content type selected through content negotiation</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> selectedConverterType the converter type selected to write to the response</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> request the current request</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> response the current response</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the body that was passed in or a modified (possibly new) instance</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">T <span class="title">beforeBodyWrite</span><span class="params">(T body, MethodParameter returnType, MediaType selectedContentType,</span></span></span><br><span class="line"><span class="function"><span class="params">			Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType,</span></span></span><br><span class="line"><span class="function"><span class="params">			ServerHttpRequest request, ServerHttpResponse response)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>supports</code>方法指定是否需要执行<code>beforeBodyWrite</code>, 其中参数<code>returnType</code>可以拿到Controller对应方法中的方法注解以及参数注解: <code>returnType.getMethodAnnotation(XXXAnnotation.class)</code>、<code>returnType.getParameterAnnotation(XXXAnnotation.class)</code>. </p>
<p><code>beforeBodyWrite</code>可以对返回的body进行包装或加密: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ybd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 18-5-15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@contact</span> yangbingdong1994@gmail.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span>(annotations = Rest<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">GlobalControllerAdvisor</span> <span class="keyword">implements</span> <span class="title">ResponseBodyAdvice</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String VOID = <span class="string">"void"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * String 类型不支持</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(MethodParameter returnType, Class converterType)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> !(returnType.getGenericParameterType() <span class="keyword">instanceof</span> Class) || !((Class&lt;?&gt;) returnType.getGenericParameterType()).isAssignableFrom(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">beforeBodyWrite</span><span class="params">(Object body, MethodParameter returnType, MediaType selectedContentType, Class selectedConverterType, ServerHttpRequest request, ServerHttpResponse response)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> isVoidMethod(returnType) ? Response.ok() : Response.ok(body);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isVoidMethod</span><span class="params">(MethodParameter returnType)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> VOID.equals(returnType.getGenericParameterType().getTypeName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>需要在类上面添加<code>@ControllerAdvice</code>或<code>@RestControllerAdvice</code>才能生效</li>
</ul>
<blockquote>
<p> <code>RequestBodyAdvice</code>的<code>beforeBodyRead</code>在拦截器之后执行, 所以可以在拦截器做签名检验, 然后在<code>RequestBodyAdvice</code>中解密请求参数</p>
</blockquote>
<h2 id="Spring-Boot和Feign中使用Java-8时间日期API（LocalDate等）的序列化问题"><a href="#Spring-Boot和Feign中使用Java-8时间日期API（LocalDate等）的序列化问题" class="headerlink" title="Spring Boot和Feign中使用Java 8时间日期API（LocalDate等）的序列化问题"></a>Spring Boot和Feign中使用Java 8时间日期API（LocalDate等）的序列化问题</h2><p><strong><em><a href="http://blog.didispace.com/Spring-Boot-And-Feign-Use-localdate/" rel="external nofollow noopener noreferrer" target="_blank">http://blog.didispace.com/Spring-Boot-And-Feign-Use-localdate/</a></em></strong></p>
<h2 id="RequestBody-多读"><a href="#RequestBody-多读" class="headerlink" title="RequestBody 多读"></a>RequestBody 多读</h2><p>有时候, 我们想要在过滤器或者拦截器中记录一下请求信息, POST 请求的 body 部分需要在 Request 中读取 InputStream. 但默认情况下只能读取一次, 可以通过继承 <code>HttpServletRequestWrapper</code> 实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestBodyCachingWrapper</span> <span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] body;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BufferedReader reader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServletInputStream inputStream;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RequestBodyCachingWrapper</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(request);</span><br><span class="line">        loadBody(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadBody</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        body = IoUtil.readBytes(request.getInputStream());</span><br><span class="line">        inputStream = <span class="keyword">new</span> RequestCachingInputStream(body);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getBody() &#123;</span><br><span class="line">        <span class="keyword">return</span> body;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletInputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> inputStream;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getInputStream();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BufferedReader <span class="title">getReader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (reader == <span class="keyword">null</span>) &#123;</span><br><span class="line">            reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream, getCharacterEncoding()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestCachingInputStream</span> <span class="keyword">extends</span> <span class="title">ServletInputStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ByteArrayInputStream inputStream;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RequestCachingInputStream</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">            inputStream = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> inputStream.read();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> inputStream.available() == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReadListener</span><span class="params">(ReadListener readlistener)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Filter:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestBodyCachingFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String method = request.getMethod();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">"GET"</span>.equals(method) &amp;&amp; !<span class="string">"OPTIONS"</span>.equals(method)) &#123;</span><br><span class="line">            filterChain.doFilter(<span class="keyword">new</span> RequestBodyCachingWrapper(request), response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>configuration:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Conditional</span>(RequestBodyCachingCondition<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Bean</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">FilterRegistrationBean</span>&lt;<span class="title">RequestBodyCachingFilter</span>&gt; <span class="title">requestBodyCachingFilterFilterRegistrationBean</span>() </span>&#123;</span><br><span class="line">    FilterRegistrationBean&lt;RequestBodyCachingFilter&gt; registrationBean = <span class="keyword">new</span> FilterRegistrationBean&lt;&gt;();</span><br><span class="line">    RequestBodyCachingFilter requestBodyCachingFilter = <span class="keyword">new</span> RequestBodyCachingFilter();</span><br><span class="line">    registrationBean.setFilter(requestBodyCachingFilter);</span><br><span class="line">    registrationBean.setOrder(Ordered.LOWEST_PRECEDENCE - <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取 requestBody:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getRequestBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RequestBodyCachingWrapper wrapper = WebUtils.getNativeRequest(currentRequest(), RequestBodyCachingWrapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (wrapper != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buf = wrapper.getBody();</span><br><span class="line">        <span class="keyword">if</span> (buf.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(buf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> StrUtil.EMPTY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Restful-性能优化"><a href="#Restful-性能优化" class="headerlink" title="Restful 性能优化"></a>Restful 性能优化</h2><p>在 Spring MVC 中, 通过 <code>@PathVariable</code> 注解可轻松实现 Restful 风格的请求. 但是对于这种请求, Spring MVC 不能通过 url 直接获取到对应的 <code>HandlerMethod</code>, 而是通过 for 循环一个个地匹配, 效率低下.</p>
<p>我们可以通过重写 <code>RequestMappingHandlerMapping#lookupHandlerMethod</code> 方法, 思路是, 如果是匹配类型的 restful 请求, 其真正映射到的是 <code>@RequestMapping#name</code>, 请求时将 <code>name</code> 放在 Header 中, 查找的时候直接拿到通过 Hash 定位即可, 性能与直接匹配的效果一样.</p>
<p>继承 <code>RequestMappingHandlerMapping</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnhanceRequestMappingHandlerMapping</span> <span class="keyword">extends</span> <span class="title">RequestMappingHandlerMapping</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String X_INNER_ACTION = <span class="string">"X-Inner-Action"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, RequestMappingInfoHandlerMethodPair&gt; urlPairLookup;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handlerMethodsInitialized</span><span class="params">(Map&lt;RequestMappingInfo, HandlerMethod&gt; handlerMethods)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.handlerMethodsInitialized(handlerMethods);</span><br><span class="line">        urlPairLookup = <span class="keyword">new</span> HashMap&lt;&gt;(handlerMethods.size());</span><br><span class="line">        handlerMethods.forEach((k, v) -&gt; &#123;</span><br><span class="line">            Set&lt;String&gt; pathPatterns = getMappingPathPatterns(k);</span><br><span class="line">            <span class="keyword">if</span> (pathPatterns.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Not allow multi paths"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            String path = <span class="keyword">new</span> ArrayList&lt;&gt;(pathPatterns).get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (getPathMatcher().isPattern(path)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k.getName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Pattern path must have a name"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                path = k.getName();</span><br><span class="line">            &#125;</span><br><span class="line">            RequestMappingInfoHandlerMethodPair pair = buildPair(k, v);</span><br><span class="line">            urlPairLookup.put(path, pair);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">lookupHandlerMethod</span><span class="params">(String lookupPath, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        String lookupPathKey = defaultIfNull(request.getHeader(X_INNER_ACTION), lookupPath);</span><br><span class="line">        RequestMappingInfoHandlerMethodPair pair = urlPairLookup.get(lookupPathKey);</span><br><span class="line">        <span class="keyword">if</span> (pair == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        request.setAttribute(BEST_MATCHING_HANDLER_ATTRIBUTE, pair.handlerMethod);</span><br><span class="line">        handleMatch(pair.requestMappingInfo, lookupPath, request);</span><br><span class="line">        <span class="keyword">return</span> pair.handlerMethod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RequestMappingInfoHandlerMethodPair <span class="title">buildPair</span><span class="params">(RequestMappingInfo requestMappingInfo, HandlerMethod handlerMethod)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RequestMappingInfoHandlerMethodPair(requestMappingInfo, handlerMethod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestMappingInfoHandlerMethodPair</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> RequestMappingInfo requestMappingInfo;</span><br><span class="line">        <span class="keyword">private</span> HandlerMethod handlerMethod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnhanceWebMvcConfigurationSupport</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> RequestMappingHandlerMapping <span class="title">createRequestMappingHandlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EnhanceRequestMappingHandlerMapping();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="跨域配置"><a href="#跨域配置" class="headerlink" title="跨域配置"></a>跨域配置</h2><h3 id="Spring-Mvc"><a href="#Spring-Mvc" class="headerlink" title="Spring Mvc"></a>Spring Mvc</h3><p>方式一: 在 Controller 的类或者方法上贴上 <code>@CrossOrigin</code></p>
<p>方式二: 上面的方式一需要每个类或者方法都加上, 有点麻烦, 可以使用 Spring 的 <code>CorsFilter</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">	CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">	corsConfiguration.addAllowedHeader(<span class="string">"*"</span>);</span><br><span class="line">	corsConfiguration.addAllowedOrigin(<span class="string">"*"</span>);</span><br><span class="line">	corsConfiguration.addAllowedMethod(<span class="string">"*"</span>);</span><br><span class="line">	corsConfiguration.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">	corsConfiguration.setMaxAge(Duration.ofHours(<span class="number">1</span>));</span><br><span class="line">	source.registerCorsConfiguration(<span class="string">"/**"</span>, corsConfiguration);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .httpBasic()</span><br><span class="line">                .and()</span><br><span class="line">                .cors()</span><br><span class="line">                .configurationSource(corsConfigurationSource())</span><br><span class="line">                .and()</span><br><span class="line">                .csrf()</span><br><span class="line">                .disable();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">CorsConfigurationSource <span class="title">corsConfigurationSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        CorsConfiguration configuration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        configuration.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">        configuration.setAllowedOrigins(Arrays.asList(<span class="string">"*"</span>));</span><br><span class="line">        configuration.setAllowedMethods(Arrays.asList(<span class="string">"*"</span>));</span><br><span class="line">        configuration.setAllowedHeaders(Arrays.asList(<span class="string">"*"</span>));</span><br><span class="line">        configuration.setMaxAge(Duration.ofHours(<span class="number">1</span>));</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">"/**"</span>,configuration);</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="OAuth2"><a href="#OAuth2" class="headerlink" title="OAuth2"></a>OAuth2</h3><p>集成了 OAth2 后, <code>/oauth/token</code> 会先发送一次 option 请求.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalCorsConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        corsConfiguration.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">        corsConfiguration.addAllowedOrigin(<span class="string">"*"</span>);</span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">"*"</span>);</span><br><span class="line">        corsConfiguration.addAllowedMethod(<span class="string">"*"</span>);</span><br><span class="line">        UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        urlBasedCorsConfigurationSource.registerCorsConfiguration(<span class="string">"/**"</span>, corsConfiguration);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(urlBasedCorsConfigurationSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在 SecurityConfig 中开启跨域支持</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Order</span>(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">                .requestMatchers().antMatchers(HttpMethod.OPTIONS, <span class="string">"/oauth/**"</span>)</span><br><span class="line">                .and()</span><br><span class="line">                .csrf().disable().formLogin()</span><br><span class="line">                .and()</span><br><span class="line">                .cors();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Validation"><a href="#Validation" class="headerlink" title="Validation"></a>Validation</h1><h2 id="常用注解（大部分JSR中已有）"><a href="#常用注解（大部分JSR中已有）" class="headerlink" title="常用注解（大部分JSR中已有）"></a>常用注解（大部分<strong>JSR</strong>中已有）</h2><table>
<thead>
<tr>
<th>注解</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@AssertFalse</code></td>
<td>Boolean,boolean</td>
<td>验证注解的元素值是false</td>
</tr>
<tr>
<td><code>@AssertTrue</code></td>
<td>Boolean,boolean</td>
<td>验证注解的元素值是true</td>
</tr>
<tr>
<td><code>@NotNull</code></td>
<td>任意类型</td>
<td>验证注解的元素值不是null</td>
</tr>
<tr>
<td><code>@Null</code></td>
<td>任意类型</td>
<td>验证注解的元素值是null</td>
</tr>
<tr>
<td><code>@Min(value=值)</code></td>
<td>BigDecimal, BigInteger, byte,short, int, long, 等任何Number或CharSequence（存储的是数字）子类型</td>
<td>验证注解的元素值大于等于@Min指定的value值</td>
</tr>
<tr>
<td><code>@Max（value=值）</code></td>
<td>和@Min要求一样</td>
<td>验证注解的元素值小于等于@Max指定的value值</td>
</tr>
<tr>
<td><code>@DecimalMin(value=值)</code></td>
<td>和@Min要求一样</td>
<td>验证注解的元素值大于等于@ DecimalMin指定的value值</td>
</tr>
<tr>
<td><code>@DecimalMax(value=值)</code></td>
<td>和@Min要求一样</td>
<td>验证注解的元素值小于等于@ DecimalMax指定的value值</td>
</tr>
<tr>
<td><code>@Digits(integer=整数位数, fraction=小数位数)</code></td>
<td>和@Min要求一样</td>
<td>验证注解的元素值的整数位数和小数位数上限</td>
</tr>
<tr>
<td><code>@Size(min=下限, max=上限)</code></td>
<td>字符串、Collection、Map、数组等</td>
<td>验证注解的元素值的在min和max（包含）指定区间之内, 如字符长度、集合大小</td>
</tr>
<tr>
<td><code>@Past</code></td>
<td>java.util.Date,java.util.Calendar;Joda Time类库的日期类型</td>
<td>验证注解的元素值（日期类型）比当前时间早</td>
</tr>
<tr>
<td><code>@Future</code></td>
<td>与@Past要求一样</td>
<td>验证注解的元素值（日期类型）比当前时间晚</td>
</tr>
<tr>
<td><code>@NotBlank</code></td>
<td>CharSequence子类型</td>
<td>验证注解的元素值不为空（不为null、去除首位空格后长度为0）, 不同于@NotEmpty, @NotBlank只应用于字符串且在比较时会去除字符串的首位空格</td>
</tr>
<tr>
<td><code>@Length(min=下限, max=上限)</code></td>
<td>CharSequence子类型</td>
<td>验证注解的元素值长度在min和max区间内</td>
</tr>
<tr>
<td><code>@NotEmpty</code></td>
<td>CharSequence子类型、Collection、Map、数组</td>
<td>验证注解的元素值不为null且不为空（字符串长度不为0、集合大小不为0）</td>
</tr>
<tr>
<td><code>@Range(min=最小值, max=最大值)</code></td>
<td>BigDecimal,BigInteger,CharSequence, byte, short, int, long等原子类型和包装类型</td>
<td>验证注解的元素值在最小值和最大值之间</td>
</tr>
<tr>
<td><code>@Email(regexp=正则表达式,flag=标志的模式)</code></td>
<td>CharSequence子类型（如String）</td>
<td>验证注解的元素值是Email, 也可以通过regexp和flag指定自定义的email格式</td>
</tr>
<tr>
<td><code>@Pattern(regexp=正则表达式,flag=标志的模式)</code></td>
<td>String, 任何CharSequence的子类型</td>
<td>验证注解的元素值与指定的正则表达式匹配</td>
</tr>
<tr>
<td><code>@Valid</code></td>
<td>任何非原子类型</td>
<td>指定递归验证关联的对象；如用户对象中有个地址对象属性, 如果想在验证用户对象时一起验证地址对象的话, 在地址对象上加@Valid注解即可级联验证</td>
</tr>
</tbody>
</table>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>实体: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">	<span class="meta">@NotBlank</span></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Min</span>(<span class="number">18</span>)</span><br><span class="line">	<span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Pattern</span>(regexp = <span class="string">"^1([34578])\\d&#123;9&#125;$"</span>,message = <span class="string">"手机号码格式错误"</span>)</span><br><span class="line">	<span class="meta">@NotBlank</span>(message = <span class="string">"手机号码不能为空"</span>)</span><br><span class="line">	<span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Email</span>(message = <span class="string">"邮箱格式错误"</span>)</span><br><span class="line">	<span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Controller</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@PostMapping</span>(<span class="string">"/foo"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">foo</span><span class="params">(@Validated Foo foo, BindingResult bindingResult)</span> </span>&#123;</span><br><span class="line">      log.info(<span class="string">"foo: &#123;&#125;"</span>, foo);</span><br><span class="line">      <span class="keyword">if</span> (bindingResult.hasErrors()) &#123;</span><br><span class="line">         <span class="keyword">for</span> (FieldError fieldError : bindingResult.getFieldErrors()) &#123;</span><br><span class="line">            log.error(<span class="string">"valid fail: field = &#123;&#125;, message = &#123;&#125;"</span>, fieldError.getField(), fieldError.getDefaultMessage());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"fail"</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速失效"><a href="#快速失效" class="headerlink" title="快速失效"></a>快速失效</h2><p>一般情况下, Validator并不会应为第一个校验失败为停止, 而是一直校验完所有参数. 我们可以通过设置快速失效: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidatorConfiguration</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Validator <span class="title">validator</span><span class="params">()</span></span>&#123;</span><br><span class="line">		ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator<span class="class">.<span class="keyword">class</span> )</span></span><br><span class="line"><span class="class">													  .<span class="title">configure</span>()</span></span><br><span class="line"><span class="class">													  .<span class="title">failFast</span>( <span class="title">true</span> )</span></span><br><span class="line">//													  .addProperty( "hibernate.validator.fail_fast", "true" )</span><br><span class="line">													  .buildValidatorFactory();</span><br><span class="line">		<span class="keyword">return</span> validatorFactory.getValidator();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样在遇到第一个校验失败的时候就会停止对之后的参数校验. </p>
<h2 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h2><blockquote>
<p>如果同一个类, 在不同的使用场景下有不同的校验规则, 那么可以使用分组校验. 未成年人是不能喝酒的, 而在其他场景下我们不做特殊的限制, 这个需求如何体现同一个实体, 不同的校验规则呢？</p>
</blockquote>
<p>添加分组: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class Foo&#123;</span><br><span class="line">	<span class="meta">@Min</span>(value = <span class="number">18</span>,groups = &#123;Adult<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">	<span class="title">private</span> <span class="title">Integer</span> <span class="title">age</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Adult</span></span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Minor</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Controller</code>: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/drink"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">drink</span><span class="params">(@Validated(&#123;Foo.Adult.class&#125;)</span> Foo foo, BindingResult bindingResult) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bindingResult.hasErrors())&#123;</span><br><span class="line">        <span class="keyword">for</span> (FieldError fieldError : bindingResult.getFieldErrors()) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"fail"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义校验"><a href="#自定义校验" class="headerlink" title="自定义校验"></a>自定义校验</h2><p>业务需求总是比框架提供的这些简单校验要复杂的多, 我们可以自定义校验来满足我们的需求. 自定义spring validation非常简单, 主要分为两步. </p>
<p>1 自定义校验注解<br>我们尝试添加一个“字符串不能包含空格”的限制. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint</span>(validatedBy = &#123;CannotHaveBlankValidator<span class="class">.<span class="keyword">class</span>&#125;)&lt;1&gt;</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">CannotHaveBlank</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认错误消息</span></span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "不能包含空格"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分组</span></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//负载</span></span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定多个时使用</span></span><br><span class="line">    <span class="meta">@Target</span>(&#123;FIELD, METHOD, PARAMETER, ANNOTATION_TYPE&#125;)</span><br><span class="line">    <span class="meta">@Retention</span>(RUNTIME)</span><br><span class="line">    <span class="meta">@Documented</span></span><br><span class="line">    <span class="meta">@interface</span> List &#123;</span><br><span class="line">        CannotHaveBlank[] value();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们不需要关注太多东西, 使用spring validation的原则便是便捷我们的开发, 例如payload, List , groups, 都可以忽略. </p>
<p><code>&lt;1&gt;</code> 自定义注解中指定了这个注解真正的验证者类. </p>
<p>2 编写真正的校验者类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CannotHaveBlankValidator</span> <span class="keyword">implements</span> &lt;1&gt; <span class="title">ConstraintValidator</span>&lt;<span class="title">CannotHaveBlank</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(CannotHaveBlank constraintAnnotation)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String value, ConstraintValidatorContext context &lt;<span class="number">2</span>&gt;)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//null时不进行校验</span></span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; value.contains(<span class="string">" "</span>)) &#123;</span><br><span class="line">	        &lt;<span class="number">3</span>&gt;</span><br><span class="line">            <span class="comment">//获取默认提示信息</span></span><br><span class="line">            String defaultConstraintMessageTemplate = context.getDefaultConstraintMessageTemplate();</span><br><span class="line">            System.out.println(<span class="string">"default message :"</span> + defaultConstraintMessageTemplate);</span><br><span class="line">            <span class="comment">//禁用默认提示信息</span></span><br><span class="line">            context.disableDefaultConstraintViolation();</span><br><span class="line">            <span class="comment">//设置提示语</span></span><br><span class="line">            context.buildConstraintViolationWithTemplate(<span class="string">"can not contains blank"</span>).addConstraintViolation();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>&lt;1&gt;</code> 所有的验证者都需要实现<code>ConstraintValidator</code>接口, 它的接口也很形象, 包含一个初始化事件方法, 和一个判断是否合法的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">A</span> <span class="keyword">extends</span> <span class="title">Annotation</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">(A constraintAnnotation)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(T value, ConstraintValidatorContext context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>&lt;2&gt;</code> <code>ConstraintValidatorContext</code> 这个上下文包含了认证中所有的信息, 我们可以利用这个上下文实现获取默认错误提示信息, 禁用错误提示信息, 改写错误提示信息等操作. </p>
<p><code>&lt;3&gt;</code> 一些典型校验操作, 或许可以对你产生启示作用. </p>
<p>值得注意的一点是, 自定义注解可以用在<code>METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER</code>之上, <code>ConstraintValidator</code>的第二个泛型参数T, 是需要被校验的类型. </p>
<h2 id="手动校验"><a href="#手动校验" class="headerlink" title="手动校验"></a>手动校验</h2><p>可能在某些场景下需要我们手动校验, 即使用校验器对需要被校验的实体发起validate, 同步获得校验结果. 理论上我们既可以使用Hibernate Validation提供Validator, 也可以使用Spring对其的封装. 在spring构建的项目中, 提倡使用经过spring封装过后的方法, 这里两种方法都介绍下: </p>
<p><strong>Hibernate Validation</strong>: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Foo foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.setAge(<span class="number">22</span>);</span><br><span class="line">foo.setEmail(<span class="string">"000"</span>);</span><br><span class="line">ValidatorFactory vf = Validation.buildDefaultValidatorFactory();</span><br><span class="line">Validator validator = vf.getValidator();</span><br><span class="line">Set&lt;ConstraintViolation&lt;Foo&gt;&gt; set = validator.validate(foo);</span><br><span class="line"><span class="keyword">for</span> (ConstraintViolation&lt;Foo&gt; constraintViolation : set) &#123;</span><br><span class="line">    System.out.println(constraintViolation.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于依赖了Hibernate Validation框架, 我们需要调用Hibernate相关的工厂方法来获取validator实例, 从而校验. </p>
<p>在spring framework文档的Validation相关章节, 可以看到如下的描述: </p>
<blockquote>
<p>Spring provides full support for the Bean Validation API. This includes convenient support for bootstrapping a JSR-303/JSR-349 Bean Validation provider as a Spring bean. This allows for a javax.validation.ValidatorFactory or javax.validation.Validator to be injected wherever validation is needed in your application. Use the LocalValidatorFactoryBean to configure a default Validator as a Spring bean:</p>
</blockquote>
<blockquote>
<p>bean id=”validator” class=”org.springframework.validation.beanvalidation.LocalValidatorFactoryBean”</p>
</blockquote>
<blockquote>
<p>The basic configuration above will trigger Bean Validation to initialize using its default bootstrap mechanism. A JSR-303/JSR-349 provider, such as Hibernate Validator, is expected to be present in the classpath and will be detected automatically.</p>
</blockquote>
<p>上面这段话主要描述了spring对validation全面支持JSR-303、JSR-349的标准, 并且封装了<code>LocalValidatorFactoryBean</code>作为validator的实现. 值得一提的是, 这个类的责任其实是非常重大的, 他兼容了spring的validation体系和hibernate的validation体系, 也可以被开发者直接调用, 代替上述的从工厂方法中获取的hibernate validator. 由于我们使用了springboot, 会触发web模块的自动配置, <code>LocalValidatorFactoryBean</code>已经成为了Validator的默认实现, 使用时只需要自动注入即可. </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">Validator globalValidator; &lt;<span class="number">1</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/validate"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">validate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Foo foo = <span class="keyword">new</span> Foo();</span><br><span class="line">    foo.setAge(<span class="number">22</span>);</span><br><span class="line">    foo.setEmail(<span class="string">"000"</span>);</span><br><span class="line"></span><br><span class="line">    Set&lt;ConstraintViolation&lt;Foo&gt;&gt; set = globalValidator.validate(foo);&lt;<span class="number">2</span>&gt;</span><br><span class="line">    <span class="keyword">for</span> (ConstraintViolation&lt;Foo&gt; constraintViolation : set) &#123;</span><br><span class="line">        System.out.println(constraintViolation.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>&lt;1&gt;</code> 真正使用过<code>Validator</code>接口的读者会发现有两个接口, 一个是位于<code>javax.validation</code>包下, 另一个位于<code>org.springframework.validation</code>包下, <strong>注意我们这里使用的是前者</strong><code>javax.validation</code>, 后者是spring自己内置的校验接口, <code>LocalValidatorFactoryBean</code>同时实现了这两个接口. </p>
<p><code>&lt;2&gt;</code> 此处校验接口最终的实现类便是<code>LocalValidatorFactoryBean</code>. </p>
<h2 id="基于方法校验"><a href="#基于方法校验" class="headerlink" title="基于方法校验"></a>基于方法校验</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Validated</span> &lt;<span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BarController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/bar"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@NotBlank</span> &lt;<span class="number">2</span>&gt; <span class="function">String <span class="title">bar</span><span class="params">(@Min(<span class="number">18</span>)</span> Integer age &lt;3&gt;) </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"age : "</span> + age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(ConstraintViolationException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Map</span> <span class="title">handleConstraintViolationException</span>(<span class="title">ConstraintViolationException</span> <span class="title">cve</span>)</span>&#123;</span><br><span class="line">        Set&lt;ConstraintViolation&lt;?&gt;&gt; cves = cve.getConstraintViolations();&lt;<span class="number">4</span>&gt;</span><br><span class="line">        <span class="keyword">for</span> (ConstraintViolation&lt;?&gt; constraintViolation : cves) &#123;</span><br><span class="line">            System.out.println(constraintViolation.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">"errorCode"</span>,<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>&lt;1&gt;</code> 为类添加@Validated注解</p>
<p><code>&lt;2&gt; &lt;3&gt;</code> 校验方法的返回值和入参</p>
<p><code>&lt;4&gt;</code> 添加一个异常处理器, 可以获得没有通过校验的属性相关信息</p>
<p>基于方法的校验, 个人不推荐使用, 感觉和项目结合的不是很好. </p>
<h2 id="统一处理验证异常"><a href="#统一处理验证异常" class="headerlink" title="统一处理验证异常"></a>统一处理验证异常</h2><table>
<thead>
<tr>
<th>异常类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ConstraintViolationException</code></td>
<td>违反约束, javax扩展定义</td>
</tr>
<tr>
<td><code>BindException</code></td>
<td>绑定失败, 如表单对象参数违反约束</td>
</tr>
<tr>
<td><code>MethodArgumentNotValidException</code></td>
<td>参数无效, 如JSON请求参数违反约束</td>
</tr>
<tr>
<td><code>MissingServletRequestParameterException</code></td>
<td>参数缺失</td>
</tr>
<tr>
<td><code>TypeMismatchException</code></td>
<td>参数类型不匹配</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@ExceptionHandler</span>(value = &#123;</span><br><span class="line">			MethodArgumentNotValidException<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">			<span class="title">BindException</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">			<span class="title">ConstraintViolationException</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">	@<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">OK</span>)</span></span><br><span class="line"><span class="class">	<span class="title">public</span> <span class="title">Response</span>&lt;<span class="title">Void</span>&gt; <span class="title">handleValidException</span>(<span class="title">Exception</span> <span class="title">ex</span>) </span>&#123;</span><br><span class="line">		String validateFailReason;</span><br><span class="line">		<span class="keyword">if</span> (ex <span class="keyword">instanceof</span> MethodArgumentNotValidException) &#123;</span><br><span class="line">			validateFailReason = ((MethodArgumentNotValidException) ex).getBindingResult()</span><br><span class="line">																	   .getFieldError()</span><br><span class="line">																	   .getDefaultMessage();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BindException) &#123;</span><br><span class="line">			validateFailReason = ((BindException) ex).getFieldError().getDefaultMessage();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> ConstraintViolationException) &#123;</span><br><span class="line">			validateFailReason = ((ConstraintViolationException) ex).getConstraintViolations().stream()</span><br><span class="line">																	.findAny()</span><br><span class="line">																	.map(ConstraintViolation::getMessage)</span><br><span class="line">																	.orElse(<span class="string">"Unknown error message"</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			validateFailReason = <span class="string">"Unknown error message"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> Response.error(validateFailReason);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@ExceptionHandler</span>(value = &#123;Exception<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">	<span class="title">public</span> <span class="title">Response</span>&lt;<span class="title">Void</span>&gt; <span class="title">handle</span>(<span class="title">Exception</span> <span class="title">exception</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Response.error(exception.getMessage());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考:<br><strong><em><a href="https://www.cnkirito.moe/2017/08/16/%E4%BD%BF%E7%94%A8spring%20validation%E5%AE%8C%E6%88%90%E6%95%B0%E6%8D%AE%E5%90%8E%E7%AB%AF%E6%A0%A1%E9%AA%8C/" rel="external nofollow noopener noreferrer" target="_blank">https://www.cnkirito.moe/2017/08/16/%E4%BD%BF%E7%94%A8spring%20validation%E5%AE%8C%E6%88%90%E6%95%B0%E6%8D%AE%E5%90%8E%E7%AB%AF%E6%A0%A1%E9%AA%8C/</a></em></strong></p>
<p>相关代码:</p>
<p><strong><em><a href="https://github.com/masteranthoneyd/spring-boot-learning" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/masteranthoneyd/spring-boot-learning</a></em></strong></p>
</blockquote>
]]></content><categories><category>Programming</category><category>Java</category><category>Spring Boot</category></categories><tags><tag>Java</tag><tag>Spring Boot</tag><tag>Spring</tag></tags></entry><entry><title>Spring Cloud Stack Learning</title><url>/2018/spring-cloud-stack-learning/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/spring-cloud-docker-integration/spring-cloud-stack.jpg" alt></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><blockquote>
<p>Spring Cloud 是一系列框架的有序集合. 它利用 Spring Boot 的开发便利性巧妙地简化了分布式系统基础设施的开发, 如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等, 都可以用 Spring Boot 的开发风格做到一键启动和部署. Spring 并没有重复制造轮子, 它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来, 通过 Spring Boot 风格进行再封装屏蔽掉了复杂的配置和实现原理, 最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包. </p>
<p>至于各种框架组件的相关概念以及入门教程网上一大把, 此篇博文主要记录个人在使用Spring Cloud构建微服务的一些配置以及踩坑…</p>
<p>集成Docker部分请看 <strong><em><a href="/2018/spring-boot-docker-elk/">Spring Boot Docker Integration</a></em></strong></p>
</blockquote>
<a id="more"></a>
<h1 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h1><blockquote>
<p>Eureka是Netflix开发的服务发现组件, 本身是一个基于REST的服务. Spring Cloud将它集成在其子项目<code>spring-cloud-netflix</code>中, 以实现Spring Cloud的服务发现功能. </p>
</blockquote>
<h2 id="单节点"><a href="#单节点" class="headerlink" title="单节点"></a>单节点</h2><h3 id="核心依赖"><a href="#核心依赖" class="headerlink" title="核心依赖"></a>核心依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Base认证需要, 前端账户密码登陆 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a><code>application.yml</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: discovery</span><br><span class="line">  profiles:</span><br><span class="line">    active: single</span><br><span class="line">  security:  ## http base security 帐号密码</span><br><span class="line">    user:</span><br><span class="line">      name: ybd</span><br><span class="line">      password: ybd</span><br><span class="line">eureka:</span><br><span class="line">  client: # 以下两项默认为true</span><br><span class="line">    fetch-registry: true</span><br><span class="line">    register-with-eureka: true</span><br><span class="line">  instance:</span><br><span class="line">    prefer-ip-address: true</span><br><span class="line">    ip-address: $&#123;eureka.instance.hostname&#125;</span><br><span class="line">    instance-id: $&#123;spring.application.name&#125;:$&#123;spring.application.instance_id:$&#123;server.port&#125;&#125;</span><br><span class="line"></span><br><span class="line">management: # 暴露所有端点, Spring Boot Admin监控使用</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &quot;*&quot;</span><br><span class="line">  endpoint:</span><br><span class="line">    health:</span><br><span class="line">      show-details: ALWAYS</span><br></pre></td></tr></table></figure>
<ul>
<li><code>eureka.client.register-with-eureka</code>: 表示是否将自己注册到 Eureka Server, 默认为 true. </li>
<li><code>eureka.client.fetch-registry</code>: 表示是否从 Eureka Server 获取注册信息, 默认为 true. </li>
<li><code>eureka.client.service-url.defaultZone</code>: 设置与 Eureka Server 交互的地址, 查询服务和注册服务都需要依赖这个地址. 默认是 <a href="http://localhost:8761/eureka" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8761/eureka</a> ；多个地址可使用英文逗号（,）分隔. </li>
</ul>
<h3 id="application-single-yml"><a href="#application-single-yml" class="headerlink" title="application-single.yml"></a><code>application-single.yml</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8761</span><br><span class="line">eureka:</span><br><span class="line">  environment: dev</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost</span><br><span class="line">    prefer-ip-address: false</span><br><span class="line">    metadata-map:  # 由于配置了安全认证, Spring Boot Admin 通过拿到此信息获取Eureka的端点信息</span><br><span class="line">      user.name: ybd</span><br><span class="line">      user.password: ybd</span><br><span class="line">  client: </span><br><span class="line">    fetch-registry: false</span><br><span class="line">    register-with-eureka: true</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://ybd:ybd@$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span><br><span class="line">  server:</span><br><span class="line">    enable-self-preservation: false  # 禁用保护模式</span><br><span class="line">    eviction-interval-timer-in-ms: 15000</span><br></pre></td></tr></table></figure>
<h3 id="Security配置"><a href="#Security配置" class="headerlink" title="Security配置"></a>Security配置</h3><p>开启<code>basic</code>的认证需要添加依赖: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>配置类: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableWebSecurity</span><br><span class="line">class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line">	private static final String EUREKA = &quot;/eureka/**&quot;;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">		http.csrf().ignoringAntMatchers(EUREKA);</span><br><span class="line">		super.configure(http);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Docker构建HA-Eureka-Server"><a href="#Docker构建HA-Eureka-Server" class="headerlink" title="Docker构建HA Eureka Server"></a>Docker构建HA Eureka Server</h2><p><strong>基于Compose运行高可用的Eureka</strong></p>
<h3 id="application-yml-1"><a href="#application-yml-1" class="headerlink" title="application.yml"></a><code>application.yml</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: discovery</span><br><span class="line">  profiles:</span><br><span class="line">    active: single</span><br><span class="line">  security:  # 安全认证帐号密码</span><br><span class="line">    user:</span><br><span class="line">      name: ybd </span><br><span class="line">      password: ybd</span><br><span class="line">  cloud:  # 忽略以下网卡</span><br><span class="line">    inetutils:</span><br><span class="line">      ignored-interfaces:</span><br><span class="line">      - eth0</span><br><span class="line">      - eth1</span><br><span class="line">      - eth2</span><br><span class="line">      - eth3</span><br><span class="line">      - lo</span><br><span class="line">eureka:</span><br><span class="line">  environment: prod # 在Eureka控制面板中显示prod环境</span><br><span class="line">  client:  # 以下两项默认为true</span><br><span class="line">    fetch-registry: true</span><br><span class="line">    register-with-eureka: true # 注册自己</span><br><span class="line">  instance:</span><br><span class="line">    prefer-ip-address: true</span><br><span class="line">    ip-address: $&#123;eureka.instance.hostname&#125;</span><br><span class="line">    instance-id: $&#123;spring.application.name&#125;:$&#123;spring.application.instance_id:$&#123;server.port&#125;&#125;</span><br><span class="line"></span><br><span class="line">management:  # Spring Boot Admin 使用的端点</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &quot;*&quot;</span><br><span class="line">  endpoint:</span><br><span class="line">    health:</span><br><span class="line">      show-details: ALWAYS</span><br></pre></td></tr></table></figure>
<h3 id="application-cluster1-yml"><a href="#application-cluster1-yml" class="headerlink" title="application-cluster1.yml"></a><code>application-cluster1.yml</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8761</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    prefer-ip-address: true  # 优先使用ip</span><br><span class="line">    ip-address: eureka-cluster1 # ip地址, 这里对应的是docker compose文件中的网络别名aliases</span><br><span class="line">    instance-id: $&#123;spring.application.name&#125;:$&#123;spring.application.instance_id:$&#123;server.port&#125;&#125;</span><br><span class="line">    metadata-map:  # spring boot admin 会通过eureka读取该信息从而通过认证拿到相关服务发现信息</span><br><span class="line">      user.name: ybd</span><br><span class="line">      user.password: ybd</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://ybd:ybd@eureka-cluster2:8762/eureka/,http://ybd:ybd@eureka-cluster3:8763/eureka/</span><br><span class="line">  server:</span><br><span class="line">    enable-self-preservation: false # 关闭自我保护模式</span><br></pre></td></tr></table></figure>
<h3 id="application-cluster2-yml"><a href="#application-cluster2-yml" class="headerlink" title="application-cluster2.yml"></a><code>application-cluster2.yml</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8762</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    prefer-ip-address: true  # 优先使用ip</span><br><span class="line">    ip-address: eureka-cluster2 # ip地址, 这里对应的是docker compose文件中的网络alias</span><br><span class="line">    metadata-map:</span><br><span class="line">      user.name: ybd</span><br><span class="line">      user.password: ybd</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://ybd:ybd@eureka-cluster1:8761/eureka/,http://ybd:ybd@eureka-cluster3:8763/eureka/</span><br><span class="line">  server:</span><br><span class="line">    enable-self-preservation: false</span><br></pre></td></tr></table></figure>
<h3 id="application-cluster3-yml"><a href="#application-cluster3-yml" class="headerlink" title="application-cluster3.yml"></a><code>application-cluster3.yml</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8763</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    prefer-ip-address: true  # 优先使用ip</span><br><span class="line">    ip-address: eureka-cluster3 # ip地址, 这里对应的是docker compose文件中的网络alias</span><br><span class="line">    metadata-map:</span><br><span class="line">      user.name: ybd</span><br><span class="line">      user.password: ybd</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://ybd:ybd@eureka-cluster1:8761/eureka/,http://ybd:ybd@eureka-cluster2:8762/eureka/</span><br><span class="line">  server:</span><br><span class="line">    enable-self-preservation: false</span><br></pre></td></tr></table></figure>
<h3 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a><code>docker-compose.yml</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &apos;3.4&apos;</span><br><span class="line">services:</span><br><span class="line">  eureka-cluster1:</span><br><span class="line">    image: eureka-cluster:latest</span><br><span class="line">    environment:</span><br><span class="line">      - ACTIVE=cluster1</span><br><span class="line">      - JAVA_OPTS=-Xms512m -Xmx512m</span><br><span class="line">    ports:</span><br><span class="line">      - 8761:8761</span><br><span class="line">    restart: always</span><br><span class="line">    healthcheck:</span><br><span class="line">      test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://ybd:ybd@localhost:8761/actuator/health&quot;]</span><br><span class="line">      interval: 30s</span><br><span class="line">      timeout: 10s</span><br><span class="line">      retries: 3</span><br><span class="line">      start_period: 15s</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints:</span><br><span class="line">        - node.hostname == node1</span><br><span class="line">    networks:</span><br><span class="line">      backend:</span><br><span class="line">        aliases:</span><br><span class="line">          - eureka-cluster1</span><br><span class="line">          </span><br><span class="line">  eureka-cluster2:</span><br><span class="line">    image: eureka-cluster:latest</span><br><span class="line">    environment:</span><br><span class="line">      - ACTIVE=cluster2</span><br><span class="line">      - JAVA_OPTS=-Xms512m -Xmx512m</span><br><span class="line">    ports:</span><br><span class="line">      - 8762:8762</span><br><span class="line">    restart: always</span><br><span class="line">    healthcheck:</span><br><span class="line">      test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://ybd:ybd@localhost:8762/actuator/health&quot;]</span><br><span class="line">      interval: 30s</span><br><span class="line">      timeout: 10s</span><br><span class="line">      retries: 3</span><br><span class="line">      start_period: 15s</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints:</span><br><span class="line">        - node.hostname == node2</span><br><span class="line">    networks:</span><br><span class="line">      backend:</span><br><span class="line">        aliases:</span><br><span class="line">          - eureka-cluster2</span><br><span class="line">          </span><br><span class="line">  eureka-cluster3:</span><br><span class="line">    image: eureka-cluster:latest</span><br><span class="line">    environment:</span><br><span class="line">      - ACTIVE=cluster3</span><br><span class="line">      - JAVA_OPTS=-Xms512m -Xmx512m</span><br><span class="line">    ports:</span><br><span class="line">      - 8763:8763</span><br><span class="line">    restart: always</span><br><span class="line">    healthcheck:</span><br><span class="line">      test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://ybd:ybd@localhost:8763/actuator/health&quot;]</span><br><span class="line">      interval: 30s</span><br><span class="line">      timeout: 10s</span><br><span class="line">      retries: 3</span><br><span class="line">      start_period: 15s</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints:</span><br><span class="line">        - node.hostname == node3</span><br><span class="line">    networks:</span><br><span class="line">      backend:</span><br><span class="line">        aliases:</span><br><span class="line">          - eureka-cluster3</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  backend:</span><br><span class="line">    external:</span><br><span class="line">      name: backend</span><br></pre></td></tr></table></figure>
<h3 id="Docker-Compose启动"><a href="#Docker-Compose启动" class="headerlink" title="Docker Compose启动"></a>Docker Compose启动</h3><p>启动前确保创建好了网络: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker network create -d=overlay --attachable --subnet 10.10.0.0/16 backend</span><br><span class="line">docker-compse up -d</span><br></pre></td></tr></table></figure>
<p>此时在<code>Portainer</code>中可以看到三个容器已经启动: </p>
<p><img src="https://cdn.yangbingdong.com/img/spring-cloud-docker-integration/portainer-eureka.png" alt></p>
<p>随意一个eureka端口都能看到另外两个服务: </p>
<p><img src="https://cdn.yangbingdong.com/img/spring-cloud-docker-integration/compose-up03.png" alt></p>
<h3 id="Docker-Swarm启动"><a href="#Docker-Swarm启动" class="headerlink" title="Docker Swarm启动"></a>Docker Swarm启动</h3><p>由于目前使用stack方式启动是无法加载<code>env_file</code>的, 所以需要预先加载一下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export $(cat .env) &amp;&amp; docker stack deploy --compose-file=docker-compose.yml eureka-stack</span><br></pre></td></tr></table></figure>
<p>我们的app通过合适的<code>network</code>交互应该是这样的: </p>
<p><img src="https://cdn.yangbingdong.com/img/spring-cloud-docker-integration/cnm-demo.png" alt></p>
<h4 id="注意事项（ip与hostname混乱）"><a href="#注意事项（ip与hostname混乱）" class="headerlink" title="注意事项（ip与hostname混乱）"></a>注意事项（ip与hostname混乱）</h4><p>之前使用Docker Compose方式启动服务没什么问题, 后来换成Docker Swarm方式启动, 在Eureka的面板中发现有些服务是ip, 有些是hostname, 但都注册成功, 不过某些服务相互之间又访问不了. Google一番后的解决方案: </p>
<p>Server端跟Client端都使用以下配置: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:  </span><br><span class="line">    inetutils:</span><br><span class="line">      ignored-interfaces:</span><br><span class="line">      - eth0</span><br><span class="line">      - eth1</span><br><span class="line">      - eth2</span><br><span class="line">      - eth3</span><br><span class="line">      - lo</span><br><span class="line">      </span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    prefer-ip-address: true</span><br><span class="line">    ip-address: eureka-cluster1 # 这里对应上面compose文件中的aliases</span><br><span class="line">    instance-id: $&#123;spring.application.name&#125;:$&#123;spring.application.instance_id:$&#123;server.port&#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="踩坑-容器中服务下线无法向注册中心注销服务"><a href="#踩坑-容器中服务下线无法向注册中心注销服务" class="headerlink" title="踩坑(容器中服务下线无法向注册中心注销服务)"></a>踩坑(容器中服务下线无法向注册中心注销服务)</h3><p>在Docker中程序, 如果PID不是1, 是接收不到<code>docker-compose down</code>发出的<code>sigterm</code>信号从而导致只能等待被Kill, 不能向注册中心注销. </p>
<p>解决方法是在<code>Dockerfile</code>中的入口使用<code>ENTRYPOINT exec java -jar ...</code>这种方式 </p>
<p><img src="https://cdn.yangbingdong.com/img/spring-cloud-docker-integration/docker-pid1.png" alt></p>
<h3 id="Eureka-Edgware-RELEASE版本注册优化"><a href="#Eureka-Edgware-RELEASE版本注册优化" class="headerlink" title="Eureka Edgware.RELEASE版本注册优化"></a>Eureka Edgware.RELEASE版本注册优化</h3><p>在<code>Edgware.RELEASE</code>版本中相比之前的步骤, 省略了在主函数上添加<code>@EnableDiscoveryClient</code>注解这一过程. Spring Cloud默认认为客户端是要完成向注册中心进行注册的. </p>
<ul>
<li>添加对应的<code>pom</code>依赖.</li>
<li><code>properties</code>文件进行配置</li>
</ul>
<p><strong>添加pom依赖</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p><strong>properties文件进行配置</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.application.name=EUREKA-CLIENT</span><br><span class="line">eureka.client.service-url.defaultZone=http://localhost:8761/eureka</span><br></pre></td></tr></table></figure>
<p>启动Eureka Client客户端, 访问<a href="http://localhost:8761/eureka" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8761/eureka</a><br>可以看到EUEREKA-CLIENT已经注册到Eureka Server服务上了. </p>
<h3 id="关闭自动注册功能"><a href="#关闭自动注册功能" class="headerlink" title="关闭自动注册功能"></a><strong>关闭自动注册功能</strong></h3><p>Spring Cloud提供了一个参数, 该参数的作用是控制是否要向Eureka Server发起注册. 具体参数为: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//默认为true,如果控制不需要向Eureka Server发起注册将该值设置为false.</span><br><span class="line">spring.cloud.service-registry.auto-registration.enabled = xxx</span><br></pre></td></tr></table></figure>
<p>可以在<strong>JUnit测试</strong>中通过该变量关闭服务发现: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@BeforeClass</span><br><span class="line">public static void beforeClass() &#123;</span><br><span class="line">	System.setProperty(&quot;spring.cloud.service-registry.auto-registration.enabled&quot;, &quot;false&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Eureka的自我保护模式"><a href="#Eureka的自我保护模式" class="headerlink" title="Eureka的自我保护模式"></a>Eureka的自我保护模式</h3><p>当Eureka提示下面一段话的时候, 就表示它已经进入保护模式: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY&apos;RE NOT.</span><br><span class="line">RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.</span><br></pre></td></tr></table></figure>
<p>保护模式主要用于一组客户端和Eureka Server之间存在网络分区场景下的保护. 一旦进入保护模式, Eureka Server将会尝试保护其服务注册表中的信息, 不再删除服务注册表中的数据（也就是不会注销任何微服务）. </p>
<p>解决方法如下: </p>
<p>服务器端配置: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  server:</span><br><span class="line">    enable-self-preservation: false</span><br><span class="line">    eviction-interval-timer-in-ms: 15000</span><br></pre></td></tr></table></figure>
<p>客户端配置: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    lease-expiration-duration-in-seconds: 30 </span><br><span class="line">    lease-renewal-interval-in-seconds: 10</span><br></pre></td></tr></table></figure>
<p><strong>注意: </strong><br><strong>更改Eureka更新频率将打破服务器的自我保护功能, 生产环境下不建议自定义这些配置. </strong></p>
<h2 id="修改Eureka界面UI"><a href="#修改Eureka界面UI" class="headerlink" title="修改Eureka界面UI"></a>修改Eureka界面UI</h2><p>覆盖对应源码中的界面文件即可: </p>
<p><img src="https://cdn.yangbingdong.com/img/spring-cloud-docker-integration/eureka-ui.png" alt></p>
<p>效果图:<br><img src="https://cdn.yangbingdong.com/img/spring-cloud-docker-integration/eureka-custom.png" alt></p>
<p><strong>注意事项</strong>: </p>
<p>如果<code>pom.xml</code>中的<code>parent</code>不是<code>spring-boot-starter-parent</code>, 这些样式文件需要新建一个项目另外打包成jar包再引入方可生效. </p>
<h1 id="RPC-Remote-Procedure-Call"><a href="#RPC-Remote-Procedure-Call" class="headerlink" title="RPC(Remote Procedure Call)"></a>RPC(Remote Procedure Call)</h1><blockquote>
<p>这里指针对Http协议调用</p>
</blockquote>
<p>通过注册中心, 服务间的基本调用如下: </p>
<p><img src="https://cdn.yangbingdong.com/img/spring-cloud-docker-integration/micro-rpc.jpg" alt></p>
<p>调用方式主要有三种（基本上在实际应用中都使用Feign）</p>
<p><strong>前置条件: 集成服务注册中心</strong></p>
<p>服务提供者（<code>service-a</code>）: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/service-a&quot;)</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">	@GetMapping(&quot;/&#123;name&#125;&quot;)</span><br><span class="line">	public String sayHello(@PathVariable String name) throws UnknownHostException &#123;</span><br><span class="line">		InetAddress localHost = InetAddress.getLocalHost();</span><br><span class="line">		return localHost + &quot;:  Hello 『&quot; + name + &quot;』  , Date: &quot; + new Date();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LoadBalancerClient"><a href="#LoadBalancerClient" class="headerlink" title="LoadBalancerClient"></a>LoadBalancerClient</h2><p>初始化<code>RestTemplate</code>, 用来发起 REST 请求. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public RestTemplate restTemplate() &#123;</span><br><span class="line">	return new RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消费者（<code>service-b</code>）: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/service-b&quot;)</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">	@Resource</span><br><span class="line">	private LoadBalancerClient client;</span><br><span class="line"></span><br><span class="line">	@Resource</span><br><span class="line">	private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">	@GetMapping(&quot;/&#123;name&#125;&quot;)</span><br><span class="line">	public String hello(@PathVariable String name) &#123;</span><br><span class="line">		name += &quot;!&quot;;</span><br><span class="line">		ServiceInstance instance = client.choose(&quot;service-a&quot;);</span><br><span class="line">		String url = &quot;http://&quot; + instance.getHost() + &quot;:&quot; + instance.getPort() + &quot;/service-a/&quot; + name;</span><br><span class="line">		return restTemplate.getForObject(url, String.class);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问<code>http://127.0.0.1:8082/service-b/ybd</code>, 返回: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ybd-PC/127.0.1.1: Hello 『ybd!』 , Date: Wed Aug 08 18:30:48 CST 2018</span><br></pre></td></tr></table></figure>
<h2 id="Spring-Cloud-Ribbon"><a href="#Spring-Cloud-Ribbon" class="headerlink" title="Spring Cloud Ribbon"></a>Spring Cloud Ribbon</h2><blockquote>
<p> 它是一个基于 HTTP 和 TCP 的客户端负载均衡器. 它可以通过在客户端中配置 ribbonServerList 来设置服务端列表去轮询访问以达到均衡负载的作用. 当 Ribbon 与 Eureka 联合使用时, ribbonServerList 会被 DiscoveryEnabledNIWSServerList 重写, 扩展成从 Eureka 注册中心中获取服务实例列表. 同时它也会用 NIWSDiscoveryPing 来取代 IPing, 它将职责委托给 Eureka 来确定服务端是否已经启动. </p>
</blockquote>
<p>为<code>RestTemplate</code>添加<code>@LoadBalanced</code>注解:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@LoadBalanced</span><br><span class="line">@Bean</span><br><span class="line">public RestTemplate restTemplate() &#123;</span><br><span class="line">	return new RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Controller:</p>
<p>修改 controller, 去掉<code>LoadBalancerClient</code>, 并修改相应的方法, 直接用 <code>RestTemplate</code>发起请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/service-b&quot;)</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">	@Resource</span><br><span class="line">	private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">	@GetMapping(&quot;/&#123;name&#125;&quot;)</span><br><span class="line">	public String hello(@PathVariable String name) &#123;</span><br><span class="line">		name += &quot;!&quot;;</span><br><span class="line">		String url = &quot;http://service-a/service-a/&quot; + name;</span><br><span class="line">		return restTemplate.getForObject(url, String.class);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Spring-Cloud-Feign"><a href="#Spring-Cloud-Feign" class="headerlink" title="Spring Cloud Feign"></a>Spring Cloud Feign</h2><p>依赖（使用OkHttp组件）: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;feign-okhttp&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>配置: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">feign:</span><br><span class="line">  httpclient:</span><br><span class="line">    enabled: false</span><br><span class="line">  okhttp:</span><br><span class="line">    enabled: true</span><br></pre></td></tr></table></figure>
<p>在启动类上加上<code>@EnableFeignClients</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableFeignClients</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class ServiceBApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(ServiceBApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Feign:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FeignClient(value = &quot;service-a&quot;, path = &quot;/service-a&quot;)</span><br><span class="line">public interface HelloRemoteClient &#123;</span><br><span class="line"></span><br><span class="line">	@GetMapping(&quot;/&#123;name&#125;&quot;)</span><br><span class="line">	String sayHello(@PathVariable(&quot;name&quot;) String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>value</code>指被调用方的服务名</li>
<li><code>path</code>请求指定前缀, 例如上面的<code>sayHello</code>会请求<code>/service-a/{name}</code>这个url</li>
</ul>
<p>调用: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/service-b&quot;)</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">	@Resource</span><br><span class="line">	private HelloRemoteClient helloClient;</span><br><span class="line"></span><br><span class="line">	@GetMapping(&quot;/&#123;name&#125;&quot;)</span><br><span class="line">	public String hello(@PathVariable String name) &#123;</span><br><span class="line">		name += &quot;!&quot;;</span><br><span class="line">		return helloClient.sayHello(name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.IllegalStateException: PathVariable annotation was empty on param 0.</span><br></pre></td></tr></table></figure>
<p>这个大概的意思就是<code>@PathVariable</code>的第一个参数为空. . . </p>
<p>因为之前的写法是这样的: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;/&#123;name&#125;&quot;)</span><br><span class="line">String sayHello(@PathVariable String name);</span><br></pre></td></tr></table></figure>
<p><strong>正确姿势</strong>是这样的: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;/&#123;name&#125;&quot;)</span><br><span class="line">String sayHello(@PathVariable(&quot;name&quot;) String name);</span><br></pre></td></tr></table></figure>
<p><code>@PathVariable</code>需要指定占位符的名字<code>(&quot;name&quot;)</code></p>
<h1 id="Spring-Cloud-Gateway"><a href="#Spring-Cloud-Gateway" class="headerlink" title="Spring Cloud Gateway"></a>Spring Cloud Gateway</h1><p>Spring Cloud Gateway 是 Spring Cloud 的一个全新项目, 该项目是基于 Spring 5.0, Spring Boot 2.0 和 Project Reactor 等技术开发的网关, 它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式. </p>
<p>Spring Cloud Gateway 作为 Spring Cloud 生态系统中的网关, 目标是替代 Netflix Zuul, 其不仅提供统一的路由方式, 并且基于 Filter 链的方式提供了网关基本的功能, 例如: 安全、监控、埋点和限流等. </p>
<p>Spring Cloud Gateway 的特征: </p>
<ul>
<li>基于 Spring Framework 5, Project Reactor 和 Spring Boot 2.0</li>
<li>动态路由</li>
<li>Predicates 和 Filters 作用于特定路由</li>
<li>集成 Hystrix 断路器</li>
<li>集成 Spring Cloud DiscoveryClient</li>
<li>易于编写的 Predicates 和 Filters</li>
<li>限流</li>
<li>路径重写</li>
</ul>
<p><strong>流程图</strong>: </p>
<p><img src="https://cdn.yangbingdong.com/img/spring-cloud-docker-integration/spring-cloud-gateway-flow.jpg" alt></p>
<h1 id="Spring-Boot-Admin"><a href="#Spring-Boot-Admin" class="headerlink" title="Spring Boot Admin"></a>Spring Boot Admin</h1><p><img src="https://cdn.yangbingdong.com/img/spring-cloud-docker-integration/spring-boot-admin.png" alt></p>
<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.0.2&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<h2 id="主类添加注解"><a href="#主类添加注解" class="headerlink" title="主类添加注解"></a>主类添加注解</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableAdminServer</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class AdminApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(AdminApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><code>application.yml</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 6010</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: admin</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br><span class="line">  security:</span><br><span class="line">    user:</span><br><span class="line">      name: ybd</span><br><span class="line">      password: ybd</span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &quot;*&quot;</span><br><span class="line">  endpoint:</span><br><span class="line">    health:</span><br><span class="line">      show-details: ALWAYS</span><br></pre></td></tr></table></figure>
<p><code>application-dev.yml</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://ybd:ybd@127.0.0.1:8761/eureka/</span><br><span class="line">  instance:</span><br><span class="line">    metadata-map:</span><br><span class="line">      user.name: ybd</span><br><span class="line">      user.password: ybd</span><br></pre></td></tr></table></figure>
<p><code>SecuritySecureConfig</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SecuritySecureConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line">	private final String adminContextPath;</span><br><span class="line"></span><br><span class="line">	public SecuritySecureConfig(AdminServerProperties adminServerProperties) &#123;</span><br><span class="line">		this.adminContextPath = adminServerProperties.getContextPath();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">		SavedRequestAwareAuthenticationSuccessHandler successHandler = new SavedRequestAwareAuthenticationSuccessHandler();</span><br><span class="line">		successHandler.setTargetUrlParameter(&quot;redirectTo&quot;);</span><br><span class="line">		http.authorizeRequests()</span><br><span class="line">//			.antMatchers(&quot;/actuator&quot;, &quot;/actuator/health&quot;, &quot;/actuator/info&quot;).permitAll()</span><br><span class="line">			.antMatchers(adminContextPath + &quot;/assets/**&quot;).permitAll()</span><br><span class="line">			.antMatchers(adminContextPath + &quot;/login&quot;).permitAll()</span><br><span class="line">			.anyRequest().authenticated()</span><br><span class="line">			.and()</span><br><span class="line">			.formLogin().loginPage(adminContextPath + &quot;/login&quot;).successHandler(successHandler).and()</span><br><span class="line">			.logout().logoutUrl(adminContextPath + &quot;/logout&quot;).and()</span><br><span class="line">			.httpBasic()</span><br><span class="line">			.and()</span><br><span class="line">			.csrf().disable();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h1><blockquote>
<p>代码: <strong><em><a href="https://github.com/masteranthoneyd/spring-cloud-learning" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/masteranthoneyd/spring-cloud-learning</a></em></strong></p>
</blockquote>
]]></content><categories><category>Programming</category><category>Java</category><category>Spring Cloud</category></categories><tags><tag>Java</tag><tag>Spring Cloud</tag></tags></entry><entry><title>Spring Security 与 HandlerInterceptor 的认证鉴权</title><url>/2020/spring-security-mvc-interceptor/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/spring-boot-security/spring-authentication-banner.png" alt></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><blockquote>
<p>本篇总结分别基于 Spring Security 与 Spring MVC HandlerInterceptor 实现认证鉴权.</p>
</blockquote>
<a id="more"></a>
<h1 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h1><p>Spring Security 是基于嵌套 <code>Filter</code>(委派 Filter) 实现的, 在 <code>DispatcherServlet</code> 之前触发. 普通的 Filter 称之为 Web Filter, 而 Spring Security 的 Filter 称之为 Security Filter:</p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-security/security-filters.png" alt></p>
<p>默认有哪些 Filter 可以看 <code>FilterComparator</code> 中的源码:</p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-security/filter-comparator.png" alt></p>
<h2 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h2><p><img src="https://cdn.yangbingdong.com/img/spring-boot-security/core-service-Sequence.png" alt></p>
<h3 id="登录拦截"><a href="#登录拦截" class="headerlink" title="登录拦截"></a>登录拦截</h3><p>在 <code>FilterComparator</code> 中有一个 <code>UsernamePasswordAuthenticationFilter</code>, 继承了 <code>AbstractAuthenticationProcessingFilter</code>, 它就是我们登录时用到的 Filter:</p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-security/username-password-authentication-filter.png" alt></p>
<ul>
<li>可以看到, <strong>默认情况下拦截 <code>/login</code> 端点的 POST 请求</strong>, 当然, 可以通过配置改变这个 url.</li>
<li>这里还有一个关键, 在 <code>attempAuthentication</code> 中, 用户名以及密码的参数是 <code>username</code> 以及 <code>password</code>, 并且是从 http parameter 中获取的, 如果要<strong>支持 Json 格式的登录, 那就要重写这里</strong>.</li>
<li>将登录请求信息封装成 <code>Authentication</code> 的实现类, 这里是 <code>UsernamePasswordAuthenticationToken</code>, <strong>然后交给 <code>AuthenticationManager</code> 进行下一步的认证</strong>. </li>
</ul>
<blockquote>
<p><strong>这一步相当与登录信息的提取以及封装</strong>.</p>
</blockquote>
<h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><p>认证通过 <code>AuthenticationManager</code> 进行的, 这是一个接口, 默认的实现类为 <code>ProviderManager</code>:</p>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-security/provider-manager.png" alt></p>
<p>可以看到实现类 <code>ProviderManager</code> 中维护了一个 <code>List&lt;AuthenticationProvider&gt;</code> 的列表, 存放多种认证方式, 实际上这是委托者模式的应用(Delegate)</p>
<blockquote>
<p>核心的认证入口始终只有一个: <code>AuthenticationManager</code>, 不同的认证方式: 用户名 + 密码(<code>UsernamePasswordAuthenticationToken</code>), 邮箱 + 密码, 手机号码 + 密码登录则对应了三个 <code>AuthenticationProvider</code>. 在默认策略下, 只需要通过一个 <code>AuthenticationProvider</code> 的认证, 即可被认为是登录成功.</p>
</blockquote>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-security/spring%20security%20architecture.png" alt></p>
<p>一个最常用到的 <code>AuthenticationProvider</code> 实现类就是 <code>DaoAuthenticationProvider</code>, 里面比较重要的一个环节就是 <code>additionalAuthenticationChecks</code> (密码校验):</p>
<ul>
<li>通过 <code>UserDetailsService</code>  的实现类(需要用户自己实现)拿到 <code>UserDetails</code></li>
<li>将其中的 <code>password</code> 与 <code>UsernamePasswordAuthenticationToken</code> 中的 <code>credentials</code> 进行对比 </li>
</ul>
<p><img src="https://cdn.yangbingdong.com/img/spring-boot-security/dao-authentication-password-check.png" alt></p>
<p>登录成功后会执行 <code>AbstractAuthenticationProcessingFilter#successfulAuthentication</code> 将 <code>Authentication</code> 存到 <code>SecurityContextHolder</code> 中.</p>
<p>到此, 认证的核心就是这样了.</p>
<h2 id="权限校验流程"><a href="#权限校验流程" class="headerlink" title="权限校验流程"></a>权限校验流程</h2><p><code>FilterSecurityInterceptor</code> 是整个Security filter链中的最后一个, 也是最重要的一个, 它的主要功能就是判断认证成功的用户是否有权限访问接口, 其最主要的处理方法就是 调用父类（<code>AbstractSecurityInterceptor</code>）的 <code>super.beforeInvocation(fi)</code>, 我们来梳理下这个方法的处理流程：</p>
<blockquote>
<ul>
<li>通过 <code>obtainSecurityMetadataSource().getAttributes()</code> 获取 当前访问地址所需权限信息</li>
<li>通过 <code>authenticateIfRequired()</code> 获取当前访问用户的权限信息</li>
<li>通过 <code>accessDecisionManager.decide()</code> 使用 投票机制判权, 判权失败直接抛出 <code>AccessDeniedException</code> 异常</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> InterceptorStatusToken <span class="title">beforeInvocation</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">	       </span><br><span class="line">	    ......</span><br><span class="line">	    </span><br><span class="line">	    <span class="comment">// 1 获取访问地址的权限信息 </span></span><br><span class="line">		Collection&lt;ConfigAttribute&gt; attributes = <span class="keyword">this</span>.obtainSecurityMetadataSource()</span><br><span class="line">				.getAttributes(object);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (attributes == <span class="keyword">null</span> || attributes.isEmpty()) &#123;</span><br><span class="line">		</span><br><span class="line">		    ......</span><br><span class="line">		    </span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 获取当前访问用户权限信息</span></span><br><span class="line">		Authentication authenticated = authenticateIfRequired();</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">		    <span class="comment">// 3  默认调用AffirmativeBased.decide() 方法, 其内部 使用 AccessDecisionVoter 对象 进行投票机制判权, 判权失败直接抛出 AccessDeniedException 异常 </span></span><br><span class="line">			<span class="keyword">this</span>.accessDecisionManager.decide(authenticated, object, attributes);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (AccessDeniedException accessDeniedException) &#123;</span><br><span class="line">			publishEvent(<span class="keyword">new</span> AuthorizationFailureEvent(object, attributes, authenticated,</span><br><span class="line">					accessDeniedException));</span><br><span class="line"></span><br><span class="line">			<span class="keyword">throw</span> accessDeniedException;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InterceptorStatusToken(SecurityContextHolder.getContext(), <span class="keyword">false</span>,</span><br><span class="line">					attributes, object);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>因此如果要<strong>动态鉴权</strong>, 可以从两方面入手:</p>
<ul>
<li>自定义<code>SecurityMetadataSource</code>, 实现从数据库加载 <code>ConfigAttribute</code></li>
<li>另外就是可以自定义 <code>accessDecisionManager</code>, 官方的 <code>UnanimousBased</code> 其实足够使用, 并且他是基于 <code>AccessDecisionVoter</code> 来实现权限认证的, 因此我们只需要自定义一个 <code>AccessDecisionVoter</code> 就可以了</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                .withObjectPostProcessor(<span class="keyword">new</span> ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> &lt;O extends FilterSecurityInterceptor&gt; <span class="function">O <span class="title">postProcess</span><span class="params">(O object)</span> </span>&#123;</span><br><span class="line">                        object.setAccessDecisionManager(customUrlDecisionManager);</span><br><span class="line">                        object.setSecurityMetadataSource(customFilterInvocationSecurityMetadataSource);</span><br><span class="line">                        <span class="keyword">return</span> object;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .and()</span><br><span class="line">                ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="核心配置"><a href="#核心配置" class="headerlink" title="核心配置"></a>核心配置</h2><p>下面贴一个核心配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义登录逻辑验证器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserAuthenticationProvider userAuthenticationProvider;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义未登录的处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserAuthenticationEntryPoint userAuthenticationEntryPoint;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义登录成功处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserLoginSuccessHandler userLoginSuccessHandler;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义登录失败处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserLoginFailHandler userLoginFailHandler;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义注销成功处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserLogoutSuccessHandler userLogoutSuccessHandler;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义暂无权限处理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserAccessDeniedHandler userAccessDeniedHandler;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义权限解析</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserPermissionEvaluator permissionEvaluator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置登录验证逻辑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> </span>&#123;</span><br><span class="line">        auth.authenticationProvider(userAuthenticationProvider);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态资源不需要走过滤链</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> </span>&#123;</span><br><span class="line">        web.ignoring()</span><br><span class="line">           .requestMatchers(PathRequest.toStaticResources().atCommonLocations());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                <span class="comment">// 不需要认证的 url</span></span><br><span class="line">                .antMatchers(<span class="string">"/hello/**"</span>).permitAll()</span><br><span class="line">                <span class="comment">// 其他的请求需要认证</span></span><br><span class="line">                .anyRequest()</span><br><span class="line">                .authenticated()</span><br><span class="line">            .and()</span><br><span class="line">                <span class="comment">// 关闭默认的登录配置 (UsernamePasswordAuthenticationFilter), 在下面配置自定义的登录 Filter(支持 json 登录)</span></span><br><span class="line">                .formLogin()</span><br><span class="line">            .disable()</span><br><span class="line">                .logout()</span><br><span class="line">                <span class="comment">// 配置注销地址</span></span><br><span class="line">                .logoutUrl(<span class="string">"/user/logout"</span>)</span><br><span class="line">                <span class="comment">// 配置注销成功处理器</span></span><br><span class="line">                .logoutSuccessHandler(userLogoutSuccessHandler)</span><br><span class="line">            .and()</span><br><span class="line">                .exceptionHandling()</span><br><span class="line">                <span class="comment">// 配置没有权限自定义处理类</span></span><br><span class="line">                .accessDeniedHandler(userAccessDeniedHandler)</span><br><span class="line">                .authenticationEntryPoint(userAuthenticationEntryPoint)</span><br><span class="line">            .and()</span><br><span class="line">                <span class="comment">// 开启跨域</span></span><br><span class="line">                .cors()</span><br><span class="line">                .configurationSource(corsConfigurationSource())</span><br><span class="line">            .and()</span><br><span class="line">                <span class="comment">// 取消跨站请求伪造防护</span></span><br><span class="line">                .csrf()</span><br><span class="line">            .disable()</span><br><span class="line">                <span class="comment">// jwt 无状态不需要 session</span></span><br><span class="line">                .sessionManagement()</span><br><span class="line">                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">            .and()</span><br><span class="line">                .headers()</span><br><span class="line">                .cacheControl()</span><br><span class="line">                .disable()</span><br><span class="line">            .and()</span><br><span class="line">                .rememberMe()</span><br><span class="line">            .disable()</span><br><span class="line">            <span class="comment">// 自定义 Jwt 登录认证 Filter</span></span><br><span class="line">            .addFilterAt(jsonUsernamePasswordAuthenticationFilter(), UsernamePasswordAuthenticationFilter<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            // 自定义 <span class="title">Jwt</span> 过滤器</span></span><br><span class="line"><span class="class">            .<span class="title">addFilterBefore</span>(<span class="title">new</span> <span class="title">JwtAuthenticationFilter</span>(<span class="title">authenticationManagerBean</span>()), <span class="title">JsonUsernamePasswordAuthenticationFilter</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密方式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BCryptPasswordEncoder <span class="title">bCryptPasswordEncoder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义登录拦截器, 接收 json 登录信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonUsernamePasswordAuthenticationFilter <span class="title">jsonUsernamePasswordAuthenticationFilter</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        JsonUsernamePasswordAuthenticationFilter filter = <span class="keyword">new</span> JsonUsernamePasswordAuthenticationFilter();</span><br><span class="line">        filter.setFilterProcessesUrl(<span class="string">"/user/login"</span>);</span><br><span class="line">        filter.setAuthenticationSuccessHandler(userLoginSuccessHandler);</span><br><span class="line">        filter.setAuthenticationFailureHandler(userLoginFailHandler);</span><br><span class="line">        filter.setAuthenticationManager(authenticationManagerBean());</span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入自定义 PermissionEvaluator</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultWebSecurityExpressionHandler <span class="title">userSecurityExpressionHandler</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DefaultWebSecurityExpressionHandler handler = <span class="keyword">new</span> DefaultWebSecurityExpressionHandler();</span><br><span class="line">        handler.setPermissionEvaluator(permissionEvaluator);</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跨域配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsConfigurationSource <span class="title">corsConfigurationSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        CorsConfiguration configuration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        configuration.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">        configuration.setAllowedOrigins(singletonList(<span class="string">"*"</span>));</span><br><span class="line">        configuration.setAllowedMethods(singletonList(<span class="string">"*"</span>));</span><br><span class="line">        configuration.setAllowedHeaders(singletonList(<span class="string">"*"</span>));</span><br><span class="line">        configuration.setMaxAge(Duration.ofHours(<span class="number">1</span>));</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">"/**"</span>,configuration);</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 共享 AuthenticationManager</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthenticationManager <span class="title">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多源码查看: <strong><em><a href="https://github.com/masteranthoneyd/spring-boot-learning/tree/master/spring-boot-security" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/masteranthoneyd/spring-boot-learning/tree/master/spring-boot-security</a></em></strong></p>
<h2 id="其他配置说明"><a href="#其他配置说明" class="headerlink" title="其他配置说明"></a>其他配置说明</h2><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><blockquote>
<p>上面的配置是基于 jwt 无状态的, 所以不需要 session, 如果使用, 可以通过下面配置实现一些额外的功能</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">http.sessionManagement()</span><br><span class="line">     <span class="comment">// 登陆后使用新的 sessionId, 防止固定会话攻击</span></span><br><span class="line"> .sessionFixation().changeSessionId()</span><br><span class="line">  <span class="comment">// 同时在线最大数量</span></span><br><span class="line"> .maximumSessions(<span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 是否禁止新的登录</span></span><br><span class="line"> .maxSessionsPreventsLogin(<span class="keyword">false</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果是自定义的用户, <strong>需要重写 <code>equals</code> 以及 <code>hashcode</code> 方法</strong>, 因为底层是通过一个 Map 存放 session 相关信息, 而 key 则是 principal 对象.</p>
<p>如果是覆盖了 <code>UsernamePasswordAuthenticationFilter</code>, 这些 session 配置需要在自定义的 Filter 重新配置.</p>
</blockquote>
<p>同时启用 session 提供一个 bean(因为 Spring security 的通过监听事件实现 session 销毁的):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">HttpSessionEventPublisher <span class="title">httpSessionEventPublisher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HttpSessionEventPublisher();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>session 集群共享:</p>
<p>第一步, 引入 redis:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>第二部, 配置 SessionRegistry:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    FindByIndexNameSessionRepository sessionRepository;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http.authorizeRequests().anyRequest()</span><br><span class="line">                ...</span><br><span class="line">                .sessionManagement()</span><br><span class="line">                .maximumSessions(<span class="number">1</span>)</span><br><span class="line">                .maxSessionsPreventsLogin(<span class="keyword">true</span>)</span><br><span class="line">                .sessionRegistry(sessionRegistry());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">SpringSessionBackedSessionRegistry <span class="title">sessionRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SpringSessionBackedSessionRegistry(sessionRepository);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面提到的只是一个大致的核心流程, 但大概可以看出来, Spring Security 功能不仅齐全, 而且留了很多的扩展点, 可以很灵活的定制自己的权限业务.</p>
<p>但正是因为其极其丰富的扩展, 使得这框架变得”很重”, 对新手来说可能不太友好, 需要一定的学习成本.</p>
<h1 id="Spring-MVC-HandlerInterceptor"><a href="#Spring-MVC-HandlerInterceptor" class="headerlink" title="Spring MVC HandlerInterceptor"></a>Spring MVC HandlerInterceptor</h1><p>对于一般简单的登录校验而言, 使用 Spring Security 可能稍显笨重, 这时候可以基于 Spring MVC 的 HandlerInterceptor 实现简单的校验逻辑:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> AuthorizationPreHandler authorizationPreHandler;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AuthorizationInterceptor</span><span class="params">(AuthorizationPreHandler authorizationPreHandler)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.authorizationPreHandler = authorizationPreHandler;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (handler <span class="keyword">instanceof</span> HandlerMethod) &#123;</span><br><span class="line">			Method method = ((HandlerMethod) handler).getMethod();</span><br><span class="line">			<span class="keyword">if</span> (method.isAnnotationPresent(IgnoreAuth<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			authorizationPreHandler.preHandleAuth(request, response, method);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将拦截器添加到 MVC 中:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnBean</span>(AuthorizationPreHandler<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">AuthorizationInterceptorConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> AuthorizationInterceptor <span class="title">authorizationInterceptor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			ObjectProvider&lt;AuthorizationPreHandler&gt; authorizationHandlerObjectProvider)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> AuthorizationInterceptor(authorizationHandlerObjectProvider.getIfAvailable());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> AuthorizationMvcConfigure <span class="title">authorizationMvcConfigure</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			ObjectProvider&lt;AuthorizationInterceptor&gt; authorizationInterceptorObjectProvider)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> AuthorizationMvcConfigure(authorizationInterceptorObjectProvider.getIfAvailable());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationMvcConfigure</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AuthorizationInterceptor authorizationInterceptor;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (Objects.nonNull(authorizationInterceptor)) &#123;</span><br><span class="line">			registry.addInterceptor(authorizationInterceptor);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>authorizationPreHandler</code> 中简单校验是否存在 token 即可.</p>
<p>完整代码请看: <strong><em><a href="https://github.com/masteranthoneyd/alchemist/tree/master/auth" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/masteranthoneyd/alchemist/tree/master/auth</a></em></strong></p>
<h1 id="RBAC-权限设计"><a href="#RBAC-权限设计" class="headerlink" title="RBAC 权限设计"></a>RBAC 权限设计</h1><p>主要核心逻辑还是 <code>用户-角色-权限</code>.</p>
<p>在这基础上拓展出 <code>用户-用户组-角色</code> 以及 <code>权限-类型-具体权限</code>.</p>
<p><img src="https://cdn.yangbingdong.com/img/spring-auth/auth-design.jpg" alt></p>
]]></content><categories><category>Programming</category><category>Java</category><category>Spring Boot</category></categories><tags><tag>Java</tag><tag>Spring Boot</tag><tag>Spring</tag><tag>Spring Security</tag></tags></entry><entry><title>Ubuntu的Java开发环境基本搭建</title><url>/2017/ubuntu-dev-environment-to-build/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/javaDevEnv/maxresdefault.jpg" alt></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近公司的电脑由于不明原因老是奔溃, 重装过两次, 在家里也比较喜欢折腾系统, 为了不用每次都度娘谷歌, 记录下来, 一条龙走过. 博主是搞爪哇开发的, 那么以下搭建针对的是爪哇环境开发</p>
<a id="more"></a>
<h1 id="JDK以及配置环境变量"><a href="#JDK以及配置环境变量" class="headerlink" title="JDK以及配置环境变量"></a>JDK以及配置环境变量</h1><h2 id="通过Apt安装"><a href="#通过Apt安装" class="headerlink" title="通过Apt安装"></a>通过Apt安装</h2><blockquote>
<p><strong><em><a href="https://linuxconfig.org/how-to-install-java-on-ubuntu-18-04-bionic-beaver-linux" rel="external nofollow noopener noreferrer" target="_blank">https://linuxconfig.org/how-to-install-java-on-ubuntu-18-04-bionic-beaver-linux</a></em></strong></p>
</blockquote>
<h3 id="OpenJDK"><a href="#OpenJDK" class="headerlink" title="OpenJDK"></a>OpenJDK</h3><p>JDK8:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install openjdk-8-jdk</span><br></pre></td></tr></table></figure>
<p>JDK9:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install openjdk-9-jdk</span><br></pre></td></tr></table></figure>
<p>JDK11:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install openjdk-11-jdk</span><br></pre></td></tr></table></figure>
<h3 id="OracleJDK"><a href="#OracleJDK" class="headerlink" title="OracleJDK"></a>OracleJDK</h3><p><strong>注意: 这个安装可能有点慢, 建议使用代理.</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:webupd8team/java &amp;&amp; sudo apt update</span><br></pre></td></tr></table></figure>
<p>JDK8:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install oracle-java8-set-default</span><br></pre></td></tr></table></figure>
<p>JDK9:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install oracle-java9-set-default</span><br></pre></td></tr></table></figure>
<h2 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h2><h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><p>安装之前当然是老规矩地下载<code>jdk</code>: <em><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" rel="external nofollow noopener noreferrer" target="_blank">Oracle JDK官方下载</a></em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 把jdk的文件移动到 /usr/local/ 目录下</span><br><span class="line">sudo mv ~/jdk*.tar.gz /usr/local/</span><br><span class="line"># 解压文件</span><br><span class="line">cd /usr/local/</span><br><span class="line"># sudo tar -zxvf jdk-8u101-linux-x64.tar.gz</span><br><span class="line"># 创建软链接</span><br><span class="line">sudo ln -s jdk1.8.0_101 jdk</span><br></pre></td></tr></table></figure>
<p><strong><em>如需更换<code>jdk</code>, 删除旧版本的软链接, 重新创建软链接指向新版即可</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rm -rf jdk</span><br><span class="line">sudo ln -s jdk* jdk</span><br></pre></td></tr></table></figure>
<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><ul>
<li>放到 <code>/usr/local</code> 里面的程序, 建议使用系统变量. </li>
<li>用户变量<br>  <code>~/.profile</code> 文件是用户的私有配置文件<br>  <code>~/.bashrc</code>  是在bash里面使用的私有配置文件, 优先级在 <code>.profile</code> 文件之后</li>
<li>系统变量<br>  <code>/etc/profile</code> 文件是系统的公用配置文件<br>  <code>/etc/bash.bashrc</code> 是<code>bash</code>专用的配置文件, 优先级在 <code>profile</code> 文件之后</li>
<li>系统变量的配置, 不建议修改前面说到的两个文件, 而是建议在 <strong><em><code>/etc/profile.d/</code></em></strong> 目录下, 创建一个 <code>.sh</code> 结尾 的文件. </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/profile.d/jdk.sh</span><br></pre></td></tr></table></figure>
<p><strong><em>环境变量的配置内容如下: </em></strong></p>
<ol>
<li><p>设置一个名为<code>JAVA_HOME</code>的变量, 并且使用<code>export</code>命令导出为环境变量, 如果不使用 <code>export</code> , 仅在当前<code>shell</code>里面有效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/jdk</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>PATH</code>不需要<code>export</code>, 因为早在其他的地方, 已经<code>export</code>过了！, <code>\$JAVA_HOME</code> 表示引用前面配置的 <code>JAVA_HOME</code> 变量, 分隔符一定是冒号, <strong>Windows</strong>是分号,最后再引用原来的<code>PATH</code>的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置以后, 可以重新登录让配置生效, 也可以使用<code>source</code>临时加载配置文件. 使用<code>source</code>命令加载的配置, 仅在当前<code>shell</code>有效, 关闭以后失效. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source /etc/profile.d/jdk.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看<code>jdk</code>是否安装成功, 一下两条命令成功则安装成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -version</span><br><span class="line">javac -version</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://cdn.yangbingdong.com/img/javaDevEnv/javaVersion.png" alt></p>
<h1 id="Scala环境"><a href="#Scala环境" class="headerlink" title="Scala环境"></a>Scala环境</h1><p>更上面安装JDK类似</p>
<p>1、去 <em><a href="http://www.scala-lang.org/download/" rel="external nofollow noopener noreferrer" target="_blank">官网</a></em> 下载最新地SDK</p>
<p><img src="https://cdn.yangbingdong.com/img/javaDevEnv/scala-download.jpg" alt></p>
<p>2、解压到 <code>/usr/local</code> 目录, 并创建软链接为 <code>scala</code> </p>
<p>3、在 <code>/etc/profile.d</code> 目录下创建 <code>scala.sh</code> , 输入以下信息: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export SCALA_HOME=/usr/local/scala</span><br><span class="line">export PATH=$PATH:$SCALA_HOME/bin</span><br></pre></td></tr></table></figure>
<p>4、查看是否安装成功<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source /etc/profile.d/scala.sh</span><br><span class="line">scala -version</span><br></pre></td></tr></table></figure></p>
<p><img src="https://cdn.yangbingdong.com/img/javaDevEnv/source-scala.jpg" alt></p>
<h1 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h1><p><strong>安装</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># apt 安装</span><br><span class="line">sudo apt install golang</span><br><span class="line"></span><br><span class="line"># snap 安装</span><br><span class="line">sudo snap install go --classic</span><br></pre></td></tr></table></figure>
<p><strong>查看版本</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go version</span><br></pre></td></tr></table></figure>
<p><strong>智能补全</strong>:</p>
<p>修改 <code>.zshrc</code>: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins=(... golang)</span><br></pre></td></tr></table></figure>
<p><strong>环境变量配置</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tee /etc/profile.d/go.sh &lt;&lt;- EOF</span><br><span class="line">export GOPATH=$&#123;HOME&#125;/go</span><br><span class="line">export PATH=\$GOPATH/bin:\$PATH</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>运行Hello world:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go get github.com/golang/example/hello</span><br></pre></td></tr></table></figure>
<p>之后 <code>hello</code> 命令会下载到 <code>${HOME}/go/bin</code> 中.</p>
<p>解决 <code>unrecognized import path &quot;golang.org/x/sys/unix</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p $GOPATH/src/golang.org/x/</span><br><span class="line">cd !$</span><br><span class="line">git clone https://github.com/golang/net.git</span><br><span class="line">git clone https://github.com/golang/sys.git</span><br><span class="line">git clone https://github.com/golang/tools.git</span><br></pre></td></tr></table></figure>
<h1 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h1><h2 id="Eclipse"><a href="#Eclipse" class="headerlink" title="Eclipse"></a>Eclipse</h2><p>直接在 <em><a href="https://www.eclipse.org/" rel="external nofollow noopener noreferrer" target="_blank">Eclipse官方网站</a></em> 下载相关版本Eclipse<br>解压<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tar zxvf eclipse-jee-mars-2-linux-gtk-x86_64.tar.gz -C ~/IDE</span><br></pre></td></tr></table></figure></p>
<p>创建快捷方式<br>1. 在终端中执行如下命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo gedit /usr/share/applications/eclipse.desktop</span><br></pre></td></tr></table></figure></p>
<p>2. 粘贴并保存如下内容(注意更改相应的名字和目录)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Desktop Entry] </span><br><span class="line">Name=Eclipse Mars.2 </span><br><span class="line">Type=Application </span><br><span class="line">Exec=/home/ybd/IDE/eclipse </span><br><span class="line">Terminal=false </span><br><span class="line">Icon=/home/ybd/IDE/icon.xpm </span><br><span class="line">Comment=Integrated Development Environment </span><br><span class="line">NoDisplay=false </span><br><span class="line">Categories=Development;IDE; </span><br><span class="line">Name[en]=Eclipse Mars.2</span><br></pre></td></tr></table></figure></p>
<p><strong>通用设置</strong><br><code>window → preferences →</code></p>
<ul>
<li>设置字体: general → appearance → color and font → basic → text font</li>
<li>编辑器背景颜色: general →  editors → text editors → background color → <code>RGB:85,123,208</code>,<code>#C7EDCC</code></li>
<li>工作空间字符编码: general → workspace </li>
<li>作者签名: java → code style → code templates → types  签名快捷键: <code>alt + shift + j</code></li>
</ul>
<h2 id="MyEclipse"><a href="#MyEclipse" class="headerlink" title="MyEclipse"></a>MyEclipse</h2><p>MyEclipse安装请看: <strong><em><a href="/2017/ubuntu-myeclipse-crack/">Ubuntu16.04下MyEclipse安装与破解</a></em></strong></p>
<h2 id="IntelliJ-IDEA"><a href="#IntelliJ-IDEA" class="headerlink" title="IntelliJ IDEA"></a>IntelliJ IDEA</h2><p>之前听说过IDE<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top hint--error hint--medium hint--rounded hint--bounce" aria-label="IDEA 全称IntelliJ IDEA, 是java语言开发的集成环境, IntelliJ在业界被公认为最好的java开发工具之一, 尤其在智能代码助手、代码自动提示、重构、J2EE支持、Ant、JUnit、CVS整合、代码审查、 创新的GUI设计等方面的功能可以说是超常的. IDEA是JetBrains公司的产品, 这家公司总部位于捷克共和国的首都布拉格, 开发人员以严谨著称的东欧程序员为主">[1]</span></a></sup>, 都是大公司用的, 并没有用过<br>日后再研究补上<br>官网: <em><a href="http://www.jetbrains.com/idea/" rel="external nofollow noopener noreferrer" target="_blank">http://www.jetbrains.com/idea/</a></em></p>
<p>新公司好多大牛, 用的都是IDEA, 于是乎“近墨者黑”, 那么既然有机会跟大牛接触, 我也开始真正意义上的学习IDEA了</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>进过查阅, 我选择官方的盒子下载: <strong><em><a href="http://www.jetbrains.com/toolbox/app/?fromMenu" rel="external nofollow noopener noreferrer" target="_blank">http://www.jetbrains.com/toolbox/app/?fromMenu</a></em></strong><br>优点是可以自动更新<br><img src="https://cdn.yangbingdong.com/img/javaDevEnv/idea.png" alt></p>
<h3 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h3><p>博主使用授权服务器, 可以自己搭建, 详情请看 <strong><em><a href="/2017/note-of-learning-idea-under-ubuntu/#License">这里</a></em></strong></p>
<h3 id="部署Tomcat"><a href="#部署Tomcat" class="headerlink" title="部署Tomcat"></a>部署Tomcat</h3><p>若是服务器版切换root用户解压到 <code>/opt/</code> 或者 <code>/usr/local/</code> 下<br>直接运行tomcat目录下<code>bin/start.sh</code>即可开启, 前提是配置好<code>JDK</code></p>
<p>桌面版个人使用就解压到<code>/home/{user}</code>目录下就可以了</p>
<h1 id="MySQL以及GUI工具"><a href="#MySQL以及GUI工具" class="headerlink" title="MySQL以及GUI工具"></a>MySQL以及GUI工具</h1><h2 id="基于Docker安装"><a href="#基于Docker安装" class="headerlink" title="基于Docker安装"></a>基于Docker安装</h2><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure>
<h3 id="运行实例"><a href="#运行实例" class="headerlink" title="运行实例"></a>运行实例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MYSQL=/home/ybd/data/docker/mysql &amp;&amp; \</span><br><span class="line">docker run --name=mysql -p 3306:3306  \</span><br><span class="line">-v $MYSQL/data:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root -d mysql \</span><br><span class="line">--character-set-server=utf8mb4 \</span><br><span class="line">--collation-server=utf8mb4_unicode_ci \</span><br><span class="line">--sql-mode=STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION \</span><br><span class="line">--lower-case-table-names=1</span><br></pre></td></tr></table></figure>
<h3 id="终端链接"><a href="#终端链接" class="headerlink" title="终端链接"></a>终端链接</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mysql-client</span><br><span class="line"></span><br><span class="line">// 链接</span><br><span class="line">mysql -h 127.0.0.1 -P 3306 -u root -p</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.yangbingdong.com/img/javaDevEnv/mysqlStartup.png" alt></p>
<h2 id="手动折腾安装"><a href="#手动折腾安装" class="headerlink" title="手动折腾安装"></a>手动折腾安装</h2><p><strong><em>以<code>mysql5.7</code>以上版本为例 –&gt; <code>mysql-5.7.10-linux-glibc2.5-x86_64.tar.gz</code></em></strong></p>
<h3 id="必须要先安装依赖的libaio才能正常按照mysql"><a href="#必须要先安装依赖的libaio才能正常按照mysql" class="headerlink" title="必须要先安装依赖的libaio才能正常按照mysql"></a>必须要先安装依赖的libaio才能正常按照mysql</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install libaio-dev</span><br></pre></td></tr></table></figure>
<h3 id="创建用户组以及用户"><a href="#创建用户组以及用户" class="headerlink" title="创建用户组以及用户"></a>创建用户组以及用户</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo groupadd mysql</span><br><span class="line">sudo useradd -r -g mysql -s /bin/false mysql</span><br></pre></td></tr></table></figure>
<h3 id="尽量把mysql安装到-usr-local目录下面"><a href="#尽量把mysql安装到-usr-local目录下面" class="headerlink" title="尽量把mysql安装到/usr/local目录下面"></a>尽量把mysql安装到/usr/local目录下面</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /usr/local</span><br><span class="line">sudo cp /home/data/software/DataBase/mysql/mysql-5.7.10-linux-glibc2.5-x86_64.tar.gz ./</span><br><span class="line">&lt;-- 解压缩安装包 --&gt;</span><br><span class="line">sudo tar zxvf mysql-5.7.10-linux-glibc2.5-x86_64.tar.gz</span><br><span class="line">&lt;-- 创建软连接 --&gt;</span><br><span class="line">sudo ln -s mysql-5.7.10-linux-glibc2.5-x86_64 mysql</span><br></pre></td></tr></table></figure>
<h3 id="创建必须的目录和进行授权"><a href="#创建必须的目录和进行授权" class="headerlink" title="创建必须的目录和进行授权"></a>创建必须的目录和进行授权</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd mysql</span><br><span class="line">sudo mkdir mysql-files</span><br><span class="line">sudo chmod 770 mysql-files</span><br><span class="line">sudo chown -R mysql .</span><br><span class="line">sudo chgrp -R mysql .</span><br></pre></td></tr></table></figure>
<h3 id="执行安装脚本"><a href="#执行安装脚本" class="headerlink" title="执行安装脚本"></a>执行安装脚本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo bin/mysqld --initialize --user=mysql   </span><br><span class="line">sudo bin/mysql_ssl_rsa_setup</span><br></pre></td></tr></table></figure>
<p>在初始化的时候, 一定要仔细看屏幕, 最后大概有一行:<code>[Note] A temporary password is generated for root@localhost: kklNBwkei1.t</code><br>注意这是<code>root</code>的临时密码,记录下来以便后面修改密码！</p>
<h3 id="重新对一些主要的目录进行授权-确保安全性"><a href="#重新对一些主要的目录进行授权-确保安全性" class="headerlink" title="重新对一些主要的目录进行授权, 确保安全性"></a>重新对一些主要的目录进行授权, 确保安全性</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo chown -R root .</span><br><span class="line">sudo chown -R mysql data mysql-files</span><br></pre></td></tr></table></figure>
<h3 id="从默认的模板创建配置文件-需要在文件中增加-skip-grant-tables-以便启动mysql以后修改root用户的密码"><a href="#从默认的模板创建配置文件-需要在文件中增加-skip-grant-tables-以便启动mysql以后修改root用户的密码" class="headerlink" title="从默认的模板创建配置文件, 需要在文件中增加 skip-grant-tables , 以便启动mysql以后修改root用户的密码"></a>从默认的模板创建配置文件, 需要在文件中增加 skip-grant-tables , 以便启动mysql以后修改root用户的密码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo cp support-files/my-default.cnf ./my.cnf</span><br></pre></td></tr></table></figure>
<h3 id="测试启动-修改密码"><a href="#测试启动-修改密码" class="headerlink" title="测试启动, 修改密码"></a>测试启动, 修改密码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 后台启动mysql</span><br><span class="line">sudo bin/mysqld_safe --user=mysql &amp;  </span><br><span class="line"># 启动</span><br><span class="line">./bin/mysql -u root -p</span><br></pre></td></tr></table></figure>
<h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>因为前面修改了<code>my.cnf</code>文件, 增加了 <code>skip-grant-tables</code> 参数, 所以不需要用户名即可登陆<br>进去后立即修改<code>root</code>用户的密码, 密码的字段是 <code>authentication_string</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update mysql.user set authentication_string=password(&apos;root&apos;) where user=&apos;root&apos;;</span><br></pre></td></tr></table></figure></p>
<p>修改密码后, 再把<code>my.cnf</code>里面的 <code>skip-grant-tables</code> 去掉</p>
<h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>修改密码也可以使用安装到时候提示到<strong>随机密码</strong>进行登录, 然后使用下面到命令修改密码.<br>建议用下面的方式设置数据库的密码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter user user() identified by &apos;root&apos;;</span><br></pre></td></tr></table></figure></p>
<h3 id="复制启动脚本到合适的位置"><a href="#复制启动脚本到合适的位置" class="headerlink" title="复制启动脚本到合适的位置"></a>复制启动脚本到合适的位置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo cp support-files/mysql.server /etc/init.d/mysql</span><br></pre></td></tr></table></figure>
<h3 id="Optional-增加自动启动"><a href="#Optional-增加自动启动" class="headerlink" title="(Optional)增加自动启动"></a>(Optional)增加自动启动</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo update-rc.d -f mysql defaults</span><br></pre></td></tr></table></figure>
<h3 id="增加mysql命令的路径到PATH环境变量"><a href="#增加mysql命令的路径到PATH环境变量" class="headerlink" title="增加mysql命令的路径到PATH环境变量"></a>增加<code>mysql</code>命令的路径到<code>PATH</code>环境变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo touch /etc/profile.d/mysql.sh</span><br><span class="line">sudo chmod 777 /etc/profile.d/mysql.sh</span><br><span class="line">sudo echo &quot;PATH=/usr/local/mysql/bin:\$PATH&quot; &gt; /etc/profile.d/mysql.sh</span><br><span class="line">sudo chmod 644 /etc/profile.d/mysql.sh</span><br></pre></td></tr></table></figure>
<p><strong><em><font color="red">到此, mysql的安装基本完成</font></em></strong></p>
<h3 id="修复乱码以及忽略大小写-找到MySQL文件里的my-cnf在末尾添加"><a href="#修复乱码以及忽略大小写-找到MySQL文件里的my-cnf在末尾添加" class="headerlink" title="修复乱码以及忽略大小写, 找到MySQL文件里的my.cnf在末尾添加"></a>修复乱码以及忽略大小写, 找到MySQL文件里的<code>my.cnf</code>在末尾添加</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lower_case_table_names=1</span><br><span class="line">character_set_server=utf8</span><br></pre></td></tr></table></figure>
<h3 id="查看以及修改MySQL字符编码"><a href="#查看以及修改MySQL字符编码" class="headerlink" title="查看以及修改MySQL字符编码"></a>查看以及修改MySQL字符编码</h3><h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;collation_%&apos;;</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &apos;character_set_%&apos;;</span><br></pre></td></tr></table></figure>
<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; set character_set_client=utf8;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set character_set_connection=utf8;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set character_set_database=utf8;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set character_set_results=utf8;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set character_set_server=utf8;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set character_set_system=utf8;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set collation_connection=utf8_general_ci;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set collation_database=utf8mb4_general_ci;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set collation_server=utf8mb4_general_ci;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>
<h3 id="如果登录mysql出现以下错误"><a href="#如果登录mysql出现以下错误" class="headerlink" title="如果登录mysql出现以下错误"></a>如果登录mysql出现以下错误</h3><p><img src="https://cdn.yangbingdong.com/img/javaDevEnv/mysql-problom.png" alt><br><strong>则可能配置未加载或服务未启动, 请重启系统, 然后启动mysql服务</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service mysql start</span><br></pre></td></tr></table></figure></p>
<p>结束<code>mysql</code>服务<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service mysql stop</span><br></pre></td></tr></table></figure></p>
<h3 id="开启远程链接"><a href="#开启远程链接" class="headerlink" title="开启远程链接"></a>开启远程链接</h3><p>链接mysql后:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use mysql</span><br><span class="line"></span><br><span class="line">// 下面两个root分别是帐号密码</span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;root&apos; WITH GRANT OPTION;</span><br><span class="line">// 刷新特权</span><br><span class="line">flush privileges;</span><br><span class="line">// 查看修改是否成功</span><br><span class="line">select host,user from user;</span><br></pre></td></tr></table></figure></p>
<h2 id="Mysql-GUI"><a href="#Mysql-GUI" class="headerlink" title="Mysql GUI"></a>Mysql GUI</h2><h3 id="传统终端客户端"><a href="#传统终端客户端" class="headerlink" title="传统终端客户端"></a>传统终端客户端</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mysql-client</span><br><span class="line"></span><br><span class="line">// 链接</span><br><span class="line">mysql -h 127.0.0.1 -P 3306 -u root -p</span><br></pre></td></tr></table></figure>
<h3 id="智能补全命令客户端"><a href="#智能补全命令客户端" class="headerlink" title="智能补全命令客户端"></a>智能补全命令客户端</h3><p>这个一个智能补全并且高亮语法的终端客户端 <strong><em><a href="https://github.com/dbcli/mycli" rel="external nofollow noopener noreferrer" target="_blank">mycli</a></em></strong></p>
<p><img src="https://cdn.yangbingdong.com/img/mysql-related-learning/mycli.gif" alt></p>
<p>安装: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install mycli</span><br></pre></td></tr></table></figure>
<p>使用: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mycli --help</span><br><span class="line">Usage: mycli [OPTIONS] [DATABASE]</span><br><span class="line"></span><br><span class="line">  A MySQL terminal client with auto-completion and syntax highlighting.</span><br><span class="line"></span><br><span class="line">  Examples:</span><br><span class="line">    - mycli my_database</span><br><span class="line">    - mycli -u my_user -h my_host.com my_database</span><br><span class="line">    - mycli mysql://my_user@my_host.com:3306/my_database</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -h, --host TEXT               Host address of the database.</span><br><span class="line">  -P, --port INTEGER            Port number to use for connection. Honors</span><br><span class="line">                                $MYSQL_TCP_PORT.</span><br><span class="line">  -u, --user TEXT               User name to connect to the database.</span><br><span class="line">  -S, --socket TEXT             The socket file to use for connection.</span><br><span class="line">  -p, --password TEXT           Password to connect to the database.</span><br><span class="line">  --pass TEXT                   Password to connect to the database.</span><br><span class="line">  --ssl-ca PATH                 CA file in PEM format.</span><br><span class="line">  --ssl-capath TEXT             CA directory.</span><br><span class="line">  --ssl-cert PATH               X509 cert in PEM format.</span><br><span class="line">  --ssl-key PATH                X509 key in PEM format.</span><br><span class="line">  --ssl-cipher TEXT             SSL cipher to use.</span><br><span class="line">  --ssl-verify-server-cert      Verify server&apos;s &quot;Common Name&quot; in its cert</span><br><span class="line">                                against hostname used when connecting. This</span><br><span class="line">                                option is disabled by default.</span><br><span class="line">  -v, --version                 Output mycli&apos;s version.</span><br><span class="line">  -D, --database TEXT           Database to use.</span><br><span class="line">  -R, --prompt TEXT             Prompt format (Default: &quot;\t \u@\h:\d&gt; &quot;).</span><br><span class="line">  -l, --logfile FILENAME        Log every query and its results to a file.</span><br><span class="line">  --defaults-group-suffix TEXT  Read MySQL config groups with the specified</span><br><span class="line">                                suffix.</span><br><span class="line">  --defaults-file PATH          Only read MySQL options from the given file.</span><br><span class="line">  --myclirc PATH                Location of myclirc file.</span><br><span class="line">  --auto-vertical-output        Automatically switch to vertical output mode</span><br><span class="line">                                if the result is wider than the terminal</span><br><span class="line">                                width.</span><br><span class="line">  -t, --table                   Display batch output in table format.</span><br><span class="line">  --csv                         Display batch output in CSV format.</span><br><span class="line">  --warn / --no-warn            Warn before running a destructive query.</span><br><span class="line">  --local-infile BOOLEAN        Enable/disable LOAD DATA LOCAL INFILE.</span><br><span class="line">  --login-path TEXT             Read this path from the login file.</span><br><span class="line">  -e, --execute TEXT            Execute command and quit.</span><br><span class="line">  --help                        Show this message and exit.</span><br></pre></td></tr></table></figure>
<h3 id="Navicat-Premium"><a href="#Navicat-Premium" class="headerlink" title="Navicat Premium"></a>Navicat Premium</h3><h4 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h4><ol>
<li><p>到<em><a href="https://www.navicat.com/download" rel="external nofollow noopener noreferrer" target="_blank">官网</a></em>下载对应系统版本, 这里选择linux版本, 并解压</p>
</li>
<li><p>到<em><a href="https://github.com/DoubleLabyrinth/navicat-keygen/releases" rel="external nofollow noopener noreferrer" target="_blank">Github</a></em>下载注册机, 并解压</p>
</li>
<li><p>安装wine</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:ubuntu-wine/ppa</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install wine1.8</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入注册机解压目录, 在此目录下打开命令窗口输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wine navicat-patcher.exe &lt;Navicat installation path&gt; ./RegPrivateKey.pem</span><br></pre></td></tr></table></figure>
<p><code>&lt;Navicat installation path&gt;</code>就是Navicat中存放<code>navicat.exe</code>的根目录. </p>
</li>
<li><p>接着再用<code>navicat-keygen.exe</code>生成注册码, 使用命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wine navicat-keygen.exe -text ./RegPrivateKey.pem</span><br></pre></td></tr></table></figure>
<p>你会被要求选择Navicat产品类别、语言以及输入主版本号. 之后会随机生成一个序列号. </p>
<p>产品选择Premium, 语言选择Simplified Chinese, 版本输入12（当然, 因为下载的是Navicat Premium12 简体中文版）</p>
<p>然后会出现一个序列号: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Serial number:</span><br><span class="line">NAVA-DHCN-P2OI-DV46</span><br></pre></td></tr></table></figure>
<p>接下来填写<code>用户名</code>和<code>组织名</code>, 随便写. </p>
<p><strong>然后打开navicat, 然后断网</strong></p>
</li>
<li><p>在注册界面填入序列号, 然后激活. 这时会提示要手动激活, ok就选这个. </p>
</li>
<li><p>一般来说在线激活肯定会失败, 这时候Navicat会询问你是否<code>手动激活</code>, 直接选吧. </p>
</li>
<li><p>在<code>手动激活</code>窗口你会得到一个请求码, 复制它并把它粘贴到keygen里. 最后别忘了连按至少两下回车结束输入. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Your name: DoubleLabyrinth</span><br><span class="line">Your organization: DoubleLabyrinth</span><br><span class="line"></span><br><span class="line">Input request code (in Base64), input empty line to end:</span><br><span class="line">q/cv0bkTrG1YDkS+fajFdi85bwNVBD/lc5jBYJPOSS5bfl4DdtnfXo+RRxdMjJtEcYQnvLPi2LF0</span><br><span class="line">OB464brX9dqU29/O+A3qstSyhBq5//iezxfu2Maqca4y0rVtZgQSpEnZ0lBNlqKXv7CuTUYCS1pm</span><br><span class="line">tEPgwJysQTMUZf7tu5MR0cQ+hY/AlyQ9iKrQAMhHklqZslaisi8VsnoIqH56vfTyyUwUQXrFNc41</span><br><span class="line">qG5zZNsXu/NI79JOo7qTvcFHQT/k5cTadbKTxY+9c5eh+nF3JR7zEa2BDDfdQRLNvy4DTSyxdYXd</span><br><span class="line">sAk/YPU+JdWI+8ELaa0SuAuNzr5fEkD6NDSG2A==</span><br><span class="line"></span><br><span class="line">Request Info:</span><br><span class="line">&#123;&quot;K&quot;:&quot;NAVADHCNP2OIDV46&quot;, &quot;DI&quot;:&quot;Y2eJk9vrvfGudPG7Mbdn&quot;, &quot;P&quot;:&quot;WIN 8&quot;&#125;</span><br><span class="line"></span><br><span class="line">Response Info:</span><br><span class="line">&#123;&quot;K&quot;:&quot;NAVADHCNP2OIDV46&quot;,&quot;DI&quot;:&quot;Y2eJk9vrvfGudPG7Mbdn&quot;,&quot;N&quot;:&quot;DoubleLabyrinth&quot;,&quot;O&quot;:&quot;DoubleLabyrinth&quot;,&quot;T&quot;:1537630251&#125;</span><br><span class="line"></span><br><span class="line">License:</span><br><span class="line">oyoMYr9cfVGXeT7F1dqBwHsB/vvWj6SUL6aR+Kzb0lm5IyEj1CgovuSq+qMzFfx+</span><br><span class="line">oHMFaGKFg6viOY2hfJcrO2Vdq0hXZS/B/Ie3jBS2Ov37v8e3ufVajaH+wLkmEpLd</span><br><span class="line">xppCVLkDQjIHYR2IPz5s/L/RuWqDpEY4TPmGFF6q+xQMnqQA3vXPyG+JYMARXLru</span><br><span class="line">Y1gCDLN30v3DpyOeqKmFjUqiHK5h8s0NYiH2OpMyaCpi12JsF23miP89ldQp3+SJ</span><br><span class="line">8moo0cNGy7sFp2gX9ol2zVoo7qxfYlLl03f7CALJ6im0sx4yBsmlzFDdvpQUbXk8</span><br><span class="line">YZ5rT4LML2Fx6Wgnnklb5g==</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果不出意外, 你会得到一个看似用Base64编码的激活码. 直接复制它, 并把它粘贴到Navicat的<code>手动激活</code>窗口, 最后点<code>激活</code>按钮. 如果没什么意外的话应该能成功激活. </p>
</li>
</ol>
<p><img src="https://cdn.yangbingdong.com/img/javaDevEnv/navicat12.png" alt></p>
<h4 id="创建快捷方式"><a href="#创建快捷方式" class="headerlink" title="创建快捷方式"></a>创建快捷方式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /usr/share/applications/</span><br><span class="line">sudo touch navicat.desktop</span><br><span class="line">sudo vi navicat.desktop</span><br></pre></td></tr></table></figure>
<p>加入以下内容<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Encoding=UTF-8</span><br><span class="line">Name=Navicat</span><br><span class="line">Comment=The Smarter Way to manage dadabase</span><br><span class="line">Exec=/bin/sh &quot;/home/ybd/Data/soft/application/navicat112_mysql_en_x64/start_navicat&quot;</span><br><span class="line">Icon=/home/ybd/Data/soft/application/navicat112_mysql_en_x64/Navicat/navicat.png</span><br><span class="line">Categories=Application;Database;MySQL;navicat</span><br><span class="line">Version=1.0</span><br><span class="line">Type=Application</span><br><span class="line">Terminal=0</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>参考: <strong><em><a href="https://www.52pojie.cn/thread-705020-1-1.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.52pojie.cn/thread-705020-1-1.html</a></em></strong></p>
</blockquote>
<h4 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup /home/ybd/data/application/navicat/navicat120_premium_en_x64/start_navicat &gt; /dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p><strong><em><a href="/2018/redis-relate-note.html">请看这里</a></em></strong></p>
<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>官网下载或者<strong><em><a href="http://mirror.bit.edu.cn/apache/maven/maven-3/3.3.9/binaries/apache-maven-3.3.9-bin.tar.gz" rel="external nofollow noopener noreferrer" target="_blank">点击镜像获取</a></em></strong></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>1、下载解压到自己的指定的目录后, 将命令放到<code>/bin</code>下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ln -s /自定义目录/apache-maven-3.3.9/bin/mvn /bin/mvn</span><br></pre></td></tr></table></figure></p>
<p>2、添加环境变量<br>老规矩, 在<code>/etc/profile.d</code>下创建一个<code>maven.sh</code>的文件:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo touch /etc/profile.d/maven.sh</span><br><span class="line">sudo vi /etc/profile.d/maven.sh</span><br></pre></td></tr></table></figure></p>
<p>输入以下内容:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export M2_HOME=/自定义目录/apache-maven-3.3.9</span><br><span class="line">export PATH=$&#123;M2_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure></p>
<p>然后<code>source</code>一下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source /etc/profile.d/maven.sh</span><br></pre></td></tr></table></figure></p>
<p>查看是否配置成功:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn -v</span><br></pre></td></tr></table></figure></p>
<p>输入内容如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Apache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-11T00:41:47+08:00)</span><br><span class="line">Maven home: /home/ybd/Data/application/maven/apache-maven-3.3.9</span><br><span class="line">Java version: 1.8.0_65, vendor: Oracle Corporation</span><br><span class="line">Java home: /usr/local/jdk1.8.0_65/jre</span><br><span class="line">Default locale: zh_CN, platform encoding: UTF-8</span><br><span class="line">OS name: &quot;linux&quot;, version: &quot;4.4.0-67-generic&quot;, arch: &quot;amd64&quot;, family: &quot;unix&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="阿里镜像"><a href="#阿里镜像" class="headerlink" title="阿里镜像"></a>阿里镜像</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mirrors&gt;</span><br><span class="line">	&lt;mirror&gt;</span><br><span class="line">	  &lt;id&gt;alimaven&lt;/id&gt;</span><br><span class="line">	  &lt;name&gt;aliyun maven&lt;/name&gt;</span><br><span class="line">	  &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;</span><br><span class="line">	  &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; </span><br><span class="line">	&lt;/mirror&gt;</span><br><span class="line">&lt;/mirrors&gt;</span><br></pre></td></tr></table></figure>
<h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 0C49F3730359A14518585931BC711F9BA15703C6</span><br><span class="line"></span><br><span class="line">#下面命令针对ubuntu16.04版本, 在其他ubuntu版本系统请查看MongoDB官网</span><br><span class="line">echo &quot;deb [ arch=amd64,arm64 ] http://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/3.4 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-3.4.list</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get install -y mongodb-org</span><br></pre></td></tr></table></figure>
<p>安装完成后查看版本:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mongo -version</span><br></pre></td></tr></table></figure></p>
<p><img src="https://cdn.yangbingdong.com/img/mongodb/mongodb-version.png" alt></p>
<p>启动、重新启动和关闭mongodb命令:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service mongod start</span><br><span class="line">sudo service mongod stop</span><br><span class="line">sudo service mongod restart</span><br></pre></td></tr></table></figure></p>
<p>查看是否启动成功:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo cat /var/log/mongodb/mongod.log</span><br></pre></td></tr></table></figure></p>
<p>在 <code>mongod.log</code> 日志中若出现如下信息, 说明启动成功:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[initandlisten] waiting for connections on port 27017</span><br></pre></td></tr></table></figure></p>
<h2 id="MongoDB-卸载"><a href="#MongoDB-卸载" class="headerlink" title="MongoDB 卸载"></a>MongoDB 卸载</h2><p>删除 mongodb 包<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get purge mongodb-org*</span><br></pre></td></tr></table></figure></p>
<p>删除 MongoDB 数据库和日志文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rm -r /var/log/mongodb</span><br><span class="line">sudo rm -r /var/lib/mongodb</span><br></pre></td></tr></table></figure></p>
<h2 id="MongoDB-使用"><a href="#MongoDB-使用" class="headerlink" title="MongoDB 使用"></a>MongoDB 使用</h2><p>shell命令模式<br>输入<code>mongo</code>进入shell命令模式, 默认连接的数据库是test数据库, 命令如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~ mongo</span><br></pre></td></tr></table></figure></p>
<p>常用操作命令: </p>
<p><code>show dbs</code>: 显示数据库列表<br><code>show collections</code>: 显示当前数据库中的集合（类似关系数据库中的表table）<br><code>show users</code>: 显示所有用户<br><code>use yourDB</code>: 切换当前数据库至yourDB<br><code>db.help()</code> : 显示数据库操作命令<br><code>db.yourCollection.help()</code> : 显示集合操作命令, yourCollection是集合名</p>
<p>官方文档: <strong><em><a href="https://docs.mongodb.com/master/tutorial/install-mongodb-on-ubuntu/" rel="external nofollow noopener noreferrer" target="_blank">https://docs.mongodb.com/master/tutorial/install-mongodb-on-ubuntu/</a></em></strong></p>
<h2 id="GUI客户端"><a href="#GUI客户端" class="headerlink" title="GUI客户端"></a>GUI客户端</h2><p><strong><em><a href="https://www.mongodb.com/download-center#community" rel="external nofollow noopener noreferrer" target="_blank">Robomongo</a></em></strong></p>
<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><p>选择Docker安装. . . 不折腾了. . </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull rabbitmq:3-management</span><br><span class="line">docker run -d --name rabbitmq -p 5673:5672 -p 15673:15672 --restart=always rabbitmq:3-management</span><br></pre></td></tr></table></figure>
<p>(注意版本, 是<code>management</code>)</p>
<p>浏览器打开<code>localhost:15673</code>, 默认帐号密码都是<code>guest</code></p>
<p><img src="https://cdn.yangbingdong.com/img/javaDevEnv/rabbitmq.png" alt></p>
<p>集群: <a href="https://www.jianshu.com/p/624871c646b9" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/624871c646b9</a></p>
<h1 id="Pip"><a href="#Pip" class="headerlink" title="Pip"></a>Pip</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install python3-pip</span><br><span class="line"></span><br><span class="line">// for Python 2</span><br><span class="line">sudo apt install python-pip</span><br></pre></td></tr></table></figure>
<h1 id="Kafka-amp-Zookeeper集群"><a href="#Kafka-amp-Zookeeper集群" class="headerlink" title="Kafka&amp;Zookeeper集群"></a>Kafka&amp;Zookeeper集群</h1><p><code>docker-compose.yml</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &apos;3&apos;</span><br><span class="line">services:</span><br><span class="line">  kafka1:</span><br><span class="line">    image: wurstmeister/kafka:1.0.0</span><br><span class="line">    depends_on:</span><br><span class="line">      - zoo1</span><br><span class="line">      - zoo2</span><br><span class="line">      - zoo3</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;9092:9092&quot;</span><br><span class="line">    environment:</span><br><span class="line">      KAFKA_LOG_DIRS: /kafka</span><br><span class="line">      KAFKA_BROKER_ID: 1</span><br><span class="line">      KAFKA_CREATE_TOPICS: test:6:1</span><br><span class="line">      KAFKA_ADVERTISED_HOST_NAME: 192.168.6.113</span><br><span class="line">      KAFKA_ADVERTISED_PORT: 9092</span><br><span class="line">      KAFKA_ZOOKEEPER_CONNECT: zoo1:2181,zoo2:2181,zoo3:2181</span><br><span class="line"></span><br><span class="line">  kafka2:</span><br><span class="line">    image: wurstmeister/kafka:1.0.0</span><br><span class="line">    depends_on:</span><br><span class="line">      - zoo1</span><br><span class="line">      - zoo2</span><br><span class="line">      - zoo3</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;9093:9092&quot;</span><br><span class="line">    environment:</span><br><span class="line">      KAFKA_LOG_DIRS: /kafka</span><br><span class="line">      KAFKA_BROKER_ID: 2</span><br><span class="line">      KAFKA_ADVERTISED_HOST_NAME: 192.168.6.113</span><br><span class="line">      KAFKA_ADVERTISED_PORT: 9093</span><br><span class="line">      KAFKA_ZOOKEEPER_CONNECT: zoo1:2181,zoo2:2181,zoo3:2181</span><br><span class="line"></span><br><span class="line">  kafka3:</span><br><span class="line">    image: wurstmeister/kafka:1.0.0</span><br><span class="line">    depends_on:</span><br><span class="line">      - zoo1</span><br><span class="line">      - zoo2</span><br><span class="line">      - zoo3</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;9094:9092&quot;</span><br><span class="line">    environment:</span><br><span class="line">      KAFKA_LOG_DIRS: /kafka</span><br><span class="line">      KAFKA_BROKER_ID: 3</span><br><span class="line">      KAFKA_ADVERTISED_HOST_NAME: 192.168.6.113</span><br><span class="line">      KAFKA_ADVERTISED_PORT: 9094</span><br><span class="line">      KAFKA_ZOOKEEPER_CONNECT: zoo1:2181,zoo2:2181,zoo3:2181</span><br><span class="line"></span><br><span class="line">  zoo1:</span><br><span class="line">    image: zookeeper:latest</span><br><span class="line">    environment:</span><br><span class="line">      ZOO_MY_ID: 1</span><br><span class="line">      SERVERS: zoo1,zoo2,zoo3</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;2181:2181&quot;</span><br><span class="line">      - &quot;2888&quot;</span><br><span class="line">      - &quot;3888&quot;</span><br><span class="line"></span><br><span class="line">  zoo2:</span><br><span class="line">    image: zookeeper:latest</span><br><span class="line">    environment:</span><br><span class="line">      ZOO_MY_ID: 2</span><br><span class="line">      SERVERS: zoo1,zoo2,zoo3</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;2182:2181&quot;</span><br><span class="line">      - &quot;2888&quot;</span><br><span class="line">      - &quot;3888&quot;</span><br><span class="line"></span><br><span class="line">  zoo3:</span><br><span class="line">    image: zookeeper:latest</span><br><span class="line">    environment:</span><br><span class="line">      ZOO_MY_ID: 3</span><br><span class="line">      SERVERS: zoo1,zoo2,zoo3</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;2183:2181&quot;</span><br><span class="line">      - &quot;2888&quot;</span><br><span class="line">      - &quot;3888&quot;</span><br></pre></td></tr></table></figure>
<p>启动:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></p>
<p>测试: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#创建主题</span><br><span class="line">docker exec -it $&#123;CONTAINER_ID&#125; /opt/kafka/bin/kafka-topics.sh --create --zookeeper zoo1:2181 --replication-factor 1 --partitions 1 --topic test</span><br><span class="line"></span><br><span class="line">#查看topic列表</span><br><span class="line">docker exec -it $&#123;CONTAINER_ID&#125; /opt/kafka/bin/kafka-topics.sh --list --zookeeper zoo1:2181</span><br><span class="line"></span><br><span class="line">#生产者</span><br><span class="line">docker exec -it $&#123;CONTAINER_ID&#125; /opt/kafka/bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test</span><br><span class="line"></span><br><span class="line">#消费者</span><br><span class="line">docker exec -it $&#123;CONTAINER_ID&#125; /opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning</span><br></pre></td></tr></table></figure>
<h2 id="Zookeeper-UI"><a href="#Zookeeper-UI" class="headerlink" title="Zookeeper UI"></a>Zookeeper UI</h2><p><strong><em><a href="https://github.com/DeemOpen/zkui" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/DeemOpen/zkui</a></em></strong></p>
<h1 id="搭建ngrok配置"><a href="#搭建ngrok配置" class="headerlink" title="搭建ngrok配置"></a>搭建ngrok配置</h1><p><img src="https://cdn.yangbingdong.com/img/javaDevEnv/ngrok_p1.jpg" alt></p>
<blockquote>
<p>ngrok 是一个反向代理, 通过在公共的端点和本地运行的 Web 服务器之间建立一个安全的通道. ngrok 可捕获和分析所有通道上的流量, 便于后期分析和重放. 可以被使用来进行微信借口的本地调试. 在ngrok被墙之后, 我们需要通过ngrok开源的源码自行搭建ngrok服务. </p>
</blockquote>
<p>参考地址: <strong><em><a href="http://blog.csdn.net/cloume/article/details/51209493" rel="external nofollow noopener noreferrer" target="_blank">Ubuntu下配置安装ngrok</a></em></strong><br>搞了一上午, 服务运行起来了, 客户端也运行起来了, 浏览器就是访问不到！！<br>不知道是不是因为个人电脑没有域名所以才访问不到, 日后再深究.<br>无奈, 还好互联网开源精神无处不在, 某大神搭建的ngrok:<br><strong><em><a href="http://www.qydev.com/" rel="external nofollow noopener noreferrer" target="_blank">http://www.qydev.com/</a></em></strong><br>客户端和教程都在里面哦. </p>
<p><strong>Update:</strong>Ngrok已搭建成功～ , 记录于<strong><em><a href="/2017/self-hosted-build-ngrok-server/">self-hosted-build-ngrok-server</a></em></strong></p>
<p id="div-border-left-purple"><strong>其他tunnel的代理服务器</strong>:<br><strong><em><a href="http://natapp.cn" rel="external nofollow noopener noreferrer" target="_blank">natapp.cn</a></em></strong><br><strong><em><a href="http://www.ngrok.cc" rel="external nofollow noopener noreferrer" target="_blank">www.ngrok.cc</a></em></strong><br></p>






<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">IDEA 全称IntelliJ IDEA, 是java语言开发的集成环境, IntelliJ在业界被公认为最好的java开发工具之一, 尤其在智能代码助手、代码自动提示、重构、J2EE支持、Ant、JUnit、CVS整合、代码审查、 创新的GUI设计等方面的功能可以说是超常的. IDEA是JetBrains公司的产品, 这家公司总部位于捷克共和国的首都布拉格, 开发人员以严谨著称的东欧程序员为主<a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content><categories><category>OperatingSystem</category><category>Ubuntu</category></categories><tags><tag>Ubuntu</tag><tag>IDE</tag><tag>JDK</tag><tag>Tomcat</tag></tags></entry><entry><title>Ubuntu16.04下MyEclipse安装与破解</title><url>/2017/ubuntu-myeclipse-crack/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/ubuntu-myclipse-crack/myeclipseInfo.png" alt></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>之前一直用的是Eclipse Luna, 没有用MyEclipse是因为它<strong>收钱</strong>的- -, 去新公司工作需要用到MyEclipse, 下载安装happy地<strong>试用</strong>了将近一个月, 不幸, 试用期已过. 身为一个开源爱好者, 不想去用破解的（虚伪 - -）, 也不想出钱, 博主秉着屌丝的意志, 一番折腾过后, 搞定. 以下是经过参考与总结得到的操作步骤, 博主用的是Linux的发行版Ubuntu, 所以以下步骤针对Ubuntu系统, win与mac的步骤也大同小异.<br><a id="more"></a></p>
</blockquote>
<hr>
<h1 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h1><p>首先, 请前往<strong><em><a href="http://www.MyEclipsecn.com/download/" rel="external nofollow noopener noreferrer" target="_blank">MyEclipse的官网</a></em></strong> 下载相应系统的版本, 我选择的是<em>MyEclipse-2015-stable-3.0-offline-installer-linux.run</em>, 进入放置安装文件的目录, 右键在终端打开安装文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./MyEclipse-2015-stable-3.0-offline-installer-linux.run</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.yangbingdong.com/img/ubuntu-myclipse-crack/meInstall.png" alt><br>按<code>Nest</code>设置一下安装路径完成安装, 安装完之后不要选择运行MyEclipse</p>
<p><strong>破解之前请不要开启你的MyEclipse, 要保持刚安装完的状态, 如果你已经开过了, 卸载重装吧——否则你就会遭遇打开编译器, 然后校验失败, 报错关闭</strong></p>
<h1 id="破解与运行"><a href="#破解与运行" class="headerlink" title="破解与运行"></a>破解与运行</h1><p>首先请前往<strong><em><a href="https://pan.baidu.com/s/1geKxeoz" rel="external nofollow noopener noreferrer" target="_blank">博主的百度盘</a></em></strong>（密码: kv25）下载对应的破解工具, 我的MyEclipse版本是2015-stable-3.0, 所以在这以此版本作为示范. </p>
<p>下载到本地解压后并进入目录会有以下文件</p>
<p><img src="https://cdn.yangbingdong.com/img/ubuntu-myclipse-crack/meFile.png" alt></p>
<h2 id="打开注册机"><a href="#打开注册机" class="headerlink" title="打开注册机"></a>打开注册机</h2><p>进入<code>MyEclipse2015_keygen</code>, 双击打开注册机<code>cracker2015.jar</code>, 失败的话, 用java命令打开<code>cracker2015.jar</code>, <strong>前提都是你要安装了JDK并且配置好环境</strong>, JDK版本最好不要太旧, 我的是1.8</p>
<p>当前目录终端执行: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar cracker2015.jar</span><br></pre></td></tr></table></figure>
<p>运行之后出现如下界面 ↓</p>
<p><img src="https://cdn.yangbingdong.com/img/ubuntu-myclipse-crack/crack.png" alt></p>
<h2 id="开始生成注册信息"><a href="#开始生成注册信息" class="headerlink" title="开始生成注册信息"></a>开始生成注册信息</h2><ol>
<li><p>在算号器填好<code>Usercode</code>,<code>UserCode</code>可以随意输入</p>
</li>
<li><p>选择版本: 由于<code>Bling</code>版功能最全, 所以我选择了这个版本（其他版本也可以）</p>
</li>
<li><p>然后点击”SystemId”按钮, 就会出现一行ID值, 如果提示 <code>Cannot find JNIWrapper native library (jniwrap.dll) in java.library.path:</code>这样的错误, 不要紧, 再点一下应该就出来了, 还是没有的话请注意<strong>权限</strong>问题</p>
</li>
<li><p>点击<code>Active</code></p>
</li>
<li><p>保存破解信息: 点<code>Tools</code>下的<code>SaveProperites</code>把破解信息（注册码）保存到文件 （<font color="red">注意不要手残去点RebuildKey- - !</font>）</p>
</li>
</ol>

<h2 id="copy文件"><a href="#copy文件" class="headerlink" title="copy文件"></a>copy文件</h2><p>把plugins文件中的文件复制到MyEclipse的plugins文件夹中, 覆盖原文件</p>
<p><img src="https://cdn.yangbingdong.com/img/ubuntu-myclipse-crack/plugins.png" alt></p>
<h1 id="运行MyEclipse"><a href="#运行MyEclipse" class="headerlink" title="运行MyEclipse"></a>运行MyEclipse</h1><p>打开了MyEclipse, 点击菜单栏中的<code>MyEclipse</code>-&gt;<code>Subscription information</code>, 激活成功, 激动ing=.=</p>
<p><img src="https://cdn.yangbingdong.com/img/ubuntu-myclipse-crack/myeclipseInfo.png" alt></p>
<hr>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>以上是博主在Ubuntu中安装破解MyEclipse的总结过程, 对于不同的环境, 不同的版本, 不同的操作, 有可能会导致一些不一样的小问题, 那么可以在一下参考中找到一些答案</p>
<blockquote>
<p><strong>参考: </strong><br><strong><em><a href="http://yangl.net/2015/07/14/myeclipse_2015stable_1/" rel="external nofollow noopener noreferrer" target="_blank">Myeclipse 2015 stable 1.0 完美破解方法</a></em></strong><br><strong><em><a href="http://http://yangl.net/2016/10/11/myeclipse-2016-ci-6_crack/" rel="external nofollow noopener noreferrer" target="_blank">Myeclipse 2016 CI 6 破解</a></em></strong></p>
</blockquote>
]]></content><categories><category>IDE</category></categories><tags><tag>Ubuntu</tag><tag>IDE</tag></tags></entry><entry><title>Spring与任务调度</title><url>/2018/spring-boot-scheduler/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/scheduler/scheduler-banner.jpg" alt></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><blockquote>
<p>本篇主要记录<strong>任务调度</strong>相关框架知识. </p>
<p>任务调度这个在日常开发中非常经典, 比如每天固定时刻同步用户信息、或者是动态的活动开始与结束时间, 亦或者每天早上8点发条短信鼓励一下自己今天努力填坑之类的. . . </p>
</blockquote>
<a id="more"></a>
<h1 id="Quartz"><a href="#Quartz" class="headerlink" title="Quartz"></a>Quartz</h1><p><img src="https://cdn.yangbingdong.com/img/scheduler/quartz-logo.jpg" alt></p>
<blockquote>
<p><strong><em><a href="http://www.quartz-scheduler.org/documentation/" rel="external nofollow noopener noreferrer" target="_blank">官方文档</a></em></strong></p>
<p>Quartz是一个功能丰富的开源作业调度库, 几乎可以集成在任何Java应用程序中 - 从最小的独立应用程序到最大的电子商务系统. Quartz可用于创建简单或复杂的计划, 以执行数十, 数百甚至数万个作业;将任务定义为标准Java组件的作业, 这些组件可以执行几乎任何可以编程的程序. Quartz Scheduler包含许多企业级功能, 例如支持JTA事务和集群. </p>
</blockquote>
<h2 id="主要成员"><a href="#主要成员" class="headerlink" title="主要成员"></a>主要成员</h2><ul>
<li><code>Scheduler</code> - 与调度器交互的主要API. </li>
<li><code>Job</code> - 需要被调度器调度的任务必须实现的接口. </li>
<li><code>JobDetail</code> - 用于定义任务的实例. </li>
<li><code>Trigger</code> - 用于定义调度器何时调度任务执行的组件. </li>
<li><code>JobBuilder</code> - 用于定义或创建<code>JobDetail</code>的实例 . </li>
<li><code>TriggerBuilder</code> - 用于定义或创建触发器实例. </li>
</ul>
<h2 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h2><ul>
<li><p>定义<code>ScheduleFactory</code>, <code>Schedule</code>实例对象通过该工厂接口的实现类获取. </p>
</li>
<li><p>定义<code>JobDetail</code>实例对象, 该对象需要指定名称、组和<code>Job</code>接口的<code>Class</code>信息. </p>
</li>
<li><p>定义<code>Trigger</code>实例对象, 通过该对象设置触发任务的相关信息, 如起始时间、重复次数等. </p>
</li>
<li><p>向<code>Schedule</code>中注册<code>JobDetail</code>和<code>Trigger</code>, 有两种方式: </p>
</li>
<li><ul>
<li>通过<code>Schedule</code>的schedule方法注册, 此时它自动让<code>Trigger</code>和<code>JobDetail</code>绑定. </li>
<li>通过<code>addJob</code>和<code>scheduleJob</code>方法注册, 此时需要手动设置 <code>Trigger</code>的关联的<code>Job</code>组名和<code>Job</code>名称, 让<code>Trigger</code>和<code>JobDetail</code>绑定. </li>
</ul>
</li>
<li><p>启动调度器（调用<code>Schedule</code>对象的<code>start</code>方法）. </p>
</li>
</ul>
<h2 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h2><p><img src="http://www.javarticles.com/wp-content/uploads/2016/03/MainComponents.png" alt></p>
<p>内部运行图: </p>
<p><img src="http://www.javarticles.com/wp-content/uploads/2016/03/QuartzSchedulerModel.png" alt></p>
<h2 id="与Spring集成"><a href="#与Spring集成" class="headerlink" title="与Spring集成"></a>与Spring集成</h2><p>在<code>Spring</code>中使用<code>Quartz</code>有两种方式实现: <code>MethodInvokingJobDetailFactoryBean</code>和<code>QuartzJobBean</code>. 其中<code>MethodInvokingJobDetailFactoryBean</code>不支持存储到数据库, 会报<code>java.io.NotSerializableException</code>. </p>
<h3 id="xml方式声明Job"><a href="#xml方式声明Job" class="headerlink" title="xml方式声明Job"></a>xml方式声明Job</h3><h4 id="MethodInvokingJobDetailFactoryBean"><a href="#MethodInvokingJobDetailFactoryBean" class="headerlink" title="MethodInvokingJobDetailFactoryBean"></a>MethodInvokingJobDetailFactoryBean</h4><p>先来看一下<code>MethodInvokingJobDetailFactoryBean</code>的方式（指定<code>targetObject</code>与<code>targetMethod</code>再通过反射调用）: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用MethodInvokingJobDetailFactoryBean, 任务类可以不实现Job接口, 通过targetMethod指定调用方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"taskJob"</span> <span class="attr">class</span>=<span class="string">"com.xxx.DataConversionTask"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jobDetail"</span> <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"group"</span> <span class="attr">value</span>=<span class="string">"job_work"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"job_work_name"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--false表示等上一个任务执行完后再开启新的任务--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"concurrent"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetObject"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"taskJob"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定执行方法 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetMethod"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>run<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="QuartzJobBean"><a href="#QuartzJobBean" class="headerlink" title="QuartzJobBean"></a>QuartzJobBean</h4><p>一般很少会使用上述方式, 一般是使用<code>QuartzJobBean</code>: </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"redisKeySpaceMetricReportJob"</span> <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.quartz.JobDetailFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jobClass"</span> <span class="attr">value</span>=<span class="string">"com.iba.boss.schedule.RedisKeySpaceMetricReportScheduleJob"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"durability"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 向jobDataMap中注入依赖, Spring会通过反射将这些属性注入到RedisKeySpaceMetricReportScheduleJob中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jobDataMap"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"contextUtil"</span> <span class="attr">value-ref</span>=<span class="string">"applicationContextUtil"</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 定时任务执行开关 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"isOpen"</span> <span class="attr">value</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"redisMetricReportTrigger"</span> <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.quartz.CronTriggerFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jobDetail"</span> <span class="attr">ref</span>=<span class="string">"redisKeySpaceMetricReportJob"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cronExpression"</span> <span class="attr">value</span>=<span class="string">"0 30 9 * * ?"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"schedulerFactoryBean"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.quartz.SchedulerFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"triggers"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"redisMetricReportTrigger"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisKeySpaceMetricReportScheduleJob</span> <span class="keyword">extends</span> <span class="title">QuartzJobBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Boolean isOpen;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeInternal</span><span class="params">(JobExecutionContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isOpen) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// Do something</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIsOpen</span><span class="params">(Boolean isOpen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.isOpen = isOpen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContextUtil</span><span class="params">(ApplicationContextUtil contextUtil)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = contextUtil.getContext();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JobFactory"><a href="#JobFactory" class="headerlink" title="JobFactory"></a>JobFactory</h3><p>Quartz是通过<code>JobFactory#newJob()</code>接口返回<code>Job</code>实例的, 默认实现<code>SimpleJobFactory</code>是通过<code>jobClass.newInstance()</code>反射构建实例的. </p>
<p>在Spring中, 也是类似地通过反射构建<code>Job</code>实例, 不同的是在此实例上做了扩展（注入Spring Bean）. </p>
<p><code>AdaptableJobFactory</code>只是简单地通过反射构建<code>Job</code>, <code>SpringBeanJobFactory</code>继承<code>AdaptableJobFactory</code>并重写<code>createJobInstance</code>方法, 把<code>jobDataMap</code>跟<code>triggerDataMap</code>中的<code>bean</code>注入到<code>Job</code>实例当中: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createJobInstance</span><span class="params">(TriggerFiredBundle bundle)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	Object job = <span class="keyword">super</span>.createJobInstance(bundle);</span><br><span class="line">	BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(job);</span><br><span class="line">	<span class="keyword">if</span> (isEligibleForPropertyPopulation(bw.getWrappedInstance())) &#123;</span><br><span class="line">		MutablePropertyValues pvs = <span class="keyword">new</span> MutablePropertyValues();</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.schedulerContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">			pvs.addPropertyValues(<span class="keyword">this</span>.schedulerContext);</span><br><span class="line">		&#125;</span><br><span class="line">		pvs.addPropertyValues(getJobDetailDataMap(bundle));</span><br><span class="line">		pvs.addPropertyValues(getTriggerDataMap(bundle));</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.ignoredUnknownProperties != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (String propName : <span class="keyword">this</span>.ignoredUnknownProperties) &#123;</span><br><span class="line">				<span class="keyword">if</span> (pvs.contains(propName) &amp;&amp; !bw.isWritableProperty(propName)) &#123;</span><br><span class="line">					pvs.removePropertyValue(propName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			bw.setPropertyValues(pvs);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			bw.setPropertyValues(pvs, <span class="keyword">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> job;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>isEligibleForPropertyPopulation()</code>: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isEligibleForPropertyPopulation</span><span class="params">(Object jobObject)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (!(jobObject <span class="keyword">instanceof</span> QuartzJobBean));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以要获得注入<code>bean</code>的支持, 有两步, 第一继承<code>QuartzJobBean</code>, 在构建<code>JobDetail</code>时在<code>jobDataMap</code>中注入Spring Bean. </p>
<p>不过这种方法也有缺点, 理论上我们是不应该关注<code>Job</code>中依赖了哪些Spring Bean, 这样耦合度太大. 所以在Spring Boot中已经优化掉了这一点. </p>
<h2 id="Spring-Boot自动配置"><a href="#Spring-Boot自动配置" class="headerlink" title="Spring Boot自动配置"></a>Spring Boot自动配置</h2><p>在Spring Boot 中通过<code>QuartzAutoConfiguration</code>自动配置Quartz相关类并对<code>SpringBeanJobFactory</code>进行了扩展: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutowireCapableBeanJobFactory</span> <span class="keyword">extends</span> <span class="title">SpringBeanJobFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AutowireCapableBeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">	AutowireCapableBeanJobFactory(AutowireCapableBeanFactory beanFactory) &#123;</span><br><span class="line">		Assert.notNull(beanFactory, <span class="string">"Bean factory must not be null"</span>);</span><br><span class="line">		<span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">createJobInstance</span><span class="params">(TriggerFiredBundle bundle)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Object jobInstance = <span class="keyword">super</span>.createJobInstance(bundle);</span><br><span class="line">		<span class="keyword">this</span>.beanFactory.autowireBean(jobInstance);</span><br><span class="line">		<span class="keyword">this</span>.beanFactory.initializeBean(jobInstance, <span class="keyword">null</span>);</span><br><span class="line">		<span class="keyword">return</span> jobInstance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们只需要在<code>Job</code>实现类中用<code>@Autowired</code>或<code>@Resource</code>注解声明需要注入的Spring Bean即可. </p>
<p>Spring Boot提供<code>SchedulerFactoryBeanCustomizer</code>定制<code>SchedulerFactoryBean</code>, 比如换一个<code>JobFactory</code>（从Spring IoC容器中获取无状态<code>Job</code>）: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzScheduleFactoryBeanCustomizer</span> <span class="keyword">implements</span> <span class="title">SchedulerFactoryBeanCustomizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Resource</span></span><br><span class="line">	<span class="keyword">private</span> CustomizedActivitySchedulerFactory customizedSchedulerFactory;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(SchedulerFactoryBean schedulerFactoryBean)</span> </span>&#123;</span><br><span class="line">		schedulerFactoryBean.setJobFactory(customizedSchedulerFactory);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizedActivitySchedulerFactory</span> <span class="keyword">implements</span> <span class="title">JobFactory</span>, <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Job <span class="title">newJob</span><span class="params">(TriggerFiredBundle bundle, Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> applicationContext.getBean(bundle.getJobDetail().getJobClass());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Job的增删改"><a href="#Job的增删改" class="headerlink" title="Job的增删改"></a>Job的增删改</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ybd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 18-11-22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@contact</span> yangbingdong1994@gmail.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringQuartzJobTemplate</span> <span class="keyword">implements</span> <span class="title">ScheduleJobOperations</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(SpringQuartzJobTemplate<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"customizedSchedulerFactoryBean"</span>)</span><br><span class="line">	<span class="keyword">private</span> SchedulerFactoryBean schedulerFactoryBean;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Scheduler scheduler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOrUpdateScheduleJob</span><span class="params">(BaseJobDetail baseJobDetail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TriggerKey triggerKey = parseTriggerKey(baseJobDetail);</span><br><span class="line">            JobKey jobKey = parseJobKey(baseJobDetail);</span><br><span class="line">            <span class="keyword">boolean</span> jobExists = scheduler.checkExists(jobKey);</span><br><span class="line">            <span class="keyword">boolean</span> triggerExists = scheduler.checkExists(triggerKey);</span><br><span class="line">            CronScheduleBuilder cronScheduleBuilder = CronScheduleBuilder.cronSchedule(baseJobDetail.getCron());</span><br><span class="line">            CronTrigger cronTrigger = TriggerBuilder.newTrigger()</span><br><span class="line">                                                    .withIdentity(triggerKey)</span><br><span class="line">                                                    .withSchedule(cronScheduleBuilder)</span><br><span class="line">                                                    .build();</span><br><span class="line">            <span class="keyword">if</span> (!jobExists &amp;&amp; !triggerExists) &#123;</span><br><span class="line">                JobDetail jobDetail = buildJobDetail(baseJobDetail, jobKey);</span><br><span class="line">                scheduler.scheduleJob(jobDetail, cronTrigger);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (jobExists &amp;&amp; triggerExists) &#123;</span><br><span class="line">                <span class="keyword">if</span> (baseJobDetail.getJobDataMap() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    JobDetail jobDetail = buildJobDetail(baseJobDetail, jobKey);</span><br><span class="line">                    scheduler.addJob(jobDetail, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                scheduler.rescheduleJob(triggerKey, cronTrigger);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ScheduleJobException(<span class="string">"Illegal state -&gt; jobExists: "</span> + jobExists + <span class="string">", triggerExists: "</span> + triggerExists);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ScheduleJobException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> JobDetail <span class="title">buildJobDetail</span><span class="params">(BaseJobDetail baseJobDetail, JobKey jobKey)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Class&lt;? extends Job&gt; jobClass = Class.forName(baseJobDetail.getJobClass()).asSubclass(Job<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        JobDetail jobDetail = JobBuilder.newJob(jobClass)</span><br><span class="line">                                        .withIdentity(jobKey)</span><br><span class="line">                                        .build();</span><br><span class="line">        <span class="keyword">if</span> (baseJobDetail.getId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            jobDetail.getJobDataMap().put(JOB_DETAIL_ID_KEY, baseJobDetail.getId());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (baseJobDetail.getJobDataMap() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            jobDetail.getJobDataMap().putAll(baseJobDetail.getJobDataMap());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jobDetail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteScheduleJob</span><span class="params">(BaseJobDetail baseJobDetail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TriggerKey triggerKey = parseTriggerKey(baseJobDetail);</span><br><span class="line">            <span class="keyword">if</span> (scheduler.checkExists(triggerKey)) &#123;</span><br><span class="line">                scheduler.pauseTrigger(triggerKey);</span><br><span class="line">                scheduler.unscheduleJob(triggerKey);</span><br><span class="line">                JobKey jobKey = parseJobKey(baseJobDetail);</span><br><span class="line">                <span class="keyword">if</span> (scheduler.checkExists(jobKey)) &#123;</span><br><span class="line">                    scheduler.deleteJob(parseJobKey(baseJobDetail));</span><br><span class="line">                &#125;</span><br><span class="line">                log.info(<span class="string">"Success [CREATE] quartz job: "</span> + triggerKey.toString());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.info(<span class="string">"Fail to [DELETE] schedule job, job not exist: "</span> + triggerKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SchedulerException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ScheduleJobException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trigger</span><span class="params">(BaseJobDetail baseJobDetail)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">            JobKey jobKey = parseJobKey(baseJobDetail);</span><br><span class="line">            <span class="keyword">if</span> (scheduler.checkExists(jobKey)) &#123;</span><br><span class="line">                scheduler.triggerJob(jobKey);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                JobDetail jobDetail = buildJobDetail(baseJobDetail, jobKey);</span><br><span class="line">                scheduler.addJob(jobDetail, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">                scheduler.triggerJob(jobKey);</span><br><span class="line">            &#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ScheduleJobException(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.scheduler = schedulerFactoryBean.getScheduler();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> TriggerKey <span class="title">parseTriggerKey</span><span class="params">(BaseJobDetail baseJobDetail)</span> </span>&#123;</span><br><span class="line">        requireNameAndGroupNonNull(baseJobDetail);</span><br><span class="line">        <span class="keyword">return</span> TriggerKey.triggerKey(baseJobDetail.getJobName(), baseJobDetail.getJobGroup());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> JobKey <span class="title">parseJobKey</span><span class="params">(BaseJobDetail baseJobDetail)</span> </span>&#123;</span><br><span class="line">        requireNameAndGroupNonNull(baseJobDetail);</span><br><span class="line">        <span class="keyword">return</span> JobKey.jobKey(baseJobDetail.getJobName(), baseJobDetail.getJobGroup());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">requireNameAndGroupNonNull</span><span class="params">(BaseJobDetail baseJobDetail)</span> </span>&#123;</span><br><span class="line">        requireNonNull(baseJobDetail.getJobName());</span><br><span class="line">        requireNonNull(baseJobDetail.getJobGroup());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>信息类: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseJobDetail</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * field comment: 主键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * field comment: 任务组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String jobGroup;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * field comment: 任务名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String jobName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * field comment: 任务类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String jobClass;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * field comment: cron表达式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String cron;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * field comment: 冗余, cron表达式对应执行时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Date cronTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * field comment: 触发次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer fireTimes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * field comment: 最后一次触发时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Date lastFireTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * field comment: 最后一次触发的任务耗时, 单位: 毫秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long lastFireConsume;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * field comment: 状态, 0:待执行 1:已执行 2:已取消 3:执行异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Byte status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * field comment: 作业数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String jobData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * field comment: 创建时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * field comment: 更新时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Map&lt;String, ?&gt; jobDataMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseJobDetail <span class="title">incrFireTimes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        fireTimes++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseJobDetail <span class="title">withJobData</span><span class="params">(Object jobData)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> setJobData(BaseJobData.of(jobData).toJsonString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BaseJobDetail <span class="title">of</span><span class="params">(String jobGroup, String jobName, Class&lt;? extends Job&gt; jobClass, Date cronTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BaseJobDetail().setCron(DateUtil.parseToCron(cronTime))</span><br><span class="line">                                  .setCronTime(cronTime)</span><br><span class="line">                                  .setJobGroup(jobGroup)</span><br><span class="line">                                  .setJobName(jobName)</span><br><span class="line">                                  .setJobClass(jobClass.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseJobData</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Class dataClass;</span><br><span class="line">        <span class="keyword">private</span> JSON jsonData;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BaseJobData <span class="title">resolve</span><span class="params">(String jsonData)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> parseObject(jsonData, BaseJobData<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BaseJobData <span class="title">of</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BaseJobData().setDataClass(data.getClass())</span><br><span class="line">                                    .setJsonData((JSON) toJSON(data));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">parseData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (T) parseObject(<span class="keyword">this</span>.jsonData.toJSONString(), <span class="keyword">this</span>.dataClass);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toJsonString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> toJSONString(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="Durability"><a href="#Durability" class="headerlink" title="Durability"></a>Durability</h3><p>当设置了<code>JobDetail.setDurability(true)</code>, 当<code>job</code>不再有<code>trigger</code>引用它的时候, <code>Quartz</code>也不要删除<code>job</code>. </p>
<h3 id="Misfire"><a href="#Misfire" class="headerlink" title="Misfire"></a>Misfire</h3><p>由于某些原因（比如Worker线程池满了）导致任务没有及时执行, 此时扫描Misfire的线程就会把它们找出来并按照Misfire指令处理这个任务. 比如<code>CronTrigger</code>的默认策略是<code>CronTrigger.MISFIRE_INSTRUCTION_FIRE_ONCE_NOW</code>,也可以自己指定: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CronScheduleBuilder cronScheduleBuilder = CronScheduleBuilder.cronSchedule(scheduleJobInfo.getCron()).withMisfireHandlingInstructionDoNothing();</span><br><span class="line">TriggerKey oldTriggerKey = parseTriggerKey(scheduleJobInfo);</span><br><span class="line">CronTrigger newTrigger = TriggerBuilder.newTrigger()</span><br><span class="line">										.withIdentity(oldTriggerKey)</span><br><span class="line">										.withSchedule(cronScheduleBuilder)</span><br><span class="line">										.build();</span><br><span class="line">scheduler.rescheduleJob(oldTriggerKey, newTrigger);</span><br></pre></td></tr></table></figure>
<h3 id="maxBatchSize"><a href="#maxBatchSize" class="headerlink" title="maxBatchSize"></a>maxBatchSize</h3><p>一次拉取trigger的最大数量, 默认是1, 可通过<code>org.quartz.scheduler.batchTriggerAcquisitionMaxCount</code>改写. 但是在集群环境下, 不建议设置为很大值. 如果值 &gt; 1, 并且使用了 JDBC JobStore的话, <code>org.quartz.jobStore.acquireTriggersWithinLock</code>属性必须设置为<code>true</code>, 以避免”弄脏”数据. </p>
<blockquote>
<p>更多参数配置: <strong><em><a href="https://blog.csdn.net/zixiao217/article/details/53091812" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/zixiao217/article/details/53091812</a></em></strong></p>
</blockquote>
<h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>由于Quartz的集群是通过底层调度依赖数据库的悲观锁, 谁先抢到谁调度, 这样会导致节点负载不均衡, 并且影响性能. </p>
<h1 id="Spring-Scheduler"><a href="#Spring-Scheduler" class="headerlink" title="Spring Scheduler"></a>Spring Scheduler</h1><blockquote>
<p>Spring Scheduler相对Quartz来说比较轻量级, 通过简单的配置就可以使用了, 但灵活度不如Quartz</p>
</blockquote>
<h2 id="开启配置"><a href="#开启配置" class="headerlink" title="开启配置"></a>开启配置</h2><h3 id="Xml方式"><a href="#Xml方式" class="headerlink" title="Xml方式"></a>Xml方式</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">task:scheduler</span> <span class="attr">id</span>=<span class="string">"scheduler"</span> <span class="attr">pool-size</span>=<span class="string">"50"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果不设置<code>pool-size</code>, 默认是1, 会导致任务单线程执行. </li>
</ul>
<h3 id="Java配置方式"><a href="#Java配置方式" class="headerlink" title="Java配置方式"></a>Java配置方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringScheduleConfig</span> <span class="keyword">implements</span> <span class="title">SchedulingConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> </span>&#123;</span><br><span class="line">		taskRegistrar.setScheduler(taskExecutor());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Executor <span class="title">taskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">4</span>,</span><br><span class="line">				<span class="keyword">new</span> BasicThreadFactory</span><br><span class="line">						.Builder()</span><br><span class="line">						.namingPattern(<span class="string">"schedule-pool-thread-%d"</span>)</span><br><span class="line">						.build());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>@EnableScheduling</code>表示告诉Spring开启Scheduler</li>
<li>实现<code>SchedulingConfigurer</code>是为了配置线程池</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="Xml方式-1"><a href="#Xml方式-1" class="headerlink" title="Xml方式"></a>Xml方式</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">task:scheduled-tasks</span> <span class="attr">scheduler</span>=<span class="string">"myScheduler"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">task:scheduled</span> <span class="attr">ref</span>=<span class="string">"doSomethingTask"</span> <span class="attr">method</span>=<span class="string">"doSomething"</span> <span class="attr">cron</span>=<span class="string">"0 * * * * *"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">task:scheduled-tasks</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoSomethingTask</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Scheduled</span>(cron=<span class="string">"0 * * * * *"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do something"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注解声明方式"><a href="#注解声明方式" class="headerlink" title="注解声明方式"></a>注解声明方式</h3><p>使用<code>@Scheduled</code>可以非常简单地就声明一个任务: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoSomethingTask</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Scheduled</span>(cron=<span class="string">"0 * * * * *"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do something"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@Scheduled</code>有几个参数: </p>
<ul>
<li><p><code>cron</code>: cron表达式, 指定任务在特定时间执行；</p>
</li>
<li><p><code>fixedDelay</code>: 表示上一次任务执行完成后多久再次执行, 参数类型为long, 单位ms；</p>
</li>
<li><p><code>fixedDelayString</code>: 与<code>fixedDelay</code>含义一样, 只是参数类型变为String；</p>
</li>
<li><p><code>fixedRate</code>: 表示按一定的频率执行任务, 参数类型为long, 单位ms；</p>
</li>
<li><p><code>fixedRateString</code>: 与<code>fixedRate</code>的含义一样, 只是将参数类型变为String；</p>
</li>
<li><p><code>initialDelay</code>: 表示延迟多久再第一次执行任务, 参数类型为long, 单位ms；</p>
</li>
<li><p><code>initialDelayString</code>: 与<code>initialDelay</code>的含义一样, 只是将参数类型变为String；</p>
</li>
<li><p><code>zone</code>: 时区, 默认为当前时区, 一般没有用到. </p>
</li>
</ul>
<h1 id="Cron表达式"><a href="#Cron表达式" class="headerlink" title="Cron表达式"></a>Cron表达式</h1><p>想了解Cron最好的方法是看<strong><em><a href="http://www.quartz-scheduler.org/documentation/quartz-2.2.x/tutorials/crontrigger" rel="external nofollow noopener noreferrer" target="_blank">Quartz的官方文档</a></em></strong>. 本节也会大致介绍一下. </p>
<p>Cron表达式由6~7项组成, 中间用空格分开. 从左到右依次是: 秒、分、时、日、月、周几、年（可省略）. 值可以是数字, 也可以是以下符号:<br><code>*</code>: 所有值都匹配<br><code>?</code>: 无所谓, 不关心, 通常放在“周几”里<br><code>,</code>: 或者<br><code>/</code>: 增量值<br><code>-</code>: 区间</p>
<p>下面举几个例子, 看了就知道了:<br><code>0 * * * * *</code>: 每分钟（当秒为0的时候）<br><code>0 0 * * * *</code>: 每小时（当秒和分都为0的时候）<br><code>*/10 * * * * *</code>: 每10秒<br><code>0 5/15 * * * *</code>: 每小时的5分、20分、35分、50分<br><code>0 0 9,13 * * *</code>: 每天的9点和13点<br><code>0 0 8-10 * * *</code>: 每天的8点、9点、10点<br><code>0 0/30 8-10 * * *</code>: 每天的8点、8点半、9点、9点半、10点<br><code>0 0 9-17 * * MON-FRI</code>: 每周一到周五的9点、10点…直到17点（含）<br><code>0 0 0 25 12 ?</code>: 每年12约25日圣诞节的0点0分0秒（午夜）<br><code>0 30 10 * * ? 2016</code>: 2016年每天的10点半</p>
<p>其中的<code>?</code>在用法上其实和<code>*</code>是相同的. 但是<code>*</code>语义上表示全匹配, 而<code>?</code>并不代表全匹配, 而是不关心. 比如对于<code>0 0 0 5 8 ? 2016</code>来说, 2016年8月5日是周五, <code>?</code>表示我不关心它是周几. 而<code>0 0 0 5 8 * 2016</code>中的<code>*</code>表示周一也行, 周二也行……语义上和2016年8月5日冲突了, 你说谁优先生效呢. </p>
<p>不记得也没关系, 记住<strong><em><a href="http://www.cronmaker.com/" rel="external nofollow noopener noreferrer" target="_blank">Cron Maker</a></em></strong>也可以, 它可以在线生成cron表达式. </p>
<h1 id="时间轮"><a href="#时间轮" class="headerlink" title="时间轮"></a>时间轮</h1><blockquote>
<p><strong><em><a href="https://github.com/ifesdjeen/hashed-wheel-timer" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/ifesdjeen/hashed-wheel-timer</a></em></strong></p>
</blockquote>
<p><img src="https://cdn.yangbingdong.com/img/scheduler/o_timewheel.png" alt></p>
<blockquote>
<p>时间轮算法可以类比于时钟，如上图箭头（指针）按某一个方向按固定频率轮动，每一次跳动称为一个 tick。这样可以看出定时轮由个3个重要的属性参数，ticksPerWheel（一轮的tick数），tickDuration（一个tick的持续时间）以及 timeUnit（时间单位），例如当ticksPerWheel=60，tickDuration=1，timeUnit=秒，这就和现实中的始终的秒针走动完全类似了。</p>
</blockquote>
<p>例子, 使用Netty中的时间轮实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.util.HashedWheelTimer;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.Timeout;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.Timer;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashedWheelTimerTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTimerTask</span> <span class="keyword">implements</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">		<span class="keyword">boolean</span> flag;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">MyTimerTask</span><span class="params">(<span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.flag = flag;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"执行延迟任务..."</span>);</span><br><span class="line">			<span class="keyword">this</span>.flag = <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		MyTimerTask timerTask = <span class="keyword">new</span> MyTimerTask(<span class="keyword">true</span>);</span><br><span class="line">		Timer timer = <span class="keyword">new</span> HashedWheelTimer();</span><br><span class="line">		timer.newTimeout(timerTask, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (timerTask.flag) &#123;</span><br><span class="line">			Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			System.out.println(i + <span class="string">"秒过去了"</span>);</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Elastic-Job"><a href="#Elastic-Job" class="headerlink" title="Elastic Job"></a>Elastic Job</h1><blockquote>
<p>官网: <strong><em><a href="http://elasticjob.io/" rel="external nofollow noopener noreferrer" target="_blank">Elastic Job</a></em></strong></p>
</blockquote>
<h2 id="Elastic-Job-与-Sping-Cloud-集成解决依赖冲突问题"><a href="#Elastic-Job-与-Sping-Cloud-集成解决依赖冲突问题" class="headerlink" title="Elastic Job 与 Sping Cloud 集成解决依赖冲突问题"></a>Elastic Job 与 Sping Cloud 集成解决依赖冲突问题</h2><p>由于Elastic Job自身的 <code>curator-client</code>,<code>curator-framework</code>,<code>curator-recipes</code>与Spring Cloud组件中的<code>curator-client</code>,<code>curator-framework</code>,<code>curator-recipes</code>有版本冲突，在启动过程会报如下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-07-06 18:19:34.403 | epms |  WARN | IP: |            main | AnnotationConfigServletWebServerApplicationContext |   558 | refresh | Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;reqAspect&apos; defined in file [/home/ybd/data/git-repo/bitbucket/epms/epms-core/target/classes/com/yanglaoban/epms/core/aop/ReqAspect.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;disruptorConfig&apos;: Injection of resource dependencies failed; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;delayHandler&apos; defined in file [/home/ybd/data/git-repo/bitbucket/epms/epms-core/target/classes/com/yanglaoban/epms/core/pubsub/disruptor/handler/DelayHandler.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;delayService&apos; defined in file [/home/ybd/data/git-repo/bitbucket/epms/epms-core/target/classes/com/yanglaoban/epms/core/domain/service/DelayService.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;elasticJobService&apos; defined in file [/home/ybd/data/git-repo/bitbucket/epms/epms-core/target/classes/com/yanglaoban/epms/core/elasticjob/ElasticJobService.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;regCenter&apos; defined in class path resource [com/yanglaoban/epms/core/elasticjob/config/ElasticJobConfig.class]: Invocation of init method failed; nested exception is java.lang.NoClassDefFoundError: org/apache/curator/connection/StandardConnectionHandlingPolicy</span><br></pre></td></tr></table></figure>
<p>解决方式是排除Elastic Job中<code>curator</code>相关依赖，重新导入：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">elastic-job.version</span>&gt;</span>2.1.5<span class="tag">&lt;/<span class="name">elastic-job.version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">curator.version</span>&gt;</span>2.10.0<span class="tag">&lt;/<span class="name">curator.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.dangdang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elastic-job-lite-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;elastic-job.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;curator.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;curator.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;curator.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Spting-Boot-集成"><a href="#Spting-Boot-集成" class="headerlink" title="Spting Boot 集成"></a>Spting Boot 集成</h2><blockquote>
<p>Github: <strong><em><a href="https://github.com/yinjihuan/elastic-job-spring-boot-starter" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/yinjihuan/elastic-job-spring-boot-starter</a></em></strong></p>
</blockquote>
<p>pom.xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.yinjihuan<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elastic-job-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;curator.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;curator.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;curator.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>还需要加上repository配置:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>jitpack.io<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://jitpack.io<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>yml配置:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">elastic:</span></span><br><span class="line">  <span class="attr">job:</span></span><br><span class="line">    <span class="attr">zk:</span></span><br><span class="line">      <span class="attr">serverLists:</span> <span class="number">192.168</span><span class="number">.6</span><span class="number">.113</span><span class="string">:2181</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">test</span></span><br></pre></td></tr></table></figure>
<p>只需一个注解即可开启任务:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ElasticJobConf</span>(name = JobName, cron = <span class="string">"0 0 0 * * ?"</span>, failover = <span class="keyword">true</span>, misfire = <span class="keyword">true</span>, overwrite = <span class="keyword">true</span>,</span><br><span class="line">		eventTraceRdbDataSource = <span class="string">"dataSource"</span>)</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySimpleJob</span> <span class="keyword">implements</span> <span class="title">SimpleJob</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> String JobName = <span class="string">"MySimpleJob"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ShardingContext shardingContext)</span> </span>&#123;</span><br><span class="line">		log.info(<span class="string">"执行定时任务: "</span> + shardingContext);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>eventTraceRdbDataSource = &quot;dataSource&quot;</code> 是启用事件追踪, 但在最新版的Spring Boot 中并不会创建 <code>JOB_EXECUTION_LOG</code> 与 <code>JOB_STATUS_TRACE_LOG</code> 这两个记录表, 最好是手动创建, 下面是建表语句:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`JOB_EXECUTION_LOG`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">varchar</span>(<span class="number">40</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`job_name`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`task_id`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`hostname`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`ip`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`sharding_item`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`execution_source`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`failure_cause`</span> <span class="built_in">varchar</span>(<span class="number">4000</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`is_success`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`start_time`</span> <span class="built_in">timestamp</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`complete_time`</span> <span class="built_in">timestamp</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 ROW_FORMAT=DYNAMIC;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`JOB_STATUS_TRACE_LOG`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">varchar</span>(<span class="number">40</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`job_name`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`original_task_id`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`task_id`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`slave_id`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`source`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`execution_type`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`sharding_item`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`state`</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`message`</span> <span class="built_in">varchar</span>(<span class="number">4000</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`creation_time`</span> <span class="built_in">timestamp</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`TASK_ID_STATE_INDEX`</span> (<span class="string">`task_id`</span>,<span class="string">`state`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 ROW_FORMAT=DYNAMIC;</span><br></pre></td></tr></table></figure>
<h2 id="运维平台"><a href="#运维平台" class="headerlink" title="运维平台"></a>运维平台</h2><p>ElasticJob提供了一个运维平台拱查看任务执行详情.</p>
<p>需要clone ElasticJob源码并install, 会生成运维平台的压缩包, 解压后通过脚本可一键启动运维平台.</p>
<p>根据启动脚本的内容, 可做成Docker镜像, 只需将lib包中的jar包copy进去再按照脚本的启动方式配置entrypoint即可.</p>
<p>Dockerfile:</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> frolvlad/alpine-oraclejre8:slim</span><br><span class="line"><span class="keyword">MAINTAINER</span> ybd &lt;yangbingdong1994@gmail.com&gt;</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> elastic-job-lite-console.tar.gz /</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> elastic-job-lite-console</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> <span class="built_in">exec</span> java -classpath ./lib/*:. io.elasticjob.lite.console.ConsoleBootstrap 8080</span></span><br></pre></td></tr></table></figure>
<p>docker-compose.yml:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &apos;3.7&apos;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  job-console:</span><br><span class="line">    image: yangbingdong/elastic-job-console:latest</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8090:8080&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - backend</span><br><span class="line">    volumes:</span><br><span class="line">      - ./auth.properties:/elastic-job-lite-console/conf/auth.propertise</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  backend:</span><br><span class="line">    external: true</span><br></pre></td></tr></table></figure>
<p>auth.properties:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root.username=admin</span><br><span class="line">root.password=admin</span><br><span class="line">guest.username=guest</span><br><span class="line">guest.password=guest</span><br></pre></td></tr></table></figure>
<h1 id="Redis-Keyspace-Notifications"><a href="#Redis-Keyspace-Notifications" class="headerlink" title="Redis Keyspace Notifications"></a>Redis Keyspace Notifications</h1><p>通过设置一个过期键, 并在过期的时候回调监听者实现延迟任务.</p>
<p>可参考:  <strong><em><a href="/2018/spring-boot-learning-redis/#Spring%E7%9B%91%E5%90%ACRedis-Keyspace-Event">Spring监听Redis Keyspace Event</a></em></strong></p>
<blockquote>
<p>Redis的<strong>pub/sub</strong>机制存在一个硬伤，官网内容如下<br><strong>原</strong>:Because Redis Pub/Sub is fire and forget currently there is no way to use this feature if your application demands reliable notification of events, that is, if your Pub/Sub client disconnects, and reconnects later, all the events delivered during the time the client was disconnected are lost.</p>
<p>就是说Redis的发布/订阅目前是即发即弃(fire and forget)模式的，因此无法实现事件的可靠通知。也就是说，如果发布/订阅的客户端断链之后又重连，则在客户端断链期间的所有事件都丢失了。</p>
</blockquote>
<h1 id="RabbitMQ-延迟队列"><a href="#RabbitMQ-延迟队列" class="headerlink" title="RabbitMQ 延迟队列"></a>RabbitMQ 延迟队列</h1><p>这是一个不错的方案, 结合 <code>rabbitmq_delayed_message_exchange</code> 插件可以很优雅地做到延迟任务.</p>
<p>可参考: <strong><em><a href="/2019/rabbitmq-and-spring-amqp-learning/#%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97">延迟队列</a></em></strong></p>
<h1 id="基于-Redis-Sorted-Set-轮训的延迟任务"><a href="#基于-Redis-Sorted-Set-轮训的延迟任务" class="headerlink" title="基于 Redis Sorted Set 轮训的延迟任务"></a>基于 Redis Sorted Set 轮训的延迟任务</h1><ol>
<li>将关键数据以及<strong>执行时间戳</strong>分别作为 <code>Sorted Set</code> 的 <code>member</code> 和 <code>score</code> 添加到 <code>Sorted Set</code> 中.</li>
<li>通过周期任务使用 <code>ZRANGEBYSCORE</code> 命令读取指定数量的数据并删除 <code>Sorted Set</code> 中对应的数据.</li>
</ol>
<p>对于第二部需要使用 lua 保证原子性:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> zset_key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> min_score = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> max_score = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">local</span> offset = ARGV[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">local</span> limit = ARGV[<span class="number">4</span>]</span><br><span class="line"><span class="comment">-- TYPE命令的返回结果是&#123;'ok':'zset'&#125;这样子,这里利用next做一轮迭代</span></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">status</span>, <span class="built_in">type</span> = <span class="built_in">next</span>(redis.call(<span class="string">'TYPE'</span>, zset_key))</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">status</span> ~= <span class="literal">nil</span> <span class="keyword">and</span> <span class="built_in">status</span> == <span class="string">'ok'</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span> == <span class="string">'zset'</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> list = redis.call(<span class="string">'ZRANGEBYSCORE'</span>, zset_key, max_score, min_score, <span class="string">'LIMIT'</span>, offset, limit)</span><br><span class="line">        <span class="keyword">if</span> list ~= <span class="literal">nil</span> <span class="keyword">and</span> #list &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">            <span class="comment">-- unpack函数能把table转化为可变参数</span></span><br><span class="line">            redis.call(<span class="string">'ZREM'</span>, zset_key, <span class="built_in">unpack</span>(list))</span><br><span class="line">            <span class="keyword">return</span> list</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p><code>ZRANGEBYSCORE</code> 的时间复杂度为 <code>O(log(N)+M)</code>, 为了避免带来性能问题, 我们可以对key取模进行哈希处理.</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="XXL-Job"><a href="#XXL-Job" class="headerlink" title="XXL Job"></a>XXL Job</h2><p>由个人开源的中心化分布式调度平台:</p>
<p><strong><em><a href="http://www.xuxueli.com/xxl-job/#/" rel="external nofollow noopener noreferrer" target="_blank">http://www.xuxueli.com/xxl-job/#/</a></em></strong></p>
<h2 id="Saturn"><a href="#Saturn" class="headerlink" title="Saturn"></a>Saturn</h2><p>唯品会基于 Elastic Job 开发的分布式任务调度平台:</p>
<p><strong><em><a href="https://vipshop.github.io/Saturn/#" rel="external nofollow noopener noreferrer" target="_blank">https://vipshop.github.io/Saturn/#</a></em></strong></p>
]]></content><categories><category>Programming</category><category>Java</category><category>Spring Boot</category></categories><tags><tag>Java</tag><tag>Spring Boot</tag><tag>Scheduler</tag></tags></entry><entry><title>微信公众号开发</title><url>/2020/weixin-mp-dev/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/weixin-dev/weixin-mp-dev-banner.png" alt></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><blockquote>
<p>使用微信提供的微信平台体系(微信开放平台/微信公众号平台/微信小程序/微信支付等)可以使我们的业务接入庞大的微信体系, 定义自己的个性化业务.</p>
<p>这里主要记录一下微信公众号开发相关的要点…</p>
</blockquote>
<a id="more"></a>
<h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><ul>
<li>是已认证的服务号</li>
<li>后端采用 Java 开发</li>
</ul>
<p>后端微信开发工具包采用官方推荐的 Java 工具包: <strong><em><a href="https://github.com/Wechat-Group/WxJava" rel="external nofollow noopener noreferrer" target="_blank">WxJava</a></em></strong>, 假定你已经阅读过<strong><em><a href="https://github.com/Wechat-Group/WxJava/wiki" rel="external nofollow noopener noreferrer" target="_blank">官方 Wiki</a></em></strong></p>
<p>下面集成用例均在本地完成, 微信对于<strong>开发者服务器只能是80端口或者443</strong>, 因此本地开发调试时, 需要借助<strong>内网穿透</strong>工具, 该类工具有很多, 比如 Ngrok, 如何使用请自行搜索.</p>
<h2 id="Maven-引用开发包"><a href="#Maven-引用开发包" class="headerlink" title="Maven 引用开发包"></a>Maven 引用开发包</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.binarywang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>（不同模块参考下文）<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>(参考 Github 最新版本)<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>微信小程序：<code>weixin-java-miniapp</code></li>
<li>微信支付：<code>weixin-java-pay</code></li>
<li>微信开放平台：<code>weixin-java-open</code></li>
<li>公众号（包括订阅号和服务号）：<code>weixin-java-mp</code></li>
<li>企业号/企业微信：<code>weixin-java-cp</code></li>
</ul>
<h1 id="开发者服务器配置"><a href="#开发者服务器配置" class="headerlink" title="开发者服务器配置"></a>开发者服务器配置</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul>
<li>接收微信各种事件推送(eg: 关注公众号事件/关键字回复/公众号菜单点击事件/扫码事件等)</li>
<li>扩展微信公众号功能(eg: 自动回复/自定义菜单等)</li>
</ul>
<h2 id="流程说明"><a href="#流程说明" class="headerlink" title="流程说明"></a>流程说明</h2><p>服务器地址<strong>只能配置一个 URL</strong>, 此后所有检测(微信会定时发送 GET 请求到此 URL 确认服务器还正常运行)以及所有的事件回调(关注事件/文本接收等)都会发送到此 URL:</p>
<ul>
<li>对于服务器检测, 发送的是 <strong>GET</strong> 请求</li>
<li>其他事件推送, 发送的是 <strong>POST</strong> 请求</li>
</ul>
<h2 id="服务器开发"><a href="#服务器开发" class="headerlink" title="服务器开发"></a>服务器开发</h2><p>在配置服务器前, 需要实现开发(只需要能够收到并处理检测的 GET 请求即可)并启动服务器</p>
<p>因为在提交配置的时候微信会检测服务器可用情况.</p>
<p>核心代码示例(WxJava配置请查看官网):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/wx/portal"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WxController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> WxMpService wxService;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@GetMapping</span>(produces = <span class="string">"text/plain;charset=utf-8"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">authGet</span><span class="params">(@RequestParam(name = <span class="string">"signature"</span>, required = <span class="keyword">false</span>)</span> String signature,</span></span><br><span class="line"><span class="function">						  @<span class="title">RequestParam</span><span class="params">(name = <span class="string">"timestamp"</span>, required = <span class="keyword">false</span>)</span> String timestamp,</span></span><br><span class="line"><span class="function">						  @<span class="title">RequestParam</span><span class="params">(name = <span class="string">"nonce"</span>, required = <span class="keyword">false</span>)</span> String nonce,</span></span><br><span class="line"><span class="function">						  @<span class="title">RequestParam</span><span class="params">(name = <span class="string">"echostr"</span>, required = <span class="keyword">false</span>)</span> String echostr) </span>&#123;</span><br><span class="line">		log.info(<span class="string">"\n接收到来自微信服务器的认证消息：[&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;]"</span>, signature, timestamp, nonce, echostr);</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.isAnyBlank(signature, timestamp, nonce, echostr)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"请求参数非法，请核实!"</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> wxService.checkSignature(timestamp, nonce, signature) ? echostr : <span class="string">"非法请求"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时我们处理微信请求的路径为 <code>/wx/portal</code>, 假定:</p>
<ul>
<li><code>serverContextPath</code> 为 <code>portal-user</code></li>
<li>内网穿透地址为 <code>http://wx.ngrok.yangbingdong.com</code></li>
</ul>
<p>那么我们最终的服务器 URL 为 <code>http://wx.ngrok.yangbingdong.com/portal-user/wx/portal</code>.</p>
<h2 id="配置服务器"><a href="#配置服务器" class="headerlink" title="配置服务器"></a>配置服务器</h2><p>进入微信公众号平台, 在左边最下面找到<strong>开发</strong> -&gt; <strong>基本配置</strong>:</p>
<p><img src="https://cdn.yangbingdong.com/img/weixin-dev/weixin-mp-dev-setting-bar.png" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/weixin-dev/weixin-mp-dev-setting.png" alt></p>
<p>点击修改配置, 并填入 URL:</p>
<p><img src="https://cdn.yangbingdong.com/img/weixin-dev/weixin-mp-dev-setting-server.png" alt></p>
<p>点击提交, 此时微信会发送 GET 请求到服务器:</p>
<p><img src="https://cdn.yangbingdong.com/img/weixin-dev/weixin-mp-server-verify.png" alt></p>
<p>至此, 自己的服务器已接入微信公众号平台.</p>
<h2 id="启用服务器"><a href="#启用服务器" class="headerlink" title="启用服务器"></a>启用服务器</h2><p>接收微信的推送事件需要将服务器配置<strong>启用</strong>, 否则会无法收到事件推送.</p>
<p><img src="https://cdn.yangbingdong.com/img/weixin-dev/weixin-mp-dev-enable-server.png" alt></p>
<h2 id="配置白名单"><a href="#配置白名单" class="headerlink" title="配置白名单"></a>配置白名单</h2><p>获取微信公众号 access_token 前, 还需要配置 <strong>IP 白名单</strong>, 否则会报 <strong>40164</strong> 错误(<code>invalid ip x.x.x.x, not in whitelist hint...</code>)</p>
<h1 id="接收并处理微信推送的消息"><a href="#接收并处理微信推送的消息" class="headerlink" title="接收并处理微信推送的消息"></a>接收并处理微信推送的消息</h1><blockquote>
<p>微信推送都是以 POST 请求发送的.</p>
<p><strong>注意</strong>: <strong>公众号调用各接口时都需使用access_token</strong>, 文档请看<strong><em><a href="https://developers.weixin.qq.com/doc/offiaccount/Basic_Information/Get_access_token.html" rel="external nofollow noopener noreferrer" target="_blank">这里</a></em></strong>, 在 WxJava 中通过 <code>WxMpConfigStorage</code> 管理 access_token, 我们只需要 Redis版 的 <code>WxMpConfigStorage</code>  即可(请看 WxJava 官方 Demo).</p>
</blockquote>
<p>先看两段段明文的消息报文示例:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ToUserName</span>&gt;</span>&lt;![CDATA[gh_0544c55c0947]]&gt;<span class="tag">&lt;/<span class="name">ToUserName</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">FromUserName</span>&gt;</span>&lt;![CDATA[ouaAwuL0sOndEGFIvXULJlwj0jrk]]&gt;<span class="tag">&lt;/<span class="name">FromUserName</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">CreateTime</span>&gt;</span>1596276376<span class="tag">&lt;/<span class="name">CreateTime</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">MsgType</span>&gt;</span>&lt;![CDATA[text]]&gt;<span class="tag">&lt;/<span class="name">MsgType</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">Content</span>&gt;</span>&lt;![CDATA[你好]]&gt;<span class="tag">&lt;/<span class="name">Content</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">MsgId</span>&gt;</span>22853185785369939<span class="tag">&lt;/<span class="name">MsgId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xml</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ToUserName</span>&gt;</span>&lt;![CDATA[gh_0544c55c0947]]&gt;<span class="tag">&lt;/<span class="name">ToUserName</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">FromUserName</span>&gt;</span>&lt;![CDATA[ouaAwuL0sOndEGFIvXULJlwj0jrk]]&gt;<span class="tag">&lt;/<span class="name">FromUserName</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">CreateTime</span>&gt;</span>1596276457<span class="tag">&lt;/<span class="name">CreateTime</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">MsgType</span>&gt;</span>&lt;![CDATA[event]]&gt;<span class="tag">&lt;/<span class="name">MsgType</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">Event</span>&gt;</span>&lt;![CDATA[VIEW]]&gt;<span class="tag">&lt;/<span class="name">Event</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">EventKey</span>&gt;</span>&lt;![CDATA[https://open.weixin.qq.com/connect/oauth2/authorize?appid=wx123123123123&amp;redirect_uri=http%3A%2F%2Fwx.ngrok.yangbingdong.com%2Fportal-user%2Fwx%2Fredirect%2Fgreet&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=&amp;connect_redirect=1#wechat_redirect]]&gt;<span class="tag">&lt;/<span class="name">EventKey</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">MenuId</span>&gt;</span>426548808<span class="tag">&lt;/<span class="name">MenuId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">xml</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>微信推送的消息基本都会带有 <code>MsgType</code> 字段, 比较常用的就是:</p>
<ul>
<li><code>text</code>: 普通文本消息</li>
<li><code>event</code>: 事件, 如果 MsgType 为 <code>event</code>, 那么还会附带 <code>Event</code> 字段, 代表事件类型:<ul>
<li><code>subscribe</code>: 关注事件</li>
<li><code>CLICK</code>: 菜单点击事件</li>
<li><code>VIEW</code>: 菜单连接查看事件</li>
</ul>
</li>
</ul>
<p>更多的消息类型以及事件类型查看 <code>me.chanjar.weixin.common.api.WxConsts.XmlMsgType</code> 与 <code>me.chanjar.weixin.common.api.WxConsts.EventType</code>.</p>
<p>处理这类消息也很简单, 只需要配置 <code>WxMpMessageRouter</code> 即可:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WxMpMessageRouter <span class="title">messageRouter</span><span class="params">(WxMpService wxMpService,</span></span></span><br><span class="line"><span class="function"><span class="params">									   ObjectProvider&lt;RedisUtils&gt; redisUtilsObjectProvider)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> WxMpMessageRouter newRouter = <span class="keyword">new</span> WxMpMessageRouter(wxMpService);</span><br><span class="line">	newRouter.setMessageDuplicateChecker(<span class="keyword">new</span> WxRedisMessageDuplicateChecker(redisUtilsObjectProvider.getIfAvailable()));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 记录所有事件的日志 （异步执行）</span></span><br><span class="line">	newRouter.rule().handler(wxEventLogHandler).next();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自定义菜单事件</span></span><br><span class="line">	newRouter.rule().async(<span class="keyword">false</span>).msgType(EVENT).event(WxConsts.EventType.CLICK).handler(menuHandler).end();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 点击菜单连接事件</span></span><br><span class="line">	newRouter.rule().async(<span class="keyword">false</span>).msgType(EVENT).event(WxConsts.EventType.VIEW).handler(nullHandler).end();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关注事件</span></span><br><span class="line">	newRouter.rule().async(<span class="keyword">false</span>).msgType(EVENT).event(SUBSCRIBE).handler(subscribeHandler).end();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 取消关注事件</span></span><br><span class="line">	newRouter.rule().msgType(EVENT).event(UNSUBSCRIBE).handler(unsubscribeHandler).end();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 扫码事件</span></span><br><span class="line">	newRouter.rule().async(<span class="keyword">false</span>).msgType(EVENT).event(WxConsts.EventType.SCAN).handler(scanHandler).end();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 文本输入</span></span><br><span class="line">	newRouter.rule().async(<span class="keyword">false</span>).msgType(TEXT).handler(msgHandler).end();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 默认</span></span><br><span class="line">	newRouter.rule().async(<span class="keyword">false</span>).handler(nullHandler).end();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> newRouter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在 POST 请求中处理:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(produces = <span class="string">"application/xml; charset=UTF-8"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">post</span><span class="params">(@RequestBody String requestBody,</span></span></span><br><span class="line"><span class="function"><span class="params">				   @RequestParam(<span class="string">"signature"</span>)</span> String signature,</span></span><br><span class="line"><span class="function">				   @<span class="title">RequestParam</span><span class="params">(<span class="string">"timestamp"</span>)</span> String timestamp,</span></span><br><span class="line"><span class="function">				   @<span class="title">RequestParam</span><span class="params">(<span class="string">"nonce"</span>)</span> String nonce,</span></span><br><span class="line"><span class="function">				   @<span class="title">RequestParam</span><span class="params">(<span class="string">"openid"</span>)</span> String openid,</span></span><br><span class="line"><span class="function">				   @<span class="title">RequestParam</span><span class="params">(name = <span class="string">"encrypt_type"</span>, required = <span class="keyword">false</span>)</span> String encType,</span></span><br><span class="line"><span class="function">				   @<span class="title">RequestParam</span><span class="params">(name = <span class="string">"msg_signature"</span>, required = <span class="keyword">false</span>)</span> String msgSignature) </span>&#123;</span><br><span class="line">	log.info(<span class="string">"接收微信请求：[openid=[&#123;&#125;], [signature=[&#123;&#125;], encType=[&#123;&#125;], msgSignature=[&#123;&#125;], timestamp=[&#123;&#125;], nonce=[&#123;&#125;], requestBody=[\n&#123;&#125;\n] "</span>,</span><br><span class="line">		openid, signature, encType, msgSignature, timestamp, nonce, requestBody);</span><br><span class="line">	<span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">		log.debug(<span class="string">"接收微信请求：[openid=[&#123;&#125;], [signature=[&#123;&#125;], encType=[&#123;&#125;], msgSignature=[&#123;&#125;], timestamp=[&#123;&#125;], nonce=[&#123;&#125;], requestBody=[\n&#123;&#125;\n] "</span>,</span><br><span class="line">			openid, signature, encType, msgSignature, timestamp, nonce, requestBody);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!wxService.checkSignature(timestamp, nonce, signature)) &#123;</span><br><span class="line">		log.warn(<span class="string">"非法请求，可能属于伪造的请求！[openid=[&#123;&#125;], [signature=[&#123;&#125;], encType=[&#123;&#125;], msgSignature=[&#123;&#125;], timestamp=[&#123;&#125;], nonce=[&#123;&#125;], requestBody=[\n&#123;&#125;\n] "</span>,</span><br><span class="line">			openid, signature, encType, msgSignature, timestamp, nonce, requestBody);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	String out = encrypt(encType) ?</span><br><span class="line">		handlerEncryptedMessage(requestBody, timestamp, nonce, msgSignature) :</span><br><span class="line">		handlerPlainTextMessage(requestBody);</span><br><span class="line">	<span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">		log.debug(<span class="string">"组装回复信息：&#123;&#125;"</span>, out);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">encrypt</span><span class="params">(String encType)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"aes"</span>.equalsIgnoreCase(encType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理明文</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">handlerPlainTextMessage</span><span class="params">(String requestBody)</span> </span>&#123;</span><br><span class="line">	WxMpXmlMessage inMessage = WxMpXmlMessage.fromXml(requestBody);</span><br><span class="line">	<span class="keyword">return</span> Optional.ofNullable(route(inMessage))</span><br><span class="line">				   .map(WxMpXmlOutMessage::toXml)</span><br><span class="line">				   .orElse(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理密文</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">handlerEncryptedMessage</span><span class="params">(String requestBody, String timestamp, String nonce, String msgSignature)</span> </span>&#123;</span><br><span class="line">	WxMpXmlMessage inMessage = WxMpXmlMessage.fromEncryptedXml(requestBody, wxService.getWxMpConfigStorage(), timestamp, nonce, msgSignature);</span><br><span class="line">	<span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">		log.debug(<span class="string">"消息解密后内容为：\n&#123;&#125; "</span>, inMessage.toString());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Optional.ofNullable(<span class="keyword">this</span>.route(inMessage))</span><br><span class="line">				   .map(m -&gt; m.toEncryptedXml(wxService.getWxMpConfigStorage()))</span><br><span class="line">				   .orElse(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> WxMpXmlOutMessage <span class="title">route</span><span class="params">(WxMpXmlMessage message)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.messageRouter.route(message);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		log.error(<span class="string">"路由微信消息时出现异常！"</span>, e);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="授权获取用户信息"><a href="#授权获取用户信息" class="headerlink" title="授权获取用户信息"></a>授权获取用户信息</h1><blockquote>
<p><strong><em><a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html" rel="external nofollow noopener noreferrer" target="_blank">微信网页授权文档</a></em></strong></p>
</blockquote>
<p>在调用授权接口之前, 需要配置网页授权域名, 在 <strong>公众号设置</strong> -&gt; <strong>功能设置</strong> -&gt; <strong>网页授权域名</strong></p>
<p><strong>切记</strong>, <strong>只需要配置域名</strong>, <strong>不要加协议</strong>, <strong>也不要加路径</strong>, 否则 <strong>10003</strong> 错误, 也就是 <strong><code>redirect_uri</code>域名与后台配置不一致错误</strong>. <code>redirect_uri</code> 上面配置的网页授权域名, <code>redirect_uri</code> 可以添加参数, 比如标记落地页等. 用户同意授权后微信会在 <code>redirect_uri</code> 后面加上 <code>code</code> 参数, 并重定向到该 URL.</p>
<p>流程走的是标准的 OAUTH2, 什么是 OAUTH2 自行搜索…</p>
<p>主要流程就是:</p>
<ul>
<li><p>构建授权 URL(微信跳转到该 <code>redirectUri</code> 时会在参数后面拼接上 <code>code</code>):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String url = <span class="keyword">this</span>.wxService.oauth2buildAuthorizationUrl(redirectUri, WxConsts.OAuth2Scope.SNSAPI_USERINFO, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>用户点击 URL, 微信重定向到 <code>redirectUri</code>, 并附带上 <code>code</code> 参数</p>
</li>
<li><p>利用 <code>code</code> 获取 <code>access_token</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WxMpOAuth2AccessToken accessToken = wxService.oauth2getAccessToken(code);</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用 <code>access_token</code> 获取用户信息:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WxMpUser user = wxService.oauth2getUserInfo(accessToken, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="获取-JS-SDK-加密信息"><a href="#获取-JS-SDK-加密信息" class="headerlink" title="获取 JS-SDK 加密信息"></a>获取 JS-SDK 加密信息</h1><blockquote>
<p> <strong><em><a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html" rel="external nofollow noopener noreferrer" target="_blank">JS-SDK 说明文档</a></em></strong></p>
<p> <strong><em><a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html#62" rel="external nofollow noopener noreferrer" target="_blank">JS-SDK 使用权限签名算法</a></em></strong></p>
</blockquote>
<p><strong>需要提前配置JS接口安全域名</strong>, <strong>公众号设置</strong> -&gt; <strong>功能设置</strong> -&gt; <strong>JS接口安全域名</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WxJsapiSignature jsapiSignature = wxService.createJsapiSignature(<span class="string">"当前页面 URL"</span>);</span><br></pre></td></tr></table></figure>
<h1 id="创建自定义公众号菜单"><a href="#创建自定义公众号菜单" class="headerlink" title="创建自定义公众号菜单"></a>创建自定义公众号菜单</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/create"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">menuCreateSample</span><span class="params">(@PathVariable String appid)</span> <span class="keyword">throws</span> WxErrorException, MalformedURLException </span>&#123;</span><br><span class="line">    WxMenu menu = <span class="keyword">new</span> WxMenu();</span><br><span class="line">    WxMenuButton button1 = <span class="keyword">new</span> WxMenuButton();</span><br><span class="line">    button1.setType(MenuButtonType.CLICK);</span><br><span class="line">    button1.setName(<span class="string">"今日歌曲"</span>);</span><br><span class="line">    button1.setKey(<span class="string">"V1001_TODAY_MUSIC"</span>);</span><br><span class="line"></span><br><span class="line">   WxMenuButton button2 = <span class="keyword">new</span> WxMenuButton();</span><br><span class="line">   button2.setType(MenuButtonType.MINIPROGRAM);</span><br><span class="line">   button2.setName(<span class="string">"小程序"</span>);</span><br><span class="line">   button2.setAppId(<span class="string">"wx286b93c14bbf93aa"</span>);</span><br><span class="line">   button2.setPagePath(<span class="string">"pages/lunar/index.html"</span>);</span><br><span class="line">   button2.setUrl(<span class="string">"http://mp.weixin.qq.com"</span>);</span><br><span class="line"></span><br><span class="line">    WxMenuButton button3 = <span class="keyword">new</span> WxMenuButton();</span><br><span class="line">    button3.setName(<span class="string">"菜单"</span>);</span><br><span class="line"></span><br><span class="line">    menu.getButtons().add(button1);</span><br><span class="line">    menu.getButtons().add(button2);</span><br><span class="line">    menu.getButtons().add(button3);</span><br><span class="line"></span><br><span class="line">    WxMenuButton button31 = <span class="keyword">new</span> WxMenuButton();</span><br><span class="line">    button31.setType(MenuButtonType.VIEW);</span><br><span class="line">    button31.setName(<span class="string">"搜索"</span>);</span><br><span class="line">    button31.setUrl(<span class="string">"http://www.soso.com/"</span>);</span><br><span class="line"></span><br><span class="line">    WxMenuButton button32 = <span class="keyword">new</span> WxMenuButton();</span><br><span class="line">    button32.setType(MenuButtonType.VIEW);</span><br><span class="line">    button32.setName(<span class="string">"视频"</span>);</span><br><span class="line">    button32.setUrl(<span class="string">"http://v.qq.com/"</span>);</span><br><span class="line"></span><br><span class="line">    WxMenuButton button33 = <span class="keyword">new</span> WxMenuButton();</span><br><span class="line">    button33.setType(MenuButtonType.CLICK);</span><br><span class="line">    button33.setName(<span class="string">"赞一下我们"</span>);</span><br><span class="line">    button33.setKey(<span class="string">"V1001_GOOD"</span>);</span><br><span class="line"></span><br><span class="line">    WxMenuButton button34 = <span class="keyword">new</span> WxMenuButton();</span><br><span class="line">    button34.setType(MenuButtonType.VIEW);</span><br><span class="line">    button34.setName(<span class="string">"获取用户信息"</span>);</span><br><span class="line"></span><br><span class="line">    ServletRequestAttributes servletRequestAttributes =</span><br><span class="line">        (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">    <span class="keyword">if</span> (servletRequestAttributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        HttpServletRequest request = servletRequestAttributes.getRequest();</span><br><span class="line">        URL requestURL = <span class="keyword">new</span> URL(request.getRequestURL().toString());</span><br><span class="line">        String url = <span class="keyword">this</span>.wxService.switchoverTo(appid).oauth2buildAuthorizationUrl(</span><br><span class="line">            String.format(<span class="string">"%s://%s/wx/redirect/%s/greet"</span>, requestURL.getProtocol(), requestURL.getHost(), appid),</span><br><span class="line">            WxConsts.OAuth2Scope.SNSAPI_USERINFO, <span class="keyword">null</span>);</span><br><span class="line">        button34.setUrl(url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    button3.getSubButtons().add(button31);</span><br><span class="line">    button3.getSubButtons().add(button32);</span><br><span class="line">    button3.getSubButtons().add(button33);</span><br><span class="line">    button3.getSubButtons().add(button34);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.wxService.switchover(appid);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.wxService.getMenuService().menuCreate(menu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul>
<li>配置的服务器 URL 不要拦截(登录拦截等)</li>
<li>微信消息可能会重复发送, 需要开发者自己确保幂等, 虽然 WxJava 已经带有消息去重逻辑, 但模式实现是单机版的, 所以如果是集群的服务器, 需要自己实现 <code>WxMessageDuplicateChecker</code>, 并配置到 <code>WxMpMessageRouter</code> 中.</li>
</ul>
]]></content><categories><category>Java</category></categories><tags><tag>Java</tag><tag>Weixin</tag></tags></entry><entry><title>Ubuntu主题美化与常用软件记录</title><url>/2017/ubuntu-todo-after-install/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/individuation/ubuntu-desktop.png" alt></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p> 时间已经来到了9102年, 当初的<strong><em><a href="https://www.ubuntu.com/download/desktop" rel="external nofollow noopener noreferrer" target="_blank">Ubuntu 18.04 LTS</a></em></strong> 版本已经回归GNOME环境, 各种主题优化教程也层出不穷了, 说明 Ubuntu 的使用人群也渐渐增加…</p>
<p> 一键安装主题软件脚本: <strong><em><a href="https://github.com/masteranthoneyd/ubuntu-desktop-initializer" rel="external nofollow noopener noreferrer" target="_blank">ubuntu-desktop-initializer</a></em></strong></p>
</blockquote>
<a id="more"></a>
<h1 id="启动盘制作篇"><a href="#启动盘制作篇" class="headerlink" title="启动盘制作篇"></a>启动盘制作篇</h1><h2 id="Windows中利用UltraISO制作"><a href="#Windows中利用UltraISO制作" class="headerlink" title="Windows中利用UltraISO制作"></a>Windows中利用UltraISO制作</h2><p>在Windows环境下一般是通过 <strong><em><a href="https://www.ultraiso.com/" rel="external nofollow noopener noreferrer" target="_blank">UltraISO</a></em></strong> 制作U盘启动盘（最好是<strong>FAT32</strong>格式）, 步骤通常如下（安装UltraISO前提下）: </p>
<ul>
<li>选择并打开系统镜像（iso）</li>
<li>选择 <code>启动</code> -&gt; <code>写入硬盘映像</code> , 会弹出一个写入硬盘映像的对话框</li>
<li>选择对应U盘</li>
<li>点击 <code>便捷启动</code> -&gt; <code>写入新的驱动器引导扇区</code> -&gt; <code>Syslinux</code></li>
<li>最后再点击 <code>写入</code> 等待完成即可</li>
</ul>
<p>图就不贴了, 搜索引擎上一大堆. </p>
<p>接下来要介绍的是在Linux环境中制作启动盘</p>
<h2 id="Linux中利用DD命令制作"><a href="#Linux中利用DD命令制作" class="headerlink" title="Linux中利用DD命令制作"></a>Linux中利用DD命令制作</h2><h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h3><p>U盘插入电脑后, 用<code>lsblk</code>命令查看一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ lsblk</span><br><span class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda      8:0    0 111.8G  0 disk </span><br><span class="line">├─sda1   8:1    0   512M  0 part /boot/efi</span><br><span class="line">├─sda2   8:2    0    14G  0 part /usr</span><br><span class="line">├─sda3   8:3    0    14G  0 part /opt</span><br><span class="line">├─sda4   8:4    0   4.7G  0 part /boot</span><br><span class="line">└─sda5   8:5    0  78.7G  0 part /home</span><br><span class="line">sdb      8:16   0 931.5G  0 disk </span><br><span class="line">├─sdb1   8:17   0 745.1G  0 part /</span><br><span class="line">└─sdb2   8:18   0   8.4G  0 part [SWAP]</span><br><span class="line">sdc      8:32   1  14.5G  0 disk </span><br><span class="line">└─sdc4   8:36   1  14.5G  0 part /media/ybd/SSS_X64FRE_</span><br></pre></td></tr></table></figure>
<p>很明显, <code>/media/ybd/SSS_X64FRE_</code>这个挂载的就是U盘, U盘对应的路径是<code>/dev/sdc</code>如果不确定, 可以进去看一下文件目录. </p>
<blockquote>
<p>找到对应的挂载目录很重要, 少有不慎, 可能会导致整个系统瘫痪 23333………..</p>
</blockquote>
<h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h3><p>需要卸载掉挂载的目录: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">umount /media/ybd/SSS_X64FRE_</span><br></pre></td></tr></table></figure>
<p>再用<code>lsblk</code>确认一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda      8:0    0 111.8G  0 disk </span><br><span class="line">├─sda1   8:1    0   512M  0 part /boot/efi</span><br><span class="line">├─sda2   8:2    0    14G  0 part /usr</span><br><span class="line">├─sda3   8:3    0    14G  0 part /opt</span><br><span class="line">├─sda4   8:4    0   4.7G  0 part /boot</span><br><span class="line">└─sda5   8:5    0  78.7G  0 part /home</span><br><span class="line">sdb      8:16   0 931.5G  0 disk </span><br><span class="line">├─sdb1   8:17   0 745.1G  0 part /</span><br><span class="line">└─sdb2   8:18   0   8.4G  0 part [SWAP]</span><br><span class="line">sdc      8:32   1  14.5G  0 disk </span><br><span class="line">└─sdc4   8:36   1  14.5G  0 part</span><br></pre></td></tr></table></figure>
<p>可以看到已经没有挂载了</p>
<h3 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h3><p>用<code>dd</code>命令将iso映像写入U盘（一般Linux的镜像是直接将整个安装系统包括引导直接压缩进iso当中）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dd if=ubuntu-16.04-desktop-amd64.iso of=/dev/sdc bs=1M</span><br></pre></td></tr></table></figure>
<p>过程中不会有任何输入, 并且时间可能稍久, 完成后会输出这样的信息: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/dev/sdc bs=1M</span><br><span class="line">1520+0 records in</span><br><span class="line">1520+0 records out</span><br><span class="line">1593835520 bytes (1.6 GB) copied, 493.732 s, 3.2 MB/s</span><br></pre></td></tr></table></figure>
<p>到此制作完成. </p>
<h2 id="安装建议"><a href="#安装建议" class="headerlink" title="安装建议"></a>安装建议</h2><ul>
<li>硬盘格式: GPT ; 引导类型: UEFI.</li>
<li>单系统用户, 务必准备一个 <strong>EFI (ESP)</strong> 分区, 否则无法写入 GRUB 引导.</li>
<li>最小安装</li>
</ul>
<h1 id="系统篇"><a href="#系统篇" class="headerlink" title="系统篇"></a>系统篇</h1><h2 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h2><p>更换最佳源服务器, 打开 <strong>软件和更新</strong>（这里可以选择阿里的, 或者点击右边的 选择最佳服务器）: </p>
<p><img src="https://cdn.yangbingdong.com/img/individuation/source-server.png" alt></p>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>之前的16.04是会安装很多用不上的软件, 好在18.04版本优化掉了, 最小安装保持干净系统</p>
<p>安装完系统之后, 需要更新一些补丁. <code>Ctrl+Alt+T</code>调出终端, 执行一下代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt upgrade -y &amp;&amp; sudo apt autoremove</span><br></pre></td></tr></table></figure></p>
<h2 id="关掉sudo的密码"><a href="#关掉sudo的密码" class="headerlink" title="关掉sudo的密码"></a>关掉sudo的密码</h2><p>先修改默认编辑器为vim（默认为nano）: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --config editor</span><br></pre></td></tr></table></figure>
<p>输入vim对应的序号回车即可</p>
<p>打开 <code>visudo</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo visudo</span><br></pre></td></tr></table></figure>
<p>找到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%sudo   ALL=(ALL:ALL) ALL</span><br></pre></td></tr></table></figure>
<p>修改为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%sudo   ALL=(ALL:ALL) NOPASSWD:ALL</span><br></pre></td></tr></table></figure>
<p>这样所有sudo组内的用户使用sudo时就不需要密码了. </p>
<h2 id="exfat驱动"><a href="#exfat驱动" class="headerlink" title="exfat驱动"></a>exfat驱动</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install exfat-fuse exfat-utils</span><br></pre></td></tr></table></figure>
<h2 id="统一Win10和Ubuntu18-04双系统的时间"><a href="#统一Win10和Ubuntu18-04双系统的时间" class="headerlink" title="统一Win10和Ubuntu18.04双系统的时间"></a>统一Win10和Ubuntu18.04双系统的时间</h2><blockquote>
<p>双系统导致的时间不统一.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">timedatectl set-local-rtc 1 --adjust-system-clock</span><br></pre></td></tr></table></figure>
<h2 id="Apt-Fast"><a href="#Apt-Fast" class="headerlink" title="Apt Fast"></a>Apt Fast</h2><blockquote>
<p><strong><em><a href="https://github.com/ilikenwf/apt-fast" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/ilikenwf/apt-fast</a></em></strong></p>
<p>apt-fast 是一个为 <code>apt-get</code> 和 <code>aptitude</code> 做的 <strong>shell 脚本封装</strong>，通过对每个包进行并发下载的方式可以大大减少 APT 的下载时间。apt-fast 使用 <strong>aria2c</strong> 下载管理器来减少 APT 下载时间。就像传统的 apt-get 包管理器一样，apt-fast 支持几乎所有的 apt-get 功能，如， <code>install</code> , <code>remove</code> , <code>update</code> , <code>upgrade</code> , <code>dist-upgrade</code> 等等，并且更重要的是它也支持 proxy。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository -y ppa:apt-fast/stable &amp;&amp; \</span><br><span class="line">sudo apt install -y apt-fast</span><br></pre></td></tr></table></figure>
<p>之后就可以用 <code>apt-fast</code>  代替 <code>apt</code> 或 <code>apt-get</code> 命令了.</p>
<h2 id="Gdebi"><a href="#Gdebi" class="headerlink" title="Gdebi"></a>Gdebi</h2><p>有时候安装deb包不满足依赖还需要手动执行<code>sudo apt install -f</code>, 我们可以使用<code>gdebi</code>解决这个问题:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install gdebi</span><br></pre></td></tr></table></figure>
<p>之后使用<code>sudo gdebi xxx.deb</code>安装即可</p>
<h2 id="Snap"><a href="#Snap" class="headerlink" title="Snap"></a>Snap</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install -y snapd</span><br></pre></td></tr></table></figure>
<h3 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl edit snapd.service</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment=http_proxy=http://proxy:port</span><br><span class="line">Environment=https_proxy=http://proxy:port</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart snapd.service</span><br></pre></td></tr></table></figure>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 列出已经安装的snap包</span><br><span class="line">sudo snap list</span><br><span class="line"></span><br><span class="line"># 搜索要安装的snap包</span><br><span class="line">sudo snap find &lt;text to search&gt;</span><br><span class="line"></span><br><span class="line"># 安装一个snap包</span><br><span class="line">sudo snap install &lt;snap name&gt;</span><br><span class="line"></span><br><span class="line"># 更新一个snap包，如果你后面不加包的名字的话那就是更新所有的snap包</span><br><span class="line">sudo snap refresh &lt;snap name&gt;</span><br><span class="line"></span><br><span class="line"># 把一个包还原到以前安装的版本</span><br><span class="line">sudo snap revert &lt;snap name&gt;</span><br><span class="line"></span><br><span class="line"># 删除一个snap包</span><br><span class="line">sudo snap remove &lt;snap name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="关闭-avahi-daemon-服务"><a href="#关闭-avahi-daemon-服务" class="headerlink" title="关闭 avahi-daemon 服务"></a>关闭 avahi-daemon 服务</h2><p><code>avahi-daemon</code> 造成过网络异常，用处也不大，停止服务并关闭开机启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl stop avahi-daemon.socket</span><br><span class="line">sudo systemctl stop avahi-daemon.service</span><br><span class="line">sudo /lib/systemd/systemd-sysv-install disable avahi-daemon</span><br><span class="line"></span><br><span class="line">sudo systemctl disable avahi-daemon.socket</span><br><span class="line">sudo systemctl disable avahi-daemon.service</span><br></pre></td></tr></table></figure>
<h2 id="显卡驱动"><a href="#显卡驱动" class="headerlink" title="显卡驱动"></a>显卡驱动</h2><p>查看可安装显卡:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ubuntu-drivers devices</span><br></pre></td></tr></table></figure>
<p>安装:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装系统推荐驱动</span><br><span class="line">sudo ubuntu-drivers autoinstall</span><br><span class="line"></span><br><span class="line"># 安装指定驱动</span><br><span class="line">sudo apt install nvidia-340</span><br></pre></td></tr></table></figure>
<p>安装Beta版本驱动:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:graphics-drivers/ppa -y</span><br><span class="line"></span><br><span class="line"># 再次查看可安装的显卡驱动</span><br><span class="line">ubuntu-drivers devices</span><br></pre></td></tr></table></figure>
<p>输出如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ubuntu-drivers devices</span><br><span class="line">== /sys/devices/pci0000:00/0000:00:01.0/0000:01:00.0 ==</span><br><span class="line">modalias : pci:v000010DEd00001380sv00001458sd0000362Dbc03sc00i00</span><br><span class="line">vendor   : NVIDIA Corporation</span><br><span class="line">model    : GM107 [GeForce GTX 750 Ti]</span><br><span class="line">driver   : nvidia-driver-396 - third-party free</span><br><span class="line">driver   : nvidia-340 - distro non-free</span><br><span class="line">driver   : nvidia-driver-390 - distro non-free</span><br><span class="line">driver   : nvidia-driver-410 - third-party free</span><br><span class="line">driver   : nvidia-driver-418 - third-party free recommended</span><br><span class="line">driver   : nvidia-driver-415 - third-party free</span><br><span class="line">driver   : xserver-xorg-video-nouveau - distro free builtin</span><br></pre></td></tr></table></figure>
<p>安装:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ubuntu-drivers autoinstall  # sudo apt install nvidia-418</span><br></pre></td></tr></table></figure>
<p>重启后生效.</p>
<h1 id="主题美化篇"><a href="#主题美化篇" class="headerlink" title="主题美化篇"></a>主题美化篇</h1><p>推荐一个网站 <strong><em><a href="https://www.gnome-look.org/" rel="external nofollow noopener noreferrer" target="_blank">Gnome Look</a></em></strong>, 这里面有大量的主题, 并且都是以压缩包形式的.</p>
<ul>
<li>主题存放目录：<code>/usr/share/themes</code> 或 <code>~/.themes</code></li>
<li>图标存放目录：<code>/usr/share/icons</code> 或 <code>~/.icons</code></li>
<li>字体存放目录：<code>/usr/share/fonts</code> 或 <code>~/.fonts</code></li>
</ul>
<p>其中 <code>/usr/share</code> 目录需要 root 权限才能修改，可以对文件管理提权后打开：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo nautilus</span><br></pre></td></tr></table></figure>
<p> 并且注意一下解压后shell的主题文件夹的二级目录应该是<code>/gnome-shell</code>, 然后分别放到对应的目录, 就能在<strong>gnome-tweak</strong>工具里面识别了</p>
<h2 id="GNOME美化"><a href="#GNOME美化" class="headerlink" title="GNOME美化"></a>GNOME美化</h2><h3 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install -y \</span><br><span class="line">gnome-tweak-tool \</span><br><span class="line">gnome-shell-extensions \</span><br><span class="line">chrome-gnome-shell \</span><br><span class="line">gtk2-engines-pixbuf \</span><br><span class="line">libxml2-utils</span><br></pre></td></tr></table></figure>
<h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><h4 id="Sierra-gtk-theme"><a href="#Sierra-gtk-theme" class="headerlink" title="Sierra-gtk-theme"></a>Sierra-gtk-theme</h4><blockquote>
<p><strong><em><a href="https://github.com/vinceliuice/Sierra-gtk-theme" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/vinceliuice/Sierra-gtk-theme</a></em></strong></p>
</blockquote>
<p>这是一款类苹果的主题…</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository -y ppa:dyatlov-igor/sierra-theme</span><br><span class="line">sudo apt install sierra-gtk-theme</span><br></pre></td></tr></table></figure>
<h4 id="Flatabulous"><a href="#Flatabulous" class="headerlink" title="Flatabulous"></a>Flatabulous</h4><p><code>Flatabulous</code>主题是一款<code>Ubuntu</code>下扁平化主题.</p>
<p>执行以下命令安装<code>Flatabulous</code>主题: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:noobslab/themes </span><br><span class="line">sudo apt update </span><br><span class="line">sudo apt install flatabulous-theme</span><br></pre></td></tr></table></figure>
<p>该主题有配套的图标, 安装方式如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:noobslab/icons </span><br><span class="line">sudo apt update </span><br><span class="line">sudo apt install ultra-flat-icons</span><br></pre></td></tr></table></figure></p>
<h4 id="Arc-Theme"><a href="#Arc-Theme" class="headerlink" title="Arc-Theme"></a>Arc-Theme</h4><blockquote>
<p><strong><em><a href="https://github.com/horst3180/arc-theme" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/horst3180/arc-theme</a></em></strong></p>
</blockquote>
<p>这也是一款很漂亮的主题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install arc-theme</span><br></pre></td></tr></table></figure>
<h4 id="Sweet"><a href="#Sweet" class="headerlink" title="Sweet"></a>Sweet</h4><p><strong><em><a href="https://www.gnome-look.org/p/1253385/" rel="external nofollow noopener noreferrer" target="_blank">https://www.gnome-look.org/p/1253385/</a></em></strong></p>
<h3 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h3><h4 id="Suru-Plus"><a href="#Suru-Plus" class="headerlink" title="Suru Plus"></a>Suru Plus</h4><blockquote>
<p><strong><em><a href="https://www.opendesktop.org/p/1210408/" rel="external nofollow noopener noreferrer" target="_blank">https://www.opendesktop.org/p/1210408/</a></em></strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -qO- https://raw.githubusercontent.com/gusbemacbe/suru-plus/master/install.sh | sh</span><br></pre></td></tr></table></figure>
<p>更换文件夹颜色(<strong><em><a href="https://github.com/gusbemacbe/suru-plus-folders/blob/master/languages/en.md" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/gusbemacbe/suru-plus-folders/blob/master/languages/en.md</a></em></strong>):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装</span><br><span class="line">curl -fsSL https://raw.githubusercontent.com/gusbemacbe/suru-plus-folders/master/install.sh | sh</span><br><span class="line"># 查看颜色</span><br><span class="line">suru-plus-folders -l --theme Suru++</span><br><span class="line"># 更换</span><br><span class="line">suru-plus-folders -C cyan --theme Suru++</span><br></pre></td></tr></table></figure>
<h4 id="Papirus"><a href="#Papirus" class="headerlink" title="Papirus"></a>Papirus</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository -y ppa:papirus/papirus</span><br><span class="line">sudo apt install papirus-icon-theme</span><br></pre></td></tr></table></figure>
<p>或者下载最新的 <a href="https://launchpad.net/~papirus/+archive/ubuntu/papirus/+packages?field.name_filter=papirus-icon-theme" rel="external nofollow noopener noreferrer" target="_blank"><strong>deb 安装包</strong></a><br><strong><em><a href="https://github.com/PapirusDevelopmentTeam/papirus-icon-theme" rel="external nofollow noopener noreferrer" target="_blank">项目地址</a></em></strong></p>
<h4 id="Paper"><a href="#Paper" class="headerlink" title="Paper"></a>Paper</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository -y ppa:snwh/pulp</span><br><span class="line">sudo apt install paper-icon-theme</span><br><span class="line"># 同时也可以安装 GTK 和 Cursor 主题</span><br><span class="line">sudo apt install paper-gtk-theme</span><br><span class="line">sudo apt install paper-cursor-theme</span><br></pre></td></tr></table></figure>
<p><strong><a href="https://github.com/snwh/paper-icon-theme" rel="external nofollow noopener noreferrer" target="_blank">项目地址</a></strong></p>
<h3 id="光标"><a href="#光标" class="headerlink" title="光标"></a>光标</h3><h4 id="Capitaine-Cursors"><a href="#Capitaine-Cursors" class="headerlink" title="Capitaine Cursors"></a>Capitaine Cursors</h4><blockquote>
<p><strong><em><a href="https://www.gnome-look.org/p/1148692/" rel="external nofollow noopener noreferrer" target="_blank">https://www.gnome-look.org/p/1148692/</a></em></strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository -y ppa:dyatlov-igor/la-capitaine</span><br><span class="line">sudo apt install -y la-capitaine-cursor-theme</span><br></pre></td></tr></table></figure>
<h4 id="Oxy-Blue"><a href="#Oxy-Blue" class="headerlink" title="Oxy Blue"></a>Oxy Blue</h4><p><strong><em><a href="https://www.opendesktop.org/p/1274872/" rel="external nofollow noopener noreferrer" target="_blank">https://www.opendesktop.org/p/1274872/</a></em></strong></p>
<p>下载后解压到 <code>/usr/share/themes</code> 目录下</p>
<h2 id="GNOME-Extensions"><a href="#GNOME-Extensions" class="headerlink" title="GNOME Extensions"></a>GNOME Extensions</h2><blockquote>
<p>Ubuntu 18.04 抛弃了 Unity 桌面转而使用 Gnome ，所以 Gnome 桌面下的一些 Shell 扩展在 Ubuntu 18.04 中就可以使用了。</p>
</blockquote>
<p>先上图…</p>
<p><img src="https://cdn.yangbingdong.com/img/gnome/desktop1.png" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/gnome/desktop2.png" alt></p>
<h3 id="Chrome-Gnome-Shell"><a href="#Chrome-Gnome-Shell" class="headerlink" title="Chrome Gnome Shell"></a>Chrome Gnome Shell</h3><p>首先安装 Chrome Gnome Shell ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install chrome-gnome-shell</span><br></pre></td></tr></table></figure>
<p>然后安装浏览器插件（<strong>谷歌浏览器</strong>）：<a href="https://chrome.google.com/webstore/detail/gnome-shell-integration/gphhapmejobijbbhgpjhcjognlahblep" rel="external nofollow noopener noreferrer" target="_blank">Chrome 网上应用商店</a></p>
<p>浏览器插件安装完成后点击 <em>插件图标</em> 就能进入：<strong><a href="https://extensions.gnome.org/" rel="external nofollow noopener noreferrer" target="_blank">Shell 扩展商店</a></strong></p>
<h3 id="Dash-To-Dock"><a href="#Dash-To-Dock" class="headerlink" title="Dash To Dock"></a>Dash To Dock</h3><p><strong><a href="https://extensions.gnome.org/extension/307/dash-to-dock/" rel="external nofollow noopener noreferrer" target="_blank">Dash To Dock</a></strong>: 虽然Ubuntu18已经有了一个Dock, 但定制性不强. 这个Dock插件提供了很多选项定制, 个人比较喜欢的一个选项就是隔离工作区. </p>
<p><img src="https://cdn.yangbingdong.com/img/gnome/dock02.png" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/gnome/dock01.png" alt></p>
<h3 id="Topicons-Plus"><a href="#Topicons-Plus" class="headerlink" title="Topicons Plus"></a>Topicons Plus</h3><p><a href="https://extensions.gnome.org/extension/1031/topicons/" rel="external nofollow noopener noreferrer" target="_blank"><strong>Topicons Plus</strong></a> 任务图标栏</p>
<p>任务图标栏使用默认的图标, 如何让他使用自定义的图标主题呢？<br>比如使用 <strong>Papirus</strong> , 它支持 <code>hardcode-tray</code> 脚本来实现</p>
<ol>
<li>安装 <code>hardcode-tray</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:andreas-angerer89/sni-qt-patched</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install sni-qt sni-qt:i386 hardcode-tray inkscape</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>转换图标</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hardcode-tray --conversion-tool Inkscape</span><br></pre></td></tr></table></figure>
<h3 id="Nvidia-GPU-Temperature-Indicator"><a href="#Nvidia-GPU-Temperature-Indicator" class="headerlink" title="Nvidia GPU Temperature Indicator"></a>Nvidia GPU Temperature Indicator</h3><p><a href="https://extensions.gnome.org/extension/541/nvidia-gpu-temperature-indicator/" rel="external nofollow noopener noreferrer" target="_blank"><strong>Nvidia GPU Temperature Indicator</strong></a> 显卡温度指示器</p>
<h3 id="User-Themes"><a href="#User-Themes" class="headerlink" title="User Themes"></a>User Themes</h3><p><strong><a href="https://extensions.gnome.org/extension/19/user-themes/" rel="external nofollow noopener noreferrer" target="_blank">User Themes</a></strong> 可以使用shell-theme: </p>
<p><img src="https://cdn.yangbingdong.com/img/individuation/user-themes.png" alt></p>
<h3 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h3><p><strong>以下是其他的Gnome 扩展推荐</strong> :</p>
<table>
<thead>
<tr>
<th>扩展</th>
<th>简要功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><em><a href="https://extensions.gnome.org/extension/6/applications-menu/" rel="external nofollow noopener noreferrer" target="_blank">Applications Menu</a></em></strong></td>
<td>在顶部添加一个应用程序入口</td>
</tr>
<tr>
<td><strong><em><a href="https://extensions.gnome.org/extension/97/coverflow-alt-tab/" rel="external nofollow noopener noreferrer" target="_blank">Coverflow Alt-Tab</a></em></strong></td>
<td>Alt Tab 切换应用（更酷炫的界面）</td>
</tr>
<tr>
<td><strong><em><a href="https://extensions.gnome.org/extension/307/dash-to-dock/" rel="external nofollow noopener noreferrer" target="_blank">Dash to Dock</a></em></strong></td>
<td>Dock （大名鼎鼎）</td>
</tr>
<tr>
<td><strong><em><a href="https://extensions.gnome.org/extension/1160/dash-to-panel/" rel="external nofollow noopener noreferrer" target="_blank">Dash to Panel</a></em></strong></td>
<td>对顶栏的操作处理（诸如自动隐藏等）</td>
</tr>
<tr>
<td><strong><em><a href="https://extensions.gnome.org/extension/690/easyscreencast/" rel="external nofollow noopener noreferrer" target="_blank">EasyScreenCast</a></em></strong></td>
<td>录屏工具（录制质量优秀）</td>
</tr>
<tr>
<td><strong><em><a href="https://extensions.gnome.org/extension/1166/extension-update-notifier/" rel="external nofollow noopener noreferrer" target="_blank">Extension update notifier</a></em></strong></td>
<td>自动推送所有扩展的更新信息</td>
</tr>
<tr>
<td><strong><em><a href="https://extensions.gnome.org/extension/1461/internet-speed-meter/" rel="external nofollow noopener noreferrer" target="_blank">Internet speed meter</a> / <a href="https://extensions.gnome.org/extension/104/netspeed/" rel="external nofollow noopener noreferrer" target="_blank">NetSpeed</a></em></strong></td>
<td>顶栏显示当前网络速度</td>
</tr>
<tr>
<td><strong><em><a href="https://extensions.gnome.org/extension/750/openweather/" rel="external nofollow noopener noreferrer" target="_blank">OpenWeather</a></em></strong></td>
<td>顶栏显示天气情况（支持中文）</td>
</tr>
<tr>
<td><strong><em><a href="https://extensions.gnome.org/extension/885/dynamic-top-bar/" rel="external nofollow noopener noreferrer" target="_blank">Dynamic Top Bar</a></em></strong></td>
<td>动态调整状态栏透明度</td>
</tr>
<tr>
<td><strong><em><a href="https://extensions.gnome.org/extension/8/places-status-indicator/" rel="external nofollow noopener noreferrer" target="_blank">Places Status Indicator</a></em></strong></td>
<td>提供快捷目录入口（同文件管理器）</td>
</tr>
<tr>
<td><strong><em><a href="https://extensions.gnome.org/extension/1349/popup-dict-switcher/" rel="external nofollow noopener noreferrer" target="_blank">Popup dict Switcher</a></em></strong></td>
<td>一键开关划词翻译</td>
</tr>
<tr>
<td><strong><em><a href="https://extensions.gnome.org/extension/7/removable-drive-menu/" rel="external nofollow noopener noreferrer" target="_blank">Removable Drive Menu</a></em></strong></td>
<td>移除可移动设备</td>
</tr>
<tr>
<td><strong><em><a href="https://extensions.gnome.org/extension/1112/screenshot-tool/" rel="external nofollow noopener noreferrer" target="_blank">Screenshot Tool</a></em></strong></td>
<td>截图工具（挺方便）</td>
</tr>
<tr>
<td><strong><em><a href="https://extensions.gnome.org/extension/906/sound-output-device-chooser/" rel="external nofollow noopener noreferrer" target="_blank">Sound Input &amp; Output Device Chooser</a></em></strong></td>
<td>更方便的调整声音、亮度</td>
</tr>
<tr>
<td><strong><em><a href="https://extensions.gnome.org/extension/120/system-monitor/" rel="external nofollow noopener noreferrer" target="_blank">System-monitor</a> / <a href="https://extensions.gnome.org/extension/1064/system-monitor/" rel="external nofollow noopener noreferrer" target="_blank">System-monitor</a></em></strong></td>
<td>在状态栏中显示系统信息（很多类型）</td>
</tr>
</tbody>
</table>
<blockquote>
<p>若出现安装失败，请检查 <strong>是否满足相关依赖</strong> 。</p>
</blockquote>
<h2 id="Oh-My-Zsh"><a href="#Oh-My-Zsh" class="headerlink" title="Oh-My-Zsh"></a>Oh-My-Zsh</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>终端采用<code>zsh</code>和<code>oh-my-zsh</code>, 既美观又简单易用, 主要是能提高你的逼格！！！</p>
<p>首先, 安装<code>zsh</code>: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install zsh</span><br></pre></td></tr></table></figure>
<p>接下来我们需要下载 <code>oh-my-zsh</code> 项目来帮我们配置 <code>zsh</code>, 采用<code>wget</code>安装(需要先安装<code>git</code>)<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">"<span class="variable">$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)</span>"</span></span><br></pre></td></tr></table></figure></p>
<p>重启后生效.</p>
<h3 id="语法高亮"><a href="#语法高亮" class="headerlink" title="语法高亮"></a>语法高亮</h3><p>安装插件<code>highlight</code>, <strong>高亮语法</strong>: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~/.oh-my-zsh/custom/plugins &amp;&amp;\</span><br><span class="line">git clone git://github.com/zsh-users/zsh-syntax-highlighting.git</span><br></pre></td></tr></table></figure>
<p>在<code>Oh-my-zsh</code>的配置文件中<code>~/.zshrc</code>中添加插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins=( [plugins...] zsh-syntax-highlighting)</span><br></pre></td></tr></table></figure>
<p>重新打开终端即可生效！</p>
<h3 id="调色"><a href="#调色" class="headerlink" title="调色"></a>调色</h3><p>最后, 修改以下配色, 会让你的终端样式看起来更舒服, 在终端任意地方右键, 进入配置文件(<code>profile</code>)-&gt;外观配置(<code>profile Preferences</code>), 弹出如下界面, 进入<code>colors</code>一栏:<br><img src="https://cdn.yangbingdong.com/img/individuation/zsh02.png" alt></p>
<p>其中, 文字和背景采用系统主题, 透明度设为10%, 下面的<code>palette</code>样式采用<code>Tango</code>, 这样一通设置后, 效果如下:<br><img src="https://cdn.yangbingdong.com/img/individuation/screenfetch.png" alt></p>
<p><strong>推荐配色</strong>: </p>
<ul>
<li>文本颜色: <code>#00FF00</code></li>
<li>粗体字颜色: 与文本颜色相同</li>
<li>背景颜色: <code>#002B36</code></li>
</ul>
<h3 id="主题-1"><a href="#主题-1" class="headerlink" title="主题"></a>主题</h3><p>在<code>~/.oh-my-zsh/themes</code>中查看主题. </p>
<p>然后编辑<code>~/.zshrc</code>, 找到<code>ZSH_THEME</code>修改为你想要的主题即可（感觉<code>ys</code>这个主题不错）. </p>
<p><code>agnoster</code>, <em><a href="https://github.com/caiogondim/bullet-train.zsh" rel="external nofollow noopener noreferrer" target="_blank">bullet-train</a></em> 这两款主题也不错, 但需要先安装一些 <em><a href="https://github.com/powerline/fonts" rel="external nofollow noopener noreferrer" target="_blank">字体样式</a></em>: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/powerline/fonts.git --depth=1</span><br><span class="line">cd fonts</span><br><span class="line">./install.sh</span><br><span class="line">cd ..</span><br><span class="line">rm -rf fonts</span><br></pre></td></tr></table></figure>
<p><strong>装完后需要在终端配置Powerline字体</strong>.</p>
<p>其他主题:</p>
<p><strong><em><a href="https://github.com/bhilburn/powerlevel9k" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/bhilburn/powerlevel9k</a></em></strong></p>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p><code>Ubuntu</code>自带的字体不太好看, 所以采用<strong>文泉译微米黑/正黑</strong>替代, 效果会比较好, 毕竟是国产字体！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install fonts-wqy-microhei fonts-wqy-zenhei</span><br></pre></td></tr></table></figure>
<p>然后通过<code>gnome-tweak-tool</code>来替换字体</p>
<h2 id="GRUB-2-主题"><a href="#GRUB-2-主题" class="headerlink" title="GRUB 2 主题"></a>GRUB 2 主题</h2><blockquote>
<p>由于安装了多系统, 恰好Ubuntu的GRUB2提供了切换系统的选择, 但是界面不咋样</p>
</blockquote>
<p>前往 <strong><em><a href="https://www.gnome-look.org/browse/cat/109/" rel="external nofollow noopener noreferrer" target="_blank">https://www.gnome-look.org/browse/cat/109/</a></em></strong> 选择一款合适自己的主题安装</p>
<p>博主推荐 <strong><em><a href="https://www.gnome-look.org/p/1009236/" rel="external nofollow noopener noreferrer" target="_blank">Grub-theme-vimix</a></em></strong>  <strong><em><a href="https://www.gnome-look.org/p/1220920/" rel="external nofollow noopener noreferrer" target="_blank">Blur grub</a></em></strong> 或者 <a href="https://github.com/shvchk/fallout-grub-theme" rel="external nofollow noopener noreferrer" target="_blank"><strong><em>fallout-grub-theme</em></strong></a></p>
<p><img src="https://cdn.yangbingdong.com/img/gnome/stylish.png" alt></p>
<p>根据提示下载源码执行安装脚本即可. </p>
<p>但某些主题只提供主题包并没有安装脚本, 则我们需要<strong>手动安装</strong>:</p>
<p>首先下载主题包，多为压缩包，解压出文件。使用 <code>sudo nautilus</code> 打开文件管理器。</p>
<p>定位到目录：<code>/boot/grub</code>，在该目录下 <strong>新建文件夹</strong> ：<code>themes</code>，把解压出的文件拷贝到文件夹中。</p>
<ul>
<li><strong>方案一：手写配置文件</strong></li>
</ul>
<p>接着（终端下）使用 gedit 修改 <em>grub</em> 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo gedit /etc/default/grub</span><br></pre></td></tr></table></figure>
<p>在该文件末尾添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># GRUB_THEME=&quot;/boot/grub/themes/主题包文件夹名称/theme.txt&quot;</span><br><span class="line">GRUB_THEME=&quot;/boot/grub/themes/fallout-grub-theme-master/theme.txt&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>方案二：利用软件 Grub Customizer</strong></li>
</ul>
<p>添加 PPA ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:danielrichter2007/grub-customizer</span><br></pre></td></tr></table></figure>
<p>安装软件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install grub-customizer</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>最后</strong> 更新配置文件：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo update-grub</span><br></pre></td></tr></table></figure>
<blockquote>
<p>谈到 grub 就不得不谈到 <code>/boot/grub/grub.cfg</code> ，这个文件才是事实上的配置文件，所谓更新就是重新生成 <em>grub.cfg</em> 。</p>
</blockquote>
<h2 id="GDM-登录背景图"><a href="#GDM-登录背景图" class="headerlink" title="GDM 登录背景图"></a>GDM 登录背景图</h2><blockquote>
<p>更多GDM主题请看 <strong><em><a href="https://www.pling.com/s/Gnome/browse/cat/131/order/latest/" rel="external nofollow noopener noreferrer" target="_blank">https://www.pling.com/s/Gnome/browse/cat/131/order/latest/</a></em></strong></p>
<p>修改之前可以备份一下<code>ubuntu.css</code>文件, 避免错了改不会来…</p>
</blockquote>
<p>更换登录界面的背景图需要修改文件 <code>ubuntu.css</code>，它位于 <code>/usr/share/gnome-shell/theme</code> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo gedit /usr/share/gnome-shell/theme/ubuntu.css</span><br></pre></td></tr></table></figure>
<p>在文件中找到关键字 <code>lockDialogGroup</code>，如下行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#lockDialogGroup &#123;</span><br><span class="line">   background: #2c001e url(resource:///org/gnome/shell/theme/noise-texture.png);</span><br><span class="line">   background-repeat: repeat; &#125;</span><br></pre></td></tr></table></figure>
<p>修改图片路径即可，样例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#lockDialogGroup &#123;</span><br><span class="line">  background: #2c001e url(file:///home/ybd/data/pic/spain.jpg);</span><br><span class="line">  background-repeat: no-repeat;</span><br><span class="line">  background-size: cover;</span><br><span class="line">  background-position: center; &#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>file:///home/ybd/data/pic/spain.jpg</code>为图片路径.</p>
<h2 id="开机动画"><a href="#开机动画" class="headerlink" title="开机动画"></a>开机动画</h2><blockquote>
<p>查找喜欢的开机动画: <strong><em><a href="https://www.gnome-look.org/browse/cat/108/order/latest" rel="external nofollow noopener noreferrer" target="_blank">https://www.gnome-look.org/browse/cat/108/order/latest</a></em></strong></p>
</blockquote>
<p>几个不错的动画:</p>
<ul>
<li><em><a href="https://www.gnome-look.org/p/1176419/" rel="external nofollow noopener noreferrer" target="_blank">UbuntuStudio - Suade</a></em></li>
<li><em><a href="https://www.gnome-look.org/p/1156215/" rel="external nofollow noopener noreferrer" target="_blank">Mint Floral</a></em></li>
<li><em><a href="https://www.gnome-look.org/p/1215618/" rel="external nofollow noopener noreferrer" target="_blank">ArcOS-X-Flatabulous</a></em></li>
</ul>
<p>下面说安装流程:</p>
<ol>
<li><p>首先下载并解压自己喜欢的开机动画;</p>
</li>
<li><p>把解压后的文件夹复制到 <code>/usr/share/plymouth/themes/</code> 文件夹下;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo cp $&#123;caton-path&#125; /usr/share/plymouth/themes/ -r</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑配置文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo gedit /etc/alternatives/default.plymouth</span><br></pre></td></tr></table></figure>
<p>把后两行修改为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[script]</span><br><span class="line">ImageDir=/usr/share/plymouth/themes/$&#123;theme-directory&#125;</span><br><span class="line">ScriptFile=/usr/share/plymouth/themes/$&#123;theme-directory&#125;/$&#123;script-file-name&#125;</span><br></pre></td></tr></table></figure>
<p>其中:</p>
<ul>
<li><code>${theme-directory}</code> 是你的主题文件夹名;</li>
<li><code>${script-file-name}</code> 是主题文件夹下后缀为 <code>.script</code> 文件的文件名.</li>
</ul>
</li>
<li><p>重启即可.</p>
</li>
</ol>
<h2 id="动态桌面"><a href="#动态桌面" class="headerlink" title="动态桌面"></a>动态桌面</h2><p>在 Windows 中有 <strong>Wallpaper Engine</strong>, 收费的. 但在 Linux 中有一款开源的动态桌面软件 <strong><em><a href="https://github.com/cheesecakeufo/komorebi" rel="external nofollow noopener noreferrer" target="_blank">komorebi</a></em></strong> .</p>
<p>在 <strong><em><a href="https://github.com/cheesecakeufo/komorebi/releases" rel="external nofollow noopener noreferrer" target="_blank">releases</a></em></strong> 页面中下载 deb 包安装即可.</p>
<p>依赖:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install -y libgstreamer1.0-0 gstreamer1.0-plugins-base gstreamer1.0-plugins-good gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly gstreamer1.0-libav gstreamer1.0-doc gstreamer1.0-tools</span><br></pre></td></tr></table></figure>
<p>安装完后在启动器中搜索 <code>komorebi</code>, 除了看到 <code>komorebi</code> 之外还有一个 <code>Wallpaper Creator</code>, 这个是用来制作动态桌面壁纸的.</p>
<p>之后直接打开 <code>komorebi</code> 即可, 在桌面上右键即可打开菜单进行配置.</p>
<p>效果:</p>
<p><img src="https://cdn.yangbingdong.com/img/gnome/dynamic-desktop.gif" alt></p>
<p>附动画: <strong><em><a href="https://cdn.yangbingdong.com/resource/desktop/%E5%96%84%E9%80%B8.zip" rel="external nofollow noopener noreferrer" target="_blank">https://cdn.yangbingdong.com/resource/desktop/%E5%96%84%E9%80%B8.zip</a></em></strong></p>
<h2 id="壁纸推荐"><a href="#壁纸推荐" class="headerlink" title="壁纸推荐"></a>壁纸推荐</h2><p>推荐几个不错的壁纸下载网站: </p>
<ul>
<li><p><strong><em><a href="https://wallpapershome.com" rel="external nofollow noopener noreferrer" target="_blank">https://wallpapershome.com</a></em></strong></p>
</li>
<li><p><strong><em><a href="https://pixabay.com" rel="external nofollow noopener noreferrer" target="_blank">https://pixabay.com</a></em></strong></p>
</li>
<li><p><strong><em><a href="https://alpha.wallhaven.cc/" rel="external nofollow noopener noreferrer" target="_blank">https://alpha.wallhaven.cc/</a></em></strong></p>
</li>
</ul>
<h1 id="软件篇"><a href="#软件篇" class="headerlink" title="软件篇"></a>软件篇</h1><blockquote>
<p>Java开发者的环境搭建请看: <strong><em><a href="/2017/ubuntu-dev-environment-to-build/">Ubuntu的Java开发环境基本搭建</a></em></strong></p>
</blockquote>
<h2 id="搜狗输入法"><a href="#搜狗输入法" class="headerlink" title="搜狗输入法"></a>搜狗输入法</h2><p>卸载ibus. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove ibus</span><br></pre></td></tr></table></figure>
<p>清除ibus配置. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get purge ibus</span><br></pre></td></tr></table></figure>
<p>卸载顶部面板任务栏上的键盘指示. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo  apt-get remove indicator-keyboard</span><br></pre></td></tr></table></figure>
<p>安装fcitx输入法框架</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install fcitx-table-wbpy fcitx-config-gtk</span><br></pre></td></tr></table></figure>
<p>切换为 Fcitx输入法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">im-config -n fcitx</span><br></pre></td></tr></table></figure>
<p>im-config 配置需要重启系统才能生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo shutdown -r now</span><br></pre></td></tr></table></figure>
<p>点击下载 Sogou For Linux -&gt; <a id="download" href="http://pinyin.sogou.com/linux/" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-download"></i><span> Download Now</span><br></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http://cdn2.ime.sogou.com/dl/index/1524572264/sogoupinyin_2.2.0.0108_amd64.deb?st=ryCwKkvb-0zXvtBlhw5q4Q&amp;e=1529739124&amp;fn=sogoupinyin_2.2.0.0108_amd64.deb</span><br></pre></td></tr></table></figure>
<p>安装搜狗输入法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i sogoupinyin_2.2.0.0108_amd64.deb</span><br></pre></td></tr></table></figure>
<p>修复损坏缺少的包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -f</span><br></pre></td></tr></table></figure>
<p>打开 Fcitx 输入法配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fcitx-config-gtk3</span><br></pre></td></tr></table></figure>
<p>问题: 输入法皮肤透明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fcitx设置 &gt;&gt; 附加组件 &gt;&gt; 勾选高级 &gt;&gt; 取消经典界面</span><br><span class="line"></span><br><span class="line">Configure&gt;&gt;  Addon  &gt;&gt;Advanced&gt;&gt;Classic</span><br></pre></td></tr></table></figure>
<p>再次重启. </p>
<h2 id="Deepin-Wine-For-Ubuntu"><a href="#Deepin-Wine-For-Ubuntu" class="headerlink" title="Deepin Wine For Ubuntu"></a>Deepin Wine For Ubuntu</h2><p>这个项目是 Deepin-wine 环境的 Ubuntu 移植版, 可以在 Ubuntu 上运行 Tim, 微信, 网易云音乐, 百度云网盘, 迅雷等 Windows 软件: <strong><em><a href="https://github.com/wszqkzqk/deepin-wine-ubuntu" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/wszqkzqk/deepin-wine-ubuntu</a></em></strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://gitee.com/wszqkzqk/deepin-wine-for-ubuntu.git</span><br><span class="line"><span class="built_in">cd</span> deepin-wine-for-ubuntu</span><br><span class="line">./install.sh</span><br></pre></td></tr></table></figure>
<blockquote>
<p> <strong>关于托盘</strong>：安装 <em>TopIconPlus</em> 的 gnome-shell 扩展。</p>
<p> 然后在所有软件中找到 <strong>优化 (Gnome-tweak-tool)</strong> ，在扩展中打开 <em>Topicons plus</em> 。</p>
</blockquote>
<p>在 <strong><em><a href="https://mirrors.aliyun.com/deepin/pool/non-free/d/" rel="external nofollow noopener noreferrer" target="_blank">https://mirrors.aliyun.com/deepin/pool/non-free/d/</a></em></strong> 中寻找需要的软件, 使用 <code>dpkg</code> 安装即可.</p>
<h3 id="企业微信"><a href="#企业微信" class="headerlink" title="企业微信"></a>企业微信</h3><p><strong><em><a href="https://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.weixin.work/" rel="external nofollow noopener noreferrer" target="_blank">https://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.weixin.work/</a></em></strong></p>
<p>安装完需要安装一下这个依赖, 不要会出现cpu彪高以及图片不能正常展示的问题:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install libjpeg62:i386</span><br></pre></td></tr></table></figure>
<h3 id="Wechat"><a href="#Wechat" class="headerlink" title="Wechat"></a>Wechat</h3><p><strong><em><a href="https://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.wechat/" rel="external nofollow noopener noreferrer" target="_blank">https://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.wechat/</a></em></strong></p>
<h3 id="微信开发者工具"><a href="#微信开发者工具" class="headerlink" title="微信开发者工具"></a>微信开发者工具</h3><p><strong><em><a href="https://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.wechat.devtools/" rel="external nofollow noopener noreferrer" target="_blank">https://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.wechat.devtools/</a></em></strong></p>
<p>确保安装了依赖:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libxtst6:i386</span><br></pre></td></tr></table></figure>
<h3 id="QQ"><a href="#QQ" class="headerlink" title="QQ"></a>QQ</h3><p><strong><em><a href="https://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.im/" rel="external nofollow noopener noreferrer" target="_blank">https://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.im/</a></em></strong></p>
<h2 id="GUI-SmartGit"><a href="#GUI-SmartGit" class="headerlink" title="GUI-SmartGit"></a>GUI-SmartGit</h2><p>git的一个GUI:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:eugenesan/ppa</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install smartgithg</span><br></pre></td></tr></table></figure>
<h2 id="SVN-GUI-SmartSVN"><a href="#SVN-GUI-SmartSVN" class="headerlink" title="SVN GUI-SmartSVN"></a>SVN GUI-SmartSVN</h2><p>下载地址: <strong><em><a href="https://www.smartsvn.com/download/" rel="external nofollow noopener noreferrer" target="_blank">https://www.smartsvn.com/download/</a></em></strong></p>
<p><code>smartsvn.license</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Name=csdn  </span><br><span class="line">Address=1337 iNViSiBLE Str.  </span><br><span class="line">Email=admin@csdn.net  </span><br><span class="line">FreeUpdatesUntil=2099-09-26  </span><br><span class="line">LicenseCount=1337  </span><br><span class="line">Addon-xMerge=true  </span><br><span class="line">Addon-API=true  </span><br><span class="line">Enterprise=true  </span><br><span class="line">Key=4kl-&lt;Zqcm-iUF7I-IVmYG-XAyvv-KYRoC-xlgsv-sSBds-VAnP6</span><br></pre></td></tr></table></figure>
<p>注册时, 选中上面文件就OK了.</p>
<h2 id="Typora-Markdown编辑器"><a href="#Typora-Markdown编辑器" class="headerlink" title="Typora(Markdown编辑器)"></a>Typora(Markdown编辑器)</h2><p><em><a href="https://typora.io/#linux" rel="external nofollow noopener noreferrer" target="_blank">官方</a></em> 安装方法如下: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -</span><br><span class="line">sudo add-apt-repository -y &apos;deb https://typora.io/linux ./&apos;</span><br><span class="line">sudo apt install typora</span><br></pre></td></tr></table></figure>
<p>如果加粗或斜体没有正确显示, 需要编辑 <code>github.css</code>(默认主题是Github), 将 <code>body</code> 标签中 <code>Open Sans</code> 改为 <code>Open Sans Regular</code></p>
<h2 id="GIF制作软件-Peek"><a href="#GIF制作软件-Peek" class="headerlink" title="GIF制作软件 Peek"></a>GIF制作软件 Peek</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:peek-developers/stable</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install peek</span><br></pre></td></tr></table></figure>
<p>终端执行<code>peek</code>即可运行</p>
<h2 id="KVM"><a href="#KVM" class="headerlink" title="KVM"></a>KVM</h2><p>KVM要求我们的CPU支持硬件虚拟化(hardware virtualization)．在终端里输入下面的命令来查看CPU是否支持硬件虚拟化: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">egrep -c &apos;(svm|vmx)&apos; /proc/cpuinfo</span><br></pre></td></tr></table></figure>
<p>如果上面的命令返回数字０, 就表示CPU不支持硬件虚拟化, 那么我们就只能使用<a href="http://www.linuxdashen.com/category/virtualbox" rel="external nofollow noopener noreferrer" target="_blank">Virtualbox</a>或VMware来创建虚拟机了．如果返回的数字大于０, 那么表示CPU支持硬件虚拟化, 我们就能使用KVM来创建虚拟机．</p>
<p>安装: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install qemu-kvm libvirt-bin ubuntu-vm-builder bridge-utils virt-manager virtinst virt-viewer</span><br></pre></td></tr></table></figure>
<p>Dash里打开virt-manager:</p>
<p><img src="https://cdn.yangbingdong.com/img/individuation/kvm-manager.png" alt></p>
<h2 id="SecureCRT"><a href="#SecureCRT" class="headerlink" title="SecureCRT"></a>SecureCRT</h2><h3 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h3><p>官方下载地址（选择Linux版deb包）: <strong><em><a href="https://www.vandyke.com/download/securecrt/download.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.vandyke.com/download/securecrt/download.html</a></em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i scrt-8.3.2-1584.ubuntu16-64.x86_64.deb</span><br></pre></td></tr></table></figure>
<h3 id="Crack"><a href="#Crack" class="headerlink" title="Crack"></a>Crack</h3><p>准备: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http://download.boll.me/securecrt_linux_crack.pl &amp;&amp; \</span><br><span class="line">sudo apt install perl</span><br></pre></td></tr></table></figure>
<p>查看一下SecureCRT的安装路径: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">whereis SecureCRT</span><br><span class="line"></span><br><span class="line"># 不出意外应该是在 /usr/bin/SecureCRT</span><br></pre></td></tr></table></figure>
<p>运行perl脚本: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo perl securecrt_linux_crack.pl /usr/bin/SecureCRT</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.yangbingdong.com/img/individuation/securecrt-crack.png" alt></p>
<p>然后按照提示手动输入License即可</p>
<h2 id="WPS"><a href="#WPS" class="headerlink" title="WPS"></a>WPS</h2><p>去 <em><a href="http://linux.wps.cn/" rel="external nofollow noopener noreferrer" target="_blank">wps官网</a></em> 下载wps for Linux.<br>先不要执行dpkg -i 去执行安装. 这个地方有个问题, 就是ubuntu 16 版本不支持32位的支持库, 所以需要安装一下支持库.<br>32位的支持库名为: ia32-libs<br>安装的时候会提示有替代包, 需要安装替代包. </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install lib32ncurses5 lib32z1</span><br></pre></td></tr></table></figure>
<p>还是不要执行dpkg -i , 因为即使现在安装还是会缺少一个依赖. 这个依赖是libpng-12.0. 不过这个在默认的apt 仓库里没有. 所以需要手动下载一下.<br>下载地址: <strong><em><a href="https://packages.debian.org/zh-cn/wheezy/amd64/libpng12-0/download" rel="external nofollow noopener noreferrer" target="_blank">https://packages.debian.org/zh-cn/wheezy/amd64/libpng12-0/download</a></em></strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i libpng12-0_1.2.49-1+deb7u2_amd64.deb</span><br></pre></td></tr></table></figure>
<p>最后:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i wps-office_10.1.0.5672~a21_amd64.deb</span><br></pre></td></tr></table></figure></p>
<h2 id="数据库建模工具"><a href="#数据库建模工具" class="headerlink" title="数据库建模工具"></a>数据库建模工具</h2><h3 id="PDMan"><a href="#PDMan" class="headerlink" title="PDMan"></a>PDMan</h3><p><strong><em><a href="http://www.pdman.cn/#/downLoad" rel="external nofollow noopener noreferrer" target="_blank">http://www.pdman.cn/#/downLoad</a></em></strong></p>
<p>在线打开 pmd 文件:</p>
<p><strong><em><a href="http://www.dmanywhere.cn/" rel="external nofollow noopener noreferrer" target="_blank">http://www.dmanywhere.cn/</a></em></strong></p>
<h2 id="有道云笔记客户端"><a href="#有道云笔记客户端" class="headerlink" title="有道云笔记客户端"></a>有道云笔记客户端</h2><p>官方并没有停 Linux 的客户端, 但 Github 有非官方的开源版:</p>
<p><strong><em><a href="https://github.com/jamasBian/youdao-note-electron" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/jamasBian/youdao-note-electron</a></em></strong></p>
<h2 id="坚果云同步"><a href="#坚果云同步" class="headerlink" title="坚果云同步"></a>坚果云同步</h2><p><strong><em><a href="https://www.jianguoyun.com/s/downloads/linux" rel="external nofollow noopener noreferrer" target="_blank">官网下载</a></em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo gdebi  nautilus_nutstore_amd64.deb</span><br></pre></td></tr></table></figure>
<h2 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h2><p>到<em><a href="https://www.google.com/chrome/browser/desktop/index.html" rel="external nofollow noopener noreferrer" target="_blank">chrome官网</a></em> 下载linux版的chrome.<br>不能翻墙的小朋友可以到<strong><em><a href="https://pan.baidu.com/s/1c2uyTEw" rel="external nofollow noopener noreferrer" target="_blank">博主的百度盘</a></em></strong> (密码: 9bpi)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i google-chrome-stable_current_amd64.deb</span><br></pre></td></tr></table></figure></p>
<p>或者通过apt安装:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo wget https://repo.fdzh.org/chrome/google-chrome.list -P /etc/apt/sources.list.d/ &amp;&amp; \</span><br><span class="line">wget -q -O - https://dl.google.com/linux/linux_signing_key.pub  | sudo apt-key add - &amp;&amp; \</span><br><span class="line">sudo apt update &amp;&amp; \</span><br><span class="line">sudo apt install google-chrome-stable</span><br></pre></td></tr></table></figure>
<h3 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h3><p>推荐几个不错的Chrome扩展:</p>
<table>
<thead>
<tr>
<th>插件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><em><a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif" rel="external nofollow noopener noreferrer" target="_blank">Proxy SwitchyOmega</a></em></strong></td>
<td>谁用谁知道…</td>
</tr>
<tr>
<td><strong><em><a href="https://chrome.google.com/webstore/detail/axure-rp-extension-for-ch/dogkpdfcklifaemcdfbildhcofnopogp" rel="external nofollow noopener noreferrer" target="_blank">Axure RP Extension for Chrome</a></em></strong></td>
<td>可以打开Axure原型文件</td>
</tr>
<tr>
<td><strong><em><a href="https://chrome.google.com/webstore/detail/gnome-shell-integration/gphhapmejobijbbhgpjhcjognlahblep" rel="external nofollow noopener noreferrer" target="_blank">GNOME Shell integration</a></em></strong></td>
<td>可用过Chrome扩展Gnome插件</td>
</tr>
<tr>
<td><strong><em><a href="https://chrome.google.com/webstore/detail/adblock-plus-free-ad-bloc/cfhdojbkjhnklbpkdaibdccddilifddb" rel="external nofollow noopener noreferrer" target="_blank">Adblock Plus</a></em></strong></td>
<td>广告拦截</td>
</tr>
<tr>
<td><strong><em><a href="https://chrome.google.com/webstore/detail/google-translate/aapbdbdomjkkjkaonfhkkikfgjllcleb" rel="external nofollow noopener noreferrer" target="_blank">Google translate</a></em></strong></td>
<td>谷歌翻译</td>
</tr>
<tr>
<td><strong><em><a href="https://chrome.google.com/webstore/detail/elasticsearch-head/ffmkiejjmecolpfloofpjologoblkegm" rel="external nofollow noopener noreferrer" target="_blank">ElasticSearch Head</a></em></strong></td>
<td>ElasticSearch Head Chome插件</td>
</tr>
<tr>
<td><strong><em><a href="https://github.com/acgotaku/BaiduExporter" rel="external nofollow noopener noreferrer" target="_blank">BaiduExporter</a></em></strong></td>
<td>导出百度盘链接</td>
</tr>
<tr>
<td><strong><em><a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc" rel="external nofollow noopener noreferrer" target="_blank">Octotree</a></em></strong></td>
<td>Github左侧展示树状结构</td>
</tr>
<tr>
<td><strong><em><a href="https://chrome.google.com/webstore/detail/enhanced-github/anlikcnbgdeidpacdbdljnabclhahhmd" rel="external nofollow noopener noreferrer" target="_blank">Enhanced Github</a></em></strong></td>
<td>可下载Github中单个文件</td>
</tr>
<tr>
<td><strong><em><a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo" rel="external nofollow noopener noreferrer" target="_blank">Tampermonkey</a></em></strong></td>
<td>油猴, 脚本网站: <em><a href="https://greasyfork.org/zh-CN" rel="external nofollow noopener noreferrer" target="_blank">https://greasyfork.org/zh-CN</a></em>, <em><a href="https://openuserjs.org/" rel="external nofollow noopener noreferrer" target="_blank">https://openuserjs.org/</a></em></td>
</tr>
<tr>
<td><strong><em><a href="https://chrome.google.com/webstore/detail/crxmouse-chrome-gestures/jlgkpaicikihijadgifklkbpdajbkhjo" rel="external nofollow noopener noreferrer" target="_blank">CrxMouse Chrome™ Gestures</a></em></strong></td>
<td>高度可自定义的鼠标手势, 超级拖拽, 鼠标滚轮手势, 遥感手势, 提升工作效率</td>
</tr>
<tr>
<td><strong><em><a href="https://chrome.google.com/webstore/detail/%E6%8E%98%E9%87%91/lecdifefmmfjnjjinhaennhdlmcaeeeb" rel="external nofollow noopener noreferrer" target="_blank">掘金</a></em></strong></td>
<td>为程序员、设计师、产品经理每日发现优质内容</td>
</tr>
<tr>
<td><strong><em><a href="https://chrome.google.com/webstore/detail/atom-file-icons-web/pljfkbaipkidhmaljaaakibigbcmmpnc" rel="external nofollow noopener noreferrer" target="_blank">Atom File Icons Web</a></em></strong></td>
<td>修改 Github 或者 Bitbucket 上面的图标</td>
</tr>
</tbody>
</table>
<h2 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h2><h3 id="Shutter"><a href="#Shutter" class="headerlink" title="Shutter"></a>Shutter</h3><p><code>Ubuntu</code>下很强大的一款截图软件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install shutter</span><br></pre></td></tr></table></figure>
<p><strong>设置快捷键: </strong><br>打开系统设置 -&gt; <code>键盘</code> -&gt; <code>快捷键</code> -&gt; <code>自定义快捷键</code> -&gt; <code>点击&quot; + &quot;</code><br>名字随便起, 命令: <code>shutter -s</code><br>点击确定, 再点禁用, 键盘按下<code>ctrl+alt+a</code>, 完成设置</p>
<h4 id="编辑按钮变成程灰色解决方法"><a href="#编辑按钮变成程灰色解决方法" class="headerlink" title="编辑按钮变成程灰色解决方法"></a>编辑按钮变成程灰色解决方法</h4><p>需要3个deb包: </p>
<p><em><a href="https://launchpad.net/ubuntu/+archive/primary/+files/libgoocanvas-common_1.0.0-1_all.deb" rel="external nofollow noopener noreferrer" target="_blank">libgoocanvas-common</a></em></p>
<p><em><a href="https://launchpad.net/ubuntu/+archive/primary/+files/libgoocanvas3_1.0.0-1_amd64.deb" rel="external nofollow noopener noreferrer" target="_blank">libgoocanvas3</a></em></p>
<p><em><a href="https://launchpad.net/ubuntu/+archive/primary/+files/libgoo-canvas-perl_0.06-2ubuntu3_amd64.deb" rel="external nofollow noopener noreferrer" target="_blank">libgoo-canvas-perl</a></em></p>
<p>或者: <strong><em><a href="https://pan.baidu.com/s/1c2uyTEw" rel="external nofollow noopener noreferrer" target="_blank">博主的百度盘</a></em></strong> (密码: 9bpi) (提取路径: <code>UbuntuTools -&gt; shutter-1804-editor.zip</code>)</p>
<p>依次使用<code>dpkg</code>命令安装, 报错使用<code>sudo apt-get -f install</code>修复</p>
<p>最后重启Shutter进程就好了</p>
<h3 id="Deepin-Screenshot"><a href="#Deepin-Screenshot" class="headerlink" title="Deepin Screenshot"></a>Deepin Screenshot</h3><p>这个是Deepin开发的截图工具, 目前已经可以在软件商店中找到:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install deepin-screenshot</span><br></pre></td></tr></table></figure>
<p>然后跟上面的Shutter一样设置快捷键就可以了, 命令是<code>deepin-screenshot</code></p>
<h2 id="系统清理软件-BleachBit"><a href="#系统清理软件-BleachBit" class="headerlink" title="系统清理软件 BleachBit"></a>系统清理软件 BleachBit</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install -y bleachbit</span><br></pre></td></tr></table></figure>
<h2 id="下载相关"><a href="#下载相关" class="headerlink" title="下载相关"></a>下载相关</h2><h3 id="多协议下载器-Aria2"><a href="#多协议下载器-Aria2" class="headerlink" title="多协议下载器 Aria2"></a>多协议下载器 Aria2</h3><blockquote>
<p>aria2: <strong><em><a href="https://github.com/aria2/aria2" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/aria2/aria2</a></em></strong></p>
<p>部分使用说明: <strong><em><a href="https://aria2c.com/usage.html" rel="external nofollow noopener noreferrer" target="_blank">https://aria2c.com/usage.html</a></em></strong></p>
</blockquote>
<p>一般在Linux环境中下载东西都是比较不友好的, 不支持多种协议, 方式单一, 但这款Aria2就是为了解决多协议问题而诞生的, 配合UI界面可以很方便地<del>随心所欲</del>地下载. </p>
<h4 id="直接安装"><a href="#直接安装" class="headerlink" title="直接安装"></a>直接安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install aria2</span><br></pre></td></tr></table></figure>
<p>添加配置文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mkdir /etc/aria2</span><br><span class="line">sudo touch /etc/aria2/aria2.session</span><br><span class="line">sudo chmod 777 /etc/aria2/aria2.session</span><br><span class="line">sudo gedit /etc/aria2/aria2.conf</span><br></pre></td></tr></table></figure>
<p>配置文件可参考: <strong><em><a href="https://github.com/fsaimon/aria2.conf" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/fsaimon/aria2.conf</a></em></strong></p>
<p>后台运行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo aria2c --conf-path=/etc/aria2/aria2.conf -D</span><br></pre></td></tr></table></figure>
<h4 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h4><ol>
<li><strong><em><a href="https://ugetdm.com/" rel="external nofollow noopener noreferrer" target="_blank">Uget</a></em></strong></li>
<li>chrome 扩展 <strong><em><a href="https://chrome.google.com/webstore/detail/yaaw-for-chrome/dennnbdlpgjgbcjfgaohdahloollfgoc" rel="external nofollow noopener noreferrer" target="_blank">YAAW for Chrome</a></em></strong></li>
</ol>
<h4 id="通过-Docker-搭建-Aria2-以及-AriaNg-Web-UI"><a href="#通过-Docker-搭建-Aria2-以及-AriaNg-Web-UI" class="headerlink" title="通过 Docker 搭建 Aria2 以及 AriaNg Web UI"></a>通过 Docker 搭建 Aria2 以及 AriaNg Web UI</h4><p><img src="https://cdn.yangbingdong.com/img/individuation/aria2-ariaNg.jpg" alt></p>
<blockquote>
<p>博主选择使用Docker</p>
</blockquote>
<p>参考 <em><a href="https://github.com/wahyd4/aria2-ariang-docker" rel="external nofollow noopener noreferrer" target="_blank">aria2-ariang-docker</a></em> 以及 <em><a href="https://github.com/wahyd4/aria2-ariang-x-docker-compose" rel="external nofollow noopener noreferrer" target="_blank">aria2-ariang-x-docker-compose</a></em></p>
<h5 id="配置aria2-conf"><a href="#配置aria2-conf" class="headerlink" title="配置aria2.conf"></a>配置<code>aria2.conf</code></h5><p>这个文件是从作者地 Github下载下来的, 主要加了代理, 而这个代理是 <code>sock5</code> 通过 <code>privoxy</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#所有协议代理</span><br><span class="line">all-proxy=http://192.168.6.113:8118</span><br><span class="line">#用户名</span><br><span class="line">#rpc-user=user</span><br><span class="line">#密码</span><br><span class="line">#rpc-passwd=passwd</span><br><span class="line">#上面的认证方式不建议使用,建议使用下面的token方式</span><br><span class="line">#设置加密的密钥</span><br><span class="line">#rpc-secret=token</span><br><span class="line">#允许rpc</span><br><span class="line">enable-rpc=true</span><br><span class="line">#允许所有来源, web界面跨域权限需要</span><br><span class="line">rpc-allow-origin-all=true</span><br><span class="line">#允许外部访问，false的话只监听本地端口</span><br><span class="line">rpc-listen-all=true</span><br><span class="line">#RPC端口, 仅当默认端口被占用时修改</span><br><span class="line">#rpc-listen-port=6800</span><br><span class="line">#最大同时下载数(任务数), 路由建议值: 3</span><br><span class="line">max-concurrent-downloads=5</span><br><span class="line">#断点续传</span><br><span class="line">continue=true</span><br><span class="line">#同服务器连接数</span><br><span class="line">max-connection-per-server=5</span><br><span class="line">#最小文件分片大小, 下载线程数上限取决于能分出多少片, 对于小文件重要</span><br><span class="line">min-split-size=2M</span><br><span class="line">#单文件最大线程数, 路由建议值: 5</span><br><span class="line">split=10</span><br><span class="line">#下载速度限制</span><br><span class="line">max-overall-download-limit=0</span><br><span class="line">#单文件速度限制</span><br><span class="line">max-download-limit=0</span><br><span class="line">#上传速度限制</span><br><span class="line">max-overall-upload-limit=0</span><br><span class="line">#单文件速度限制</span><br><span class="line">max-upload-limit=0</span><br><span class="line">#断开速度过慢的连接</span><br><span class="line">#lowest-speed-limit=0</span><br><span class="line">#验证用，需要1.16.1之后的release版本</span><br><span class="line">#referer=*</span><br><span class="line">#文件保存路径, 默认为当前启动位置</span><br><span class="line"># dir=/user-files/superuser/</span><br><span class="line">dir=/data</span><br><span class="line">#文件缓存, 使用内置的文件缓存, 如果你不相信Linux内核文件缓存和磁盘内置缓存时使用, 需要1.16及以上版本</span><br><span class="line">#disk-cache=0</span><br><span class="line">#另一种Linux文件缓存方式, 使用前确保您使用的内核支持此选项, 需要1.15及以上版本(?)</span><br><span class="line">enable-mmap=true</span><br><span class="line">#文件预分配, 能有效降低文件碎片, 提高磁盘性能. 缺点是预分配时间较长</span><br><span class="line">#所需时间 none &lt; falloc ? trunc « prealloc, falloc和trunc需要文件系统和内核支持</span><br><span class="line">file-allocation=prealloc</span><br><span class="line"></span><br><span class="line"># General Options</span><br><span class="line">log=/var/log/aria2.log</span><br><span class="line">#You can set either debug, info, notice, warn or error.</span><br><span class="line">log-level=error</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 进度保存相关 ##</span><br><span class="line"># 从会话文件中读取下载任务</span><br><span class="line">input-file=/root/conf/aria2.session</span><br><span class="line"># 在Aria2退出时保存`错误/未完成`的下载任务到会话文件</span><br><span class="line">save-session=/root/conf/aria2.session</span><br><span class="line"># 定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0</span><br><span class="line">save-session-interval=10</span><br><span class="line"></span><br><span class="line"># BT trackers from https://raw.githubusercontent.com/ngosang/trackerslist/master/trackers_best.txt</span><br><span class="line">bt-tracker=udp://tracker.leechers-paradise.org:6969/announce, udp://tracker.internetwarriors.net:1337/announce, udp://tracker.opentrackr.org:1337/announce, udp://9.rarbg.to:2710/announce, udp://tracker.coppersurfer.tk:6969/announce, udp://exodus.desync.com:6969/announce, udp://explodie.org:6969/announce, http://tracker3.itzmx.com:6961/announce, udp://tracker1.itzmx.com:8080/announce, udp://tracker.tiny-vps.com:6969/announce, udp://thetracker.org:80/announce, udp://open.demonii.si:1337/announce, udp://denis.stalker.upeer.me:6969/announce, udp://bt.xxx-tracker.com:2710/announce, http://tracker4.itzmx.com:2710/announce, udp://tracker2.itzmx.com:6961/announce, udp://tracker.torrent.eu.org:451/announce, udp://tracker.port443.xyz:6969/announce, udp://tracker.cyberia.is:6969/announce, udp://open.stealth.si:80/announce</span><br></pre></td></tr></table></figure>
<h5 id="使用h5ai作为文件管理器"><a href="#使用h5ai作为文件管理器" class="headerlink" title="使用h5ai作为文件管理器"></a>使用h5ai作为文件管理器</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &apos;3.4&apos;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  h5ai:</span><br><span class="line">    image: bixidock/h5ai</span><br><span class="line">    volumes:</span><br><span class="line">      - /home/ybd/data/docker/aria2/data:/var/www</span><br><span class="line">    restart: always</span><br><span class="line">  aria2:</span><br><span class="line">    image: wahyd4/aria2-ui:h5ai</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8000:80&quot;</span><br><span class="line">      - &quot;6800:6800&quot;</span><br><span class="line">    volumes:</span><br><span class="line">    #   - /some_folder:/root/conf/key</span><br><span class="line">      - /home/ybd/data/docker/aria2/config/aria2.conf:/root/conf/aria2.conf</span><br><span class="line">      - /home/ybd/data/docker/aria2/config/aria2.session:/root/conf/aria2.session</span><br><span class="line">      - /home/ybd/data/docker/aria2/cache/dht.dat:/root/.cache/aria2/dht.dat</span><br><span class="line">      - /home/ybd/data/docker/aria2/data:/data</span><br><span class="line">    environment:</span><br><span class="line">      - DOMAIN=:80</span><br><span class="line">      # - SSL=true</span><br><span class="line">      # - RPC_SECRET=Hello</span><br><span class="line">      # - ARIA2_USER=admin</span><br><span class="line">      # - ARIA2_PWD=password</span><br><span class="line">      # - ENABLE_AUTH=true</span><br><span class="line">    links:</span><br><span class="line">      - h5ai:file-manager</span><br><span class="line">    restart: always</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.yangbingdong.com/img/individuation/h5ai.jpg" alt></p>
<ol>
<li>查看文件h5ai： <em><a href="http://localhost:8000/" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8000</a></em></li>
<li>AriaNg： <em><a href="http://localhost:8000/aria2/" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:8000/aria2/</a></em> 注意地址后面一定要带<code>/</code> </li>
</ol>
<h3 id="Motrix"><a href="#Motrix" class="headerlink" title="Motrix"></a>Motrix</h3><p><strong><em><a href="https://github.com/agalwood/Motrix" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/agalwood/Motrix</a></em></strong></p>
<h3 id="其他下载器"><a href="#其他下载器" class="headerlink" title="其他下载器"></a>其他下载器</h3><p>一款跨平台的快速，简单，干净的视频下载器：Annie，支持Bilibili/Youtube等多个网站: <strong><em><a href="https://github.com/iawia002/annie" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/iawia002/annie</a></em></strong></p>
<p>一款开源、免费带Web面板的多功能下载神器: <strong><em><a href="https://github.com/pyload/pyload" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/pyload/pyload</a></em></strong></p>
<h3 id="磁力搜"><a href="#磁力搜" class="headerlink" title="磁力搜"></a>磁力搜</h3><p>磁力链接聚合搜索: <strong><em><a href="https://github.com/xiandanin/magnetW" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/xiandanin/magnetW</a></em></strong></p>
<p><strong>注意</strong>: 这个默认需要9000端口, 所以打开前确保9000端口没有被占用.</p>
<h3 id="bugstag"><a href="#bugstag" class="headerlink" title="bugstag"></a>bugstag</h3><p><strong><em><a href="https://github.com/gxtrobot/bustag" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/gxtrobot/bustag</a></em></strong></p>
<h2 id="百度网盘相关"><a href="#百度网盘相关" class="headerlink" title="百度网盘相关"></a>百度网盘相关</h2><h3 id="BaiduExporter"><a href="#BaiduExporter" class="headerlink" title="BaiduExporter"></a>BaiduExporter</h3><blockquote>
<p>官方是这么说明的</p>
<ul>
<li>Chrome : Click Settings -&gt; Extensions, drag BaiduExporter.crx file to the page, install it, or check Developer mode -&gt; Load unpacked extension, navigate to the chrome/release folder.</li>
<li>Firefox : Open about:debugging in Firefox, click “Load Temporary Add-on” and navigate to the chrome/release folder, select manifest.json, click OK.</li>
</ul>
</blockquote>
<p>1、到 <em><a href="https://github.com/acgotaku/BaiduExporter" rel="external nofollow noopener noreferrer" target="_blank">Github</a></em> 下载源码</p>
<p>2、打开Chrome -&gt; 扩展程序 -&gt; 勾选开发者模式 -&gt; 加载已解压的扩展程序 , 然后会弹出文件框, 找到刚才下载的源码, 找到chrome -&gt; release, 添加成功！</p>
<p>3、打开百度云盘网页版, 勾选需要下载的文件, 在上方会出现导出下载地选项, 通过设置可以修改RCP地址</p>
<p><img src="https://cdn.yangbingdong.com/img/individuation/baiduexporter1.jpg" alt><br><img src="https://cdn.yangbingdong.com/img/individuation/baiduexporter2.jpg" alt></p>
<h3 id="BaiduPCS-Go"><a href="#BaiduPCS-Go" class="headerlink" title="BaiduPCS-Go"></a>BaiduPCS-Go</h3><p>这里还有一个很有意思的通过终端与百度盘交互的项目: <strong><em><a href="https://github.com/iikira/BaiduPCS-Go" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/iikira/BaiduPCS-Go</a></em></strong></p>
<h3 id="百度网盘直接下载助手"><a href="#百度网盘直接下载助手" class="headerlink" title="百度网盘直接下载助手"></a>百度网盘直接下载助手</h3><p>1、安装 <em><a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?hl=zh-CN" rel="external nofollow noopener noreferrer" target="_blank">Tampermonkey</a></em> Chrome插件, 这个主要是管理脚本的, 下面安装百度云盘脚本需要用到</p>
<p>2、进入 <em><a href="https://greasyfork.org/zh-CN/scripts/36549-%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E5%8A%A9%E6%89%8B-%E6%98%BE%E7%A4%BA%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E5%85%A5%E5%8F%A3" rel="external nofollow noopener noreferrer" target="_blank">百度网盘直接下载助手(显示直接下载入口)</a></em> , 点击<code>安装</code>或者<code>install</code>,完了直接刷新界面, 进入到自己的百度云盘选择所需的下载文件即可. </p>
<h3 id="pan-light"><a href="#pan-light" class="headerlink" title="pan-light"></a>pan-light</h3><p>百度网盘不限速客户端, golang + qt5, 跨平台图形界面: <strong><em><a href="https://github.com/peterq/pan-light" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/peterq/pan-light</a></em></strong></p>
<h2 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h2><h3 id="Stardict火星译王"><a href="#Stardict火星译王" class="headerlink" title="Stardict火星译王"></a>Stardict火星译王</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install stardict</span><br></pre></td></tr></table></figure>
<p><strong>安装词库: </strong><br>进入<em><a href="http://download.huzheng.org/" rel="external nofollow noopener noreferrer" target="_blank">http://download.huzheng.org/</a></em><br>选择所需词库并下载, <code>a</code>为下载的词库名, 然后重启<code>stardict</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xjvf a.tar.bz2</span><br><span class="line">mv a /usr/share/stardict/dic</span><br></pre></td></tr></table></figure>
<h3 id="golddict翻译"><a href="#golddict翻译" class="headerlink" title="golddict翻译"></a>golddict翻译</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install goldendict</span><br></pre></td></tr></table></figure>
<p>在 编辑 -&gt; 词典 中添加有道翻译 <code>http://dict.youdao.com/search?q=%GDWORD%&amp;ue=utf8</code>, 再禁用其他翻译源.</p>
<p>选中英文, 按 <code>Ctrl</code> + <code>C</code> + <code>C</code> 即可弹出翻译界面.</p>
<h2 id="备份工具-Timeshift"><a href="#备份工具-Timeshift" class="headerlink" title="备份工具 Timeshift"></a>备份工具 Timeshift</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository -y ppa:teejee2008/ppa</span><br><span class="line">sudo apt install -y timeshift</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.yangbingdong.com/img/individuation/time-shift.png" alt></p>
<h2 id="Albert"><a href="#Albert" class="headerlink" title="Albert"></a>Albert</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install curl</span><br><span class="line">curl https://build.opensuse.org/projects/home:manuelschneid3r/public_key | sudo apt-key add -</span><br><span class="line">sudo sh -c <span class="string">"echo 'deb http://download.opensuse.org/repositories/home:/manuelschneid3r/xUbuntu_18.04/ /' &gt; /etc/apt/sources.list.d/home:manuelschneid3r.list"</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install albert</span><br></pre></td></tr></table></figure>
<p>第一次打开的时候需要设置快捷键, 推荐 <code>Ctrl</code> + <code>~</code>.</p>
<p>隐藏 Albert 图标只需要在设置中将 <code>showTray</code> 的勾选去除即可.</p>
<blockquote>
<p>去除图标之后设置就不知道怎么按出来了, 这时候可以在 <code>/home/{USER}/.config/albert/albert.conf</code> 中配置.</p>
<p>或者通过快捷键按出 Albert 输入栏, 设置一般在输入栏的右上角.</p>
</blockquote>
<h2 id="PostMan"><a href="#PostMan" class="headerlink" title="PostMan"></a>PostMan</h2><p>下载: <strong><em><a href="https://www.getpostman.com/downloads/" rel="external nofollow noopener noreferrer" target="_blank">https://www.getpostman.com/downloads/</a></em></strong></p>
<p>Json Body 字体问题:</p>
<p>在Linux中, postman 的 body 和 response 使用的默认字体如果没有安装的话, 会导致字体和光标的位置不一致, 例如字体显示长度只有30, 而光标在70的位置, 导致编辑困难.</p>
<p>解决:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo wget -P /usr/share/fonts/custom https://github.com/fangwentong/dotfiles/raw/master/ubuntu-gui/fonts/Monaco.ttf</span><br><span class="line">sudo chmod 744 /usr/share/fonts/custom/Monaco.ttf</span><br><span class="line">sudo mkfontscale  &amp;&amp; sudo mkfontdir &amp;&amp; sudo <span class="built_in">fc</span>-cache -fv</span><br></pre></td></tr></table></figure>
<h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><h3 id="Charles"><a href="#Charles" class="headerlink" title="Charles"></a>Charles</h3><blockquote>
<p>官网下载地址: <strong><em><a href="https://www.charlesproxy.com/download/" rel="external nofollow noopener noreferrer" target="_blank">https://www.charlesproxy.com/download/</a></em></strong></p>
</blockquote>
<p>apt 安装:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -q -O - https://www.charlesproxy.com/packages/apt/PublicKey | sudo apt-key add </span><br><span class="line">sudo sh -c <span class="string">'echo deb https://www.charlesproxy.com/packages/apt/ charles-proxy main &gt; /etc/apt/sources.list.d/charles.list'</span></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install -y charles-proxy</span><br></pre></td></tr></table></figure>
<h2 id="硬件信息"><a href="#硬件信息" class="headerlink" title="硬件信息"></a>硬件信息</h2><h3 id="I-Nex"><a href="#I-Nex" class="headerlink" title="I-Nex"></a>I-Nex</h3><p>这是一个类似CPU-Z的工具</p>
<p>下载链接: <strong><em><a href="https://launchpad.net/i-nex/+download" rel="external nofollow noopener noreferrer" target="_blank">https://launchpad.net/i-nex/+download</a></em></strong></p>
<p><img src="https://cdn.yangbingdong.com/img/individuation/I-Nex%20-%20CPU_001.png" alt></p>
<h3 id="Hardinfo"><a href="#Hardinfo" class="headerlink" title="Hardinfo"></a>Hardinfo</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install hardinfo -y</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.yangbingdong.com/img/individuation/System%20Information_002.png" alt></p>
<h1 id="其他设置篇"><a href="#其他设置篇" class="headerlink" title="其他设置篇"></a>其他设置篇</h1><h2 id="Grub2"><a href="#Grub2" class="headerlink" title="Grub2"></a>Grub2</h2><h3 id="设置引导等待时间"><a href="#设置引导等待时间" class="headerlink" title="设置引导等待时间"></a>设置引导等待时间</h3><p><code>Ubuntu</code>系统的<code>Grub2</code>菜单的相关信息在读取<code>/boot/grub/grub.cfg</code>文件, 不过<code>Ubuntu</code>官方不建议直接修改这个文件, 想要修改<code>Grub2</code>的等待时间还可以修改<code>/etc/deafalt/grub</code>来实现. 具体的修改方法如下: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo gedit /etc/default/grub</span><br></pre></td></tr></table></figure>
<p>将<code>GRUB_TIMEOUT=10</code>中的<code>10</code>改为你想要修改的等待时间, 比如<code>3</code>, 网上很多的教程都是到这一步, 其实是不行的, 估计都是乱转一气. 到这里还有最重要的一步, 就是使用<code>#</code>号将<code>GRUB_HIDDEN_TIMEOUT=0</code>标注,然后再次回到终端, 输入下面的命令刷新<code>/boot/grub/grub.cfg</code>文件:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo update-grub2</span><br></pre></td></tr></table></figure></p>
<h3 id="Grub-Customizer"><a href="#Grub-Customizer" class="headerlink" title="Grub Customizer"></a>Grub Customizer</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository -y ppa:danielrichter2007/grub-customizer</span><br><span class="line">sudo apt install grub-customizer</span><br></pre></td></tr></table></figure>
<p>修改保存后更新配置文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo update-grub</span><br></pre></td></tr></table></figure>
<h2 id="启动项管理"><a href="#启动项管理" class="headerlink" title="启动项管理"></a>启动项管理</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gnome-session-properties</span><br></pre></td></tr></table></figure>
<h2 id="提高逼格"><a href="#提高逼格" class="headerlink" title="提高逼格"></a>提高逼格</h2><h3 id="screenfetch"><a href="#screenfetch" class="headerlink" title="screenfetch"></a>screenfetch</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install screenfetch</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.yangbingdong.com/img/individuation/screenfetch.png" alt></p>
<h3 id="edex-ui"><a href="#edex-ui" class="headerlink" title="edex-ui"></a>edex-ui</h3><blockquote>
<p><strong><em><a href="https://github.com/GitSquared/edex-ui" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/GitSquared/edex-ui</a></em></strong></p>
</blockquote>
<p>在Release页面中下载AppImage运行即可:</p>
<p><img src="https://cdn.yangbingdong.com/img/individuation/eDEX-UI.png" alt></p>
<h3 id="终端高逼格屏保"><a href="#终端高逼格屏保" class="headerlink" title="终端高逼格屏保"></a>终端高逼格屏保</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install cmatrix</span><br><span class="line">cmatrix -b</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.yangbingdong.com/img/individuation/cmatrix.png" alt></p>
<p>够骚气. . . </p>
<h2 id="键盘输入声音特效（Tickys）"><a href="#键盘输入声音特效（Tickys）" class="headerlink" title="键盘输入声音特效（Tickys）"></a>键盘输入声音特效（Tickys）</h2><p><strong><em><a href="http://www.yingdev.com/projects/tickeys" rel="external nofollow noopener noreferrer" target="_blank">官网</a></em></strong> 或者 <strong><em><a href="https://pan.baidu.com/s/1c2uyTEw" rel="external nofollow noopener noreferrer" target="_blank">博主的百度盘</a></em></strong> (密码: 9bpi)</p>
<p>Tickeys依赖 <code>gksu</code>, 然而 <code>gksu</code> 在Ubuntu18之后被移除了, 所以想要安装还需要装回 <code>gksu</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF | sudo tee /etc/apt/sources.list.d/artful.list</span><br><span class="line">deb http://archive.ubuntu.com/ubuntu/ artful universe</span><br><span class="line">EOF</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install -i gksu</span><br><span class="line">sudo dpkg -i tickeys_0.2.5_amd64.deb</span><br><span class="line"></span><br><span class="line"># 如有依赖未安装</span><br><span class="line">sudo apt install -f</span><br></pre></td></tr></table></figure>
<p>然后通过<code>sudo tickeys</code>来打开 (sudo tickeys -c 打开CLI版本)<br><img src="https://cdn.yangbingdong.com/img/individuation/tickeys_v0.2.5.png" alt></p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="软件图标（-desktop）文件位置"><a href="#软件图标（-desktop）文件位置" class="headerlink" title="软件图标（.desktop）文件位置"></a>软件图标（.desktop）文件位置</h2><ul>
<li><code>/usr/share/applications</code> # 大部分启动图标都在此</li>
<li><code>~/.local/share/applications</code> # 一部分本地图标</li>
<li><code>/var/lib/snapd/desktop/applications</code> # snap 类软件在此</li>
</ul>
<h2 id="生成软件图标工具"><a href="#生成软件图标工具" class="headerlink" title="生成软件图标工具"></a>生成软件图标工具</h2><p>工具安装:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install gnome-panel</span><br></pre></td></tr></table></figure>
<p>创建:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo gnome-desktop-item-edit /usr/share/applications/ --create-new</span><br></pre></td></tr></table></figure>
<p>然后会弹出一个框, 在里面选择命令以及图标生成即可.</p>
<h2 id="gsetting-与-dconf"><a href="#gsetting-与-dconf" class="headerlink" title="gsetting 与 dconf"></a>gsetting 与 dconf</h2><p>gsetting 与 dconf 是 Linux Gnome下实现对应用程序的配置及管理功能的工具.</p>
<p>gsetting命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#gsettings list-schemas             显示系统已安装的不可重定位的schema</span><br><span class="line">#gsettings list-relocatable-schemas 显示已安装的可重定位的schema</span><br><span class="line">#gsettings list-children SCHEMA     显示指定schema的children，其中SCHEMA指xml文件中schema的id属性值，例如实例中的&quot;org.lili.test.app.testgsettings&quot;</span><br><span class="line">#gsettings list-keys SCHEMA         显示指定schema的所有项(key)</span><br><span class="line">#gsettings range SCHEMA KEY         查询指定schema的指定项KEY的有效取值范围</span><br><span class="line">#gsettings get SCHEMA KEY           显示指定schema的指定项KEY的值</span><br><span class="line">#gsettings set SCHEMA KEY VALUE     设置指定schema的指定项KEY的值为VALUE</span><br><span class="line">#gsettings reset SCHEMA KEY         恢复指定schema的指定项KEY的值为默认值</span><br><span class="line">#gsettings reset-recursively SCHEMA 恢复指定schema的所有key的值为默认值</span><br><span class="line">#gsettings list-recursively [SCHEMA]如果有SCHEMA参数，则递归显示指定schema的所有项(key)和值(value)，如果没有SCHEMA参数，则递归显示所有schema的所有项(key)和值(value)</span><br></pre></td></tr></table></figure>
<p>dconf 可以实现配置的导入与导出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dconf dump /org/gnome/shell/extensions/dynamic-top-bar/ &gt; ~/backup.txt</span><br><span class="line"></span><br><span class="line">dconf load /org/gnome/shell/extensions/topicons/ &lt;&lt;- EOF</span><br><span class="line">[/]</span><br><span class="line">icon-size=24</span><br><span class="line">icon-spacing=12</span><br><span class="line">tray-pos=&apos;right&apos;</span><br><span class="line">tray-order=1</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>也可以使用 <code>dconf-editor</code> 对其进行管理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install -y dconf-editor</span><br></pre></td></tr></table></figure>
<h2 id="强制清空回收站"><a href="#强制清空回收站" class="headerlink" title="强制清空回收站"></a>强制清空回收站</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rm -rf $HOME/.local/share/Trash/files/*</span><br></pre></td></tr></table></figure>
<h2 id="终端写出图形文字"><a href="#终端写出图形文字" class="headerlink" title="终端写出图形文字"></a>终端写出图形文字</h2><p><strong><em><a href="http://patorjk.com/software/taag/#p=display&amp;f=Slant&amp;t=Composer" rel="external nofollow noopener noreferrer" target="_blank">Text to ASCII Art Generator</a></em></strong></p>
<h2 id="其他-Ubuntu-衍生版"><a href="#其他-Ubuntu-衍生版" class="headerlink" title="其他 Ubuntu 衍生版"></a>其他 Ubuntu 衍生版</h2><ul>
<li><strong><em><a href="https://elementary.io/zh_CN/" rel="external nofollow noopener noreferrer" target="_blank">Elementary OS</a></em></strong></li>
<li><strong><em><a href="https://www.linuxmint.com/" rel="external nofollow noopener noreferrer" target="_blank">Linux Mint</a></em></strong></li>
<li><strong><em><a href="https://zorinos.com/" rel="external nofollow noopener noreferrer" target="_blank">Zorin OS</a></em></strong></li>
</ul>
<h1 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h1><blockquote>
<p>参考: </p>
<ul>
<li><strong><em><a href="https://inkss.cn/2018/09/12/ubuntu-1804-installation-record/" rel="external nofollow noopener noreferrer" target="_blank">https://inkss.cn/2018/09/12/ubuntu-1804-installation-record/</a></em></strong></li>
<li><strong><em><a href="https://blog.diqigan.cn/posts/ubuntu-18-10-beautify.html" rel="external nofollow noopener noreferrer" target="_blank">https://blog.diqigan.cn/posts/ubuntu-18-10-beautify.html</a></em></strong></li>
</ul>
</blockquote>
<p>使用Ubuntu的这一路过来跌跌撞撞, 摸爬滚打不断解决各种奇怪的系统问题, 磨合了也有好长一段日子, 重装系统的次数也数不过来了. . . 给我最大的收获并不是觉得自己用Ubuntu用得多牛X, 而是修身养性. . . </p>
<p>本文将定期更新, 与时俱进~</p>
]]></content><categories><category>OperatingSystem</category><category>Ubuntu</category></categories><tags><tag>Ubuntu</tag></tags></entry><entry><title>V2Proxy 正确的代理模式</title><url>/2017/v2proxy/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/vps/whats-shadowsocks-04.png" alt></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><blockquote>
<p>作为一名开发人员, 日常离不开 Google, 那么在这之前, 必须要先学会如何代理.</p>
<p>本人 <strong><em><a href="https://www.linode.com/" rel="external nofollow noopener noreferrer" target="_blank">Linode</a></em></strong> 邀请码: <code>79e24952d46644605b071a55c4fda3b23e1d1a5a</code> </p>
</blockquote>
<a id="more"></a>
<h1 id="代理方式介绍"><a href="#代理方式介绍" class="headerlink" title="代理方式介绍"></a>代理方式介绍</h1><blockquote>
<p>核心原理都一样, 如上方图所示. 推荐使用 <strong><em><a href="https://github.com/trojan-gfw/trojan" rel="external nofollow noopener noreferrer" target="_blank">Trojan</a></em></strong>.</p>
</blockquote>
<ul>
<li><strong><em><a href="https://shadowsocks.org/" rel="external nofollow noopener noreferrer" target="_blank">Shadowsocks</a></em></strong>: 过去比较常用, 据说如今 GFW 已经能够识别出, 所以经常掉链子.</li>
<li><strong><em><a href="https://www.v2ray.com/" rel="external nofollow noopener noreferrer" target="_blank">V2ray</a></em></strong>: Go 语言开发的高性能网络工具集, 服务端客户端于一体, 功能比较多, 支持 Shadowsocks 协议, 属于目前比较流行的科学上网软件.</li>
<li><strong><em><a href="https://github.com/trojan-gfw/trojan" rel="external nofollow noopener noreferrer" target="_blank">Trojan</a></em></strong>: 专门为绕过 GFW 而生的新一代科学上网软件, 由 C++ 编写, 需要域名以及证书伪装成 HTTPS.</li>
</ul>
<p>难度 | 稳定: <code>Shadowsocks</code> &lt; <code>V2ray</code> &lt; <code>Trojan</code></p>
<h1 id="VPS选择"><a href="#VPS选择" class="headerlink" title="VPS选择"></a>VPS选择</h1><blockquote>
<p>VPS 厂商众多, 其他的我不多说.</p>
</blockquote>
<ul>
<li><strong><em><a href="https://www.linode.com" rel="external nofollow noopener noreferrer" target="_blank">Linode</a></em></strong> VPS 大厂了, 价格不算便宜, 我用的5$每月, 稳定网速快, 推荐. 邀请码: <code>79e24952d46644605b071a55c4fda3b23e1d1a5a</code></li>
<li><strong><em><a href="https://bandwagonhost.com/" rel="external nofollow noopener noreferrer" target="_blank">BandwagonHOST</a></em></strong> 搬瓦工(已被墙), 便宜, 性价比高</li>
<li>阿里云香港ECS, 优点不说了, 缺点就是太贵, 如果只是查查资料或者玩游戏的, 可以买按流量计费的</li>
</ul>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="准备一台VPS"><a href="#准备一台VPS" class="headerlink" title="准备一台VPS"></a>准备一台VPS</h2><p>博主选择<strong><em><a href="https://www.linode.com" rel="external nofollow noopener noreferrer" target="_blank">Linode</a></em></strong></p>
<p>博主的邀请码: <code>79e24952d46644605b071a55c4fda3b23e1d1a5a</code></p>
<h2 id="SSH无密码登录VPS-可选"><a href="#SSH无密码登录VPS-可选" class="headerlink" title="SSH无密码登录VPS (可选)"></a>SSH无密码登录VPS (可选)</h2><p>参考 <strong><em><a href="/2017/note-of-linux-command/#免密码登录远程服务器">免密码登录远程服务器</a></em></strong></p>
<h1 id="各大代理安装与使用"><a href="#各大代理安装与使用" class="headerlink" title="各大代理安装与使用"></a>各大代理安装与使用</h1><p>安装方式各种各样. . .同意 推荐使用 Docker 镜像安装.</p>
<h2 id="Shadowsocks"><a href="#Shadowsocks" class="headerlink" title="Shadowsocks"></a>Shadowsocks</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>拉取镜像:</p>
<p><code>Showdowsocks</code>镜像: <strong><em><a href="https://hub.docker.com/r/mritd/shadowsocks/" rel="external nofollow noopener noreferrer" target="_blank">https://hub.docker.com/r/mritd/shadowsocks/</a></em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull mritd/shadowsocks:latest</span><br></pre></td></tr></table></figure>
<p>运行: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -dt --name ssserver --restart=always -p 6443:6443 mritd/shadowsocks:latest -m &quot;ss-server&quot; -s &quot;-s 0.0.0.0 -p 6443 -m aes-256-cfb -k 123456 --fast-open&quot;</span><br></pre></td></tr></table></figure>
<p>ss命令说明: </p>
<ul>
<li><code>-s</code> : 监听服务ip, 为服务器本地</li>
<li><code>-p</code> : 端口</li>
<li><code>-m</code> : 加密算法</li>
<li><code>-k</code> : 密码</li>
<li><code>--fast-open</code> : 开启TCP <code>fast-open</code></li>
</ul>
<h3 id="脚本一键安装"><a href="#脚本一键安装" class="headerlink" title="脚本一键安装"></a>脚本一键安装</h3><blockquote>
<p>更多精彩被容请移步到 <strong><em><a href="https://teddysun.com/" rel="external nofollow noopener noreferrer" target="_blank">https://teddysun.com/</a></em></strong></p>
</blockquote>
<p>root用户执行: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh</span><br><span class="line">chmod +x shadowsocks-all.sh</span><br><span class="line">./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</span><br></pre></td></tr></table></figure>
<p>安装完成后, 脚本提示如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Congratulations, your_shadowsocks_version install completed!</span><br><span class="line">Your Server IP        :your_server_ip</span><br><span class="line">Your Server Port      :your_server_port</span><br><span class="line">Your Password         :your_password</span><br><span class="line">Your Encryption Method:your_encryption_method</span><br><span class="line"></span><br><span class="line">Your QR Code: (For Shadowsocks Windows, OSX, Android and iOS clients)</span><br><span class="line"> ss://your_encryption_method:your_password@your_server_ip:your_server_port</span><br><span class="line">Your QR Code has been saved as a PNG file path:</span><br><span class="line"> your_path.png</span><br><span class="line"></span><br><span class="line">Welcome to visit:https://teddysun.com/486.html</span><br><span class="line">Enjoy it!</span><br></pre></td></tr></table></figure>
<p>卸载方法:</p>
<p>若已安装多个版本, 则卸载时也需多次运行（每次卸载一种）</p>
<p>使用root用户登录, 运行以下命令: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./shadowsocks-all.sh uninstall</span><br></pre></td></tr></table></figure>
<p>启动脚本:</p>
<p>启动脚本后面的参数含义, 从左至右依次为: 启动, 停止, 重启, 查看状态. </p>
<p><strong>Shadowsocks-Python</strong> 版:<br><code>/etc/init.d/shadowsocks-python start | stop | restart | status</code></p>
<p><strong>ShadowsocksR</strong> 版:<br><code>/etc/init.d/shadowsocks-r start | stop | restart | status</code></p>
<p><strong>Shadowsocks-Go</strong> 版:<br><code>/etc/init.d/shadowsocks-go start | stop | restart | status</code></p>
<p><strong>Shadowsocks-libev</strong> 版:<br><code>/etc/init.d/shadowsocks-libev start | stop | restart | status</code></p>
<p>各版本默认配置文件:</p>
<p><strong>Shadowsocks-Python</strong> 版:<br><code>/etc/shadowsocks-python/config.json</code></p>
<p><strong>ShadowsocksR</strong> 版:<br><code>/etc/shadowsocks-r/config.json</code></p>
<p><strong>Shadowsocks-Go</strong> 版:<br><code>/etc/shadowsocks-go/config.json</code></p>
<p><strong>Shadowsocks-libev</strong> 版:<br><code>/etc/shadowsocks-libev/config.json</code></p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>官网各大客户端: <strong><em><a href="https://shadowsocks.org/en/download/clients.html" rel="external nofollow noopener noreferrer" target="_blank">https://shadowsocks.org/en/download/clients.html</a></em></strong></p>
<p>Docker 客户端:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -dt --name ssclient --restart=always -p 1080:1080 mritd/shadowsocks:latest -m &quot;ss-local&quot; -s &quot;-s server-ip -p 6443 -b 0.0.0.0 -l 1080 -m aes-256-cfb -k 123456 --fast-open&quot;</span><br></pre></td></tr></table></figure>
<h3 id="多用户管理"><a href="#多用户管理" class="headerlink" title="多用户管理"></a>多用户管理</h3><p><strong><em><a href="https://github.com/mmmwhy/ss-panel-and-ss-py-mu" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/mmmwhy/ss-panel-and-ss-py-mu</a></em></strong> :</p>
<p><strong><em><a href="https://github.com/Ehco1996/django-sspanel" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/Ehco1996/django-sspanel</a></em></strong></p>
<p><strong><em><a href="https://github.com/iMeiji/shadowsocks_install/wiki/%E6%90%AD%E5%BB%BA-sspanel-v3-%E9%AD%94%E6%94%B9%E7%89%88%E8%AE%B0%E5%BD%95" rel="external nofollow noopener noreferrer" target="_blank">搭建-sspanel-v3-魔改版记录</a></em></strong></p>
<p><strong><em><a href="https://91vps.win/" rel="external nofollow noopener noreferrer" target="_blank">https://91vps.win/</a></em></strong></p>
<h2 id="V2Ray"><a href="#V2Ray" class="headerlink" title="V2Ray"></a>V2Ray</h2><blockquote>
<p>项目地址: <strong><em><a href="https://github.com/v2ray/v2ray-core" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/v2ray/v2ray-core</a></em></strong></p>
<p>参考文档: <strong><em><a href="https://toutyrater.github.io/" rel="external nofollow noopener noreferrer" target="_blank">https://toutyrater.github.io/</a></em></strong> (已被墙)</p>
<p>一键安装:<br><strong><em><a href="https://github.com/Jrohy/multi-v2ray" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/Jrohy/multi-v2ray</a></em></strong><br><strong><em><a href="https://github.com/233boy/v2ray" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/233boy/v2ray</a></em></strong></p>
</blockquote>
<h3 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h3><p><code>docker-compose.yml</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.7'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">v2ray:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">v2ray/official</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">v2ray</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"443:443"</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./config.json:/etc/v2ray/config.json</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">v2ray</span> <span class="string">-config=/etc/v2ray/config.json</span></span><br></pre></td></tr></table></figure>
<p><code>config.json</code>:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"inbounds"</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"port"</span>:<span class="number">443</span>,</span><br><span class="line">            <span class="attr">"protocol"</span>:<span class="string">"vmess"</span>,</span><br><span class="line">            <span class="attr">"settings"</span>:&#123;</span><br><span class="line">                <span class="attr">"clients"</span>:[</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"id"</span>:<span class="string">"b371a709-f63c-42d7-88bf-2a67cff72267"</span>,</span><br><span class="line">                        <span class="attr">"alterId"</span>:<span class="number">64</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"outbounds"</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"protocol"</span>:<span class="string">"freedom"</span>,</span><br><span class="line">            <span class="attr">"settings"</span>:&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><p><code>docker-compose.yml</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.7'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">v2ray:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">v2ray/official</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">v2ray</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"1080:1080"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"1080:1080/udp"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./client-config.json:/etc/v2ray/config.json</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">["v2ray",</span> <span class="string">"-config=/etc/v2ray/config.json"</span><span class="string">]</span></span><br></pre></td></tr></table></figure>
<p><code>client-config.json</code>:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"inbounds"</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"port"</span>:<span class="number">1080</span>,</span><br><span class="line">            <span class="attr">"protocol"</span>:<span class="string">"socks"</span>,</span><br><span class="line">            <span class="attr">"sniffing"</span>:&#123;</span><br><span class="line">                <span class="attr">"enabled"</span>:<span class="literal">true</span>,</span><br><span class="line">                <span class="attr">"destOverride"</span>:[</span><br><span class="line">                    <span class="string">"http"</span>,</span><br><span class="line">                    <span class="string">"tls"</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"settings"</span>:&#123;</span><br><span class="line">                <span class="attr">"auth"</span>:<span class="string">"noauth"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"outbounds"</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"protocol"</span>:<span class="string">"vmess"</span>,</span><br><span class="line">            <span class="attr">"settings"</span>:&#123;</span><br><span class="line">                <span class="attr">"vnext"</span>:[</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"address"</span>:<span class="string">"123.456.678.0"</span>,</span><br><span class="line">                        <span class="attr">"port"</span>:<span class="number">443</span>,</span><br><span class="line">                        <span class="attr">"users"</span>:[</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">"id"</span>:<span class="string">"b371a709-f63c-42d7-88bf-2a67cff72267"</span>,</span><br><span class="line">                                <span class="attr">"alterId"</span>:<span class="number">64</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">"mux"</span>:&#123;</span><br><span class="line">                    <span class="attr">"enabled"</span>:<span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多用户管理UI"><a href="#多用户管理UI" class="headerlink" title="多用户管理UI"></a>多用户管理UI</h3><p><strong><em><a href="https://blog.sprov.xyz/2019/08/03/v2-ui/" rel="external nofollow noopener noreferrer" target="_blank">https://blog.sprov.xyz/2019/08/03/v2-ui/</a></em></strong></p>
<h2 id="Trajon"><a href="#Trajon" class="headerlink" title="Trajon"></a>Trajon</h2><h3 id="服务端-2"><a href="#服务端-2" class="headerlink" title="服务端"></a>服务端</h3><p><strong><em><a href="https://www.atrandys.com/category/kxsw/trojan" rel="external nofollow noopener noreferrer" target="_blank">https://www.atrandys.com/category/kxsw/trojan</a></em></strong> / <strong><em><a href="https://github.com/atrandys/trojan" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/atrandys/trojan</a></em></strong></p>
<p><strong><em><a href="https://github.com/mark-logs-code-hub/trojan-wiz" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/mark-logs-code-hub/trojan-wiz</a></em></strong></p>
<p>或者是一下我写的…:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -N --no-check-certificate &apos;https://raw.githubusercontent.com/masteranthoneyd/about-shell/master/trojan.sh&apos; &amp;&amp; chmod +x trojan.sh &amp;&amp; ./trojan.sh $DOMAIN</span><br></pre></td></tr></table></figure>
<p>将 <code>$DOMAIN</code> 换成自己的域名.</p>
<h3 id="客户端-2"><a href="#客户端-2" class="headerlink" title="客户端"></a>客户端</h3><p><code>docker-compose.yml</code>:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.7'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">v2ray:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">trojangfw/trojan</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">trojan</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"1081:1080"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./config:/config</span></span><br></pre></td></tr></table></figure>
<p><code>config</code> 文件夹中应该包含Json配置文件以及证书.</p>
<p><code>config.json</code>:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"run_type"</span>: <span class="string">"client"</span>,</span><br><span class="line">    <span class="attr">"local_addr"</span>: <span class="string">"0.0.0.0"</span>,</span><br><span class="line">    <span class="attr">"local_port"</span>: <span class="number">1080</span>,</span><br><span class="line">    <span class="attr">"remote_addr"</span>: <span class="string">"YOUR_DOMAIN"</span>,</span><br><span class="line">    <span class="attr">"remote_port"</span>: <span class="number">443</span>,</span><br><span class="line">    <span class="attr">"password"</span>: [</span><br><span class="line">        <span class="string">"YOUR_PASSWORD"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"log_level"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"ssl"</span>: &#123;</span><br><span class="line">        <span class="attr">"verify"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"verify_hostname"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"cert"</span>: <span class="string">"fullchain.cer"</span>,</span><br><span class="line">        <span class="attr">"cipher_tls13"</span>:<span class="string">"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_256_GCM_SHA384"</span>,</span><br><span class="line"><span class="attr">"sni"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"alpn"</span>: [</span><br><span class="line">            <span class="string">"h2"</span>,</span><br><span class="line">            <span class="string">"http/1.1"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"reuse_session"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"session_ticket"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"curves"</span>: <span class="string">""</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"tcp"</span>: &#123;</span><br><span class="line">        <span class="attr">"no_delay"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"keep_alive"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"fast_open"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"fast_open_qlen"</span>: <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Just-My-Socks"><a href="#Just-My-Socks" class="headerlink" title="Just My Socks"></a>Just My Socks</h2><p>搬瓦工官方机场: <strong><em><a href="https://justmysocks.net/" rel="external nofollow noopener noreferrer" target="_blank">https://justmysocks.net/</a></em></strong></p>
<p>使用: <strong><em><a href="https://blog.shuziyimin.org/840" rel="external nofollow noopener noreferrer" target="_blank">https://blog.shuziyimin.org/840</a></em></strong></p>
<h1 id="将流量转发到代理"><a href="#将流量转发到代理" class="headerlink" title="将流量转发到代理"></a>将流量转发到代理</h1><p>上面所介绍的代理软件基本上客户端都是<strong>监听本地1080端口</strong>, 并且是 <strong>Sock5</strong> 协议,  所以需要将 HTTP 流量<strong>转发</strong>到本地的1080端口. 好处是<strong>解耦了代理的实现</strong>, 可以<strong>随时更换代理软件</strong>, 比如将 V2ray 换成 Trojan, 只需要更换客户端.</p>
<h2 id="浏览器转发"><a href="#浏览器转发" class="headerlink" title="浏览器转发"></a>浏览器转发</h2><p>推荐使用 Chrome 或者使用 Chrome 内核的浏览器如360. 其他浏览器自行研究.</p>
<p>这种方式适合所有桌面版系统平台, 有些代理客户端可以设置全局流量转发比如 Windows 的 <strong><em><a href="https://github.com/shadowsocks/shadowsocks-windows" rel="external nofollow noopener noreferrer" target="_blank">shadowsocks-win</a></em></strong>, 不建议将全局流量转发作为常用设置, 不好控制. 而使用浏览器插件可控度高, 有些网站没有被墙比如 Github, 但是加载速度比较慢, 可在浏览器中直接强制走代理.</p>
<h3 id="SwitchyOmega插件安装"><a href="#SwitchyOmega插件安装" class="headerlink" title="SwitchyOmega插件安装"></a>SwitchyOmega插件安装</h3><p><strong><em><a href="https://github.com/FelisCatus/SwitchyOmega" rel="external nofollow noopener noreferrer" target="_blank">SwitchyOmega</a></em></strong> 可以将浏览器的流量转发到我们本地的 Socks5 端口.</p>
<p>安装方式:</p>
<ul>
<li>从 <strong><em><a href="https://chrome.google.com/webstore/detail/padekgcemlokbadohgkifijomclgjgif" rel="external nofollow noopener noreferrer" target="_blank">Chrome Web Store</a></em></strong> 下载, 首先你得能访问 Google, 这是一个<strong>悖论</strong></li>
<li>从 <strong><em><a href="https://github.com/FelisCatus/SwitchyOmega/releases/" rel="external nofollow noopener noreferrer" target="_blank">Releases</a></em></strong> 页面下载离线安装包, 浏览器地址打开<code>chrome://extensions/</code>,  启用<strong>开发者模式</strong>,将下载的安装包拖进去</li>
<li>无法安装的参考一下这里: <strong><em><a href="https://zhuanlan.zhihu.com/p/78519194" rel="external nofollow noopener noreferrer" target="_blank">四种谷歌浏览器扩展插件安装方法，完美解决程序包无效问题！</a></em></strong></li>
</ul>
<h3 id="设置代理地址"><a href="#设置代理地址" class="headerlink" title="设置代理地址"></a>设置代理地址</h3><p>安装好插件会自动跳到设置选项, 有提示你可以跳过. 左边新建情景模式-选择代理服务器-比如命名为shadowProxy（叫什么无所谓）其他默认之后创建, 之后在代理协议选择 SOCKS5, 地址为<code>127.0.0.1</code>,端口默认<code>1080</code> . 然后保存即应用选项.<br><img src="https://cdn.yangbingdong.com/img/vps/proxy.png" alt><br><img src="https://cdn.yangbingdong.com/img/vps/proxy01.png" alt></p>
<h3 id="设置自动切换"><a href="#设置自动切换" class="headerlink" title="设置自动切换"></a>设置自动切换</h3><p>接着点击自动切换 ( Auto switch）上面的不用管, 在按照规则列表匹配请求后面选择刚才新建的SS, 默认情景模式选择直接连接. 点击应用选项保存. 再往下规则列表设置选择<code>AutoProxy</code> 然后将 <em><a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt" rel="external nofollow noopener noreferrer" target="_blank">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</a></em> 填进去, 点击下面的立即更新情景模式, 会有提示更新成功！<br><img src="https://cdn.yangbingdong.com/img/vps/proxy03.png" alt></p>
<p>点击浏览器右上角的 SwitchyOmega 图标, 下面选择自动切换, 然后打开 <strong><em><a href="https://www.google.com/" rel="external nofollow noopener noreferrer" target="_blank">google.com</a></em></strong> 试试, 其他的就不在这贴图了.<br><img src="https://cdn.yangbingdong.com/img/vps/proxy04.png" alt></p>
<h2 id="GenPAC全局代理"><a href="#GenPAC全局代理" class="headerlink" title="GenPAC全局代理"></a>GenPAC全局代理</h2><p>如果不想每个浏览器都要设置代理, 可以通过GenPAC实现全局代理. </p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>pip:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python-pip python-dev build-essential </span><br><span class="line">sudo pip install --upgrade pip </span><br><span class="line">sudo pip install --upgrade virtualenv</span><br></pre></td></tr></table></figure></p>
<p>GenPAC:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pip install genpac</span><br><span class="line">sudo pip install --upgrade genpac</span><br></pre></td></tr></table></figure></p>
<h3 id="设置全局代理"><a href="#设置全局代理" class="headerlink" title="设置全局代理"></a>设置全局代理</h3><p>1、进入终端, Ctrl+Alt+T, cd到你希望生成文件存放的位置.<br>例如:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /home/ybd/Data/application/shadowsocks</span><br></pre></td></tr></table></figure></p>
<p>2、执行下面的语句:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo genpac --proxy="SOCKS5 127.0.0.1:1080" --gfwlist-proxy="SOCKS5 127.0.0.1:1080" -o autoproxy.pac --gfwlist-url="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt"</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>:<br>上面语句中<code>127.0.0.1:1080</code>应按照自己的情况填写.<br>如果出现下面这种报错:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fetch gfwlist fail. online: https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt local: None</span><br></pre></td></tr></table></figure></p>
<p>那么换成执行下面的语句:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo genpac --proxy="SOCKS5 127.0.0.1:1080" -o autoproxy.pac --gfwlist-url="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt"</span><br></pre></td></tr></table></figure></p>
<p>如果出现<code>base64 decoding fail .</code>, 安装其他版本:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pip install https://github.com/JinnLynn/genpac/archive/master.zip</span><br><span class="line">sudo pip install --upgrade https://github.com/JinnLynn/genpac/archive/master.zip</span><br><span class="line">sudo pip uninstall genpac</span><br></pre></td></tr></table></figure></p>
<p>3、全局代理<br>系统设置 –&gt; 网络 –&gt; 网络代理<br>“方法”选择“自动”<br>“配置URL”填写:<br><code>file:///home/ybd/Data/application/shadowsocks/autoproxy.pac</code><br>点击“应用到整个系统”, 接下来可以愉悦的跨过墙了～</p>
<h2 id="Proxychains-代理"><a href="#Proxychains-代理" class="headerlink" title="Proxychains 代理"></a>Proxychains 代理</h2><blockquote>
<p><strong><em><a href="https://github.com/rofl0r/proxychains-ng" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/rofl0r/proxychains-ng</a></em></strong></p>
<p>这个是最新版的proxychains, 下面通过apt安装的是3.1版本的.</p>
</blockquote>
<p>安装proxychains:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install proxychains</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 最新版为 sudo apt install proxychains4, 配置文件在/etc/proxychains4.conf, 命令为proxychains4</span></span><br></pre></td></tr></table></figure></p>
<p>配置proxychains:<br>编辑<code>/etc/proxychains.conf</code>, 最下面有一行<code>socks4 127.0.0.1 9050</code>, 把这一行注释掉, 添加一行<code>socks5 127.0.0.1 1080</code><br>测试: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">proxychains curl www.google.com</span><br></pre></td></tr></table></figure>
<p>使用:<br>用命令行启动软件, 在前面加上proxychains, 如:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">proxychains firefox</span><br></pre></td></tr></table></figure></p>
<p>使用<code>shadowsocks</code>+<code>proxychains</code>代理打开新的Firefox实现浏览器翻墙.<br>也可以通过输入<code>proxychains bash</code>建立一个新的<code>shell</code>, 基于这个<code>shell</code>运行的所有命令都将使用代理. </p>
<blockquote>
<p> 如果需要配置<strong>不输出代理信息</strong>, 编辑 <code>/etc/proxychains.conf</code> 将 <code>#quiet_mode</code> 改为 <code>quiet_mode</code>.</p>
</blockquote>
<h2 id="Privoxy"><a href="#Privoxy" class="headerlink" title="Privoxy"></a>Privoxy</h2><p>Privoxy是一款带过滤功能的代理服务器, 针对HTTP、HTTPS协议. 通过Privoxy的过滤功能, 用户可以保护隐私、对网页内容进行过滤、管理cookies, 以及拦阻各种广告等. Privoxy可以用作单机, 也可以应用到多用户的网络. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install privoxy</span><br></pre></td></tr></table></figure>
<p>安装好后进行配置, Privoxy的配置文件在<code>/etc/privoxy/config</code>, 这个配置文件中注释很多. </p>
<p>找到<code>4.1. listen-address</code>这一节, 确认监听的端口号, 如果有内网地址可以监听 <code>0.0.0.0:8118</code>. </p>
<p><img src="https://cdn.yangbingdong.com/img/vps/privoxy-config01.png" alt></p>
<p>找到<code>5.2. forward-socks4, forward-socks4a, forward-socks5 and forward-socks5t</code>这一节, 加上如下配置, 注意最后的点号. </p>
<p><img src="https://cdn.yangbingdong.com/img/vps/privoxy-config02.png" alt></p>
<p>重启一下Privoxy</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/privoxy restart</span><br></pre></td></tr></table></figure>
<p>终端体验: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export http_proxy=&quot;127.0.0.1:8118&quot; &amp;&amp; export https_proxy=&quot;127.0.0.1:8118&quot;</span><br><span class="line">wget http://www.google.com</span><br></pre></td></tr></table></figure>
<p>在<code>/etc/profile</code>的末尾添加如下两句. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export http_proxy=&quot;127.0.0.1:8118&quot;</span><br><span class="line">export https_proxy=&quot;127.0.0.1:8118&quot;</span><br></pre></td></tr></table></figure>
<h1 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h1><h2 id="Google-BBR"><a href="#Google-BBR" class="headerlink" title="Google BBR"></a>Google BBR</h2><p><strong><em><a href="https://teddysun.com/489.html" rel="external nofollow noopener noreferrer" target="_blank">一键安装最新内核并开启 BBR 脚本</a></em></strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh &amp;&amp; chmod +x bbr.sh &amp;&amp; ./bbr.sh</span><br></pre></td></tr></table></figure>
<p>或者使用下面这个开始 BBR+.</p>
<p><strong><em><a href="https://github.com/chiakge/Linux-NetSpeed" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/chiakge/Linux-NetSpeed</a></em></strong> :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -N --no-check-certificate &quot;https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh&quot; &amp;&amp; chmod +x tcp.sh &amp;&amp; ./tcp.sh</span><br></pre></td></tr></table></figure>
<h3 id="更换Linode内核"><a href="#更换Linode内核" class="headerlink" title="更换Linode内核"></a>更换Linode内核</h3><p>谷歌开发的TCP加速外挂, 目前已集成到最新的Linux内核.<br><strong><a href="https://www.linode.com/" rel="external nofollow noopener noreferrer" target="_blank">Linode</a></strong> 不能直接命令更换内核, 需要到管理后台设置:<br><img src="https://cdn.yangbingdong.com/img/docker-shadowsocks/change-kernel.png" alt></p>
<p>安装完重启后输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure>
<p>出现 <code>tcp_bbr</code> 即说明 BBR 已经启动. </p>
<h3 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h3><p>如果是最新内核:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>
<h2 id="开启TCP-Fast-Open"><a href="#开启TCP-Fast-Open" class="headerlink" title="开启TCP Fast Open"></a>开启TCP Fast Open</h2><p>这个需要服务器和客户端都是Linux 3.7+的内核, 一般Linux的服务器发行版只有debian jessie有3.7+的, 客户端用Linux更是珍稀动物, 所以这个不多说, 如果你的服务器端和客户端都是Linux 3.7+的内核, 那就在<strong>服务端</strong>和<strong>客户端</strong>的<code>vi /etc/sysctl.conf</code>文件中再加上一行. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;net.ipv4.tcp_fastopen = 3&quot; | sudo tee -a /etc/sysctl.conf</span><br><span class="line">echo &quot;3&quot; | sudo tee /proc/sys/net/ipv4/tcp_fastopen</span><br><span class="line">sudo sysctl -p</span><br></pre></td></tr></table></figure>
<p>然后把<code>vi /etc/shadowsocks.json</code>配置文件中<code>&quot;fast_open&quot;: false</code>改为<code>&quot;fast_open&quot;: true</code>. 这样速度也将会有非常显著的提升. </p>
<h2 id="TCP优化"><a href="#TCP优化" class="headerlink" title="TCP优化"></a>TCP优化</h2><p>1.修改文件句柄数限制<br>如果是ubuntu/centos均可修改<code>/etc/sysctl.conf</code><br>找到<code>fs.file-max</code>这一行, 修改其值为<code>1024000</code>, 并保存退出. 然后执行<code>sysctl -p</code>使其生效<br>修改<code>vi /etc/security/limits.conf</code>文件, 加入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*               soft    nofile           512000</span><br><span class="line">*               hard    nofile          1024000</span><br></pre></td></tr></table></figure>
<p>针对centos,还需要修改<code>vi /etc/pam.d/common-session</code>文件, 加入<br><code>session required pam_limits.so</code></p>
<p>2.修改<code>vi /etc/profile</code>文件, 加入<br><code>ulimit -SHn 1024000</code><br>然后重启服务器执行<code>ulimit -n</code>, 查询返回1024000即可. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sysctl.conf报错解决方法</span><br><span class="line">修复modprobe的: </span><br><span class="line">rm -f /sbin/modprobe </span><br><span class="line">ln -s /bin/true /sbin/modprobe</span><br><span class="line">修复sysctl的: </span><br><span class="line">rm -f /sbin/sysctl </span><br><span class="line">ln -s /bin/true /sbin/sysctl</span><br></pre></td></tr></table></figure>
<h2 id="使用特殊端口"><a href="#使用特殊端口" class="headerlink" title="使用特殊端口"></a>使用特殊端口</h2><p>GFW会通过某些手段来减轻数据过滤的负荷, 例如特殊的端口如ssh, ssh默认端口给ss用了那么久必须修改我们登录服务器的端口.<br>修改SSH配置文件: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>
<p>找到<code>#port 22</code>, 将前面的<code>#</code>去掉, 然后修改端口 <code>port 2333</code>（自己设定）.<br>然后重启SSH: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service ssh restart</span><br></pre></td></tr></table></figure>
<h1 id="VPS-Security"><a href="#VPS-Security" class="headerlink" title="VPS Security"></a>VPS Security</h1><h2 id="修改SSH登录端口"><a href="#修改SSH登录端口" class="headerlink" title="修改SSH登录端口"></a>修改SSH登录端口</h2><h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><p>1、用下面命令进入配置文件<code>vi /etc/ssh/sshd_config</code><br>2、找到<code>#port 22</code>, 将前面的<code>#</code>去掉, 然后修改端口 <code>port 12345</code>（自己设定）.<br>3、然后重启ssh服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#Debian/ubuntu  /etc/init.d/ssh restart   or    service ssh restart</span><br><span class="line">#CentOS         service sshd restart</span><br></pre></td></tr></table></figure>
<h3 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h3><p>1、临时关闭SELinux: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setenforce 0</span><br></pre></td></tr></table></figure>
<p>2、修改SSH端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line">#在Port 22下面加一行, 以端口2333为例, Port 2333</span><br><span class="line"></span><br><span class="line">#重启ssh服务: </span><br><span class="line">systemctl restart sshd.service</span><br></pre></td></tr></table></figure>
<p>3、防火墙中放行新加入端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port=2333/tcp</span><br></pre></td></tr></table></figure>
<p>4、用该命令查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --query-port=2333/tcp</span><br></pre></td></tr></table></figure>
<p>如果是<code>yes</code>就是添加成功, 如果是no就是没成功</p>
<p>5、成功后重载防火墙</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>
<p>6、关闭SELinux</p>
<p>查看SELinux状态<code>SELINUX</code>, 如果是<code>enabled</code>就是开启状态</p>
<p><code>vi /etc/selinux/config</code></p>
<p>修改<code>SELINUX=disabled</code></p>
<p>最后重启vps试试用新的<code>2333</code>端口登录, 如果登录成功再<code>vi /etc/ssh/sshd_config</code>把<code>Port 22</code>端口删除, 再重启ssh服务就好了. </p>
<h2 id="使用密钥登录SSH"><a href="#使用密钥登录SSH" class="headerlink" title="使用密钥登录SSH"></a>使用密钥登录SSH</h2><p>1、服务端生成密钥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#生成SSH密钥对</span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line"></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">#建议直接回车使用默认路径</span><br><span class="line">Enter file in which to save the key (/root/.ssh/id_rsa): </span><br><span class="line">#输入密码短语（留空则直接回车）</span><br><span class="line">Enter passphrase (empty for no passphrase): </span><br><span class="line">#重复密码短语</span><br><span class="line">Enter same passphrase again: </span><br><span class="line">Your identification has been saved in /root/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /root/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">aa:8b:61:13:38:ad:b5:49:ca:51:45:b9:77:e1:97:e1 root@localhost.localdomain</span><br><span class="line">The key&apos;s randomart image is:</span><br><span class="line">+--[ RSA 2048]----+</span><br><span class="line">|    .o.          |</span><br><span class="line">|    ..   . .     |</span><br><span class="line">|   .  . . o o    |</span><br><span class="line">| o.  . . o E     |</span><br><span class="line">|o.=   . S .      |</span><br><span class="line">|.*.+   .         |</span><br><span class="line">|o.*   .          |</span><br><span class="line">| . + .           |</span><br><span class="line">|  . o.           |</span><br><span class="line">+-----------------+</span><br></pre></td></tr></table></figure>
<p>2、复制密钥对</p>
<blockquote>
<p>也可以手动在客户端建立目录和authorized_keys, 注意修改权限</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#复制公钥到无密码登录的服务器上,22端口改变可以使用下面的命令</span><br><span class="line">#ssh-copy-id -i ~/.ssh/id_rsa.pub &quot;-p 10022 user@server&quot;</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.15.241</span><br></pre></td></tr></table></figure>
<p>3、关闭密码登陆(编辑<code>/etc/ssh/sshd_config</code>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#禁用密码验证</span><br><span class="line">PasswordAuthentication no</span><br><span class="line"></span><br><span class="line">#启用密钥验证</span><br><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line"></span><br><span class="line">#指定公钥数据库文件</span><br><span class="line">AuthorizedKeysFile .ssh/authorized_keys</span><br><span class="line"></span><br><span class="line">#root 用户能否通过 SSH 登录</span><br><span class="line">PermitRootLogin yes</span><br></pre></td></tr></table></figure>
<p>4、重启SSH</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#RHEL/CentOS系统</span><br><span class="line">service sshd restart</span><br><span class="line">#ubuntu系统</span><br><span class="line">service ssh restart</span><br><span class="line">#debian系统</span><br><span class="line">/etc/init.d/ssh restart</span><br></pre></td></tr></table></figure>
<h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><h3 id="Ubuntu防火墙UFW"><a href="#Ubuntu防火墙UFW" class="headerlink" title="Ubuntu防火墙UFW"></a>Ubuntu防火墙UFW</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ufw enable</span><br><span class="line">ufw allow ssh</span><br><span class="line">ufw allow [shadowsocks_port]</span><br><span class="line">ufw allow from [remote_ip]</span><br></pre></td></tr></table></figure>
<h3 id="CentOS-1"><a href="#CentOS-1" class="headerlink" title="CentOS"></a>CentOS</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 显示状态</span><br><span class="line">firewall-cmd --state</span><br><span class="line"></span><br><span class="line"># 启用</span><br><span class="line">systemctl start firewalld.service</span><br><span class="line"></span><br><span class="line"># Postgresql端口设置. 允许192.168.142.166访问5432端口</span><br><span class="line">firewall-cmd --permanent --add-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;192.168.142.166&quot; port protocol=&quot;tcp&quot; port=&quot;5432&quot; accept&quot;</span><br><span class="line"></span><br><span class="line"># redis端口设置. 允许192.168.142.166访问6379端口</span><br><span class="line">firewall-cmd --permanent --add-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;192.168.142.166&quot; port protocol=&quot;tcp&quot; port=&quot;6379&quot; accept&quot;</span><br><span class="line"></span><br><span class="line"># 查看配置结果, 验证配置</span><br><span class="line">firewall-cmd --list-all</span><br><span class="line"></span><br><span class="line"># 删除规则</span><br><span class="line">firewall-cmd --permanent --remove-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;192.168.142.166&quot; port protocol=&quot;tcp&quot; port=&quot;11300&quot; accept&quot;</span><br><span class="line"></span><br><span class="line"># 更新防火墙规则</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line"># 重启防火墙</span><br><span class="line">systemctl restart firewalld.service</span><br></pre></td></tr></table></figure>
<h2 id="DDOS-deflate"><a href="#DDOS-deflate" class="headerlink" title="DDOS deflate"></a>DDOS deflate</h2><p><code>DDOS deflate</code>是一款免费的用来防御和减轻DDOS攻击的脚本. 它通过netstat监测跟踪创建大量网络连接的IP地址, 在检测到某个结点超过预设的限制时, 该程序会通过APF或IPTABLES禁止或阻挡这些IP. </p>
<p><strong>安装</strong>: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http://www.moerats.com/usr/down/DDOS/deflate.sh &amp;&amp; \</span><br><span class="line">chmod +x deflate.sh &amp;&amp; \</span><br><span class="line">./deflate.sh</span><br></pre></td></tr></table></figure>
<p>配置文件<code>/usr/local/ddos/ddos.conf</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##### Paths of the script and other files</span><br><span class="line">PROGDIR=&quot;/usr/local/ddos&quot;</span><br><span class="line">PROG=&quot;/usr/local/ddos/ddos.sh&quot;</span><br><span class="line">IGNORE_IP_LIST=&quot;/usr/local/ddos/ignore.ip.list&quot;</span><br><span class="line"># 白名单.如有反向代理,注意添加本机地址和本机外网IP地址,防止提供反向代理的主机被判定为攻击.</span><br><span class="line">CRON=&quot;/etc/cron.d/ddos.cron&quot;</span><br><span class="line">APF=&quot;/etc/apf/apf&quot;</span><br><span class="line">IPT=&quot;/sbin/iptables&quot;##### frequency in minutes for running the script</span><br><span class="line"></span><br><span class="line">##### Caution: Every time this setting is changed, run the script with cron</span><br><span class="line">##### option so that the new frequency takes effect</span><br><span class="line">FREQ=1</span><br><span class="line"></span><br><span class="line">##### How many connections define a bad IP? Indicate that below. </span><br><span class="line"># 单IP发起连接数阀值,不建议设置太低.</span><br><span class="line">NO_OF_CONNECTIONS=150</span><br><span class="line"></span><br><span class="line">##### APF_BAN=1 (Make sure your APF version is atleast 0.96)</span><br><span class="line">##### APF_BAN=0 (Uses iptables for banning ips instead of APF) </span><br><span class="line">#一般情况下你是使用iptables来做防火墙,所以这里你需要将 APF_BAN的值改为0.</span><br><span class="line">APF_BAN=1</span><br><span class="line"></span><br><span class="line">##### KILL=0 (Bad IPs are’nt banned, good for interactive execution of script)</span><br><span class="line">##### KILL=1 (Recommended setting)</span><br><span class="line">KILL=1 </span><br><span class="line">#是否屏蔽IP, 默认即可</span><br><span class="line"></span><br><span class="line">##### An email is sent to the following address when an IP is banned. </span><br><span class="line"># 当单IP发起的连接数超过阀值后,将发邮件给指定的收件人.</span><br><span class="line">##### Blank would suppress sending of mails</span><br><span class="line">EMAIL_TO=&quot;root&quot; </span><br><span class="line"># 这里是邮箱, 可以把root替换成你的邮箱</span><br><span class="line"></span><br><span class="line">##### Number of seconds the banned ip should remain in blacklist. </span><br><span class="line"># 设置被挡IP多少秒后移出黑名单.</span><br><span class="line">BAN_PERIOD=600</span><br></pre></td></tr></table></figure>
<p>将上述配置文件修改完成后, 使用命令启动即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ddos -d</span><br></pre></td></tr></table></figure>
<p>Ubuntu中可能会报错: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@localhost:~# ddos -d</span><br><span class="line">/usr/local/sbin/ddos: 13: [: /usr/local/ddos/ddos.conf: unexpected operator</span><br><span class="line">DDoS-Deflate version 0.6</span><br><span class="line">Copyright (C) 2005, Zaf &lt;zaf@vsnl.com&gt;</span><br></pre></td></tr></table></figure>
<p>因为启动大多数为 bash 脚本, 而 Ubuntu 的默认环境为 dash, 所以需要使用 dpkg-reconfigure dash, 选择 NO, 切换为 bash 运行脚本: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dpkg-reconfigure dash</span><br></pre></td></tr></table></figure>
<h2 id="Denyhosts防暴力攻击"><a href="#Denyhosts防暴力攻击" class="headerlink" title="Denyhosts防暴力攻击"></a>Denyhosts防暴力攻击</h2><p>这个方法比较省时省力. denyhosts 是 Python 语言写的一个程序, 它会分析 sshd 的日志文件, 当发现重复的失败登录时就会记录 IP 到 /etc/hosts.deny 文件, 从而达到自动屏 IP 的功能:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Debian/Ubuntu: </span></span><br><span class="line">sudo apt install denyhosts</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> RedHat/CentOS</span></span><br><span class="line">yum install denyhosts</span><br></pre></td></tr></table></figure></p>
<p>默认配置就能很好的工作, 如要个性化设置可以修改 <code>/etc/denyhosts.conf</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SECURE_LOG = /var/log/auth.log #ssh 日志文件, 它是根据这个文件来判断的. </span><br><span class="line">HOSTS_DENY = /etc/hosts.deny #控制用户登陆的文件</span><br><span class="line">PURGE_DENY = #过多久后清除已经禁止的, 空表示永远不解禁</span><br><span class="line">BLOCK_SERVICE = sshd #禁止的服务名, 如还要添加其他服务, 只需添加逗号跟上相应的服务即可</span><br><span class="line">DENY_THRESHOLD_INVALID = 5 #允许无效用户失败的次数</span><br><span class="line">DENY_THRESHOLD_VALID = 10 #允许普通用户登陆失败的次数</span><br><span class="line">DENY_THRESHOLD_ROOT = 1 #允许root登陆失败的次数</span><br><span class="line">DENY_THRESHOLD_RESTRICTED = 1</span><br><span class="line">WORK_DIR = /var/lib/denyhosts #运行目录</span><br><span class="line">SUSPICIOUS_LOGIN_REPORT_ALLOWED_HOSTS=YES</span><br><span class="line">HOSTNAME_LOOKUP=YES #是否进行域名反解析</span><br><span class="line">LOCK_FILE = /var/run/denyhosts.pid #程序的进程ID</span><br><span class="line">ADMIN_EMAIL = root@localhost #管理员邮件地址,它会给管理员发邮件</span><br><span class="line">SMTP_HOST = localhost</span><br><span class="line">SMTP_PORT = 25</span><br><span class="line">SMTP_FROM = DenyHosts &lt;nobody@localhost&gt;</span><br><span class="line">SMTP_SUBJECT = DenyHosts Report</span><br><span class="line">AGE_RESET_VALID=5d #用户的登录失败计数会在多久以后重置为0, (h表示小时, d表示天, m表示月, w表示周, y表示年)</span><br><span class="line">AGE_RESET_ROOT=25d</span><br><span class="line">AGE_RESET_RESTRICTED=25d</span><br><span class="line">AGE_RESET_INVALID=10d</span><br><span class="line">RESET_ON_SUCCESS = yes #如果一个ip登陆成功后, 失败的登陆计数是否重置为0</span><br><span class="line">DAEMON_LOG = /var/log/denyhosts #自己的日志文件</span><br><span class="line">DAEMON_SLEEP = 30s #当以后台方式运行时, 每读一次日志文件的时间间隔. </span><br><span class="line">DAEMON_PURGE = 1h #当以后台方式运行时, 清除机制在 HOSTS_DENY 中终止旧条目的时间间隔,这个会影响PURGE_DENY的间隔.</span><br></pre></td></tr></table></figure>
<p>查看已拦截的IP<code>cat /etc/hosts.deny</code><br>查看拦截记录<code>cat /etc/hosts.deny | wc -l</code><br>重启服务<code>service denyhosts restart</code><br>写入自启<code>echo &quot;service denyhosts restart&quot; &gt;&gt; /etc/rc.local</code></p>
<h2 id="vDDoS（只支持CentOS和CloudLinux）"><a href="#vDDoS（只支持CentOS和CloudLinux）" class="headerlink" title="vDDoS（只支持CentOS和CloudLinux）"></a>vDDoS（只支持CentOS和CloudLinux）</h2><p><strong><em><a href="https://github.com/duy13/vDDoS-Protection" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/duy13/vDDoS-Protection</a></em></strong></p>
<h2 id="CCKiller"><a href="#CCKiller" class="headerlink" title="CCKiller"></a>CCKiller</h2><p><strong><em><a href="https://github.com/jagerzhang/CCKiller" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/jagerzhang/CCKiller</a></em></strong></p>
<h1 id="VPS-Speed-Test"><a href="#VPS-Speed-Test" class="headerlink" title="VPS Speed Test"></a>VPS Speed Test</h1><h2 id="speedtest"><a href="#speedtest" class="headerlink" title="speedtest"></a>speedtest</h2><p>下载: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/sivel/speedtest-cli/master/speedtest.py &amp;&amp; \</span><br><span class="line">chmod +x speedtest.py</span><br></pre></td></tr></table></figure>
<p>运行: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./speedtest.py</span><br><span class="line"></span><br><span class="line">#或者</span><br><span class="line">python speedtest.py</span><br></pre></td></tr></table></figure>
<p>结果: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@li1890-191 ~]# ./speedtest.py</span><br><span class="line">Retrieving speedtest.net configuration...</span><br><span class="line">Testing from Linode (123.456.789.123)...</span><br><span class="line">Retrieving speedtest.net server list...</span><br><span class="line">Selecting best server based on ping...</span><br><span class="line">Hosted by IPA CyberLab (Bunkyo) [5.97 km]: 2.998 ms</span><br><span class="line">Testing download speed................................................................................</span><br><span class="line">Download: 2036.69 Mbit/s</span><br><span class="line">Testing upload speed................................................................................................</span><br><span class="line">Upload: 208.17 Mbit/s</span><br></pre></td></tr></table></figure>
<h2 id="speedtest-cli"><a href="#speedtest-cli" class="headerlink" title="speedtest-cli"></a>speedtest-cli</h2><blockquote>
<p>地址: <strong><em><a href="https://github.com/sivel/speedtest-cli" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/sivel/speedtest-cli</a></em></strong></p>
</blockquote>
<p>pip方式安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install speedtest-cli</span><br></pre></td></tr></table></figure>
<p>或github安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/sivel/speedtest-cli.git</span><br><span class="line">python speedtest-cli/setup.py install</span><br></pre></td></tr></table></figure>
<p>用法: </p>
<p>1、list</p>
<p>根据距离显示所有的节点服务器列表. </p>
<p>2、列出所有北京节点服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@li1890-191 ~]# speedtest-cli --list | grep Beijing</span><br><span class="line"> 4713) China Mobile Group Beijing Co.Ltd (Beijing, China) [2093.67 km]</span><br><span class="line"> 5505) Beijing Broadband Network (Beijing, China) [2093.67 km]</span><br><span class="line"> 5145) Beijing Unicom (Beijing, China) [2093.67 km]</span><br><span class="line">18462) Beijing Broadband Network (Beijing, China) [2093.67 km]</span><br></pre></td></tr></table></figure>
<p>3、选择节点测试下载速度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">speedtest-cli --server=6611</span><br></pre></td></tr></table></figure>
<h1 id="Finally"><a href="#Finally" class="headerlink" title="Finally"></a>Finally</h1><p>低调服用. . . </p>
]]></content><categories><category>VPS</category></categories><tags><tag>VPS</tag><tag>ShadowSocks</tag><tag>V2Ray</tag><tag>Trojan</tag></tags></entry><entry><title>使用 Reactor 进行反应式编程</title><url>/2017/with-reactor-response-encode/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/with-reactor-response-encode/reactor.png" alt></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><blockquote>
<p>反应式编程（<code>Reactive Programming</code>）这种新的编程范式越来越受到开发人员的欢迎. 在 Java 社区中比较流行的是 <code>RxJava</code> 和 <code>RxJava 2</code>. 本篇要介绍的是另外一个新的反应式编程库 <em><a href="https://github.com/reactor/reactor" rel="external nofollow noopener noreferrer" target="_blank">Rea</a><a href="http://projectreactor.io/" rel="external nofollow noopener noreferrer" target="_blank">ctor</a></em>.<br>Reactor 框架是 <strong>Pivotal</strong> 公司（开发 Spring 等技术的公司）开发的, 实现了 <code>Reactive Programming</code> 思想, 符合 <code>Reactive Streams</code> 规范（<code>Reactive Streams</code> 是由 <strong>Netflix</strong>、<strong>TypeSafe</strong>、<strong>Pivotal</strong> 等公司发起的）的一项技术. 其名字有反应堆之意, 反映了其背后的<em>强大的性能</em>. </p>
</blockquote>
<a id="more"></a>
<h1 id="反应式编程介绍"><a href="#反应式编程介绍" class="headerlink" title="反应式编程介绍"></a>反应式编程介绍</h1><p>反应式编程来源于数据流和变化的传播, 意味着由底层的执行模型负责通过数据流来自动传播变化. 比如求值一个简单的表达式 c=a+b, 当 a 或者 b 的值<strong>发生变化</strong>时, <strong>传统的编程范式</strong>需要对 a+b 进行<strong>重新计算</strong>来得到 c 的值. 如果使用<strong>反应式编程</strong>, 当 a 或者 b 的值<strong>发生变化</strong>时, c 的值会<strong>自动更新</strong>. 反应式编程最早由 .NET 平台上的 <code>Reactive Extensions</code> (<code>Rx</code>) 库来实现. 后来迁移到 Java 平台之后就产生了著名的 <code>RxJava</code> 库, 并产生了很多其他编程语言上的对应实现. 在这些实现的基础上产生了后来的反应式流（<code>Reactive Streams</code>）规范. 该规范定义了反应式流的相关接口, 并将集成到 <strong>Java 9</strong> 中. </p>
<p>在传统的编程范式中, 我们一般通过迭代器（<code>Iterator</code>）模式来遍历一个序列. 这种遍历方式是由<strong>调用者来控制节奏</strong>的, 采用的是<strong>拉</strong>的方式. 每次由调用者通过 next()方法来获取序列中的下一个值. 使用<strong>反应式流</strong>时采用的则是<strong>推</strong>的方式, 即常见的<strong>发布者-订阅者模式</strong>. 当发布者有新的数据产生时, 这些数据会被<strong>推送</strong>到<strong>订阅者</strong>来进行处理. 在反应式流上可以添加各种不同的操作来对数据进行处理, 形成数据处理链. 这个以声明式的方式添加的处理链只在订阅者进行订阅操作时才会真正执行. </p>
<p>反应式流中第一个重要概念是<strong>负压</strong>（<code>backpressure</code>）. 在基本的消息推送模式中, 当消息发布者产生数据的<strong>速度过快</strong>时, 会使得消息订阅者的处理速度<strong>无法跟上产生的速度</strong>, 从而给订阅者造成很大的<strong>压力</strong>. 当压力过大时, 有可能造成订阅者本身的<strong>奔溃</strong>, 所产生的级联效应甚至可能造成整个系统的<strong>瘫痪</strong>. <strong>负压</strong>的作用在于<strong>提供一种从订阅者到生产者的反馈渠道</strong>. 订阅者可以通过 <code>request()</code>方法来<strong>声明其一次所能处理的消息数量</strong>, <strong>而生产者就只会产生相应数量的消息</strong>, 直到下一次 <code>request()</code>方法调用. 这实际上变成了<strong>推拉结合的模式</strong>. </p>
<h1 id="Reactor-简介"><a href="#Reactor-简介" class="headerlink" title="Reactor 简介"></a>Reactor 简介</h1><p>前面提到的 <code>RxJava</code> 库是 JVM 上反应式编程的先驱, 也是反应式流规范的基础. <code>RxJava 2</code> 在 <code>RxJava</code> 的基础上做了很多的更新. 不过 <code>RxJava</code> 库也有其不足的地方. <code>RxJava</code> 产生于反应式流规范之前, 虽然可以和反应式流的接口进行转换, 但是由于底层实现的原因, 使用起来并不是很直观. <code>RxJava 2</code> 在设计和实现时考虑到了与规范的整合, 不过为了保持与 <code>RxJava</code> 的兼容性, 很多地方在使用时也并不直观. <code>Reactor</code> 则是<strong>完全基于反应式流规范设计和实现的库</strong>, 没有 <code>RxJava</code> 那样的历史包袱, 在使用上更加的直观易懂. <code>Reactor</code> 也是 Spring 5 中反应式编程的基础. 学习和掌握 <code>Reactor</code> 可以更好地理解 Spring 5 中的相关概念. </p>
<p>在 Java 程序中使用 <code>Reactor</code> 库非常的简单, 只需要通过 Maven 或 Gradle 来添加对 <code>io.projectreactor:reactor-core</code> 的依赖即可, 目前的版本是 <code>3.1.2.RELEASE</code>: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;reactor-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.1.2.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<h1 id="Flux-和-Mono"><a href="#Flux-和-Mono" class="headerlink" title="Flux 和 Mono"></a>Flux 和 Mono</h1><p><code>Flux</code> 和 <code>Mono</code> 是 <code>Reactor</code> 中的两个基本概念. <code>Flux</code> 表示的是<strong>包含 0 到 N 个元素</strong>的<strong>异步</strong>序列. 在该序列中可以包含<strong>三种不同类型</strong>的消息通知: 正常的包含元素的消息、序列结束的消息和序列出错的消息. 当消息通知产生时, <strong>订阅者</strong>中对应的方法 <code>onNext()</code>, <code>onComplete()</code>和 <code>onError()</code>会被调用. <code>Mono</code> 表示的是<strong>包含 0 或者 1 个元素</strong>的<strong>异步</strong>序列. 该序列中同样可以包含与 Flux 相同的三种类型的消息通知. <code>Flux</code> 和 <code>Mono</code> 之间可以进行<strong>转换</strong>. 对一个 <code>Flux</code> 序列进行计数操作, 得到的结果是一个 <code>Mono&lt;Long&gt;</code>对象. 把两个 <code>Mono</code> 序列合并在一起, 得到的是一个 <code>Flux</code> 对象. </p>
<h2 id="创建-Flux"><a href="#创建-Flux" class="headerlink" title="创建 Flux"></a>创建 Flux</h2><p>有多种不同的方式可以创建 Flux 序列. </p>
<h3 id="Flux-类的静态方法"><a href="#Flux-类的静态方法" class="headerlink" title="Flux 类的静态方法"></a>Flux 类的静态方法</h3><p>第一种方式是通过 Flux 类中的静态方法. </p>
<ul>
<li><code>just()</code>: 可以指定序列中包含的全部元素. 创建出来的 Flux 序列在发布这些元素之后会自动结束. </li>
<li><code>fromArray()</code>, <code>fromIterable()</code>和 <code>fromStream()</code>: 可以从一个<strong>数组</strong>、<code>Iterable</code> 对象或 <code>Stream</code> 对象中创建 <code>Flux</code> 对象. </li>
<li><code>empty()</code>: 创建一个不包含任何元素, 只发布结束消息的序列. </li>
<li><code>error(Throwable error)</code>: 创建一个只包含错误消息的序列. </li>
<li><code>never()</code>: 创建一个不包含任何消息通知的序列. </li>
<li><code>range(int start, int count)</code>: 创建包含从 start 起始的 count 个数量的 Integer 对象的序列. </li>
<li><code>interval(Duration period)</code>和 <code>interval(Duration delay, Duration period)</code>: 创建一个包含了从 0 开始递增的 Long 对象的序列. 其中包含的元素按照指定的间隔来发布. 除了间隔时间之外, 还可以指定起始元素发布之前的延迟时间. </li>
</ul>
<p>代码清单 1 中给出了上述这些方法的使用示例. </p>
<p><strong>清单 1. 通过 Flux 类的静态方法创建 Flux 序列</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">	generateSimpleFlux();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void generateSimpleFlux() throws InterruptedException &#123;</span><br><span class="line">	Flux.just(&quot;Hello&quot;, &quot;World&quot;).subscribe(System.out::println);</span><br><span class="line">	Integer[] array = &#123;1, 2, 3&#125;;</span><br><span class="line">	Flux.fromArray(array).subscribe(System.out::println);</span><br><span class="line">	Flux.fromStream(Stream.of(array)).subscribe(System.out::println);</span><br><span class="line">	Flux.fromIterable(Arrays.asList(array)).subscribe(System.out::println);</span><br><span class="line">	Flux.empty().subscribe(System.out::println);</span><br><span class="line">	Flux.range(1, 10).subscribe(System.out::println);</span><br><span class="line">	Flux.interval(Duration.ofSeconds(1)).subscribe(System.out::println);</span><br><span class="line">	// Flux.interval(Duration.of(1, ChronoUnit.SECONDS)).subscribe(System.out::println);</span><br><span class="line">	TimeUnit.SECONDS.sleep(5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的这些静态方法适合于<strong>简单</strong>的序列生成, 当序列的生成<strong>需要复杂的逻辑</strong>时, 则应该使用 <code>generate()</code> 或 <code>create()</code> 方法. </p>
<h3 id="generate-方法"><a href="#generate-方法" class="headerlink" title="generate()方法"></a>generate()方法</h3><p><code>generate()</code>方法通过<strong>同步</strong>和<strong>逐一</strong>的方式来产生 <code>Flux</code> 序列. 序列的产生是通过调用所提供的 <code>SynchronousSink</code> 对象的 <code>next()</code>, <code>complete()</code>和 <code>error(Throwable)</code>方法来完成的. 逐一生成的含义是在具体的生成逻辑中, <strong><code>next()</code>方法只能最多被调用一次</strong>. 在有些情况下, 序列的生成可能是有状态的, 需要用到某些状态对象. 此时可以使用 <code>generate()</code>方法的另外一种形式 <code>generate(Callable&lt;S&gt; stateSupplier, BiFunction&lt;S,SynchronousSink&lt;T&gt;,S&gt; generator)</code>, 其中 <code>stateSupplier</code> 用来提供初始的状态对象. 在进行序列生成时, 状态对象会作为 <code>generator</code> 使用的第一个参数传入, 可以在对应的逻辑中对该状态对象进行修改以供下一次生成时使用. </p>
<p>在代码清单 2中, 第一个序列的生成逻辑中通过 <code>next()</code>方法产生一个简单的值, 然后通过 <code>complete()</code>方法来结束该序列. 如果不调用 <code>complete()</code>方法, 所产生的是一个<strong>无限序列</strong>. 第二个序列的生成逻辑中的状态对象是一个 <code>ArrayList</code> 对象. 实际产生的值是一个<strong>随机数</strong>. 产生的随机数被添加到 <code>ArrayList</code> 中. 当产生了 10 个数时, 通过 <code>complete()</code>方法来结束序列. </p>
<p><strong>清单 2. 使用 generate()方法生成 Flux 序列</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static void fluxGenerate() &#123;</span><br><span class="line">		Flux.generate(sink -&gt; &#123;</span><br><span class="line">			sink.next(&quot;Hello&quot;);</span><br><span class="line">			sink.complete();</span><br><span class="line">		&#125;).subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		Random random = new Random();</span><br><span class="line">		Flux.generate(ArrayList::new, (list, sink) -&gt; &#123;</span><br><span class="line">			int value = random.nextInt(100);</span><br><span class="line">			list.add(value);</span><br><span class="line">			sink.next(value);</span><br><span class="line">			if (list.size() == 10) &#123;</span><br><span class="line">				sink.complete();</span><br><span class="line">			&#125;</span><br><span class="line">			return list;</span><br><span class="line">		&#125;).subscribe(System.out::println);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="create-方法"><a href="#create-方法" class="headerlink" title="create()方法"></a>create()方法</h3><p><code>create()</code>方法与 <code>generate()</code>方法的不同之处在于所使用的是 <code>FluxSink</code> 对象. <code>FluxSink</code> 支持同步和异步的消息产生, <strong>并且可以在一次调用中产生多个元素</strong>. 在代码清单 3 中, 在一次调用中就产生了全部的 10 个元素. </p>
<p><strong>清单 3. 使用 create()方法生成 Flux 序列</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Flux.create(sink -&gt; &#123;</span><br><span class="line">    for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        sink.next(i);</span><br><span class="line">    &#125;</span><br><span class="line">    sink.complete();</span><br><span class="line">&#125;).subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
<h2 id="创建-Mono"><a href="#创建-Mono" class="headerlink" title="创建 Mono"></a>创建 Mono</h2><p>Mono 的创建方式与之前介绍的 Flux 比较相似. Mono 类中也包含了一些与 Flux 类中<strong>相同的静态方法</strong>. 这些方法包括 <code>just()</code>, <code>empty()</code>, <code>error()</code>和 <code>never()</code>等. 除了这些方法之外, Mono 还有一些独有的静态方法. </p>
<ul>
<li><code>fromCallable()</code>、<code>fromCompletionStage()</code>、<code>fromFuture()</code>、<code>fromRunnable()</code>和 <code>fromSupplier()</code>: 分别从 <code>Callable</code>、<code>CompletionStage</code>、<code>CompletableFuture</code>、<code>Runnable</code> 和 <code>Supplier</code> 中创建 Mono. </li>
<li><code>delay(Duration duration)</code>: 创建一个 Mono 序列, 在指定的<strong>延迟</strong>时间之后, 产生数字 0 作为唯一值. </li>
<li><code>ignoreElements(Publisher&lt;T&gt; source)</code>: 创建一个 Mono 序列, <strong>忽略</strong>作为源的 <code>Publisher</code> 中的所有元素, <strong>只产生结束消息</strong>. </li>
<li><code>justOrEmpty(Optional&lt;? extends T&gt; data)</code>和 <code>justOrEmpty(T data)</code>: 从一个 <strong>Optional</strong> 对象或可能为 null 的对象中创建 Mono. 只有 <strong>Optional</strong> 对象中包含值或对象不为 null 时, Mono 序列才产生对应的元素. </li>
</ul>
<p>还可以通过 <code>create()</code>方法来使用 <code>MonoSink</code> 来创建 Mono. 代码清单 4 中给出了创建 Mono 序列的示例. </p>
<p><strong>清单 4. 创建 Mono 序列</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static final String HELLO = &quot;Hello&quot;;</span><br><span class="line">private static void buildMono() throws InterruptedException &#123;</span><br><span class="line">		Mono.just(HELLO).subscribe(System.out::println);</span><br><span class="line">		Mono.empty().subscribe(System.out::println);</span><br><span class="line">		Mono.fromSupplier(() -&gt; HELLO).subscribe(System.out::println);</span><br><span class="line">		Mono.justOrEmpty(Optional.of(HELLO)).subscribe(System.out::println);</span><br><span class="line">		Mono.create(sink -&gt; sink.success(HELLO)).subscribe(System.out::println);</span><br><span class="line">		Mono.delay(Duration.ofSeconds(1)).subscribe(System.out::println);</span><br><span class="line">		TimeUnit.SECONDS.sleep(2);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>和 <code>RxJava</code> 一样, <code>Reactor</code> 的强大之处在于可以在反应式流上通过<strong>声明式</strong>的方式添加多种不同的<strong>操作符</strong>. 下面对其中重要的操作符进行分类介绍. </p>
<h3 id="buffer-和-bufferTimeout"><a href="#buffer-和-bufferTimeout" class="headerlink" title="buffer 和 bufferTimeout"></a>buffer 和 bufferTimeout</h3><p>这两个操作符的作用是把当前流中的元素<strong>收集到集合中</strong>, 并把集合对象作为流中的新元素. 在进行收集时可以指定不同的条件: 所包含的元素的<strong>最大数量</strong>或<strong>收集的时间间隔</strong>. 方法 <code>buffer()</code>仅使用一个条件, 而 <code>bufferTimeout()</code>可以同时指定两个条件. 指定时间间隔时可以使用 <code>Duration</code> 对象或毫秒数. </p>
<p>除了元素数量和时间间隔之外, 还可以通过 <code>bufferUntil</code> 和 <code>bufferWhile</code> 操作符来进行收集. 这两个操作符的参数是表示每个集合中的元素所要<strong>满足的条件</strong>的 <code>Predicate</code> 对象. <code>bufferUntil</code> 会<strong>一直收集</strong>直到 <code>Predicate</code> 返回为 <code>true</code>. 使得 <code>Predicate</code> 返回 <code>true</code> 的那个元素可以选择添加到当前集合或下一个集合中；<code>bufferWhile</code> 则<strong>只有当 <code>Predicate</code> 返回 <code>true</code> 时才会收集</strong>. 一旦值为 <code>false</code>, 会立即开始下一次收集. </p>
<p>代码清单 5 给出了 <code>buffer</code> 相关操作符的使用示例. 第一行语句输出的是 5 个包含 20 个元素的数组；第二行语句输出的是 2 个包含了 10 个元素的数组；第三行语句输出的是 5 个包含 2 个元素的数组. 每当遇到一个偶数就会结束当前的收集；第四行语句输出的是 5 个包含 1 个元素的数组, 数组里面包含的只有偶数. </p>
<p>需要注意的是, 在代码清单 5 中, 首先通过 <code>toStream()</code>方法把 Flux 序列转换成 Java 8 中的 <code>Stream</code> 对象, 再通过 <code>forEach()</code>方法来进行输出. 这是因为序列的生成是异步的, 而转换成 <code>Stream</code> 对象可以保证主线程在序列生成完成之前不会退出, 从而可以正确地输出序列中的所有元素. </p>
<p><strong>清单 5. buffer 相关操作符的使用示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Flux.range(1, 100).buffer(20).subscribe(System.out::println);</span><br><span class="line">Flux.interval(Duration.ofMillis(100)).buffer(10).take(2).toStream().forEach(System.out::println);</span><br><span class="line">Flux.range(1, 10).bufferUntil(i -&gt; i % 2 == 0).subscribe(System.out::println);</span><br><span class="line">Flux.range(1, 10).bufferWhile(i -&gt; i % 2 == 0).subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>对流中包含的元素进行过滤, 只留下<strong>满足</strong> <code>Predicate</code> 指定条件的元素. 代码清单 6 中的语句输出的是 1 到 10 中的所有偶数. </p>
<p><strong>清单 6. filter 操作符使用示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Flux.range(1, 10).filter(i -&gt; i % 2 == 0).subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
<h3 id="window"><a href="#window" class="headerlink" title="window"></a>window</h3><p><code>window</code> 操作符的作用类似于 <code>buffer</code>, 所不同的是 <code>window</code> 操作符是把<strong>当前流中的元素收集到另外的 Flux 序列中</strong>, 因此返回值类型是 <code>Flux&lt;Flux&lt;T&gt;&gt;</code>. 在代码清单 7 中, 两行语句的输出结果分别是 5 个和 2 个 <code>UnicastProcessor</code> 字符. 这是因为 <code>window</code> 操作符所产生的流中包含的是 <code>UnicastProcessor</code> 类的对象, 而 <code>UnicastProcessor</code> 类的 <code>toString</code> 方法输出的就是 <code>UnicastProcessor</code> 字符. </p>
<p><strong>清单 7. window 操作符使用示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Flux.range(1, 100).window(20).subscribe(System.out::println);</span><br><span class="line">Flux.intervalMillis(100).windowMillis(1001).take(2).toStream().forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h3 id="zipWith"><a href="#zipWith" class="headerlink" title="zipWith"></a>zipWith</h3><p><code>zipWith</code> 操作符把<strong>当前流中的元素与另外一个流中的元素按照一对一的方式进行合并</strong>. 在合并时可以不做任何处理, 由此得到的是一个元素类型为 <code>Tuple2</code> 的流；也可以通过一个 <code>BiFunction</code> 函数对合并的元素进行处理, 所得到的流的元素类型为该函数的返回值. </p>
<p>在代码清单 8 中, 两个流中包含的元素分别是 a, b 和 c, d. 第一个 <code>zipWith</code> 操作符没有使用合并函数, 因此结果流中的元素类型为 <code>Tuple2</code>；第二个 <code>zipWith</code> 操作通过合并函数把元素类型变为 String. </p>
<p><strong>清单 8. zipWith 操作符使用示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Flux.just(&quot;a&quot;, &quot;b&quot;)</span><br><span class="line">        .zipWith(Flux.just(&quot;c&quot;, &quot;d&quot;))</span><br><span class="line">        .subscribe(System.out::println);</span><br><span class="line">Flux.just(&quot;a&quot;, &quot;b&quot;)</span><br><span class="line">        .zipWith(Flux.just(&quot;c&quot;, &quot;d&quot;), (s1, s2) -&gt; String.format(&quot;%s-%s&quot;, s1, s2))</span><br><span class="line">        .subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
<h3 id="take"><a href="#take" class="headerlink" title="take"></a>take</h3><p><code>take</code> 系列操作符用来从当前流中提取元素. 提取的方式可以有很多种. </p>
<ul>
<li><code>take(long n)</code>, <code>take(Duration timespan)</code>和 <code>takeMillis(long timespan)</code>: 按照指定的数量或时间间隔来提取. </li>
<li><code>takeLast(long n)</code>: 提取流中的最后 N 个元素. </li>
<li><code>takeUntil(Predicate&lt;? super T&gt; predicate)</code>: 提取元素直到 <code>Predicate</code> 返回 <code>true</code>. </li>
<li><code>takeWhile(Predicate&lt;? super T&gt; continuePredicate)</code>: 当 <code>Predicate</code> 返回 <code>true</code> 时才进行提取. </li>
<li><code>takeUntilOther(Publisher&lt;?&gt; other)</code>: 提取元素直到另外一个流开始产生元素. </li>
</ul>
<p>在代码清单 9 中, 第一行语句输出的是数字 1 到 10；第二行语句输出的是数字 991 到 1000；第三行语句输出的是数字 1 到 9；第四行语句输出的是数字 1 到 10, 使得 <code>Predicate</code> 返回 <code>true</code> 的元素也是包含在内的. </p>
<p><strong>清单 9. take 系列操作符使用示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Flux.range(1, 1000).take(10).subscribe(System.out::println);</span><br><span class="line">Flux.range(1, 1000).takeLast(10).subscribe(System.out::println);</span><br><span class="line">Flux.range(1, 1000).takeWhile(i -&gt; i &lt; 10).subscribe(System.out::println);</span><br><span class="line">Flux.range(1, 1000).takeUntil(i -&gt; i == 10).subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
<h3 id="reduce-和-reduceWith"><a href="#reduce-和-reduceWith" class="headerlink" title="reduce 和 reduceWith"></a>reduce 和 reduceWith</h3><p><code>reduce</code> 和 <code>reduceWith</code> 操作符对流中包含的所有元素进行累积操作, 得到一个包含计算结果的 Mono 序列. 累积操作是通过一个 <code>BiFunction</code> 来表示的. 在操作时可以指定一个初始值. 如果没有初始值, 则序列的第一个元素作为初始值. </p>
<p>在代码清单 10 中, 第一行语句对流中的元素进行相加操作, 结果为 5050；第二行语句同样也是进行相加操作, 不过通过一个 <code>Supplier</code> 给出了初始值为 100, 所以结果为 5150. </p>
<p><strong>清单 10. reduce 和 reduceWith 操作符使用示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Flux.range(1, 100).reduce((x, y) -&gt; x + y).subscribe(System.out::println);</span><br><span class="line">Flux.range(1, 100).reduceWith(() -&gt; 100, (x, y) -&gt; x + y).subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
<h3 id="merge-和-mergeSequential"><a href="#merge-和-mergeSequential" class="headerlink" title="merge 和 mergeSequential"></a>merge 和 mergeSequential</h3><p><code>merge</code> 和 <code>mergeSequential</code> 操作符用来把多个流合并成一个 <code>Flux</code> 序列. 不同之处在于 <code>merge</code> <strong>按照所有流中元素的实际产生顺序来合并</strong>, 而 <code>mergeSequential</code> 则<strong>按照所有流被订阅的顺序</strong>, 以流为单位进行合并. </p>
<p>代码清单 11 中分别使用了 <code>merge</code> 和 <code>mergeSequential</code> 操作符. 进行合并的流都是每隔 100 毫秒产生一个元素, 不过第二个流中的每个元素的产生都比第一个流要延迟 50 毫秒. 在使用 <code>merge</code> 的结果流中, 来自<strong>两个流的元素是按照时间顺序交织在一起</strong>；而使用 <code>mergeSequential</code> 的结果流则是首<strong>先产生第一个流中的全部元素, 再产生第二个流中的全部元素</strong>. </p>
<p><strong>清单 11. merge 和 mergeSequential 操作符使用示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Flux.merge(Flux.interval(Duration.ofMillis(100)).take(5), Flux.interval(Duration.ofMillis(50), Duration.ofMillis(100)).take(5)).subscribe(System.out::println);</span><br><span class="line">TimeUnit.SECONDS.sleep(2);</span><br><span class="line">System.out.println();</span><br><span class="line">Flux.mergeSequential(Flux.interval(Duration.ofMillis(100)).take(5), Flux.interval(Duration.ofMillis(50), Duration.ofMillis(100)).take(5))</span><br><span class="line">			.toStream()</span><br><span class="line">			.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h3 id="flatMap-和-flatMapSequential"><a href="#flatMap-和-flatMapSequential" class="headerlink" title="flatMap 和 flatMapSequential"></a>flatMap 和 flatMapSequential</h3><p><code>flatMap</code> 和 <code>flatMapSequential</code> 操作符把流中的<strong>每个元素转换成一个流</strong>, <strong>再把所有流中的元素进行合并</strong>. <code>flatMapSequential</code> 和 <code>flatMap</code> 之间的<strong>区别</strong>与 <code>mergeSequential</code> 和 <code>merge</code> 之间的区别是一样的. </p>
<p>在代码清单 12 中, 流中的元素被转换成每隔 100 毫秒产生的数量不同的流, 再进行合并. 由于第一个流中包含的元素数量较少, 所以在结果流中一开始是两个流的元素交织在一起, 然后就只有第二个流中的元素. </p>
<p><strong>清单 12. flatMap 操作符使用示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Flux.just(5, 10)</span><br><span class="line">        .flatMap(x -&gt; Flux.intervalMillis(x * 10, 100).take(x))</span><br><span class="line">        .toStream()</span><br><span class="line">        .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h3 id="concatMap"><a href="#concatMap" class="headerlink" title="concatMap"></a>concatMap</h3><p><code>concatMap</code> 操作符的作用<strong>也是把流中的每个元素转换成一个流</strong>, 再把所有流进行合并. 与 <code>flatMap</code> 不同的是, <code>concatMap</code> 会根据原始流中的元素顺序<strong>依次</strong>把转换之后的流进行合并；与 <code>flatMapSequential</code> 不同的是, <code>concatMap</code> 对转换之后的流的订阅是动态进行的, 而 <code>flatMapSequential</code> 在合并之前就已经订阅了所有的流. </p>
<p>代码清单 13 与代码清单 12 类似, 只不过把 <code>flatMap</code> 换成了 <code>concatMap</code>, 结果流中依次包含了第一个流和第二个流中的全部元素. </p>
<p><strong>清单 13. concatMap 操作符使用示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Flux.just(5, 10)</span><br><span class="line">        .concatMap(x -&gt; Flux.intervalMillis(x * 10, 100).take(x))</span><br><span class="line">        .toStream()</span><br><span class="line">        .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h3 id="combineLatest"><a href="#combineLatest" class="headerlink" title="combineLatest"></a>combineLatest</h3><p><code>combineLatest</code> 操作符把所有流中的最新产生的元素合并成一个新的元素, 作为返回结果流中的元素. <strong><em>只要其中任何一个流中产生了新的元素</em></strong>, <strong><em>合并操作就会被执行一次</em></strong>, 结果流中就会产生新的元素. 在 代码清单 14 中, 流中最新产生的元素会被收集到一个数组中, 通过 <code>Arrays.toString</code> 方法来把数组转换成 <code>String</code>. </p>
<p><strong>清单 14. combineLatest 操作符使用示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Flux.combineLatest(</span><br><span class="line">        Arrays::toString,</span><br><span class="line">        Flux.intervalMillis(100).take(5),</span><br><span class="line">        Flux.intervalMillis(50, 100).take(5)</span><br><span class="line">).toStream().forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h1 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h1><p>当需要处理 Flux 或 Mono 中的消息时, 如之前的代码清单所示, 可以通过 <code>subscribe</code> 方法来添加相应的<strong>订阅逻辑</strong>. 在调用 <code>subscribe</code> 方法时可以<strong>指定需要处理的消息类型</strong>. 可以只处理其中包含的正常消息, 也可以同时处理错误消息和完成消息. 代码清单 15 中通过 <code>subscribe()</code>方法同时处理了正常消息和错误消息. </p>
<p><strong>清单 15. 通过 subscribe()方法处理正常和错误消息</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Flux.just(1, 2)</span><br><span class="line">        .concatWith(Mono.error(new IllegalStateException()))</span><br><span class="line">        .subscribe(System.out::println, System.err::println);</span><br></pre></td></tr></table></figure>
<p>正常的消息处理相对简单. 当出现错误时, 有多种不同的处理策略. 第一种策略是通过 <code>onErrorReturn()</code>方法返回一个默认值. 在代码清单 16 中, 当出现错误时, 流会产生默认值 0.</p>
<p><strong>清单 16. 出现错误时返回默认值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Flux.just(1, 2)</span><br><span class="line">			.concatWith(Mono.error(new IllegalStateException()))</span><br><span class="line">			.onErrorReturn(0)</span><br><span class="line">			.subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
<p>第二种策略是通过 <code>onErrorResume()</code>方法来根据不同的异常类型来选择要使用的产生元素的流. 在代码清单 18 中, 根据异常类型来返回不同的流作为出现错误时的数据来源. 因为异常的类型为 <code>IllegalArgumentException</code>, 所产生的元素为-1. </p>
<p><strong>清单 18. 出现错误时根据异常类型来选择流</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Flux.just(1, 2)</span><br><span class="line">			.concatWith(Mono.error(new IllegalArgumentException()))</span><br><span class="line">			.onErrorResume(e -&gt; &#123;</span><br><span class="line">				if (e instanceof IllegalStateException) &#123;</span><br><span class="line">					return Mono.just(0);</span><br><span class="line">				&#125; else if (e instanceof IllegalArgumentException) &#123;</span><br><span class="line">					return Mono.just(-1);</span><br><span class="line">				&#125;</span><br><span class="line">				return Mono.empty();</span><br><span class="line">			&#125;)</span><br><span class="line">			.subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
<p>当出现错误时, 还可以通过 <code>retry</code> 操作符来进行重试. 重试的动作是通过重新订阅序列来实现的. 在使用 retry 操作符时可以指定重试的次数. 代码清单 19 中指定了重试次数为 1, 所输出的结果是 1, 2, 1, 2 和错误信息. </p>
<p><strong>清单 19. 使用 retry 操作符进行重试</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Flux.just(1, 2)</span><br><span class="line">        .concatWith(Mono.error(new IllegalStateException()))</span><br><span class="line">        .retry(1)</span><br><span class="line">        .subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
<h1 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h1><p>前面介绍了反应式流和在其上可以进行的各种操作, 通过调度器（<code>Scheduler</code>）可以<strong>指定这些操作执行的方式和所在的线程</strong>. 有下面几种不同的调度器实现. </p>
<ul>
<li>当前线程, 通过 <code>Schedulers.immediate()</code>方法来创建. </li>
<li><strong>单一</strong>的可复用的线程, 通过 <code>Schedulers.single()</code>方法来创建. </li>
<li>使用<strong>弹性的线程池</strong>, 通过 <code>Schedulers.elastic()</code>方法来创建. 线程池中的线程是可以<strong>复用</strong>的. 当所需要时, 新的线程会被创建. 如果一个线程闲置太长时间, 则会被销毁. 该调度器<strong>适用于 I/O 操作</strong>相关的流的处理. </li>
<li>使用对<strong>并行操作优化</strong>的线程池, 通过 <code>Schedulers.parallel()</code>方法来创建. 其中的线程数量<strong>取决于 CPU 的核的数量</strong>. 该调度器<strong>适用于计算密集型的流的处理</strong>. </li>
<li>使用<strong>支持任务调度的调度器</strong>, 通过 <code>Schedulers.timer()</code>方法来创建. </li>
<li>从已有的 <code>ExecutorService</code> 对象中创建调度器, 通过 <code>Schedulers.fromExecutorService()</code>方法来创建. </li>
</ul>
<p>某些操作符默认就已经使用了特定类型的调度器. 比如 <code>interval()</code>方法创建的流就使用了由 <code>Schedulers.parallel()</code>创建的调度器. 通过 <code>publishOn()</code>和 <code>subscribeOn()</code>方法可以切换执行操作的调度器. 其中 <code>publishOn()</code>方法切换的是<strong>操作符的执行方式</strong>, 而 <code>subscribeOn()</code>方法切换的是<strong>产生流中元素时的执行方式</strong>. </p>
<p>在代码清单 20 中, 使用 <code>create()</code>方法创建一个新的 <code>Flux</code> 对象, 其中包含唯一的元素是当前线程的名称. 接着是两对 <code>publishOn()</code>和 <code>map()</code>方法, 其作用是先切换执行时的调度器, 再把当前的线程名称作为前缀添加. 最后通过 <code>subscribeOn()</code>方法来改变流产生时的执行方式. 运行之后的结果是[elastic-2][single-1] parallel-1. 最内层的线程名字 parallel-1 来自产生流中元素时使用的 <code>Schedulers.parallel()</code>调度器, 中间的线程名称 single-1 来自第一个 map 操作之前的 <code>Schedulers.single()</code>调度器, 最外层的线程名字 elastic-2 来自第二个 map 操作之前的 <code>Schedulers.elastic()</code>调度器. </p>
<p><strong>清单 20. 使用调度器切换操作符执行方式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Flux.create(sink -&gt; &#123;</span><br><span class="line">    sink.next(Thread.currentThread().getName());</span><br><span class="line">    sink.complete();</span><br><span class="line">&#125;)</span><br><span class="line">.publishOn(Schedulers.single())</span><br><span class="line">.map(x -&gt; String.format(&quot;[%s] %s&quot;, Thread.currentThread().getName(), x))</span><br><span class="line">.publishOn(Schedulers.elastic())</span><br><span class="line">.map(x -&gt; String.format(&quot;[%s] %s&quot;, Thread.currentThread().getName(), x))</span><br><span class="line">.subscribeOn(Schedulers.parallel())</span><br><span class="line">.toStream()</span><br><span class="line">.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>在对使用 Reactor 的代码进行测试时, 需要用到 <code>io.projectreactor.addons:reactor-test</code> 库. </p>
<h2 id="使用-StepVerifier"><a href="#使用-StepVerifier" class="headerlink" title="使用 StepVerifier"></a>使用 StepVerifier</h2><p>进行测试时的一个典型的场景是对于一个序列, 验证其中所包含的元素是否符合预期. <code>StepVerifier</code> 的作用是可以对序列中包含的元素进行逐一验证. 在代码清单 21 中, 需要验证的流中包含 a 和 b 两个元素. 通过 <code>StepVerifier.create()</code>方法对一个流进行包装之后再进行验证. <code>expectNext()</code>方法用来声明测试时所期待的流中的下一个元素的值, 而 <code>verifyComplete()</code>方法则验证流是否正常结束. 类似的方法还有 <code>verifyError()</code>来验证流由于错误而终止. </p>
<p><strong>清单 21. 使用 StepVerifier 验证流中的元素</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">StepVerifier.create(Flux.just(&quot;a&quot;, &quot;b&quot;))</span><br><span class="line">        .expectNext(&quot;a&quot;)</span><br><span class="line">        .expectNext(&quot;b&quot;)</span><br><span class="line">        .verifyComplete();</span><br></pre></td></tr></table></figure>
<h2 id="操作测试时间"><a href="#操作测试时间" class="headerlink" title="操作测试时间"></a>操作测试时间</h2><p>有些序列的生成是有时间要求的, 比如每隔 1 分钟才产生一个新的元素. 在进行测试中, 不可能花费实际的时间来等待每个元素的生成. 此时需要用到 <code>StepVerifier</code> 提供的<strong>虚拟时间功能</strong>. 通过 <code>StepVerifier.withVirtualTime()</code>方法可以创建出使用虚拟时钟的 <code>StepVerifier</code>. 通过 <code>thenAwait(Duration)</code>方法可以让虚拟时钟<strong>前进</strong>. </p>
<p>在代码清单 22 中, 需要验证的流中包含两个产生间隔为一天的元素, 并且第一个元素的产生延迟是 4 个小时. 在通过 <code>StepVerifier.withVirtualTime()</code>方法包装流之后, <code>expectNoEvent()</code>方法用来验证在 4 个小时之内没有任何消息产生, 然后验证第一个元素 0 产生；接着 <code>thenAwait()</code>方法来让虚拟时钟前进一天, 然后验证第二个元素 1 产生；最后验证流正常结束. </p>
<p><strong>清单 22. 操作测试时间</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">StepVerifier.withVirtualTime(() -&gt; Flux.interval(Duration.ofHours(4), Duration.ofDays(1)).take(2))</span><br><span class="line">        .expectSubscription()</span><br><span class="line">        .expectNoEvent(Duration.ofHours(4))</span><br><span class="line">        .expectNext(0L)</span><br><span class="line">        .thenAwait(Duration.ofDays(1))</span><br><span class="line">        .expectNext(1L)</span><br><span class="line">        .verifyComplete();</span><br></pre></td></tr></table></figure>
<h2 id="使用-TestPublisher"><a href="#使用-TestPublisher" class="headerlink" title="使用 TestPublisher"></a>使用 TestPublisher</h2><p><code>TestPublisher</code> 的作用在于可以控制流中元素的产生, 甚至是<strong>违反</strong>反应流规范的情况. 在代码清单 23 中, 通过 <code>create()</code>方法创建一个新的 <code>TestPublisher</code> 对象, 然后使用 <code>next()</code>方法来产生元素, 使用 <code>complete()</code>方法来结束流. <code>TestPublisher</code> <strong>主要用来测试开发人员自己创建的操作符</strong>. </p>
<p><strong>清单 23. 使用 TestPublisher 创建测试所用的流</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final TestPublisher&lt;String&gt; testPublisher = TestPublisher.create();</span><br><span class="line">testPublisher.next(&quot;a&quot;);</span><br><span class="line">testPublisher.next(&quot;b&quot;);</span><br><span class="line">testPublisher.complete();</span><br><span class="line"> </span><br><span class="line">StepVerifier.create(testPublisher)</span><br><span class="line">        .expectNext(&quot;a&quot;)</span><br><span class="line">        .expectNext(&quot;b&quot;)</span><br><span class="line">        .expectComplete();</span><br></pre></td></tr></table></figure>
<h2 id="启用调试模式"><a href="#启用调试模式" class="headerlink" title="启用调试模式"></a>启用调试模式</h2><p>当需要获取更多与流相关的执行信息时, 可以在程序开始的地方添加代码清单 24 中的代码来启用调试模式. 在调试模式启用之后, 所有的操作符在执行时都会保存额外的与执行链相关的信息. 当出现错误时, 这些信息会被作为异常堆栈信息的一部分输出. 通过这些信息可以分析出具体是在哪个操作符的执行中出现了问题. </p>
<p><strong>清单 24. 启用调试模式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hooks.onOperatorDebug();</span><br></pre></td></tr></table></figure>
<p>不过当调试模式启用之后, 记录这些额外的信息是有代价的. 一般只有在出现了错误之后, 再考虑启用调试模式. 但是当为了找到问题而启用了调试模式之后, 之前的错误不一定能很容易重现出来. 为了减少可能的开销, 可以限制只对特定类型的操作符启用调试模式. </p>
<h2 id="使用检查点"><a href="#使用检查点" class="headerlink" title="使用检查点"></a>使用检查点</h2><p>另外一种做法是通过 <code>checkpoint</code> 操作符来对特定的流处理链来启用调试模式. 代码清单 25 中, 在 <code>map</code> 操作符之后添加了一个名为 <code>test</code> 的检查点. 当出现错误时, 检查点名称会出现在异常堆栈信息中. 对于程序中重要或者复杂的流处理链, 可以在关键的位置上启用检查点来帮助定位可能存在的问题. </p>
<p><strong>清单 25. 使用 checkpoint 操作符</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Flux.just(1, 0).map(x -&gt; 1 / x).checkpoint(&quot;test&quot;).subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
<h2 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h2><p>在开发和调试中的另外一项实用功能是把流相关的事件记录在日志中. 这可以通过添加 <code>log</code> 操作符来实现. 在代码清单 26 中, 添加了 <code>log</code> 操作符并指定了日志分类的名称. </p>
<p><strong>清单 26. 使用 log 操作符记录事件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Flux.range(1, 2).log(&quot;YBD&quot;).subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
<p>在实际的运行时, 所产生的输出如代码清单 27 所示. </p>
<p><strong>清单 27. log 操作符所产生的日志</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">16:18:06.381 [main] DEBUG reactor.util.Loggers$LoggerFactory - Using Slf4j logging framework</span><br><span class="line">16:18:06.391 [main] INFO YBD - | onSubscribe([Synchronous Fuseable] FluxRange.RangeSubscription)</span><br><span class="line">16:18:06.393 [main] INFO YBD - | request(unbounded)</span><br><span class="line">16:18:06.393 [main] INFO YBD - | onNext(1)</span><br><span class="line">1</span><br><span class="line">16:18:06.394 [main] INFO YBD - | onNext(2)</span><br><span class="line">2</span><br><span class="line">16:18:06.394 [main] INFO YBD - | onComplete()</span><br></pre></td></tr></table></figure>
<h1 id="“冷”与“热”序列"><a href="#“冷”与“热”序列" class="headerlink" title="“冷”与“热”序列"></a>“冷”与“热”序列</h1><p>之前的代码清单中所创建的都是<strong>冷序列</strong>. 冷序列的含义是<strong>不论订阅者在何时订阅该序列</strong>, <strong>总是能收到序列中产生的全部消息</strong>. 而与之对应的<strong>热序列</strong>, <strong>则是在持续不断地产生消息</strong>, <strong>订阅者只能获取到在其订阅之后产生的消息</strong>. </p>
<p>在代码清单 28 中, 原始的序列中包含 10 个间隔为 1 秒的元素. 通过 <code>publish()</code>方法把一个 Flux 对象转换成 <code>ConnectableFlux</code> 对象. 方法 <code>autoConnect()</code>的作用是当 <code>ConnectableFlux</code> 对象有一个订阅者时就开始产生消息. 代码 <code>source.subscribe()</code>的作用是订阅该 <code>ConnectableFlux</code> 对象, 让其开始产生数据. 接着当前线程睡眠 5 秒钟, 第二个订阅者此时只能获得到该序列中的后 5 个元素, 因此所输出的是数字 5 到 9. </p>
<p><strong>清单 28. 热序列</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final Flux&lt;Long&gt; source = Flux.interval(Duration.ofSeconds(1))</span><br><span class="line">							.take(10)</span><br><span class="line">							.publish()</span><br><span class="line">							.autoConnect();</span><br><span class="line">source.subscribe();</span><br><span class="line">Thread.sleep(5000);</span><br><span class="line">source.toStream()</span><br><span class="line">	  .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>反应式编程范式对于习惯了传统编程范式的开发人员来说, 既是一个需要进行思维方式转变的挑战, 也是一个充满了更多可能的机会. Reactor 作为一个基于反应式流规范的新的 Java 库, 可以作为反应式应用的基础. 本文对 Reactor 库做了详细的介绍, 包括 Flux 和 Mono 序列的创建、常用操作符的使用、调度器、错误处理以及测试和调试技巧等. </p>
<blockquote>
<p>参考: <strong><em><a href="https://www.ibm.com/developerworks/cn/java/j-cn-with-reactor-response-encode/index.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.ibm.com/developerworks/cn/java/j-cn-with-reactor-response-encode/index.html</a></em></strong></p>
<p>Demo: <strong><em><a href="https://github.com/masteranthoneyd/reactor-simple-demo" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/masteranthoneyd/reactor-simple-demo</a></em></strong></p>
</blockquote>
]]></content><categories><category>Programming</category><category>Java</category></categories><tags><tag>Java</tag><tag>Reactor</tag></tags></entry><entry><title>转载—自己动手写区块链</title><url>/2018/write-your-own-blockchain/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/blockchain/blockchain.jpg" alt></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><blockquote>
<p><strong>区块链</strong>（英语: blockchain 或 block chain）是用<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93" rel="external nofollow noopener noreferrer" target="_blank">分布式数据库</a>识别、传播和记载信息的智能化<a href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E7%AD%89%E7%BD%91%E7%BB%9C" rel="external nofollow noopener noreferrer" target="_blank">对等网络</a>, 也称为价值互联网. <a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%9C%AC%E8%81%AA" rel="external nofollow noopener noreferrer" target="_blank">中本聪</a>在2008年, 于《<a href="https://zh.wikipedia.org/wiki/%E6%AF%94%E7%89%B9%E5%B8%81" rel="external nofollow noopener noreferrer" target="_blank">比特币</a>白皮书》中提出“区块链”概念, 并在2009年创立了<a href="https://zh.wikipedia.org/w/index.php?title=%E6%AF%94%E7%89%B9%E5%B8%81%E7%A4%BE%E4%BC%9A%E7%BD%91%E7%BB%9C&amp;action=edit&amp;redlink=1" rel="external nofollow noopener noreferrer" target="_blank">比特币社会网络</a>, 开发出第一个区块, 即“创世区块”. </p>
<p>区块链共享价值体系首先被众多的<a href="https://zh.wikipedia.org/wiki/%E5%8A%A0%E5%AF%86%E8%B2%A8%E5%B9%A3" rel="external nofollow noopener noreferrer" target="_blank">加密货币</a>效仿, 并在<a href="https://zh.wikipedia.org/wiki/%E5%B7%A5%E4%BD%9C%E9%87%8F%E8%AD%89%E6%98%8E" rel="external nofollow noopener noreferrer" target="_blank">工作量证明</a>上和算法上进行了改进, 如采用<a href="https://zh.wikipedia.org/wiki/%E6%9D%83%E7%9B%8A%E8%AF%81%E6%98%8E" rel="external nofollow noopener noreferrer" target="_blank">权益证明</a>和<a href="https://zh.wikipedia.org/w/index.php?title=SCrypt%E7%AE%97%E6%B3%95&amp;action=edit&amp;redlink=1" rel="external nofollow noopener noreferrer" target="_blank">SCrypt算法</a>. 随后, 区块链生态系统在全球不断进化, 出现了<a href="https://zh.wikipedia.org/wiki/%E9%A6%96%E6%AC%A1%E4%BB%A3%E5%B8%81%E5%8F%91%E5%94%AE" rel="external nofollow noopener noreferrer" target="_blank">首次代币发售</a>ICO；智能合约区块链<a href="https://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E5%9D%8A" rel="external nofollow noopener noreferrer" target="_blank">以太坊</a>；“轻所有权、重使用权”的资产代币化<a href="https://zh.wikipedia.org/wiki/%E5%85%B1%E4%BA%AB%E7%B6%93%E6%BF%9F" rel="external nofollow noopener noreferrer" target="_blank">共享经济</a>； 和<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9B%BD%E5%AE%B6&amp;action=edit&amp;redlink=1" rel="external nofollow noopener noreferrer" target="_blank">区块链国家</a>. 目前, 人们正在利用这一共享价值体系, 在各行各业开发去中心化电脑程序(Decentralized applications, Dapp), 在全球各地构建<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E8%87%AA%E4%B8%BB%E7%BB%84%E7%BB%87&amp;action=edit&amp;redlink=1" rel="external nofollow noopener noreferrer" target="_blank">去中心化自主组织</a>和去中心化自主社区(Decentralized autonomous society, DAS). </p>
<p>——来自维基百科</p>
</blockquote>
<a id="more"></a>
<h1 id="比特币UTXO和去中心化系统的设计"><a href="#比特币UTXO和去中心化系统的设计" class="headerlink" title="比特币UTXO和去中心化系统的设计"></a>比特币UTXO和去中心化系统的设计</h1><blockquote>
<p>引用来自<strong><em><a href="https://github.com/JoeCao" rel="external nofollow noopener noreferrer" target="_blank">JoeCao</a></em></strong>大神的一段<em><a href="https://github.com/JoeCao/JoeCao.github.io/issues/12" rel="external nofollow noopener noreferrer" target="_blank">文章</a></em></p>
</blockquote>
<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>刚进2018年, 区块链突然大火, 程序员们可能莫名其妙, 不就是一个分布式系统么, 怎么突然就要改变互联网了？趁着这个东风, 我们了解一些区块链基础知识. 看看是否可以改变世界. </p>
<h2 id="UTXO是什么"><a href="#UTXO是什么" class="headerlink" title="UTXO是什么"></a>UTXO是什么</h2><p>是Unspent Transaction Output（未消费交易输出）简写. 这绝对是比特币的非常特殊的地方, 理解UTXO也就理解了比特币去中心化的含义. </p>
<p>说起UTXO必须先要介绍交易模型. 以我们平时对交易的理解, 我给张三转账了一笔100块钱, 那就是我的账上的钱少了100, 张三账上的钱多了100. 我们再把问题稍微复杂一些, 我和张三合起来买一个李四的一个商品390块钱. 我的账户支付100, 张三账户支付300, 李四的帐户获得390, 支付宝账户获得了10块钱的转账手续费. 那么对这比交易的记录应该是这样的: </p>
<p><a href="https://camo.githubusercontent.com/dc61609affa838e8aca79b30ce4313b852457743/687474703a2f2f6f7338776a76796b772e626b742e636c6f7564646e2e636f6d2f323031382d30312d32362d3131323832322e6a7067" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://camo.githubusercontent.com/dc61609affa838e8aca79b30ce4313b852457743/687474703a2f2f6f7338776a76796b772e626b742e636c6f7564646e2e636f6d2f323031382d30312d32362d3131323832322e6a7067" alt="帐户模型"></a></p>
<p>这种记账方式常用在财务记账上. 不过作为一个去中心化的系统, 是没有一个中心化银行管理你的开户、销户、余额的. 没有余额, 怎么判断你的账上有100块钱？</p>
<p><a href="https://camo.githubusercontent.com/cfdfe28f28fe95857fa08d75e41692386fc7b26f/687474703a2f2f6f7338776a76796b772e626b742e636c6f7564646e2e636f6d2f323031382d30312d32362d3131323831392e6a7067" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://camo.githubusercontent.com/cfdfe28f28fe95857fa08d75e41692386fc7b26f/687474703a2f2f6f7338776a76796b772e626b742e636c6f7564646e2e636f6d2f323031382d30312d32362d3131323831392e6a7067" alt="如何确认"></a></p>
<p>此时用户C必须将前面几次交易的比特币输出作为下一个关联交易的输入, 具体见下图的no 321笔交易, 用户C将前面获得的两次输出, 作为输入放在了交易中, 然后给自己输出1个比特币的找零（如果不给自己输出找零, 那么这个差额就被矿工当成小费了, 切记切记）. 比特币的程序会判定, 如果两个UTXO加在一起不够支付, 则交易不成功. </p>
<p><a href="https://camo.githubusercontent.com/4f314bd52ecbc90b59054cadb5b96de7dc99d237/687474703a2f2f6f7338776a76796b772e626b742e636c6f7564646e2e636f6d2f323031382d30312d32362d3131323832312e6a7067" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://camo.githubusercontent.com/4f314bd52ecbc90b59054cadb5b96de7dc99d237/687474703a2f2f6f7338776a76796b772e626b742e636c6f7564646e2e636f6d2f323031382d30312d32362d3131323832312e6a7067" alt="区块链基础.001"></a></p>
<p>比特币UTXO使用有点像古代的银锭</p>
<ul>
<li>五两的银锭付给别人二两, 需要通过夹剪将一整块银锭剪成两块, 二两的给别人, 三两的留给自己. 对比: 比特币在输出中重新创建一个新的UTXO作为给自己的找零</li>
<li>要付给别人五两, 手上有几块碎银子单都不足五两, 则需要将碎银子一起付给对方. 对比: 比特币在输入中同时引用多个输出UTXO. </li>
</ul>
<p>这样的做法很繁琐, 所以银两在古代并不是一个很普遍的支付方式（别被武侠片给骗了, 大部分还是用铜钱）.<br>比特币采用UTXO并不能很直观的去理解, 但是为什么要用呢？</p>
<h2 id="使用UTXO的动机"><a href="#使用UTXO的动机" class="headerlink" title="使用UTXO的动机"></a>使用UTXO的动机</h2><p>那么我们站在系统设计的角度猜测一下为什么中本聪会考虑使用UTXO. </p>
<ul>
<li>比特币是没有开户的过程的, 一个本地计算生成公私钥就能构成一个合法的帐户, 甚至有些用户为了一些“靓号”帐户, 通过暴力运算生成天量的再也不会使用的帐户. 去中心化系统无法跟踪每个账户的生成和销毁, 这样的系统里面的帐户数量远大于未消费的输出数量, 所以以UTXO来替代跟踪帐户交易的方式, 消耗的系统资源会比较少 ；</li>
<li>比特币有个比较好的特性是匿名性, 很多人每次交易就换一对公私钥, 交易输出的给自己的找零往往输出到一个另外的帐户下去, UTXO迎合了这种需求. 而使用帐户就没那么灵活了. </li>
<li>如果我使用余额系统, 那么在生成一笔交易的时候, 我首先要考虑的就是“幂等”问题, 因为发出去的交易是给某个帐户加减钱, 如果交易因为网络等原因重新发送, 变成两笔交易重复扣钱, 我就要哭了, 这是在区块链里面著名的“重放攻击”. 所以交易必须设计一个唯一的标识id让服务器知道这是同一笔交易. 但是在去中心化系统中没有一个超级服务器统一分配交易ID, 只能本地生成, 而且跟踪这些交易ID的状态, 也是一个很大的负担, 因为我需要将区块链从创世块到现在所有的交易都遍历一遍, 才能确定是是否是重复交易. 如果用UTXO就可以避免这个问题, UTXO相比交易数少了不止一个数量级, 而且UTXO只有两个状态—未消费、被消费, 比特币只能有一个操作— 将为消费的UTXO变为已消费状态. 不管我发送多少次交易, 都会得到一个结果. </li>
<li>在中本聪倡导每个cpu都是一票的去中心化社区, 让每个节点都有能力去做计算是需要特别重视的, 否则单个节点的计算能力要求过高, 整个系统将向着“中心化”趋势滑下去. </li>
</ul>
<p>在比特币的实现中, 是把所有的UTXO保存在一个单独的UTXOSet缓存中, 截止2017年9月, 这个缓存大概2.7Gb, 与之对应, 整个区块链的交易数据达到140Gb, UTXO缓存像是一个只保存了最终一个状态的git, 整体的消耗负担小了很多很多. </p>
<p>但是中本聪没想到, 很多人现在把交易输出的脚本玩出花来了, 导致很多UTXO创建出来就是不为消费用的, 永远不会被消费掉, 节点的负担越来越重. 这才有了后续的<strong>BIP改进</strong>以及<strong>以太坊的账户模型</strong>. 那又是一个很长的故事了…</p>
<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><blockquote>
<p>也可以看一下这一篇: <strong><em><a href="https://yemengying.com/2018/02/11/hash-blockchain/" rel="external nofollow noopener noreferrer" target="_blank">https://yemengying.com/2018/02/11/hash-blockchain/</a></em></strong></p>
</blockquote>
<p>2018年开始区块链真是火啊. 一夜暴富的例子一直在传说. 今天我们就自己动手写一个基本的区块链. </p>
<p>先简单的说一下区块链是个什么（相信你早就知道了）. </p>
<p>区块链就是一个链表. 把一堆区块串起来就是区块链. 每个<code>block</code>有自己的数字签名（就是一串不规则看起来叼叼的字符串）, 同时包含有上一个<code>block</code>的数字签名, 然后包含一些其他的<code>data</code>. </p>
<p>大体就长这样: </p>
<p><img src="https://cdn.yangbingdong.com/img/blockchain/blockchain01.webp" alt="img"></p>
<p>是不是很熟悉, 链表. </p>
<p>好, 继续. </p>
<p>数字签名是什么？就是<code>hash</code>. </p>
<p>而且每个<code>block</code>含有前一个<code>block</code>的<code>hash</code>值, 而且每个<code>block</code>自己的<code>hash</code>也是由前一个的<code>hash</code>计算得来的. 如果前一个<code>block</code>（数据块）的数据发生改变, 那么前一个的<code>hash</code>值也改变了, 由此就会影响到之后的数据块的所有<code>hash</code>值. </p>
<p>所以, 通过计算和对比<code>hash</code>值这种方式我们就可以知道区块链是不是合法的, 是不是已经被篡改. </p>
<p>什么意思呢？意味着只要你修改了区块链中的任何一个块中的数据, 都将会改变<code>hash</code>, 从而破坏了整个链. </p>
<p>好, 不多说. 上代码: </p>
<h2 id="block块定义"><a href="#block块定义" class="headerlink" title="block块定义"></a><strong>block块定义</strong></h2><p>先新建个block块: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Block &#123;</span><br><span class="line"></span><br><span class="line">   public String hash;</span><br><span class="line">   public String previousHash; </span><br><span class="line">   private String data; //our data will be a simple message.</span><br><span class="line">   private long timeStamp; //as number of milliseconds since 1/1/1970.</span><br><span class="line"></span><br><span class="line">   //Block Constructor.  </span><br><span class="line">   public Block(String data,String previousHash ) &#123;</span><br><span class="line">      this.data = data;</span><br><span class="line">      this.previousHash = previousHash;</span><br><span class="line">      this.timeStamp = new Date().getTime();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也看到了我们的<code>Block</code>里有四个字段, <code>hash</code>就是这个块自己的<code>hash</code>值, <code>previousHash</code>就是上一个块的<code>hash</code>值, <code>data</code>就是这个块所持有的数据, <code>timeStamp</code>就是一个时间记录. </p>
<h2 id="数字签名生成"><a href="#数字签名生成" class="headerlink" title="数字签名生成"></a><strong>数字签名生成</strong></h2><p>接下来我们就需要生成数字签名. </p>
<p>有很多种的加密算法来生成数字签名. 这里我们就选择<code>SHA256</code>. 这里先新建一个工具类用来搞定这个件事情: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.security.MessageDigest;//通过导入MessageDigest来使用SHA256</span><br><span class="line"></span><br><span class="line">public class StringUtil &#123;</span><br><span class="line"></span><br><span class="line">   //Applies Sha256 to a string and returns the result. </span><br><span class="line">   public static String applySha256(String input)&#123;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">         MessageDigest digest = MessageDigest.getInstance(&quot;SHA-256&quot;);</span><br><span class="line"></span><br><span class="line">         //Applies sha256 to our input, </span><br><span class="line">         byte[] hash = digest.digest(input.getBytes(&quot;UTF-8&quot;));</span><br><span class="line"></span><br><span class="line">         StringBuffer hexString = new StringBuffer(); // This will contain hash as hexidecimal</span><br><span class="line">         for (int i = 0; i &lt; hash.length; i++) &#123;</span><br><span class="line">            String hex = Integer.toHexString(0xff &amp; hash[i]);</span><br><span class="line">            if(hex.length() == 1) hexString.append(&apos;0&apos;);</span><br><span class="line">            hexString.append(hex);</span><br><span class="line">         &#125;</span><br><span class="line">         return hexString.toString();</span><br><span class="line">      &#125;</span><br><span class="line">      catch(Exception e) &#123;</span><br><span class="line">         throw new RuntimeException(e);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //Short hand helper to turn Object into a json string</span><br><span class="line">   public static String getJson(Object o) &#123;</span><br><span class="line">      return new GsonBuilder().setPrettyPrinting().create().toJson(o);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //Returns difficulty string target, to compare to hash. eg difficulty of 5 will return &quot;00000&quot;  </span><br><span class="line">   public static String getDificultyString(int difficulty) &#123;</span><br><span class="line">      return new String(new char[difficulty]).replace(&apos;\0&apos;, &apos;0&apos;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好, 现在我们在<code>Block</code>里添加生成<code>hash</code>的方法: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//Calculate new hash based on blocks contents</span><br><span class="line">public String calculateHash() &#123;</span><br><span class="line">   String calculatedhash = StringUtil.applySha256( </span><br><span class="line">         previousHash +</span><br><span class="line">         Long.toString(timeStamp) +</span><br><span class="line">         Integer.toString(nonce) + </span><br><span class="line">         data </span><br><span class="line">         );</span><br><span class="line">   return calculatedhash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们在构造函数里添加<code>hash</code>值的计算: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//Block Constructor.  </span><br><span class="line">public Block(String data,String previousHash ) &#123;</span><br><span class="line">   this.data = data;</span><br><span class="line">   this.previousHash = previousHash;</span><br><span class="line">   this.timeStamp = new Date().getTime();</span><br><span class="line"></span><br><span class="line">   this.hash = calculateHash(); //Making sure we do this after we set the other values.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一试身手"><a href="#一试身手" class="headerlink" title="一试身手"></a><strong>一试身手</strong></h2><p>现在是时候一试身手了. 我们新建一个<code>main</code>类来玩耍一次: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">   Block genesisBlock = new Block(&quot;Hi im the first block&quot;, &quot;0&quot;);</span><br><span class="line">   System.out.println(&quot;block 1的hash值 : &quot; + genesisBlock.hash);</span><br><span class="line"></span><br><span class="line">   Block secondBlock = new Block(&quot;Yo im the second block&quot;,genesisBlock.hash);</span><br><span class="line">   System.out.println(&quot;block 2的hash值: &quot; + secondBlock.hash);</span><br><span class="line"></span><br><span class="line">   Block thirdBlock = new Block(&quot;Hey im the third block&quot;,secondBlock.hash);</span><br><span class="line">   System.out.println(&quot;block 3的hash值: &quot; + thirdBlock.hash);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下: </p>
<p><img src="https://cdn.yangbingdong.com/img/blockchain/blockchain02.webp" alt="img"></p>
<p><em><code>hash</code>值是不一样的, 因为每个<code>block</code>的时间戳不同. </em></p>
<p>现在每个块都有了自己的数字签名, 并且这些数字签名都是基于每个块自身的信息以及前一个块的数字签名联合起来生成的数字签名. </p>
<p>但, 现在还不能叫区块链. 只是一个个区块. 接下来就让我们把这些块装入一个<code>ArrayList</code>中: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static ArrayList&lt;Block&gt; blockchain = new ArrayList&lt;Block&gt;();</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    //add our blocks to the blockchain ArrayList:</span><br><span class="line">    blockchain.add(new Block(&quot;Hi im the first block&quot;, &quot;0&quot;));</span><br><span class="line">    blockchain.add(new Block(&quot;Yo im the second block&quot;,blockchain.get(blockchain.size()-1).hash));</span><br><span class="line">    blockchain.add(new Block(&quot;Hey im the third block&quot;,blockchain.get(blockchain.size()-1).hash));</span><br><span class="line"></span><br><span class="line">    String blockchainJson = new GsonBuilder().setPrettyPrinting().create().toJson(blockchain);</span><br><span class="line">    System.out.println(blockchainJson);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在看起来就比较紧凑了, 也像个区块链的样子了: </p>
<p><img src="https://cdn.yangbingdong.com/img/blockchain/blockchain03.webp" alt="img"></p>
<h2 id="检查区块链的完整性"><a href="#检查区块链的完整性" class="headerlink" title="检查区块链的完整性"></a><strong>检查区块链的完整性</strong></h2><p>现在就让我们在<code>ImportChain</code>中创建一个<code>isChainValid()</code>方法, 它会遍历链中每个块, 然后对比<code>hash</code>值. 这个方法做的事情就是检查<code>hash</code>变量的值是否等于计算出来的<code>hash</code>值以及上一个块的<code>hash</code>是否等于<code>previousHash</code>变量的值. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Boolean isChainValid() &#123;</span><br><span class="line">   Block currentBlock; </span><br><span class="line">   Block previousBlock;</span><br><span class="line">   String hashTarget = new String(new char[difficulty]).replace(&apos;\0&apos;, &apos;0&apos;);</span><br><span class="line"></span><br><span class="line">   //循环遍历每个块检查hash</span><br><span class="line">   for(int i=1; i &lt; blockchain.size(); i++) &#123;</span><br><span class="line">      currentBlock = blockchain.get(i);</span><br><span class="line">      previousBlock = blockchain.get(i-1);</span><br><span class="line">      //比较注册的hash和计算的hash:</span><br><span class="line">      if(!currentBlock.hash.equals(currentBlock.calculateHash()) )&#123;</span><br><span class="line">         System.out.println(&quot;Current Hashes not equal&quot;);          </span><br><span class="line">         return false;</span><br><span class="line">      &#125;</span><br><span class="line">      //比较上一个块的hash和注册的上一个hash（也就是previousHash）</span><br><span class="line">      if(!previousBlock.hash.equals(currentBlock.previousHash) ) &#123;</span><br><span class="line">         System.out.println(&quot;Previous Hashes not equal&quot;);</span><br><span class="line">         return false;</span><br><span class="line">      &#125;</span><br><span class="line">      //检查hash是否被处理</span><br><span class="line">      if(!currentBlock.hash.substring( 0, difficulty).equals(hashTarget)) &#123;</span><br><span class="line">         System.out.println(&quot;This block hasn&apos;t been mined&quot;);</span><br><span class="line">         return false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对区块链中的块的任何更改都将导致此方法返回false. </p>
<p>On the bitcoin network nodes share their blockchains and the <strong>longest valid chain is accepted</strong> by the network. What’s to stop someone tampering with data in an old block then creating a whole new longer blockchain and presenting that to the network ? <strong>Proof of work</strong>. The hashcash proof of work system means it takes considerable time and computational power to create new blocks. Hence the attacker would need more computational power than the rest of the peers combined.</p>
<p>上面说的就是POW . 之后会介绍. </p>
<p>好, 上面基本上把区块链搞完了. </p>
<p>现在我们开始新的征程吧！</p>
<h2 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a><strong>挖矿</strong></h2><p>我们将要求矿工们来做POW, 具体就是通过尝试不同的变量直到块的<code>hash</code>以几个0开头. </p>
<p>然后我们添加一个<code>nonce</code>（Number once）到<code>calculateHash()</code> 方法以及<code>mineBlock()</code>方法: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ImportChain &#123;</span><br><span class="line"></span><br><span class="line">   public static ArrayList&lt;Block&gt; blockchain = new ArrayList&lt;Block&gt;();</span><br><span class="line">   public static int difficulty = 5;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      //add our blocks to the blockchain ArrayList:</span><br><span class="line"></span><br><span class="line">      System.out.println(&quot;正在尝试挖掘block 1... &quot;);</span><br><span class="line">      addBlock(new Block(&quot;Hi im the first block&quot;, &quot;0&quot;));</span><br><span class="line"></span><br><span class="line">      System.out.println(&quot;正在尝试挖掘block 2... &quot;);</span><br><span class="line">      addBlock(new Block(&quot;Yo im the second block&quot;,blockchain.get(blockchain.size()-1).hash));</span><br><span class="line"></span><br><span class="line">      System.out.println(&quot;正在尝试挖掘block 3... &quot;);</span><br><span class="line">      addBlock(new Block(&quot;Hey im the third block&quot;,blockchain.get(blockchain.size()-1).hash));</span><br><span class="line"></span><br><span class="line">      System.out.println(&quot;\nBlockchain is Valid: &quot; + isChainValid());</span><br><span class="line"></span><br><span class="line">      String blockchainJson = StringUtil.getJson(blockchain);</span><br><span class="line">      System.out.println(&quot;\nThe block chain: &quot;);</span><br><span class="line">      System.out.println(blockchainJson);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static Boolean isChainValid() &#123;</span><br><span class="line">      Block currentBlock; </span><br><span class="line">      Block previousBlock;</span><br><span class="line">      String hashTarget = new String(new char[difficulty]).replace(&apos;\0&apos;, &apos;0&apos;);</span><br><span class="line"></span><br><span class="line">      //loop through blockchain to check hashes:</span><br><span class="line">      for(int i=1; i &lt; blockchain.size(); i++) &#123;</span><br><span class="line">         currentBlock = blockchain.get(i);</span><br><span class="line">         previousBlock = blockchain.get(i-1);</span><br><span class="line">         //compare registered hash and calculated hash:</span><br><span class="line">         if(!currentBlock.hash.equals(currentBlock.calculateHash()) )&#123;</span><br><span class="line">            System.out.println(&quot;Current Hashes not equal&quot;);          </span><br><span class="line">            return false;</span><br><span class="line">         &#125;</span><br><span class="line">         //compare previous hash and registered previous hash</span><br><span class="line">         if(!previousBlock.hash.equals(currentBlock.previousHash) ) &#123;</span><br><span class="line">            System.out.println(&quot;Previous Hashes not equal&quot;);</span><br><span class="line">            return false;</span><br><span class="line">         &#125;</span><br><span class="line">         //check if hash is solved</span><br><span class="line">         if(!currentBlock.hash.substring( 0, difficulty).equals(hashTarget)) &#123;</span><br><span class="line">            System.out.println(&quot;This block hasn&apos;t been mined&quot;);</span><br><span class="line">            return false;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      return true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void addBlock(Block newBlock) &#123;</span><br><span class="line">      newBlock.mineBlock(difficulty);</span><br><span class="line">      blockchain.add(newBlock);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class Block &#123;</span><br><span class="line"></span><br><span class="line">   public String hash;</span><br><span class="line">   public String previousHash; </span><br><span class="line">   private String data; //our data will be a simple message.</span><br><span class="line">   private long timeStamp; //as number of milliseconds since 1/1/1970.</span><br><span class="line">   private int nonce;</span><br><span class="line"></span><br><span class="line">   //Block Constructor.  </span><br><span class="line">   public Block(String data,String previousHash ) &#123;</span><br><span class="line">      this.data = data;</span><br><span class="line">      this.previousHash = previousHash;</span><br><span class="line">      this.timeStamp = new Date().getTime();</span><br><span class="line"></span><br><span class="line">      this.hash = calculateHash(); //Making sure we do this after we set the other values.</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //Calculate new hash based on blocks contents</span><br><span class="line">   public String calculateHash() &#123;</span><br><span class="line">      String calculatedhash = StringUtil.applySha256( </span><br><span class="line">            previousHash +</span><br><span class="line">            Long.toString(timeStamp) +</span><br><span class="line">            Integer.toString(nonce) + </span><br><span class="line">            data </span><br><span class="line">            );</span><br><span class="line">      return calculatedhash;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //Increases nonce value until hash target is reached.</span><br><span class="line">   public void mineBlock(int difficulty) &#123;</span><br><span class="line">      String target = StringUtil.getDificultyString(difficulty); //Create a string with difficulty * &quot;0&quot; </span><br><span class="line">      while(!hash.substring( 0, difficulty).equals(target)) &#123;</span><br><span class="line">         nonce ++;</span><br><span class="line">         hash = calculateHash();</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(&quot;Block已挖到!!! : &quot; + hash);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行main, 输出如下: </p>
<p><img src="https://cdn.yangbingdong.com/img/blockchain/blockchain04.webp" alt="img"></p>
<p>挖掘每一个块都需要一些时间, 大概3秒钟. 你可以调整难度, 看看是如何影响挖矿时间的. </p>
<p>如果有人要窜改区块链中的数据, 那么他们的区块链将是无效的, invalid. </p>
<p>他们将无法创建更长的区块链. </p>
<p>在你的网络中诚实的区块链有更大的时间优势来创建一个最长的链. </p>
<p>被篡改的区块链将无法追上更长、更有效的链. </p>
<p>除非它们比网络中的所有其他节点具有更快的计算速度. 比如未来的量子计算机之类的东西. </p>
<p>好, 我们已经完成了一个基本的区块链！</p>
<p>总结一下我们的这个区块链: </p>
<ul>
<li>每个区块上携带数据. </li>
<li>有数字签名. </li>
<li>必须通过POW来挖掘来验证新的区块. </li>
<li>可以验证数据是否合法和是否被修改. </li>
</ul>
<blockquote>
<p><strong><em><a href="https://mp.weixin.qq.com/s?__biz=MzA5MzQ2NTY0OA==&amp;mid=2650797410&amp;idx=1&amp;sn=c16d1b0064768479a05dc65cf2b542d3&amp;chksm=8856283dbf21a12be25300c012dc344199320f54a13b54d595c4db899d74ede95cb06d7e784c&amp;mpshare=1&amp;scene=1&amp;srcid=0305VPK6hQFN8yg7iE3wz917#rd" rel="external nofollow noopener noreferrer" target="_blank">原文链接</a></em></strong></p>
</blockquote>
<h1 id="发起一笔交易"><a href="#发起一笔交易" class="headerlink" title="发起一笔交易"></a>发起一笔交易</h1><p>上一文我们已经学会了写一个基本的区块链: <a href="http://mp.weixin.qq.com/s?__biz=MzA5MzQ2NTY0OA==&amp;mid=2650797410&amp;idx=1&amp;sn=c16d1b0064768479a05dc65cf2b542d3&amp;chksm=8856283dbf21a12be25300c012dc344199320f54a13b54d595c4db899d74ede95cb06d7e784c&amp;scene=21#wechat_redirect" rel="external nofollow noopener noreferrer" target="_blank">自己动手写区块链（Java版）</a>. </p>
<p>本文我们接着前文, 继续深入. </p>
<p>本文我们将会做以下事情: </p>
<p>1、创建一个钱包（wallet）. </p>
<p>2、使用我们的前面创建的区块链发送一笔签名的交易出去. </p>
<p>3、还有其他更叼的事情等等. </p>
<p>听起来是不是就让人心动. </p>
<p>最后的结果就是我们有了自己的<strong>加密货币</strong>, 是的, <code>crypto coin</code>. </p>
<p>前面我们已经构建了一个基本的区块链. 但目前这个区块链的区块中的<code>message</code>是一些没有什么实际用途和意义的数据. 本文我们就尝试让区块中能够存储一些交易数据（一个区块中可以存储多笔交易数据）, 这样我们就可以创建自己的加密货币（当然还是一个简单的）, 这里给我们的货币起个名字叫: “NoobCoin”. </p>
<h2 id="1、创建钱包"><a href="#1、创建钱包" class="headerlink" title="1、创建钱包"></a><strong>1、创建钱包</strong></h2><p>在加密货币（crypto-currencies）中, 货币所有权被作为交易（transaction）在区块链上进行转移, 参与者有一个收发资金的地址. </p>
<p><img src="https://cdn.yangbingdong.com/img/blockchain/blockchain5.webp" alt="img"></p>
<p>好, 现在让我们创建一个钱包（Wallet）来持有<code>pubkey</code>和<code>private key</code>: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.security.*;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Wallet &#123;</span><br><span class="line"></span><br><span class="line">   public PrivateKey privateKey;</span><br><span class="line">   public PublicKey publicKey;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>公钥和私钥的用途是什么？</strong></p>
<p>对于我们的“<code>noobcoin</code>”, 公钥（<code>public key</code>）就是我们的一个地址, <code>address</code>. </p>
<p>可以与其他人共享这个公钥, 来接受支付. 我们的私钥是用来签署（<code>sign</code>）我们的交易（<code>transaction</code>）, 所以除了私钥（<code>private key</code>）的所有者, 没有人可以花我们的钱. 用户将不得不对自己的私钥保密！我们还将公钥与交易（<code>transaction</code>）一起发送, 它可以用来验证我们的签名是否有效, 并且数据没有被篡改. </p>
<p><img src="https://cdn.yangbingdong.com/img/blockchain/blockchain06.webp" alt="img"></p>
<p><em>私钥用于对我们不希望被篡改的数据进行签名. 公钥用于验证签名. </em></p>
<p>我们在一个<code>KeyPair</code>中生成我们的私钥和公钥. 这里使用<code>Elliptic-curve</code>加密来生成<code>KeyPair</code>. 现在我们就去<code>Wallet</code>类中添加一个方法<code>generateKeyPair()</code>, 然后在构造函数中调用它: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Wallet &#123;</span><br><span class="line"></span><br><span class="line">   public PrivateKey privateKey;</span><br><span class="line">   public PublicKey publicKey;</span><br><span class="line"></span><br><span class="line">   public Wallet() &#123;</span><br><span class="line">      generateKeyPair();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void generateKeyPair() &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">         KeyPairGenerator keyGen = KeyPairGenerator.getInstance(&quot;ECDSA&quot;,&quot;BC&quot;);</span><br><span class="line">         SecureRandom random = SecureRandom.getInstance(&quot;SHA1PRNG&quot;);</span><br><span class="line">         ECGenParameterSpec ecSpec = new ECGenParameterSpec(&quot;prime192v1&quot;);</span><br><span class="line">         // Initialize the key generator and generate a KeyPair</span><br><span class="line">         keyGen.initialize(ecSpec, random); //256 </span><br><span class="line">           KeyPair keyPair = keyGen.generateKeyPair();</span><br><span class="line">           // Set the public and private keys from the keyPair</span><br><span class="line">           privateKey = keyPair.getPrivate();</span><br><span class="line">           publicKey = keyPair.getPublic();</span><br><span class="line"></span><br><span class="line">      &#125;catch(Exception e) &#123;</span><br><span class="line">         throw new RuntimeException(e);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法就是负责生成公钥和私钥. 具体就是通过<code>Java.security.KeyPairGenerator</code>来生成<code>Elliptic Curve key</code>对. 然后把这个方法加入到<code>Wallet</code>的<strong>构造函</strong>数中. </p>
<p>现在我们已经有了一个大体的钱包类. 接下来我们看看交易（<code>transaction</code>）类. </p>
<h2 id="2-交易和签名（Transactions-amp-Signatures）"><a href="#2-交易和签名（Transactions-amp-Signatures）" class="headerlink" title="2. 交易和签名（Transactions &amp; Signatures）"></a><strong>2. 交易和签名（Transactions &amp; Signatures）</strong></h2><p>每笔交易将会携带如下数据: </p>
<p>1、资金发送方的公钥（地址）. </p>
<p>2、资金接收方的公钥（地址）. </p>
<p>3、要转移的资金金额. </p>
<p>4、输入（<code>Inputs</code>）. 这个输入是对以前交易的引用, 这些交易证明发件人拥有要发送的资金. </p>
<p>5、输出（<code>Outputs</code>）, 显示交易中收到的相关地址量. （这些输出作为新交易中的输入引用）</p>
<p>6、一个加密签名. 证明地址的所有者是发起该交易的人, 并且数据没有被更改. （例如: 防止第三方更改发送的金额）</p>
<p>让我们创建交易类吧: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.security.*;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class Transaction &#123;</span><br><span class="line"></span><br><span class="line">   public String transactionId; //Contains a hash of transaction*</span><br><span class="line">   public PublicKey sender; //Senders address/public key.</span><br><span class="line">   public PublicKey reciepient; //Recipients address/public key.</span><br><span class="line">   public float value; //Contains the amount we wish to send to the recipient.</span><br><span class="line">   public byte[] signature; //This is to prevent anybody else from spending funds in our wallet.</span><br><span class="line"></span><br><span class="line">   public ArrayList&lt;TransactionInput&gt; inputs = new ArrayList&lt;TransactionInput&gt;();</span><br><span class="line">   public ArrayList&lt;TransactionOutput&gt; outputs = new ArrayList&lt;TransactionOutput&gt;();</span><br><span class="line"></span><br><span class="line">   private static int sequence = 0; //A rough count of how many transactions have been generated </span><br><span class="line"></span><br><span class="line">   // Constructor: </span><br><span class="line">   public Transaction(PublicKey from, PublicKey to, float value,  ArrayList&lt;TransactionInput&gt; inputs) &#123;</span><br><span class="line">      this.sender = from;</span><br><span class="line">      this.reciepient = to;</span><br><span class="line">      this.value = value;</span><br><span class="line">      this.inputs = inputs;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private String calulateHash() &#123;</span><br><span class="line">      sequence++; //increase the sequence to avoid 2 identical transactions having the same hash</span><br><span class="line">      return StringUtil.applySha256(</span><br><span class="line">            StringUtil.getStringFromKey(sender) +</span><br><span class="line">            StringUtil.getStringFromKey(reciepient) +</span><br><span class="line">            Float.toString(value) + sequence</span><br><span class="line">            );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的<code>TransactionInput</code>和<code>TransactionOutput</code>类一会再新建. </p>
<p>我们的交易（<code>Transaction</code>）类还应该包含生成/验证签名和验证交易的相关方法. </p>
<p>注意这里, 既有验证签名的方法, 也有验证交易的方法. </p>
<p>但是, 稍等…</p>
<p>先来说说签名的目的是什么？它们是如何工作的？</p>
<p><strong>签名在我们的区块链上执行两个非常重要的任务: 首先, 它能只允许所有者使用其货币；其次, 在新区块被挖掘之前, 它能防止其他人篡改其提交的交易（在入口点）</strong>. </p>
<p><strong>私钥用于对数据进行签名, 公钥可用于验证其完整性</strong>. </p>
<p>例如: Bob想给Sally发送2个NoobCoin, 然后他们的钱包软件生成了这个交易并将其提交给矿工, 以便将其包含在下一个块中. 一名矿工试图将2枚货币的接收人改为Josh. 不过, 幸运的是, Bob已经用他的私钥签署了交易数据, 允许任何人使用Bob的公钥去验证交易数据是否被更改（因为没有其他任何人的公钥能够验证交易）. </p>
<p>可以（从前面的代码块中）看到我们的签名就是一堆字节, 所以现在创建一个方法来生成签名. 我们首先需要的是<code>StringUtil</code>类中的几个<code>helper</code>方法: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//Applies ECDSA Signature and returns the result ( as bytes ).</span><br><span class="line">public static byte[] applyECDSASig(PrivateKey privateKey, String input) &#123;</span><br><span class="line">   Signature dsa;</span><br><span class="line">   byte[] output = new byte[0];</span><br><span class="line">   try &#123;</span><br><span class="line">      dsa = Signature.getInstance(&quot;ECDSA&quot;, &quot;BC&quot;);</span><br><span class="line">      dsa.initSign(privateKey);</span><br><span class="line">      byte[] strByte = input.getBytes();</span><br><span class="line">      dsa.update(strByte);</span><br><span class="line">      byte[] realSig = dsa.sign();</span><br><span class="line">      output = realSig;</span><br><span class="line">   &#125; catch (Exception e) &#123;</span><br><span class="line">      throw new RuntimeException(e);</span><br><span class="line">   &#125;</span><br><span class="line">   return output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Verifies a String signature</span><br><span class="line">public static boolean verifyECDSASig(PublicKey publicKey, String data, byte[] signature) &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">      Signature ecdsaVerify = Signature.getInstance(&quot;ECDSA&quot;, &quot;BC&quot;);</span><br><span class="line">      ecdsaVerify.initVerify(publicKey);</span><br><span class="line">      ecdsaVerify.update(data.getBytes());</span><br><span class="line">      return ecdsaVerify.verify(signature);</span><br><span class="line">   &#125;catch(Exception e) &#123;</span><br><span class="line">      throw new RuntimeException(e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static String getStringFromKey(Key key) &#123;</span><br><span class="line">   return Base64.getEncoder().encodeToString(key.getEncoded());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>不要过分担心这些方法具体的逻辑. 你只需要知道的是: <code>applyECDSASig</code>方法接收发送方的私钥和字符串输入, 对其进行签名并返回字节数组. <code>verifyECDSASig</code>接受签名、公钥和字符串数据, 如果签名是有效的, 则返回<code>true</code>, 否则<code>false</code>. <code>getStringFromKey</code>从任意<code>key</code>返回编码的字符串. </em></p>
<p>现在让我们在<code>Transaction</code>类中使用这些签名方法, 分别创建<code>generateSignature()</code>和<code>verifiySignature()</code>方法: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void generateSignature(PrivateKey privateKey) &#123;</span><br><span class="line">   String data = StringUtil.getStringFromKey(sender) + StringUtil.getStringFromKey(reciepient) + Float.toString(value)    ;</span><br><span class="line">   signature = StringUtil.applyECDSASig(privateKey,data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean verifySignature() &#123;</span><br><span class="line">   String data = StringUtil.getStringFromKey(sender) + StringUtil.getStringFromKey(reciepient) + Float.toString(value)    ;</span><br><span class="line">   return StringUtil.verifyECDSASig(sender, data, signature);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在现实中, 你可能希望签署更多的信息, 比如使用的输出（outputs）/输入（inputs）和/或时间戳（time-stamp）（现在我们只签署了最基本的）. </p>
<p>在将新的交易添加到块中时, 矿工将对签名进行验证. </p>
<p>当我们检查区块链的合法性的时候, 其实也可以检查签名. </p>
<h2 id="3-测试钱包（Wallets）和签名（Signatures）"><a href="#3-测试钱包（Wallets）和签名（Signatures）" class="headerlink" title="3.测试钱包（Wallets）和签名（Signatures）"></a><strong>3.测试钱包（Wallets）和签名（Signatures）</strong></h2><p>现在我们差不多完成了一半了, 先来测试下已经完成的是不是可以正常工作. 在<code>NoobChain</code>类中, 让我们添加一些新变量并替换main方法的内容如下: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.security.Security;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">public class NoobChain &#123;</span><br><span class="line"></span><br><span class="line">    public static ArrayList&lt;Block&gt; blockchain = new ArrayList&lt;Block&gt;();</span><br><span class="line">    public static int difficulty = 5;</span><br><span class="line">    public static Wallet walletA;</span><br><span class="line">    public static Wallet walletB;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //Setup Bouncey castle as a Security Provider</span><br><span class="line">        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());</span><br><span class="line">        //Create the new wallets</span><br><span class="line">        walletA = new Wallet();</span><br><span class="line">        walletB = new Wallet();</span><br><span class="line">        //Test public and private keys</span><br><span class="line">        System.out.println(&quot;Private and public keys:&quot;);</span><br><span class="line">        System.out.println(StringUtil.getStringFromKey(walletA.privateKey));</span><br><span class="line">        System.out.println(StringUtil.getStringFromKey(walletA.publicKey));</span><br><span class="line">        //Create a test transaction from WalletA to walletB</span><br><span class="line">        Transaction transaction = new Transaction(walletA.publicKey, walletB.publicKey, 5, null);</span><br><span class="line">        transaction.generateSignature(walletA.privateKey);</span><br><span class="line">        //Verify the signature works and verify it from the public key</span><br><span class="line">        System.out.println(&quot;Is signature verified&quot;);</span><br><span class="line">        System.out.println(transaction.verifySignature());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现我们使用了<code>boncey castle</code>来作为安全实现的提供者. </p>
<p>还创建了两个钱包, 钱包A和钱包B, 然后打印了钱包A的私钥和公钥. 还新建一笔交易. 然后使用钱包A的公钥对这笔交易进行了签名. </p>
<p>输出:</p>
<p><img src="https://cdn.yangbingdong.com/img/blockchain/blockchain07.webp" alt="img"></p>
<p>嗯, 签名验证是<code>true</code>, 符合期望. </p>
<p>现在是时候小开心一下了. 现在我们只需要创建和校验输出（<code>outputs</code>）和输入（<code>inputs</code>）然后把交易存储到区块链中. </p>
<h2 id="4-输入（Inputs）与输出（Outputs）1-加密货币是如何拥有的…"><a href="#4-输入（Inputs）与输出（Outputs）1-加密货币是如何拥有的…" class="headerlink" title="4. 输入（Inputs）与输出（Outputs）1: 加密货币是如何拥有的…"></a><strong>4. 输入（Inputs）与输出（Outputs）1: 加密货币是如何拥有的…</strong></h2><p>如果你想拥有1个比特币, 你必须收到1个比特币. 总账不会真的给你添加一个比特币, 从发送者那里减去一个比特币, 发送者提到他/她以前收到一个比特币, 然后创建一个交易输出, 显示1比特币被发送到你的地址. （交易输入是对以前交易输出的引用. ）</p>
<p><strong>你的钱包余额是所有发送给你的未使用的交易输出的总和. </strong></p>
<p>ps: 这里略微有点绕, 总之你就记住<strong>进账</strong>和<strong>出账</strong>这回事情. </p>
<p>从现在开始, 我们将遵循比特币惯例并调用未使用的交易输出: <code>UTXO</code>. </p>
<p>好, 让我们创建一个<code>TransactionInput</code>类: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TransactionInput &#123;</span><br><span class="line">   public String transactionOutputId; //Reference to TransactionOutputs -transactionId</span><br><span class="line">   public TransactionOutput UTXO; //Contains the Unspent transaction output</span><br><span class="line"></span><br><span class="line">   public TransactionInput(String transactionOutputId) &#123;</span><br><span class="line">      this.transactionOutputId = transactionOutputId;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类将用于引用尚未使用的<code>TransactionOutputs</code>的值. <code>transactionOutputId</code>将用于查找相关的<code>TransactionOutput</code>, 从而允许矿工检查你的所有权. </p>
<p>下面是<code>TransactionOutput</code>类: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.security.PublicKey;</span><br><span class="line"></span><br><span class="line">public class TransactionOutput &#123;</span><br><span class="line">   public String id;</span><br><span class="line">   public PublicKey reciepient; //also known as the new owner of these coins.</span><br><span class="line">   public float value; //the amount of coins they own</span><br><span class="line">   public String parentTransactionId; //the id of the transaction this output was created in</span><br><span class="line"></span><br><span class="line">   //Constructor</span><br><span class="line">   public TransactionOutput(PublicKey reciepient, float value, String parentTransactionId) &#123;</span><br><span class="line">      this.reciepient = reciepient;</span><br><span class="line">      this.value = value;</span><br><span class="line">      this.parentTransactionId = parentTransactionId;</span><br><span class="line">      this.id = StringUtil.applySha256(StringUtil.getStringFromKey(reciepient)+Float.toString(value)+parentTransactionId);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //Check if coin belongs to you</span><br><span class="line">   public boolean isMine(PublicKey publicKey) &#123;</span><br><span class="line">      return (publicKey == reciepient);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>交易输出将显示从交易发送到每一方的最终金额. 当在新的交易中作为输入引用时, 它们将作为你要发送的货币的证明, 能够证明你有钱可发送. </p>
<h2 id="5-输入（Inputs）与输出（Outputs）2-处理交易……"><a href="#5-输入（Inputs）与输出（Outputs）2-处理交易……" class="headerlink" title="5. 输入（Inputs）与输出（Outputs）2: 处理交易……"></a><strong>5. 输入（Inputs）与输出（Outputs）2: 处理交易……</strong></h2><p>链中的块可能接收到许多交易, 而区块链可能非常非常长, 处理新交易可能需要数亿年的时间, 因为我们必须查找并检查它的输入. 要解决这个问题, 我们就需要存在一个额外的集合（<code>collection</code>）来保存所有未使用的可被作为输入（<code>inputs</code>）的交易. 在下面的<code>ImportChain</code>类中, 添加一个所有UTXO的集合: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ImportChain &#123;</span><br><span class="line"></span><br><span class="line">   public static ArrayList&lt;Block&gt; blockchain = new ArrayList&lt;Block&gt;();</span><br><span class="line">   public static HashMap&lt;String,TransactionOutput&gt; UTXOs = new HashMap&lt;String,TransactionOutput&gt;();</span><br><span class="line"></span><br><span class="line">   public static int difficulty = 3;</span><br><span class="line">   public static float minimumTransaction = 0.1f;</span><br><span class="line">   public static Wallet walletA;</span><br><span class="line">   public static Wallet walletB;</span><br><span class="line">   public static Transaction genesisTransaction;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br></pre></td></tr></table></figure>
<p>现在我们把之前的那些实现放在一起来处理一笔交易吧. 先在<code>Transaction</code>类中的添加一个方法<code>processTransaction</code>: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean processTransaction() &#123;</span><br><span class="line"></span><br><span class="line">   if(verifySignature() == false) &#123;</span><br><span class="line">      System.out.println(&quot;#Transaction Signature failed to verify&quot;);</span><br><span class="line">      return false;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //Gathers transaction inputs (Making sure they are unspent):</span><br><span class="line">   for(TransactionInput i : inputs) &#123;</span><br><span class="line">      i.UTXO = ImportChain.UTXOs.get(i.transactionOutputId);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //Checks if transaction is valid:</span><br><span class="line">   if(getInputsValue() &lt; ImportChain.minimumTransaction) &#123;</span><br><span class="line">      System.out.println(&quot;Transaction Inputs to small: &quot; + getInputsValue());</span><br><span class="line">      return false;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //Generate transaction outputs:</span><br><span class="line">   float leftOver = getInputsValue() - value; //get value of inputs then the left over change:</span><br><span class="line">   transactionId = calulateHash();</span><br><span class="line">   outputs.add(new TransactionOutput( this.reciepient, value,transactionId)); //send value to recipient</span><br><span class="line">   outputs.add(new TransactionOutput( this.sender, leftOver,transactionId)); //send the left over &apos;change&apos; back to sender</span><br><span class="line"></span><br><span class="line">   //Add outputs to Unspent list</span><br><span class="line">   for(TransactionOutput o : outputs) &#123;</span><br><span class="line">      ImportChain.UTXOs.put(o.id , o);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //Remove transaction inputs from UTXO lists as spent:</span><br><span class="line">   for(TransactionInput i : inputs) &#123;</span><br><span class="line">      if(i.UTXO == null) continue; //if Transaction can&apos;t be found skip it</span><br><span class="line">      ImportChain.UTXOs.remove(i.UTXO.id);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还添加了<code>getInputsValue</code>方法. 使用此方法, 我们执行一些检查以确保交易是有效的, 然后收集输入并生成输出. （要了解更多信息, 请参阅代码中的注释行）. </p>
<p>重要的是, 在最后, 我们从UTXO的列表中删除<code>input</code>, 这意味着交易输出只能作为一个输入使用一次…而且必须使用完整的输入值, 因为发送方要将“更改”返回给自己. </p>
<p><img src="https://cdn.yangbingdong.com/img/blockchain/blockchain08.webp" alt="img"></p>
<p>红色箭头是输出. 请注意, 绿色输入是对以前输出的引用. </p>
<p>最后, 让我们将钱包类更新为: </p>
<p>可以汇总得到的余额（通过<strong>循环遍历UTXO列表</strong>并检查事务输出是否为<code>Mine()</code>）</p>
<p>并可以生成交易. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.security.*;</span><br><span class="line">import java.security.spec.ECGenParameterSpec;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class Wallet &#123;</span><br><span class="line"></span><br><span class="line">   public PrivateKey privateKey;</span><br><span class="line">   public PublicKey publicKey;</span><br><span class="line"></span><br><span class="line">   public HashMap&lt;String,TransactionOutput&gt; UTXOs = new HashMap&lt;String,TransactionOutput&gt;();</span><br><span class="line"></span><br><span class="line">   public Wallet() &#123;</span><br><span class="line">      generateKeyPair();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void generateKeyPair() &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">         KeyPairGenerator keyGen = KeyPairGenerator.getInstance(&quot;ECDSA&quot;,&quot;BC&quot;);</span><br><span class="line">         SecureRandom random = SecureRandom.getInstance(&quot;SHA1PRNG&quot;);</span><br><span class="line">         ECGenParameterSpec ecSpec = new ECGenParameterSpec(&quot;prime192v1&quot;);</span><br><span class="line">         // Initialize the key generator and generate a KeyPair</span><br><span class="line">         keyGen.initialize(ecSpec, random); //256 </span><br><span class="line">           KeyPair keyPair = keyGen.generateKeyPair();</span><br><span class="line">           // Set the public and private keys from the keyPair</span><br><span class="line">           privateKey = keyPair.getPrivate();</span><br><span class="line">           publicKey = keyPair.getPublic();</span><br><span class="line"></span><br><span class="line">      &#125;catch(Exception e) &#123;</span><br><span class="line">         throw new RuntimeException(e);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public float getBalance() &#123;</span><br><span class="line">      float total = 0;   </span><br><span class="line">        for (Map.Entry&lt;String, TransactionOutput&gt; item: ImportChain.UTXOs.entrySet())&#123;</span><br><span class="line">           TransactionOutput UTXO = item.getValue();</span><br><span class="line">            if(UTXO.isMine(publicKey)) &#123; //if output belongs to me ( if coins belong to me )</span><br><span class="line">               UTXOs.put(UTXO.id,UTXO); //add it to our list of unspent transactions.</span><br><span class="line">               total += UTXO.value ; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">      return total;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public Transaction sendFunds(PublicKey _recipient,float value ) &#123;</span><br><span class="line">      if(getBalance() &lt; value) &#123;</span><br><span class="line">         System.out.println(&quot;#Not Enough funds to send transaction. Transaction Discarded.&quot;);</span><br><span class="line">         return null;</span><br><span class="line">      &#125;</span><br><span class="line">      ArrayList&lt;TransactionInput&gt; inputs = new ArrayList&lt;TransactionInput&gt;();</span><br><span class="line"></span><br><span class="line">      float total = 0;</span><br><span class="line">      for (Map.Entry&lt;String, TransactionOutput&gt; item: UTXOs.entrySet())&#123;</span><br><span class="line">         TransactionOutput UTXO = item.getValue();</span><br><span class="line">         total += UTXO.value;</span><br><span class="line">         inputs.add(new TransactionInput(UTXO.id));</span><br><span class="line">         if(total value) break;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Transaction newTransaction = new Transaction(publicKey, _recipient , value, inputs);</span><br><span class="line">      newTransaction.generateSignature(privateKey);</span><br><span class="line"></span><br><span class="line">      for(TransactionInput input: inputs)&#123;</span><br><span class="line">         UTXOs.remove(input.transactionOutputId);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return newTransaction;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你还可以添加一些其他功能到你的钱包类, 比如保留记录你的交易历史记录等等. </p>
<h2 id="6-向块中添加交易"><a href="#6-向块中添加交易" class="headerlink" title="6. 向块中添加交易"></a><strong>6. 向块中添加交易</strong></h2><p>现在已有了一个可以正常工作的交易处理系统, 我们需要将它实现到我们的区块链中. 我们把上一集中块里的无用的数据替换成一个交易列表, <code>arraylist</code>. </p>
<p>然而, 在一个块中可能有1000个交易, 太多的交易不能包括在散列计算中……</p>
<p>没事, 别担心, 我们可以使用交易的<strong>merkle根</strong>, 就是下面的那个<code>getMerkleRoot()</code>方法. </p>
<p>现在在<code>StringUtils</code>中添加一个<code>helper</code>方法<code>getMerkleRoot()</code>: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static String getMerkleRoot(ArrayList&lt;Transaction&gt; transactions) &#123;</span><br><span class="line">   int count = transactions.size();</span><br><span class="line"></span><br><span class="line">   List&lt;String&gt; previousTreeLayer = new ArrayList&lt;String&gt;();</span><br><span class="line">   for(Transaction transaction : transactions) &#123;</span><br><span class="line">      previousTreeLayer.add(transaction.transactionId);</span><br><span class="line">   &#125;</span><br><span class="line">   List&lt;String&gt; treeLayer = previousTreeLayer;</span><br><span class="line"></span><br><span class="line">   while(count 1) &#123;</span><br><span class="line">      treeLayer = new ArrayList&lt;String&gt;();</span><br><span class="line">      for(int i=1; i &lt; previousTreeLayer.size(); i+=2) &#123;</span><br><span class="line">         treeLayer.add(applySha256(previousTreeLayer.get(i-1) + previousTreeLayer.get(i)));</span><br><span class="line">      &#125;</span><br><span class="line">      count = treeLayer.size();</span><br><span class="line">      previousTreeLayer = treeLayer;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   String merkleRoot = (treeLayer.size() == 1) ? treeLayer.get(0) : &quot;&quot;;</span><br><span class="line">   return merkleRoot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在, 我们把<code>Block</code>类加强一下: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class Block &#123;</span><br><span class="line"></span><br><span class="line">   public String hash;</span><br><span class="line">   public String previousHash;</span><br><span class="line">   public String merkleRoot;</span><br><span class="line">   public ArrayList&lt;Transaction&gt; transactions = new ArrayList&lt;Transaction&gt;(); //our data will be a simple message.</span><br><span class="line">   public long timeStamp; //as number of milliseconds since 1/1/1970.</span><br><span class="line">   public int nonce;</span><br><span class="line"></span><br><span class="line">   //Block Constructor.</span><br><span class="line">   public Block(String previousHash ) &#123;</span><br><span class="line">      this.previousHash = previousHash;</span><br><span class="line">      this.timeStamp = new Date().getTime();</span><br><span class="line"></span><br><span class="line">      this.hash = calculateHash(); //Making sure we do this after we set the other values.</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //Calculate new hash based on blocks contents</span><br><span class="line">   public String calculateHash() &#123;</span><br><span class="line">      String calculatedhash = StringUtil.applySha256(</span><br><span class="line">            previousHash +</span><br><span class="line">                  Long.toString(timeStamp) +</span><br><span class="line">                  Integer.toString(nonce) +</span><br><span class="line">                  merkleRoot</span><br><span class="line">      );</span><br><span class="line">      return calculatedhash;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //Increases nonce value until hash target is reached.</span><br><span class="line">   public void mineBlock(int difficulty) &#123;</span><br><span class="line">      merkleRoot = StringUtil.getMerkleRoot(transactions);</span><br><span class="line">      String target = StringUtil.getDificultyString(difficulty); //Create a string with difficulty * &quot;0&quot;</span><br><span class="line">      while(!hash.substring( 0, difficulty).equals(target)) &#123;</span><br><span class="line">         nonce ++;</span><br><span class="line">         hash = calculateHash();</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(&quot;Block Mined!!! : &quot; + hash);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //Add transactions to this block</span><br><span class="line">   public boolean addTransaction(Transaction transaction) &#123;</span><br><span class="line">      //process transaction and check if valid, unless block is genesis block then ignore.</span><br><span class="line">      if(transaction == null) return false;</span><br><span class="line">      if((previousHash != &quot;0&quot;)) &#123;</span><br><span class="line">         if((transaction.processTransaction() != true)) &#123;</span><br><span class="line">            System.out.println(&quot;Transaction failed to process. Discarded.&quot;);</span><br><span class="line">            return false;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      transactions.add(transaction);</span><br><span class="line">      System.out.println(&quot;Transaction Successfully added to Block&quot;);</span><br><span class="line">      return true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面我们更新了<code>Block</code>构造函数, 因为不再需要传入字符串数据（还记得<a href="http://mp.weixin.qq.com/s?__biz=MzA5MzQ2NTY0OA==&amp;mid=2650797410&amp;idx=1&amp;sn=c16d1b0064768479a05dc65cf2b542d3&amp;chksm=8856283dbf21a12be25300c012dc344199320f54a13b54d595c4db899d74ede95cb06d7e784c&amp;scene=21#wechat_redirect" rel="external nofollow noopener noreferrer" target="_blank">上集</a>中我们的<code>Block</code>构造函数传入了一个<code>data</code>的字符串, 这里我们往块里添加的是交易, 也就是<code>transaction</code>）, 并且在计算哈希方法中包含了<strong>merkle根</strong>. </p>
<p>并且新增了<code>addTransaction</code>方法来添加一笔交易, 并且只有在交易被成功添加时才返回<code>true</code>. </p>
<p>ok, 我们的区块链上交易所需的每个零部件都实现了. 是时候运转一下了. </p>
<h2 id="7-大结局"><a href="#7-大结局" class="headerlink" title="7. 大结局"></a><strong>7. 大结局</strong></h2><p>现在我们开始测试吧. 发送货币进出钱包, 并更新我们的区块链有效性检查. </p>
<p>但首先我们需要一个方法来引入新的币. 有许多方法可以创建新的币, 比如, 在<strong>比特币区块链</strong>上: 矿工可以将交易持有在自己手里, 作为对每个块被开采的奖励. </p>
<p>这里, 我们将只发行（release）我们希望拥有的所有货币, 在第一个块（起源块）. 就像比特币一样, 我们将对起源块进行硬编码. </p>
<p>现在把<code></code>类更新, 包含如下内容: </p>
<ul>
<li>一个“创世纪”的块, 它向钱包A发行100个新币. </li>
<li>帐户交易中的“更新的链”的有效性检查. </li>
<li>一些测试信息, 让我们看到内部运行的细节信息. </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.security.Security;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line"></span><br><span class="line">//import java.util.Base64;</span><br><span class="line">//import com.google.gson.GsonBuilder;</span><br><span class="line"></span><br><span class="line">public class ImportChain &#123;</span><br><span class="line"></span><br><span class="line">   public static ArrayList&lt;Block&gt; blockchain = new ArrayList&lt;Block&gt;();</span><br><span class="line">   public static HashMap&lt;String,TransactionOutput&gt; UTXOs = new HashMap&lt;String,TransactionOutput&gt;();</span><br><span class="line"></span><br><span class="line">   public static int difficulty = 3;</span><br><span class="line">   public static float minimumTransaction = 0.1f;</span><br><span class="line">   public static Wallet walletA;</span><br><span class="line">   public static Wallet walletB;</span><br><span class="line">   public static Transaction genesisTransaction;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      //add our blocks to the blockchain ArrayList:</span><br><span class="line">      Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider()); //Setup Bouncey castle as a Security Provider</span><br><span class="line"></span><br><span class="line">      //Create wallets:</span><br><span class="line">      walletA = new Wallet();</span><br><span class="line">      walletB = new Wallet();</span><br><span class="line">      Wallet coinbase = new Wallet();</span><br><span class="line"></span><br><span class="line">      //create genesis transaction, which sends 100 NoobCoin to walletA:</span><br><span class="line">      genesisTransaction = new Transaction(coinbase.publicKey, walletA.publicKey, 100f, null);</span><br><span class="line">      genesisTransaction.generateSignature(coinbase.privateKey);  //manually sign the genesis transaction</span><br><span class="line">      genesisTransaction.transactionId = &quot;0&quot;; //manually set the transaction id</span><br><span class="line">      genesisTransaction.outputs.add(new TransactionOutput(genesisTransaction.reciepient, genesisTransaction.value, genesisTransaction.transactionId)); //manually add the Transactions Output</span><br><span class="line">      UTXOs.put(genesisTransaction.outputs.get(0).id, genesisTransaction.outputs.get(0)); //its important to store our first transaction in the UTXOs list.</span><br><span class="line"></span><br><span class="line">      System.out.println(&quot;Creating and Mining Genesis block... &quot;);</span><br><span class="line">      Block genesis = new Block(&quot;0&quot;);</span><br><span class="line">      genesis.addTransaction(genesisTransaction);</span><br><span class="line">      addBlock(genesis);</span><br><span class="line"></span><br><span class="line">      //testing</span><br><span class="line">      Block block1 = new Block(genesis.hash);</span><br><span class="line">      System.out.println(&quot;\nWalletA&apos;s balance is: &quot; + walletA.getBalance());</span><br><span class="line">      System.out.println(&quot;\nWalletA is Attempting to send funds (40) to WalletB...&quot;);</span><br><span class="line">      block1.addTransaction(walletA.sendFunds(walletB.publicKey, 40f));</span><br><span class="line">      addBlock(block1);</span><br><span class="line">      System.out.println(&quot;\nWalletA&apos;s balance is: &quot; + walletA.getBalance());</span><br><span class="line">      System.out.println(&quot;WalletB&apos;s balance is: &quot; + walletB.getBalance());</span><br><span class="line"></span><br><span class="line">      Block block2 = new Block(block1.hash);</span><br><span class="line">      System.out.println(&quot;\nWalletA Attempting to send more funds (1000) than it has...&quot;);</span><br><span class="line">      block2.addTransaction(walletA.sendFunds(walletB.publicKey, 1000f));</span><br><span class="line">      addBlock(block2);</span><br><span class="line">      System.out.println(&quot;\nWalletA&apos;s balance is: &quot; + walletA.getBalance());</span><br><span class="line">      System.out.println(&quot;WalletB&apos;s balance is: &quot; + walletB.getBalance());</span><br><span class="line"></span><br><span class="line">      Block block3 = new Block(block2.hash);</span><br><span class="line">      System.out.println(&quot;\nWalletB is Attempting to send funds (20) to WalletA...&quot;);</span><br><span class="line">      block3.addTransaction(walletB.sendFunds( walletA.publicKey, 20));</span><br><span class="line">      System.out.println(&quot;\nWalletA&apos;s balance is: &quot; + walletA.getBalance());</span><br><span class="line">      System.out.println(&quot;WalletB&apos;s balance is: &quot; + walletB.getBalance());</span><br><span class="line"></span><br><span class="line">      isChainValid();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static Boolean isChainValid() &#123;</span><br><span class="line">      Block currentBlock;</span><br><span class="line">      Block previousBlock;</span><br><span class="line">      String hashTarget = new String(new char[difficulty]).replace(&apos;\0&apos;, &apos;0&apos;);</span><br><span class="line">      HashMap&lt;String,TransactionOutput&gt; tempUTXOs = new HashMap&lt;String,TransactionOutput&gt;(); //a temporary working list of unspent transactions at a given block state.</span><br><span class="line">      tempUTXOs.put(genesisTransaction.outputs.get(0).id, genesisTransaction.outputs.get(0));</span><br><span class="line"></span><br><span class="line">      //loop through blockchain to check hashes:</span><br><span class="line">      for(int i=1; i &lt; blockchain.size(); i++) &#123;</span><br><span class="line"></span><br><span class="line">         currentBlock = blockchain.get(i);</span><br><span class="line">         previousBlock = blockchain.get(i-1);</span><br><span class="line">         //compare registered hash and calculated hash:</span><br><span class="line">         if(!currentBlock.hash.equals(currentBlock.calculateHash()) )&#123;</span><br><span class="line">            System.out.println(&quot;#Current Hashes not equal&quot;);</span><br><span class="line">            return false;</span><br><span class="line">         &#125;</span><br><span class="line">         //compare previous hash and registered previous hash</span><br><span class="line">         if(!previousBlock.hash.equals(currentBlock.previousHash) ) &#123;</span><br><span class="line">            System.out.println(&quot;#Previous Hashes not equal&quot;);</span><br><span class="line">            return false;</span><br><span class="line">         &#125;</span><br><span class="line">         //check if hash is solved</span><br><span class="line">         if(!currentBlock.hash.substring( 0, difficulty).equals(hashTarget)) &#123;</span><br><span class="line">            System.out.println(&quot;#This block hasn&apos;t been mined&quot;);</span><br><span class="line">            return false;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         //loop thru blockchains transactions:</span><br><span class="line">         TransactionOutput tempOutput;</span><br><span class="line">         for(int t=0; t &lt;currentBlock.transactions.size(); t++) &#123;</span><br><span class="line">            Transaction currentTransaction = currentBlock.transactions.get(t);</span><br><span class="line"></span><br><span class="line">            if(!currentTransaction.verifySignature()) &#123;</span><br><span class="line">               System.out.println(&quot;#Signature on Transaction(&quot; + t + &quot;) is Invalid&quot;);</span><br><span class="line">               return false;</span><br><span class="line">            &#125;</span><br><span class="line">            if(currentTransaction.getInputsValue() != currentTransaction.getOutputsValue()) &#123;</span><br><span class="line">               System.out.println(&quot;#Inputs are note equal to outputs on Transaction(&quot; + t + &quot;)&quot;);</span><br><span class="line">               return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for(TransactionInput input: currentTransaction.inputs) &#123;</span><br><span class="line">               tempOutput = tempUTXOs.get(input.transactionOutputId);</span><br><span class="line"></span><br><span class="line">               if(tempOutput == null) &#123;</span><br><span class="line">                  System.out.println(&quot;#Referenced input on Transaction(&quot; + t + &quot;) is Missing&quot;);</span><br><span class="line">                  return false;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if(input.UTXO.value != tempOutput.value) &#123;</span><br><span class="line">                  System.out.println(&quot;#Referenced input Transaction(&quot; + t + &quot;) value is Invalid&quot;);</span><br><span class="line">                  return false;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               tempUTXOs.remove(input.transactionOutputId);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for(TransactionOutput output: currentTransaction.outputs) &#123;</span><br><span class="line">               tempUTXOs.put(output.id, output);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if( currentTransaction.outputs.get(0).reciepient != currentTransaction.reciepient) &#123;</span><br><span class="line">               System.out.println(&quot;#Transaction(&quot; + t + &quot;) output reciepient is not who it should be&quot;);</span><br><span class="line">               return false;</span><br><span class="line">            &#125;</span><br><span class="line">            if( currentTransaction.outputs.get(1).reciepient != currentTransaction.sender) &#123;</span><br><span class="line">               System.out.println(&quot;#Transaction(&quot; + t + &quot;) output &apos;change&apos; is not sender.&quot;);</span><br><span class="line">               return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(&quot;Blockchain is valid&quot;);</span><br><span class="line">      return true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void addBlock(Block newBlock) &#123;</span><br><span class="line">      newBlock.mineBlock(difficulty);</span><br><span class="line">      blockchain.add(newBlock);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果: </p>
<p><img src="https://cdn.yangbingdong.com/img/blockchain/blockchain09.webp" alt="img"></p>
<blockquote>
<p>代码链接: <strong><em><a href="https://github.com/importsource/blockchain-samples-transaction/tree/master" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/importsource/blockchain-samples-transaction/tree/master</a></em></strong></p>
<p><strong><em><a href="https://mp.weixin.qq.com/s?__biz=MzA5MzQ2NTY0OA==&amp;mid=2650797427&amp;idx=1&amp;sn=ba11e0bbe90b4776b73412264856e98c&amp;chksm=8856282cbf21a13ab4e3031d4ce1eb2ea6ce66fa6ea182f509a104f5d9258c3144f4be149886&amp;mpshare=1&amp;scene=1&amp;srcid=0305A7seElVJKytsJ4qseFzp#rd" rel="external nofollow noopener noreferrer" target="_blank">原文链接</a></em></strong></p>
</blockquote>
<h1 id="最热门的3个基于Java的Blockchain库"><a href="#最热门的3个基于Java的Blockchain库" class="headerlink" title="最热门的3个基于Java的Blockchain库"></a>最热门的3个基于Java的Blockchain库</h1><p>大家应该都听说过比特币、以太币或其他加密货币, 这些名字在新闻中经常出现, 但是作为Java开发人员, 你们知道如何轻松地与Blockchain技术进行交互吗?下面是可以利用Blockchain的三大Java项目. 这个列表是基于GitHub存储库的星序排列的. 非常感谢你的评论和意见. </p>
<h2 id="BitcoinJ"><a href="#BitcoinJ" class="headerlink" title="BitcoinJ"></a>BitcoinJ</h2><p>你有没有觉得这个名字很有描述性呢?如果你想知道如何创建一个比特币钱包, 并且管理节点之间的事务, 那么你应该<a href="https://github.com/bitcoinj/bitcoinj" rel="external nofollow noopener noreferrer" target="_blank">尝试一下BitcoinJ</a>. 这个项目有一个不断扩大的社区, 里面包含非常好的文档资料, 这对每个开发人员都是非常有利的. 当然, 作为一个试图获得声望的开源项目, 它也存在一定的局限性. 现在已经有几个已知的开放漏洞的安全问题, 以及可扩展性问题. 不过, 如果你想了解比特币协议是如何运作的, 这个项目将是非常有帮助的. 个人意见:这并不适用于生产应用. </p>
<h2 id="Web3j"><a href="#Web3j" class="headerlink" title="Web3j"></a>Web3j</h2><p>一个词——Ethereum（以太币）, 这是基于尖端技术的第二大加密货币. <a href="https://github.com/web3j/web3j" rel="external nofollow noopener noreferrer" target="_blank">Web3j项目</a>允许你使用Ethereum区块链, 同时不必为平台编写集成代码. 同样, 核心功能是创建钱包, 管理事务, 以及智能合约包装器. Ethereum项目的一部分是一种称为<a href="https://solidity.readthedocs.io/" rel="external nofollow noopener noreferrer" target="_blank">Solidity</a>的特殊语言, 它是创建智能合约的实际标准. 如果你想避免使用智能合约的底层实现细节, 那就使用Web3j的智能合约包装器. 如果这对一名开发人员来说还不够, 那我需要告诉你, 它包含很多好的文档和大量的例子, 这也是使web3j成为我个人最爱的原因. </p>
<h2 id="HyperLedger-Fabric"><a href="#HyperLedger-Fabric" class="headerlink" title="HyperLedger Fabric"></a>HyperLedger Fabric</h2><p><a href="https://github.com/hyperledger/fabric-sdk-java" rel="external nofollow noopener noreferrer" target="_blank">HyperLedger Fabric</a>是企业会用到的. Linux基金会的框架是区块链解决方案的主干. 所以无论你想创建一个简单的PoC, 还是一个生产应用程序, 它都是一个强大的工具. 该项目正在由Linux基金会成员积极组织开发. 它的重点是创建和管理智能合约. 主要特点是:</p>
<blockquote>
<p>管理共享机密信息的渠道<br>支持政策事务<br>一致地向网络中的对等节点交付事务</p>
</blockquote>
<p>如果你在软件区块链堆栈中包括了HyperLedger Fabric, 那么我的建议是熟悉其他的HyperLedger项目. 根据你的需要, 可以选择各种不同的HyperLedger项目, 这些项目将保证一个连贯的、可扩展的、易于维护的区块链基础设施. 对于许多人来说, 区块链将改变整个互联网, 难道你不想成为其中的一部分吗?</p>
]]></content><categories><category>Programming</category><category>Java</category></categories><tags><tag>Java</tag><tag>Blockchain</tag></tags></entry><entry><title>使用Caddy部署Https静态博客站点</title><url>/2019/use-caddy-to-deploy-static-blog-with-https/</url><content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><img src="https://cdn.yangbingdong.com/img/caddy/caddy-banner.png" alt></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><blockquote>
<p>Github Pages 在国内访问速度不理想, 其他国内的免费静态页面服务(Coding等)有时候也比较慢, 于是决定自己使用国内的云服务器部署静态博客. 一般是通过Nginx可以做到, 但是要开启Https以及Http2还需要手动配置一些东西, 面向普通用户不太友善, 这时候可以使用 <strong><em><a href="https://caddyserver.com" rel="external nofollow noopener noreferrer" target="_blank">Caddy</a></em></strong> 来做到简易部署Https的静态博客…</p>
</blockquote>
<a id="more"></a>
<p>简单来说, <strong><em><a href="https://caddyserver.com" rel="external nofollow noopener noreferrer" target="_blank">Caddy</a></em></strong> 是一个用GO语言编写的轻量级高性能Web服务器, 并自动启用 Https(<strong><em><a href="https://letsencrypt.org/" rel="external nofollow noopener noreferrer" target="_blank">Let’s Encrypt</a></em></strong> 自动续期) 以及 Http2, 只需要简单的配置, 对于这种静态页面网站或者简单的代理还算是比较友好的.</p>
<p>下面记录一下安装以及配置过程.</p>
<h1 id="通过官方脚本安装"><a href="#通过官方脚本安装" class="headerlink" title="通过官方脚本安装"></a>通过官方脚本安装</h1><h2 id="定制安装脚本"><a href="#定制安装脚本" class="headerlink" title="定制安装脚本"></a>定制安装脚本</h2><p>在 <strong><em><a href="https://caddyserver.com/download" rel="external nofollow noopener noreferrer" target="_blank">https://caddyserver.com/download</a></em></strong> 中定制自己的Caddy安装脚本:</p>
<p><img src="https://cdn.yangbingdong.com/img/caddy/caddy-script.png" alt></p>
<p>Copy 一键安装脚本到服务器上安装即可, 比如:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://getcaddy.com | bash -s personal http.cache,http.git,http.minify,tls.dns.linode,hook.service,http.forwardproxy</span><br></pre></td></tr></table></figure>
<h2 id="配置Systemd"><a href="#配置Systemd" class="headerlink" title="配置Systemd"></a>配置Systemd</h2><p>安装完成之后配置Systemd:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -s  https://raw.githubusercontent.com/mholt/caddy/master/dist/init/linux-systemd/caddy.service  -o /etc/systemd/system/caddy.service</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable caddy.service</span><br></pre></td></tr></table></figure>
<p>通过systemd管理caddy:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 添加或更新了daemon配置文件需要重新读取一下</span><br><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"># 设置为开机启动</span><br><span class="line">systemctl enable caddy.service</span><br><span class="line"></span><br><span class="line"># 启动Caddy</span><br><span class="line">systemctl start caddy.service</span><br><span class="line"></span><br><span class="line"># 停止Caddy</span><br><span class="line">systemctl stop caddy.service</span><br><span class="line"></span><br><span class="line"># 重启Caddy</span><br><span class="line">systemctl restart caddy.service</span><br><span class="line"></span><br><span class="line"># 重新加载Caddy配置文件</span><br><span class="line">systemctl reload caddy.service</span><br><span class="line"></span><br><span class="line"># 查看Caddy状态</span><br><span class="line">systemctl status caddy.service</span><br></pre></td></tr></table></figure>
<h2 id="配置Caddy"><a href="#配置Caddy" class="headerlink" title="配置Caddy"></a>配置Caddy</h2><ul>
<li>置文件放到 /etc/caddy 目录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir /etc/caddy</span><br><span class="line">touch /etc/caddy/Caddyfile</span><br><span class="line">chown -R root:www-data /etc/caddy</span><br></pre></td></tr></table></figure>
<ul>
<li>配置ssl证书目录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir /etc/ssl/caddy</span><br><span class="line">chown -R www-data:root /etc/ssl/caddy</span><br><span class="line">chmod 0770 /etc/ssl/caddy</span><br></pre></td></tr></table></figure>
<ul>
<li>配置网站目录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir /var/www</span><br><span class="line">chown www-data:www-data /var/www</span><br></pre></td></tr></table></figure>
<ul>
<li>配置Caddfile配置文件</li>
</ul>
<p>修改Caddfile文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/caddy/Caddyfile</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yangbingdong.com &#123;</span><br><span class="line">    root /var/www/yangbingdong.com</span><br><span class="line">    gzip</span><br><span class="line">    tls yangbingdong1994@gmail.com</span><br><span class="line">    log / /var/log/caddy/yangbingdong.com_access.log &quot;&#123;combined&#125;&quot; &#123;</span><br><span class="line">        rotate_size 10</span><br><span class="line">        rotate_age  14</span><br><span class="line">        rotate_keep 5</span><br><span class="line">        rotate_compress</span><br><span class="line">    &#125;</span><br><span class="line">    errors /var/log/caddy/yangbingdong.com_error.log &#123;</span><br><span class="line">        rotate_size 10</span><br><span class="line">        rotate_age  14</span><br><span class="line">        rotate_keep 5</span><br><span class="line">        rotate_compress</span><br><span class="line">    &#125;</span><br><span class="line">    git &#123;</span><br><span class="line">        repo https://github.com/masteranthoneyd/masteranthoneyd.github.io.git</span><br><span class="line">        branch master</span><br><span class="line">        clone_args --recursive</span><br><span class="line">        path /var/www/yangbingdong.com</span><br><span class="line">        pull_args --allow-unrelated-histories</span><br><span class="line">        hook /webhook ************************</span><br><span class="line">        hook_type github</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>tls</code>后面的邮箱是我们申请证书的邮箱，填写自己的邮箱即可</li>
<li><code>gzip</code>指开启gzip压缩</li>
<li><code>root</code>是我们站点的目录</li>
<li><code>log</code>用来记录我们博客的访问日志</li>
<li><code>repo</code>用来配置我们的git仓库</li>
<li><code>branch</code>用来配置我们要拉取的分支</li>
<li><code>path</code>是指我们的拉取代码的目标地址, 默认为<code>root</code>中指定的</li>
<li><code>then</code>用来配置拉取代码后，我们重新编译hugo的静态文件</li>
<li><code>hook</code>是我们对github开放的webhook地址和密钥</li>
<li><code>hook_type</code>是我们的webhook类型</li>
</ul>
<p>给log路径赋权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chown www-data:www-data /var/log/caddy</span><br></pre></td></tr></table></figure>
<p>上例是一个简单的websocket加静态网站配置。第一行为自己的域名，tls后面加上邮箱会自动申请let’sencrypt ssl证书。</p>
<p>之后重启Caddy访问域名即可.</p>
<h1 id="通过Docker启动Caddy"><a href="#通过Docker启动Caddy" class="headerlink" title="通过Docker启动Caddy"></a>通过Docker启动Caddy</h1><blockquote>
<p>Docker仓库: <strong><em><a href="https://hub.docker.com/r/abiosoft/caddy" rel="external nofollow noopener noreferrer" target="_blank">https://hub.docker.com/r/abiosoft/caddy</a></em></strong></p>
</blockquote>
<p>创建目录:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p /var/www/yangbingdong.com &amp;&amp; \</span><br><span class="line">mkdir -p /var/log/caddy &amp;&amp; \</span><br><span class="line">mkdir -p /etc/caddy &amp;&amp; \</span><br><span class="line">mkdir -p /etc/ssl/caddy</span><br></pre></td></tr></table></figure>
<p>配置文件 <code>vi /etc/caddy/Caddyfile</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">www.yangbingdong.com &#123;</span><br><span class="line">    redir https://yangbingdong.com&#123;url&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">yangbingdong.com, :80 &#123;</span><br><span class="line">    root /srv/www/yangbingdong.com</span><br><span class="line">    gzip</span><br><span class="line">    tls yangbingdong1994@gmail.com</span><br><span class="line">    log / /srv/log/caddy/yangbingdong.com_access.log &quot;&#123;combined&#125;&quot; &#123;</span><br><span class="line">        rotate_size 10</span><br><span class="line">        rotate_age  14</span><br><span class="line">        rotate_keep 5</span><br><span class="line">        rotate_compress</span><br><span class="line">    &#125;</span><br><span class="line">    errors /srv/log/caddy/yangbingdong.com_error.log &#123;</span><br><span class="line">        rotate_size 10</span><br><span class="line">        rotate_age  14</span><br><span class="line">        rotate_keep 5</span><br><span class="line">        rotate_compress</span><br><span class="line">    &#125;</span><br><span class="line">    git &#123;</span><br><span class="line">        repo https://github.com/masteranthoneyd/masteranthoneyd.github.io.git</span><br><span class="line">        branch master</span><br><span class="line">        clone_args --recursive</span><br><span class="line">        pull_args --allow-unrelated-histories</span><br><span class="line">        hook /webhook ************************</span><br><span class="line">        hook_type github</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Docker启动:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name caddy \</span><br><span class="line">--restart=always \</span><br><span class="line">-v /var/www/yangbingdong.com:/srv/www/yangbingdong.com \</span><br><span class="line">-v /var/log/caddy:/srv/log/caddy \</span><br><span class="line">-v /etc/caddy/Caddyfile:/etc/Caddyfile \</span><br><span class="line">-v /etc/ssl/caddy:/root/.caddy \</span><br><span class="line">-e ACME_AGREE=true \</span><br><span class="line">-p 80:80 -p 443:443 \</span><br><span class="line">abiosoft/caddy:no-stats</span><br></pre></td></tr></table></figure>
<h1 id="配置-Github-Web-Hook"><a href="#配置-Github-Web-Hook" class="headerlink" title="配置 Github Web Hook"></a>配置 Github Web Hook</h1><p>如下图:</p>
<p><img src="https://cdn.yangbingdong.com/img/caddy/config-githun-webhook.png" alt></p>
<p><img src="https://cdn.yangbingdong.com/img/caddy/add-github-webhook.png" alt></p>
<ul>
<li>Content Type 需要选择 <code>application/json</code></li>
</ul>
<p>Caddyfile 中配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    git &#123;</span><br><span class="line">        repo https://github.com/masteranthoneyd/masteranthoneyd.github.io.git</span><br><span class="line">        branch master</span><br><span class="line">        clone_args --recursive</span><br><span class="line">        pull_args --allow-unrelated-histories</span><br><span class="line">        hook /webhook ************************</span><br><span class="line">        hook_type github</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h1 id="Caddy-指令介绍"><a href="#Caddy-指令介绍" class="headerlink" title="Caddy 指令介绍"></a>Caddy 指令介绍</h1><blockquote>
<p>更多指令请查看官方文档: <strong><em><a href="https://caddyserver.com/docs" rel="external nofollow noopener noreferrer" target="_blank">https://caddyserver.com/docs</a></em></strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
<th>默认情况的处理</th>
</tr>
</thead>
<tbody>
<tr>
<td>basicauth</td>
<td>HTTP基本认证</td>
<td></td>
</tr>
<tr>
<td>bind</td>
<td>用于给TCP监听套接字绑定IP地址</td>
<td>默认绑定在为通配符地址</td>
</tr>
<tr>
<td>browse</td>
<td>目录浏览功能</td>
<td></td>
</tr>
<tr>
<td>errors</td>
<td>配置HTTP错误页面以及错误日志</td>
<td>响应码&gt;=400的返回一个纯文本错误消息,也不记录日志</td>
</tr>
<tr>
<td>expvar</td>
<td>将运行时或者当前进程的一些信息(内存统计,启动命令,协程数等)以JSON格式暴露在某个路径下.</td>
<td></td>
</tr>
<tr>
<td>ext</td>
<td>对于不存在的路径,自动追加后缀名后再次尝试</td>
<td></td>
</tr>
<tr>
<td>fastcgi</td>
<td>fastcgi配置</td>
<td></td>
</tr>
<tr>
<td>gzip</td>
<td>gzip压缩配置</td>
<td>不压缩,但是如果网站目录下存在.gz或者.br压缩文件,Caddy就会使用. 如果客户端支持gzip格式的压缩压缩文件,Caddy确保不压缩图片,视频和已压缩文件</td>
</tr>
<tr>
<td>header</td>
<td>设置响应头,可以增加,修改和删除.如果是代理的必须在proxy指令中设置</td>
<td></td>
</tr>
<tr>
<td>import</td>
<td>从其他文件或代码段导入配置,减少重复</td>
<td></td>
</tr>
<tr>
<td>index</td>
<td>索引文件配置</td>
<td>index(default).html(htm/txt)</td>
</tr>
<tr>
<td>internal</td>
<td>X-Accel-Redirect 静态转发配置, 该路径外部不可访问,caddy配置的代理可以发出X-Accel-Redirect请求</td>
<td></td>
</tr>
<tr>
<td>limit</td>
<td>设置HTTP请求头( one limit applies to all sites on the same listener)和请求体的大小限制</td>
<td>默认无限制.设置了之后,如果超出了限制返回413响应</td>
</tr>
<tr>
<td>log</td>
<td>请求日志配置</td>
<td></td>
</tr>
<tr>
<td>markdown</td>
<td>将markdown文件渲染成HTML</td>
<td></td>
</tr>
<tr>
<td>mime</td>
<td>根据响应文件扩展名设置Content-Type字段</td>
<td></td>
</tr>
<tr>
<td>on</td>
<td>在服务器启动/关闭/刷新证书的时候执行的外部命令</td>
<td></td>
</tr>
<tr>
<td>pprof</td>
<td>在某个路径下展示profiling信息</td>
<td></td>
</tr>
<tr>
<td>proxy</td>
<td>反向代理和负载均衡配置</td>
<td></td>
</tr>
<tr>
<td>push</td>
<td>开启和配置HTTP/2服务器推</td>
<td></td>
</tr>
<tr>
<td>redir</td>
<td>根据请求返回重定向响应(可自己设置重定向状态码)</td>
<td></td>
</tr>
<tr>
<td>request_id</td>
<td>生成一个UUID,之后可以通过{request_id}占位符使用</td>
<td></td>
</tr>
<tr>
<td>rewrite</td>
<td>服务器端的重定向</td>
<td></td>
</tr>
<tr>
<td>root</td>
<td>网站根目录配置</td>
<td></td>
</tr>
<tr>
<td>status</td>
<td>访问某些路径时,直接返回一个配置好的状态码</td>
<td></td>
</tr>
<tr>
<td>templates</td>
<td>模板配置</td>
<td></td>
</tr>
<tr>
<td>timeouts</td>
<td>设置超时时间:读请求的时间/读请求头的时间/写响应的时间/闲置时间(使用keep-alive时)</td>
<td>Keep-Alive超时时间默认为5分钟</td>
</tr>
<tr>
<td>tls</td>
<td>HTTPS配置,摘自文档的一句话: <strong>Since HTTPS is enabled automatically, this directive should only be used to deliberately override default settings. Use with care, if at all.</strong></td>
<td></td>
</tr>
<tr>
<td>websocket</td>
<td>提供一个简单的Websocket服务器</td>
</tr>
</tbody>
</table>
<p>占位符清单: <strong><em><a href="https://caddyserver.com/docs/placeholders" rel="external nofollow noopener noreferrer" target="_blank">https://caddyserver.com/docs/placeholders</a></em></strong></p>
]]></content><categories><category>VPS</category></categories><tags><tag>Hexo</tag><tag>VPS</tag><tag>Caddy</tag></tags></entry></search>