<!doctype html><html class="theme-next muse use-motion" lang=en><meta name=generator content="Hexo 3.9.0"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content=no-transform><meta http-equiv=cache-control content=no-siteapp><meta http-equiv=content-language content=zh-cn><script src=//cdn.bootcss.com/pace/1.0.2/pace.min.js></script><link href=//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css rel=stylesheet><style>.pace .pace-progress{background:#ff009e;height:2px}.pace .pace-progress-inner{box-shadow:0 0 10px #e6006b,0 0 5px #ff009e}.pace .pace-activity{border-top-color:#ff009e;border-left-color:#ff009e}</style><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel=stylesheet><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel=stylesheet><link href="/css/main.css?v=5.1.0" rel=stylesheet><meta name=keywords content=Java,Disruptor,><link rel=alternate href=/atom.xml title="ookamiAntD's Blog" type=application/atom+xml><link rel="shortcut icon" type=image/x-icon href="/favicon.png?v=5.1.0"><meta name=description content="Preface Disruptor是英国外汇交易公司LMAX开发的一个高性能队列, 研发的初衷是解决内存队列的延迟问题（在性能测试中发现竟然与I/O操作处于同样的数量级）. 基于Disruptor开发的系统单线程能支撑每秒600万订单, 2010年在QCon演讲后, 获得了业界关注. 2011年, 企业应用软件专家Martin Fowler专门撰写长文介绍. 同年它还获得了Oracle官方的Du"><meta name=keywords content=Java,Disruptor><meta property=og:type content=article><meta property=og:title content="极致的追求, 高性能并发框架 Disruptor"><meta property=og:url content=http://yangbingdong.com/2018/disruptor-learning/index.html><meta property=og:site_name content="ookamiAntD's Blog"><meta property=og:description content="Preface Disruptor是英国外汇交易公司LMAX开发的一个高性能队列, 研发的初衷是解决内存队列的延迟问题（在性能测试中发现竟然与I/O操作处于同样的数量级）. 基于Disruptor开发的系统单线程能支撑每秒600万订单, 2010年在QCon演讲后, 获得了业界关注. 2011年, 企业应用软件专家Martin Fowler专门撰写长文介绍. 同年它还获得了Oracle官方的Du"><meta property=og:locale content=en><meta property=og:image content=https://cdn.yangbingdong.com/img/disruptor-learning/Models.png><meta property=og:image content=https://cdn.yangbingdong.com/img/disruptor-learning/lock.png><meta property=og:image content=https://cdn.yangbingdong.com/img/disruptor-learning/cas.png><meta property=og:image content=https://cdn.yangbingdong.com/img/disruptor-learning/computer.png><meta property=og:image content=https://cdn.yangbingdong.com/img/disruptor-learning/falseSharing.png><meta property=og:image content=https://cdn.yangbingdong.com/img/disruptor-learning/singleWriter.png><meta property=og:image content=https://cdn.yangbingdong.com/img/disruptor-learning/multWriterReader.png><meta property=og:image content=https://cdn.yangbingdong.com/img/disruptor-learning/multWriterWrite.png><meta property=og:image content=https://cdn.yangbingdong.com/img/disruptor-learning/simple-test01.jpg><meta property=og:image content=https://cdn.yangbingdong.com/img/disruptor-learning/simple-test02.jpg><meta property=og:image content=https://cdn.yangbingdong.com/img/disruptor-learning/dsl1.png><meta property=og:image content=https://cdn.yangbingdong.com/img/disruptor-learning/multi-test1.jpg><meta property=og:image content=https://cdn.yangbingdong.com/img/disruptor-learning/dsl2.png><meta property=og:image content=https://cdn.yangbingdong.com/img/disruptor-learning/multi-test2.jpg><meta property=og:image content=https://cdn.yangbingdong.com/img/disruptor-learning/multi-test3.jpg><meta property=og:updated_time content=2020-04-07T10:15:47.010Z><meta name=twitter:card content=summary><meta name=twitter:title content="极致的追求, 高性能并发框架 Disruptor"><meta name=twitter:description content="Preface Disruptor是英国外汇交易公司LMAX开发的一个高性能队列, 研发的初衷是解决内存队列的延迟问题（在性能测试中发现竟然与I/O操作处于同样的数量级）. 基于Disruptor开发的系统单线程能支撑每秒600万订单, 2010年在QCon演讲后, 获得了业界关注. 2011年, 企业应用软件专家Martin Fowler专门撰写长文介绍. 同年它还获得了Oracle官方的Du"><meta name=twitter:image content=https://cdn.yangbingdong.com/img/disruptor-learning/Models.png><script id=hexo.configurations>var NexT=window.NexT||{};var CONFIG={root:'/',scheme:'Muse',sidebar:{"position":"right","display":"always"},fancybox:true,motion:true,duoshuo:{userId:'undefined',author:'Author'},algolia:{applicationID:'RI3NF6GUI0',apiKey:'3d33fa60ba30d3b17f37220bb1a36749',indexName:'blogIndex',hits:{"per_page":10},labels:{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}}};</script><link rel=canonical href=http://yangbingdong.com/2018/disruptor-learning/><script>(function(){if(''){if(prompt('请输入文章密码')!==''){alert('密码错误！');history.back();}}})();</script><title>极致的追求, 高性能并发框架 Disruptor | ookamiAntD's Blog</title><body itemscope itemtype=http://schema.org/WebPage lang=en><script>var _hmt=_hmt||[];(function(){var hm=document.createElement("script");hm.src="https://hm.baidu.com/hm.js?e9505ac4e11d464329d615553a72b526";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script><div class="container one-collumn sidebar-position-right page-post-detail"><div class=headband></div><a href=https://github.com/masteranthoneyd/blog rel="external nofollow noopener noreferrer" target=_blank><img style=position:absolute;top:0;left:0;border:0 src=https://camo.githubusercontent.com/82b228a3648bf44fc1163ef44c62fcc60081495e/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f7265645f6161303030302e706e67 alt="Fork me on GitHub" data-canonical-src=https://s3.amazonaws.com/github/ribbons/forkme_left_red_aa0000.png></a><header id=header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-meta><div class=custom-logo-site-title><a href=/ class=brand rel=start><span class=logo-line-before><i></i></span><span class=site-title>ookamiAntD's Blog</span>
<span class=logo-line-after><i></i></span></a></div><h1 class=site-subtitle itemprop=description>Easy coding,easy life.</h1></div><div class=site-nav-toggle><button>
<span class=btn-bar></span><span class=btn-bar></span><span class=btn-bar></span></button></div><nav class=site-nav><ul id=menu class=menu><li class="menu-item menu-item-home"><a href=/ rel=section><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a><li class="menu-item menu-item-archives"><a href=/archives rel=section><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a><li class="menu-item menu-item-categories"><a href=/categories rel=section><i class="menu-item-icon fa fa-fw fa-th"></i><br>Categories</a><li class="menu-item menu-item-tags"><a href=/tags rel=section><i class="menu-item-icon fa fa-fw fa-tags"></i><br>Tags</a><li class="menu-item menu-item-about"><a href=/about rel=section><i class="menu-item-icon fa fa-fw fa-user"></i><br>About</a><li class="menu-item menu-item-guestbook"><a href=/guestbook rel=section><i class="menu-item-icon fa fa-fw fa-commenting"></i><br>Message</a><li class="menu-item menu-item-search"><a href=javascript:; class=popup-trigger><i class="menu-item-icon fa fa-search fa-fw"></i><br>Search</a></ul><div class=site-search><div class=popup><span class="search-icon fa fa-search"></span><input id=local-search-input><div id=local-search-result></div><span class=popup-btn-close>close</span></div></div></nav></div></header><main id=main class=main><div class=main-inner><div class=content-wrap><div id=content class=content><div id=posts class=posts-expand><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><link itemprop=mainEntityOfPage href=http://yangbingdong.com/2018/disruptor-learning/><span style=display:none itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=name content=ookamiAntD><meta itemprop=description content><meta itemprop=image content=/images/avatar/avatar-admin.jpg></span><span style=display:none itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="ookamiAntD's Blog"><span style=display:none itemprop=logo itemscope itemtype=http://schema.org/ImageObject><img style=display:none itemprop="url image" alt="ookamiAntD's Blog" src></span></span><header class=post-header><h2 class=post-title itemprop="name headline">极致的追求, 高性能并发框架 Disruptor</h2><div class=post-meta><span class=post-time><span class=post-meta-item-icon><i class="fa fa-calendar-o"></i></span><span class=post-meta-item-text>Posted on</span>
<time title="Post created" itemprop="dateCreated datePublished" datetime=2018-02-05T15:52:51+08:00>2018-02-05</time></span>
<span class=post-category><span class=post-meta-divider>|</span>
<span class=post-meta-item-icon><i class="fa fa-folder-o"></i></span><span class=post-meta-item-text>In</span>
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/Programming/ itemprop=url rel=index><span itemprop=name>Programming</span></a></span>
,
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/Programming/Java/ itemprop=url rel=index><span itemprop=name>Java</span></a></span></span>
<span id=/2018/disruptor-learning/ class=leancloud_visitors data-flag-title="极致的追求, 高性能并发框架 Disruptor"><span class=post-meta-divider>|</span>
<span class=post-meta-item-icon><i class="fa fa-eye"></i></span><span class=post-meta-item-text>Visitors</span>
<span class=leancloud-visitors-count></span></span><br><span class=post-time><span class=post-meta-item-icon><i class="fa fa-edit"></i></span><span class=post-meta-item-text>WordCount:</span>
<span class=post-count>8,724字</span>
<span class=post-meta-divider>|</span>
<span class=post-meta-item-text>min2read:</span>
<span class=post-count>38分钟</span></span></div></header><div class=post-body itemprop=articleBody><link rel=stylesheet href=https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css><p><img src=https://cdn.yangbingdong.com/img/disruptor-learning/Models.png alt><h1 id=Preface><a href=#Preface class=headerlink title=Preface></a>Preface</h1><blockquote><p><a href=https://lmax-exchange.github.io/disruptor/ rel="external nofollow noopener noreferrer" target=_blank>Disruptor</a>是英国外汇交易公司LMAX开发的一个高性能队列, 研发的初衷是<strong>解决内存队列的延迟问题</strong>（在性能测试中发现竟然与I/O操作处于同样的数量级）. 基于Disruptor开发的系统单线程能支撑<strong>每秒600万订单</strong>, 2010年在QCon演讲后, 获得了业界关注. 2011年, 企业应用软件专家Martin Fowler专门撰写长文介绍. 同年它还获得了Oracle官方的Duke大奖. 目前, 包括<strong>Apache Storm</strong>、<strong>Camel</strong>、<strong>Log4j2</strong>、<strong>Reactor</strong>在内的很多知名项目都应用或参考了Disruptor以获取高性能.<p>其实Disruptor与其说是一个框架, 不如说是一种设计思路, 这个设计思路对于存在“并发、缓冲区、生产者—消费者模型、事务处理”这些元素的程序来说, Disruptor提出了一种大幅提升性能（TPS）的方案.<p>听说小米也是用这个东东把亚马逊搞挂了: <a href=http://bbs.xiaomi.cn/t-13417592 rel="external nofollow noopener noreferrer" target=_blank>http://bbs.xiaomi.cn/t-13417592</a></blockquote><a id=more></a><h1 id=核心概念><a href=#核心概念 class=headerlink title=核心概念></a>核心概念</h1><p>在理解<a href=https://github.com/LMAX-Exchange/disruptor rel="external nofollow noopener noreferrer" target=_blank>Disruptor</a>之前, 我们需要看一下它的核心概念<ul><li><a href=https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/RingBuffer.java rel="external nofollow noopener noreferrer" target=_blank><strong>Ring Buffer</strong></a>: Ring Buffer通常被认为是Disruptor的主要方面, 然而从3.0开始, Ring Buffer只负责存储和更新通过Disruptor的数据（Events）. 而且对于一些高级用例可以完全由用户替换.<li><a href=https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/Sequence.java rel="external nofollow noopener noreferrer" target=_blank><strong>Sequence</strong></a>: Disruptor使用序列作为一种手段来确定特定组件的位置. 每个消费者（EventProcessor）都像Disruptor本身一样维护一个Sequence. 大部分并发代码依赖于这些Sequence值的移动, 因此Sequence支持AtomicLong的许多当前特性. 事实上, 与2版本之间唯一真正的区别是序列包含额外的功能, 以防止序列和其他值之间的错误共享.<li><a href=https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/Sequencer.java rel="external nofollow noopener noreferrer" target=_blank><strong>Sequencer</strong></a>: Sequencer是Disruptor的真正核心. 这个接口的2个实现（单生产者, 多生产者）实现了所有的并发算法, 用于在生产者和消费者之间快速正确地传递数据.<li><a href=https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/SequenceBarrier.java rel="external nofollow noopener noreferrer" target=_blank><strong>Sequence Barrier</strong></a>: 序列屏障由序列发生器产生, 并包含对序列发生器的主要发布序列和任何相关消费者的序列的引用. 它包含确定消费者是否有任何事件可供处理的逻辑.<li><a href=https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/WaitStrategy.java rel="external nofollow noopener noreferrer" target=_blank><strong>Wait Strategy</strong></a>: 等待策略决定了消费者如何等待事件被生产者置于Disruptor中.<li><strong>Event</strong>: 从生产者到消费者的数据单位. 事件没有特定的代码表示, 因为它完全由用户定义.<li><a href=https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/EventProcessor.java rel="external nofollow noopener noreferrer" target=_blank><strong>EventProcessor</strong></a>: 用于处理来自Disruptor的事件的主事件循环, 并拥有消费者序列的所有权. 有一个称为BatchEventProcessor的表示, 它包含一个有效的事件循环实现, 并将回调到EventHandler接口的已用提供的实现上.<li><a href=https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/EventHandler.java rel="external nofollow noopener noreferrer" target=_blank><strong>EventHandler</strong></a>: 由用户实现的界面, 代表Disruptor的使用者.<li><strong>Producer</strong>: 这是调用Disruptor排入事件的用户代码. 这个概念在代码中也没有表示.</ul><h1 id=Java内置队列><a href=#Java内置队列 class=headerlink title=Java内置队列></a>Java内置队列</h1><blockquote><p>以下内容来自美团点评技术团队博文</blockquote><p>Java的内置队列如下表所示.<table><thead><tr><th>队列<th>有界性<th>锁<th>数据结构<tbody><tr><td>ArrayBlockingQueue<td>bounded<td>加锁<td>arraylist<tr><td>LinkedBlockingQueue<td>optionally-bounded<td>加锁<td>linkedlist<tr><td>ConcurrentLinkedQueue<td>unbounded<td>无锁<td>linkedlist<tr><td>LinkedTransferQueue<td>unbounded<td>无锁<td>linkedlist<tr><td>PriorityBlockingQueue<td>unbounded<td>加锁<td>heap<tr><td>DelayQueue<td>unbounded<td>加锁<td>heap</table><p>队列的底层一般分成三种: 数组、链表和堆. 其中, 堆一般情况下是为了实现带有优先级特性的队列, 暂且不考虑.<p>我们就从数组和链表两种数据结构来看, 基于数组线程安全的队列, 比较典型的是<code>ArrayBlockingQueue</code>, 它主要通过加锁的方式来保证线程安全；基于链表的线程安全队列分成<code>LinkedBlockingQueue</code>和<code>ConcurrentLinkedQueue</code>两大类, 前者也通过锁的方式来实现线程安全, 而后者以及上面表格中的<code>LinkedTransferQueue</code>都是通过原子变量<code>compare and swap</code>（以下简称“<strong>CAS</strong>”）这种不加锁的方式来实现的.<p>通过不加锁的方式实现的队列都是<strong>无界</strong>的（无法保证队列的长度在确定的范围内）；而加锁的方式, 可以实现有界队列. 在稳定性要求特别高的系统中, 为了防止生产者速度过快, 导致内存溢出, 只能选择有界队列；同时, 为了减少Java的垃圾回收对系统性能的影响, 会尽量选择<code>array/heap</code>格式的数据结构. 这样筛选下来, 符合条件的队列就只有<code>ArrayBlockingQueue</code>.<h1 id=ArrayBlockingQueue的问题><a href=#ArrayBlockingQueue的问题 class=headerlink title=ArrayBlockingQueue的问题></a>ArrayBlockingQueue的问题</h1><p><code>ArrayBlockingQueue</code>在实际使用过程中, 会因为加锁和伪共享等出现严重的性能问题, 我们下面来分析一下.<h2 id=加锁><a href=#加锁 class=headerlink title=加锁></a>加锁</h2><p>现实编程过程中, 加锁通常会严重地影响性能. 线程会因为竞争不到锁而被挂起, 等锁被释放的时候, 线程又会被恢复, 这个过程中存在着很大的开销, 并且通常会有较长时间的中断, 因为当一个线程正在等待锁时, 它不能做任何其他事情. 如果一个线程在持有锁的情况下被延迟执行, 例如发生了缺页错误、调度延迟或者其它类似情况, 那么所有需要这个锁的线程都无法执行下去. 如果被阻塞线程的优先级较高, 而持有锁的线程优先级较低, 就会发生优先级反转.<p>Disruptor论文中讲述了一个实验:<ul><li>这个测试程序调用了一个函数, 该函数会对一个64位的计数器循环自增5亿次.<li>机器环境: 2.4G 6核<li>运算: 64位的计数器累加5亿次</ul><table><thead><tr><th>Method<th>Time (ms)<tbody><tr><td>Single thread<td>300<tr><td>Single thread with CAS<td>5,700<tr><td>Single thread with lock<td>10,000<tr><td>Single thread with volatile write<td>4,700<tr><td>Two threads with CAS<td>30,000<tr><td>Two threads with lock<td>224,000</table><p>CAS操作比单线程无锁慢了1个数量级；有锁且多线程并发的情况下, 速度比单线程无锁慢3个数量级. 可见无锁速度最快.<p>单线程情况下, 不加锁的性能 &gt; CAS操作的性能 &gt; 加锁的性能.<p>在多线程情况下, 为了保证线程安全, 必须使用CAS或锁, 这种情况下, CAS的性能超过锁的性能, 前者大约是后者的8倍.<p><strong>综上可知, 加锁的性能是最差的.</strong><h3 id=关于锁和CAS><a href=#关于锁和CAS class=headerlink title=关于锁和CAS></a>关于锁和CAS</h3><p>保证线程安全一般分成两种方式: 锁和原子变量.<h4 id=锁><a href=#锁 class=headerlink title=锁></a>锁</h4><p><img src=https://cdn.yangbingdong.com/img/disruptor-learning/lock.png alt=img><p>采取加锁的方式, 默认线程会冲突, 访问数据时, 先加上锁再访问, 访问之后再解锁. 通过锁界定一个临界区, 同时只有一个线程进入. 如上图所示, <code>Thread2</code>访问<code>Entry</code>的时候, 加了锁, <code>Thread1</code>就不能再执行访问<code>Entry</code>的代码, 从而保证线程安全.<p>下面是<code>ArrayBlockingQueue</code>通过加锁的方式实现的<code>offer</code>方法, 保证线程安全.<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>boolean</span> <span class=title>offer</span><span class=params>(E e)</span> </span>&#123;</span><br><span class=line>    checkNotNull(e);</span><br><span class=line>    <span class=keyword>final</span> ReentrantLock lock = <span class=keyword>this</span>.lock;</span><br><span class=line>    lock.lock();</span><br><span class=line>    <span class=keyword>try</span> &#123;</span><br><span class=line>        <span class=keyword>if</span> (count == items.length)</span><br><span class=line>            <span class=keyword>return</span> <span class=keyword>false</span>;</span><br><span class=line>        <span class=keyword>else</span> &#123;</span><br><span class=line>            insert(e);</span><br><span class=line>            <span class=keyword>return</span> <span class=keyword>true</span>;</span><br><span class=line>        &#125;</span><br><span class=line>    &#125; <span class=keyword>finally</span> &#123;</span><br><span class=line>        lock.unlock();</span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br></pre></table></figure><h4 id=原子变量><a href=#原子变量 class=headerlink title=原子变量></a>原子变量</h4><p>原子变量能够保证原子性的操作, 意思是某个任务在执行过程中, 要么全部成功, 要么全部失败回滚, 恢复到执行之前的初态, 不存在初态和成功之间的中间状态. 例如CAS操作, <strong>要么比较并交换成功</strong>, <strong>要么比较并交换失败</strong>. 由CPU保证原子性.<p>通过原子变量可以实现线程安全. 执行某个任务的时候, 先假定不会有冲突, 若不发生冲突, 则直接执行成功；当发生冲突的时候, 则执行失败, 回滚再重新操作, 直到不发生冲突.<p><img src=https://cdn.yangbingdong.com/img/disruptor-learning/cas.png alt=img><p>如图所示, <code>Thread1</code>和<code>Thread2</code>都要把<code>Entry</code>加1. 若不加锁, 也不使用CAS, 有可能<code>Thread1</code>取到了<code>myValue=1</code>, <code>Thread2</code>也取到了<code>myValue=1</code>, 然后相加, <code>Entry</code>中的<code>value</code>值为2. 这与预期不相符, 我们预期的是<code>Entry</code>的值经过两次相加后等于3.<p>CAS会先把<code>Entry</code>现在的<code>value</code>跟线程当初读出的值相比较, 若相同, 则赋值；若不相同, 则赋值执行失败. 一般会通过<code>while/for</code>循环来重新执行, <strong>直到赋值成功</strong>.<p>代码示例是<code>AtomicInteger</code>的<code>getAndAdd</code>方法. CAS是CPU的一个指令, 由CPU保证原子性.<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * Atomically adds the given value to the current value.</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * <span class=doctag>@param</span> delta the value to add</span></span><br><span class=line><span class=comment> * <span class=doctag>@return</span> the previous value</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>int</span> <span class=title>getAndAdd</span><span class=params>(<span class=keyword>int</span> delta)</span> </span>&#123;</span><br><span class=line>    <span class=keyword>for</span> (;;) &#123;</span><br><span class=line>        <span class=keyword>int</span> current = get();</span><br><span class=line>        <span class=keyword>int</span> next = current + delta;</span><br><span class=line>        <span class=keyword>if</span> (compareAndSet(current, next))</span><br><span class=line>            <span class=keyword>return</span> current;</span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * Atomically sets the value to the given updated value</span></span><br><span class=line><span class=comment> * if the current value &#123;<span class=doctag>@code</span> ==&#125; the expected value.</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * <span class=doctag>@param</span> expect the expected value</span></span><br><span class=line><span class=comment> * <span class=doctag>@param</span> update the new value</span></span><br><span class=line><span class=comment> * <span class=doctag>@return</span> true if successful. False return indicates that</span></span><br><span class=line><span class=comment> * the actual value was not equal to the expected value.</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>boolean</span> <span class=title>compareAndSet</span><span class=params>(<span class=keyword>int</span> expect, <span class=keyword>int</span> update)</span> </span>&#123;</span><br><span class=line>    <span class=keyword>return</span> unsafe.compareAndSwapInt(<span class=keyword>this</span>, valueOffset, expect, update);</span><br><span class=line>&#125;</span><br></pre></table></figure><p>在高度竞争的情况下, 锁的性能将超过原子变量的性能, 但是更真实的竞争情况下, 原子变量的性能将超过锁的性能. 同时原子变量不会有死锁等活跃性问题.<h2 id=伪共享><a href=#伪共享 class=headerlink title=伪共享></a>伪共享</h2><h3 id=什么是共享><a href=#什么是共享 class=headerlink title=什么是共享></a>什么是共享</h3><p>下图是计算的基本结构. L1、L2、L3分别表示一级缓存、二级缓存、三级缓存, 越靠近CPU的缓存, 速度越快, 容量也越小. 所以L1缓存很小但很快, 并且紧靠着在使用它的CPU内核；L2大一些, 也慢一些, 并且仍然只能被一个单独的CPU核使用；L3更大、更慢, 并且被单个插槽上的所有CPU核共享；最后是主存, 由全部插槽上的所有CPU核共享.<p><img src=https://cdn.yangbingdong.com/img/disruptor-learning/computer.png alt=img><p>当CPU执行运算的时候, 它先去L1查找所需的数据、再去L2、然后是L3, 如果最后这些缓存中都没有, 所需的数据就要去主内存拿. 走得越远, 运算耗费的时间就越长. 所以如果你在做一些很频繁的事, 你要尽量确保数据在L1缓存中.<p>另外, 线程之间共享一份数据的时候, 需要一个线程把数据写回主存, 而另一个线程访问主存中相应的数据.<p>下面是从CPU访问不同层级数据的时间概念:<table><thead><tr><th>从CPU到<th>大约需要的CPU周期<th>大约需要的时间<tbody><tr><td>主存<td><td>约60-80ns<tr><td>QPI 总线传输(between sockets, not drawn)<td><td>约20ns<tr><td>L3 cache<td>约40-45 cycles<td>约15ns<tr><td>L2 cache<td>约10 cycles<td>约3ns<tr><td>L1 cache<td>约3-4 cycles<td>约1ns<tr><td>寄存器<td>1 cycle</table><p>可见CPU读取主存中的数据会比从L1中读取慢了近2个数量级.<h3 id=缓存行><a href=#缓存行 class=headerlink title=缓存行></a>缓存行</h3><p>Cache是由很多个cache line组成的. 每个cache line通常是64字节, 并且它有效地引用主内存中的一块儿地址. 一个Java的<code>long</code>类型变量是8字节, 因此在一个缓存行中可以存8个<code>long</code>类型的变量.<p>CPU每次从主存中拉取数据时, 会把相邻的数据也存入同一个cache line.<p>在访问一个long数组的时候, 如果数组中的一个值被加载到缓存中, 它会自动加载另外7个. 因此你能非常快的遍历这个数组. 事实上, 你可以非常快速的遍历在连续内存块中分配的任意数据结构.<p>下面的例子是测试利用cache line的特性和不利用cache line的特性的效果对比.<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>CacheLineEffect</span> </span>&#123;</span><br><span class=line>    <span class=comment>//考虑一般缓存行大小是64字节, 一个 long 类型占8字节</span></span><br><span class=line>    <span class=keyword>static</span>  <span class=keyword>long</span>[][] arr;</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> </span>&#123;</span><br><span class=line>        arr = <span class=keyword>new</span> <span class=keyword>long</span>[<span class=number>1024</span> * <span class=number>1024</span>][];</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i &lt; <span class=number>1024</span> * <span class=number>1024</span>; i++) &#123;</span><br><span class=line>            arr[i] = <span class=keyword>new</span> <span class=keyword>long</span>[<span class=number>8</span>];</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> j = <span class=number>0</span>; j &lt; <span class=number>8</span>; j++) &#123;</span><br><span class=line>                arr[i][j] = <span class=number>0L</span>;</span><br><span class=line>            &#125;</span><br><span class=line>        &#125;</span><br><span class=line>        <span class=keyword>long</span> sum = <span class=number>0L</span>;</span><br><span class=line>        <span class=keyword>long</span> marked = System.currentTimeMillis();</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i &lt; <span class=number>1024</span> * <span class=number>1024</span>; i+=<span class=number>1</span>) &#123;</span><br><span class=line>            <span class=keyword>for</span>(<span class=keyword>int</span> j =<span class=number>0</span>; j&lt; <span class=number>8</span>;j++)&#123;</span><br><span class=line>                sum = arr[i][j];</span><br><span class=line>            &#125;</span><br><span class=line>        &#125;</span><br><span class=line>        System.out.println(<span class=string>"Loop times:"</span> + (System.currentTimeMillis() - marked) + <span class=string>"ms"</span>);</span><br><span class=line></span><br><span class=line>        marked = System.currentTimeMillis();</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i &lt; <span class=number>8</span>; i+=<span class=number>1</span>) &#123;</span><br><span class=line>            <span class=keyword>for</span>(<span class=keyword>int</span> j =<span class=number>0</span>; j&lt; <span class=number>1024</span> * <span class=number>1024</span>;j++)&#123;</span><br><span class=line>                sum = arr[j][i];</span><br><span class=line>            &#125;</span><br><span class=line>        &#125;</span><br><span class=line>        System.out.println(<span class=string>"Loop times:"</span> + (System.currentTimeMillis() - marked) + <span class=string>"ms"</span>);</span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br></pre></table></figure><p>在2G Hz、2核、8G内存的运行环境中测试, 速度差一倍.<p>结果:<br>Loop times:30ms<br>Loop times:65ms<h3 id=什么是伪共享><a href=#什么是伪共享 class=headerlink title=什么是伪共享></a>什么是伪共享</h3><p><code>ArrayBlockingQueue</code>有三个成员变量:<ul><li><code>takeIndex</code>: 需要被取走的元素下标<li><code>putIndex</code>: 可被元素插入的位置的下标<li><code>count</code>: 队列中元素的数量</ul><p>这三个变量很容易放到一个缓存行中, 但是之间修改没有太多的关联. 所以每次修改, 都会使之前缓存的数据失效, 从而不能完全达到共享的效果.<p><img src=https://cdn.yangbingdong.com/img/disruptor-learning/falseSharing.png alt=img><p>如上图所示, 当生产者线程<code>put</code>一个元素到<code>ArrayBlockingQueue</code>时, <code>putIndex</code>会修改, 从而导致消费者线程的缓存中的缓存行无效, 需要从主存中重新读取.<p>这种无法充分使用缓存行特性的现象, 称为伪共享.<p>对于伪共享, 一般的解决方案是, 增大数组元素的间隔使得由不同线程存取的元素位于不同的缓存行上, 以空间换时间.<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>FalseSharing</span> <span class=keyword>implements</span> <span class=title>Runnable</span></span>&#123;</span><br><span class=line>        <span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>static</span> <span class=keyword>long</span> ITERATIONS = <span class=number>500L</span> * <span class=number>1000L</span> * <span class=number>100L</span>;</span><br><span class=line>        <span class=keyword>private</span> <span class=keyword>int</span> arrayIndex = <span class=number>0</span>;</span><br><span class=line></span><br><span class=line>        <span class=keyword>private</span> <span class=keyword>static</span> ValuePadding[] longs;</span><br><span class=line>        <span class=function><span class=keyword>public</span> <span class=title>FalseSharing</span><span class=params>(<span class=keyword>final</span> <span class=keyword>int</span> arrayIndex)</span> </span>&#123;</span><br><span class=line>            <span class=keyword>this</span>.arrayIndex = arrayIndex;</span><br><span class=line>        &#125;</span><br><span class=line></span><br><span class=line>        <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(<span class=keyword>final</span> String[] args)</span> <span class=keyword>throws</span> Exception </span>&#123;</span><br><span class=line>            <span class=keyword>for</span>(<span class=keyword>int</span> i=<span class=number>1</span>;i&lt;<span class=number>10</span>;i++)&#123;</span><br><span class=line>                System.gc();</span><br><span class=line>                <span class=keyword>final</span> <span class=keyword>long</span> start = System.currentTimeMillis();</span><br><span class=line>                runTest(i);</span><br><span class=line>                System.out.println(<span class=string>"Thread num "</span>+i+<span class=string>" duration = "</span> + (System.currentTimeMillis() - start));</span><br><span class=line>            &#125;</span><br><span class=line></span><br><span class=line>        &#125;</span><br><span class=line></span><br><span class=line>        <span class=function><span class=keyword>private</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>runTest</span><span class=params>(<span class=keyword>int</span> NUM_THREADS)</span> <span class=keyword>throws</span> InterruptedException </span>&#123;</span><br><span class=line>            Thread[] threads = <span class=keyword>new</span> Thread[NUM_THREADS];</span><br><span class=line>            longs = <span class=keyword>new</span> ValuePadding[NUM_THREADS];</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i &lt; longs.length; i++) &#123;</span><br><span class=line>                longs[i] = <span class=keyword>new</span> ValuePadding();</span><br><span class=line>            &#125;</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i &lt; threads.length; i++) &#123;</span><br><span class=line>                threads[i] = <span class=keyword>new</span> Thread(<span class=keyword>new</span> FalseSharing(i));</span><br><span class=line>            &#125;</span><br><span class=line></span><br><span class=line>            <span class=keyword>for</span> (Thread t : threads) &#123;</span><br><span class=line>                t.start();</span><br><span class=line>            &#125;</span><br><span class=line></span><br><span class=line>            <span class=keyword>for</span> (Thread t : threads) &#123;</span><br><span class=line>                t.join();</span><br><span class=line>            &#125;</span><br><span class=line>        &#125;</span><br><span class=line></span><br><span class=line>        <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>run</span><span class=params>()</span> </span>&#123;</span><br><span class=line>            <span class=keyword>long</span> i = ITERATIONS + <span class=number>1</span>;</span><br><span class=line>            <span class=keyword>while</span> (<span class=number>0</span> != --i) &#123;</span><br><span class=line>                longs[arrayIndex].value = <span class=number>0L</span>;</span><br><span class=line>            &#125;</span><br><span class=line>        &#125;</span><br><span class=line></span><br><span class=line>        <span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>static</span> <span class=class><span class=keyword>class</span> <span class=title>ValuePadding</span> </span>&#123;</span><br><span class=line>            <span class=keyword>protected</span> <span class=keyword>long</span> p1, p2, p3, p4, p5, p6, p7;</span><br><span class=line>            <span class=keyword>protected</span> <span class=keyword>volatile</span> <span class=keyword>long</span> value = <span class=number>0L</span>;</span><br><span class=line>            <span class=keyword>protected</span> <span class=keyword>long</span> p9, p10, p11, p12, p13, p14;</span><br><span class=line>            <span class=keyword>protected</span> <span class=keyword>long</span> p15;</span><br><span class=line>        &#125;</span><br><span class=line>        <span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>static</span> <span class=class><span class=keyword>class</span> <span class=title>ValueNoPadding</span> </span>&#123;</span><br><span class=line>            <span class=comment>// protected long p1, p2, p3, p4, p5, p6, p7;</span></span><br><span class=line>            <span class=keyword>protected</span> <span class=keyword>volatile</span> <span class=keyword>long</span> value = <span class=number>0L</span>;</span><br><span class=line>            <span class=comment>// protected long p9, p10, p11, p12, p13, p14, p15;</span></span><br><span class=line>        &#125;</span><br><span class=line>&#125;</span><br></pre></table></figure><p>在2G Hz, 2核, 8G内存, jdk 1.7.0_45 的运行环境下, 使用了共享机制比没有使用共享机制, 速度快了4倍左右.<p>结果:<br>Thread num 1 duration = 447<br>Thread num 2 duration = 463<br>Thread num 3 duration = 454<br>Thread num 4 duration = 464<br>Thread num 5 duration = 561<br>Thread num 6 duration = 606<br>Thread num 7 duration = 684<br>Thread num 8 duration = 870<br>Thread num 9 duration = 823<p>把代码中ValuePadding都替换为ValueNoPadding后的结果:<br>Thread num 1 duration = 446<br>Thread num 2 duration = 2549<br>Thread num 3 duration = 2898<br>Thread num 4 duration = 3931<br>Thread num 5 duration = 4716<br>Thread num 6 duration = 5424<br>Thread num 7 duration = 4868<br>Thread num 8 duration = 4595<br>Thread num 9 duration = 4540<p>备注: 在jdk1.8中, 有专门的注解<code>@Contended</code>来避免伪共享, 更优雅地解决问题.<h1 id=Disruptor的设计方案><a href=#Disruptor的设计方案 class=headerlink title=Disruptor的设计方案></a>Disruptor的设计方案</h1><p>Disruptor通过以下设计来解决队列速度慢的问题:<ul><li>环形数组结构</ul><p>为了避免垃圾回收, 采用数组而非链表. 同时, 数组对处理器的缓存机制更加友好.<ul><li>元素位置定位</ul><p>数组长度<code>2^n</code>, 通过位运算, 加快定位的速度. 下标采取递增的形式. 不用担心<code>index</code>溢出的问题. <code>index</code>是<code>long</code>类型, 即使100万QPS的处理速度, 也需要30万年才能用完.<ul><li>无锁设计</ul><p>每个生产者或者消费者线程, 会先<strong>申请</strong>可以操作的元素在数组中的位置, 申请到之后, 直接在该位置写入或者读取数据.<p>下面忽略数组的环形结构, 介绍一下如何实现无锁设计. 整个过程通过原子变量CAS, 保证操作的线程安全.<h2 id=一个生产者><a href=#一个生产者 class=headerlink title=一个生产者></a>一个生产者</h2><h3 id=写数据><a href=#写数据 class=headerlink title=写数据></a>写数据</h3><p>生产者单线程写数据的流程比较简单:<ol><li>申请写入m个元素；<li>若是有m个元素可以写入, 则返回<strong>最大的序列号</strong>. 这儿主要判断是否会覆盖未读的元素；<li>若是返回的正确, 则生产者开始写入元素.</ol><p><img src=https://cdn.yangbingdong.com/img/disruptor-learning/singleWriter.png alt=img><br>图5 单个生产者生产过程示意图<h2 id=多个生产者><a href=#多个生产者 class=headerlink title=多个生产者></a>多个生产者</h2><p>多个生产者的情况下, 会遇到“如何防止多个线程重复写同一个元素”的问题. Disruptor的解决方法是, <strong>每个线程获取不同的一段数组空间进行操作</strong>. 这个通过CAS很容易达到. 只需要在分配元素的时候, 通过CAS判断一下这段空间是否已经分配出去即可.<p>但是会遇到一个<strong>新问题</strong>: 如何防止读取的时候, 读到还未写的元素. Disruptor在多个生产者的情况下, 引入了一个与<code>Ring Buffer</code>大小相同的<code>buffer</code>: <code>available Buffer</code>. 当某个位置写入成功的时候, 便把<code>availble Buffer</code>相应的位置置位, 标记为写入成功. 读取的时候, 会遍历<code>available Buffer</code>, 来判断元素是否已经就绪.<p>下面分读数据和写数据两种情况介绍.<h3 id=读数据><a href=#读数据 class=headerlink title=读数据></a>读数据</h3><p>生产者多线程写入的情况会复杂很多:<ol><li>申请读取到序号n；<li>若<code>writer cursor</code> &gt;= n, 这时仍然无法确定连续可读的最大下标. 从<code>reader cursor</code>开始读取<code>available Buffer</code>, 一直查到第一个不可用的元素, 然后返回最大连续可读元素的位置；<li>消费者读取元素.</ol><p>如下图所示, 读线程读到下标为2的元素, 三个线程<code>Writer1</code>/<code>Writer2</code>/<code>Writer3</code>正在向<code>RingBuffer</code>相应位置写数据, 写线程被分配到的最大元素下标是11.<p>读线程申请读取到下标从3到11的元素, 判断<code>writer cursor&gt;=11</code>. 然后开始读取<code>availableBuffer</code>, 从3开始, 往后读取, 发现下标为7的元素没有生产成功, 于是<code>WaitFor(11)</code>返回6.<p>然后, 消费者读取下标从3到6共计4个元素.<p><img src=https://cdn.yangbingdong.com/img/disruptor-learning/multWriterReader.png alt=img><h3 id=写数据-1><a href=#写数据-1 class=headerlink title=写数据></a>写数据</h3><p>多个生产者写入的时候:<ol><li>申请写入m个元素；<li>若是有m个元素可以写入, 则返回最大的序列号. 每个生产者会被分配一段独享的空间；<li>生产者写入元素, 写入元素的同时设置<code>available Buffer</code>里面相应的位置, 以标记自己哪些位置是已经写入成功的.</ol><p>如下图所示, <code>Writer1</code>和<code>Writer2</code>两个线程写入数组, 都申请可写的数组空间. <code>Writer1</code>被分配了下标3到下表5的空间, <code>Writer2</code>被分配了下标6到下标9的空间.<p><code>Writer1</code>写入下标3位置的元素, 同时把<code>available Buffer</code>相应位置置位, 标记已经写入成功, 往后移一位, 开始写下标4位置的元素. <code>Writer2</code>同样的方式. 最终都写入完成.<p><img src=https://cdn.yangbingdong.com/img/disruptor-learning/multWriterWrite.png alt=img><p>防止不同生产者对同一段空间写入的代码, 如下所示:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>long</span> <span class=title>tryNext</span><span class=params>(<span class=keyword>int</span> n)</span> <span class=keyword>throws</span> InsufficientCapacityException</span></span><br><span class=line><span class=function></span>&#123;</span><br><span class=line>    <span class=keyword>if</span> (n &lt; <span class=number>1</span>)</span><br><span class=line>    &#123;</span><br><span class=line>        <span class=keyword>throw</span> <span class=keyword>new</span> IllegalArgumentException(<span class=string>"n must be &gt; 0"</span>);</span><br><span class=line>    &#125;</span><br><span class=line></span><br><span class=line>    <span class=keyword>long</span> current;</span><br><span class=line>    <span class=keyword>long</span> next;</span><br><span class=line></span><br><span class=line>    <span class=keyword>do</span></span><br><span class=line>    &#123;</span><br><span class=line>        current = cursor.get();</span><br><span class=line>        next = current + n;</span><br><span class=line></span><br><span class=line>        <span class=keyword>if</span> (!hasAvailableCapacity(gatingSequences, n, current))</span><br><span class=line>        &#123;</span><br><span class=line>            <span class=keyword>throw</span> InsufficientCapacityException.INSTANCE;</span><br><span class=line>        &#125;</span><br><span class=line>    &#125;</span><br><span class=line>    <span class=keyword>while</span> (!cursor.compareAndSet(current, next));</span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> next;</span><br><span class=line>&#125;</span><br></pre></table></figure><p>通过<code>do</code>/<code>while</code>循环的条件<code>cursor.compareAndSet(current, next)</code>, 来判断每次申请的空间是否已经被其他生产者占据. 假如已经被占据, 该函数会返回失败, While循环重新执行, 申请写入空间.<p>消费者的流程与生产者非常类似, 这儿就不多描述了. Disruptor通过精巧的无锁设计实现了在高并发情形下的高性能.<h1 id=等待策略><a href=#等待策略 class=headerlink title=等待策略></a>等待策略</h1><h2 id=生产者的等待策略><a href=#生产者的等待策略 class=headerlink title=生产者的等待策略></a>生产者的等待策略</h2><p>暂时只有休眠1ns.<figure class="highlight plain"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>LockSupport.parkNanos(1);</span><br></pre></table></figure><h2 id=消费者的等待策略><a href=#消费者的等待策略 class=headerlink title=消费者的等待策略></a>消费者的等待策略</h2><table><thead><tr><th>名称<th>说明<th>适用场景<tbody><tr><td><code>BlockingWaitStrategy</code><td>默认等待策略. 和<code>BlockingQueue</code>的实现很类似, 通过使用锁和条件（<code>Condition</code>）进行线程阻塞的方式, 等待生产者唤醒(线程同步和唤醒). 此策略对于线程切换来说, 最节约CPU资源, 但在高并发场景下性能有限<td>CPU资源紧缺, 吞吐量和延迟并不重要的场景<tr><td><code>BusySpinWaitStrategy</code><td>死循环策略. 消费者线程会尽最大可能监控缓冲区的变化, 会占用所有CPU资源,线程一直自旋等待, 比较耗CPU<td>通过不断重试, 减少切换线程导致的系统调用, 而降低延迟. 推荐在线程绑定到固定的CPU的场景下使用<tr><td><code>LiteBlockingWaitStrategy</code><td>通过线程阻塞的方式, 等待生产者唤醒, 比<code>BlockingWaitStrategy</code>要轻, 某些情况下可以减少阻塞的次数<td><tr><td><code>PhasedBackoffWaitStrategy</code><td>根据指定的时间段参数和指定的等待策略决定采用哪种等待策略<td>CPU资源紧缺, 吞吐量和延迟并不重要的场景<tr><td><code>SleepingWaitStrategy</code><td>CPU友好型策略. 会在循环中不断等待数据. 可通过参数设置,首先进行自旋等待, 若不成功, 则使用<code>Thread.yield()</code>让出CPU, 并使用<code>LockSupport.parkNanos(1)</code>进行线程睡眠, 通过线程调度器重新调度；或一直自旋等待, 所以, 此策略数据处理数据可能会有较高的延迟, 适合用于对延迟不敏感的场景, 优点是对生产者线程影响小, 典型应用场景是异步日志<td>性能和CPU资源之间有很好的折中. 延迟不均匀<tr><td><code>TimeoutBlockingWaitStrategy</code><td>通过参数设置阻塞时间, 如果超时则抛出异常<td>CPU资源紧缺, 吞吐量和延迟并不重要的场景<tr><td><code>YieldingWaitStrategy</code><td>低延时策略. 消费者线程会不断循环监控<code>RingBuffer</code>的变化, 在循环内部使用<code>Thread.yield()</code>让出CPU给其他线程, 通过线程调度器重新调度<td>性能和CPU资源之间有很好的折中. 延迟比较均匀</table><h1 id=核心对象><a href=#核心对象 class=headerlink title=核心对象></a>核心对象</h1><ol><li><code>RingBuffer</code>: 环形的一个数据结构, 对象初始化时, 会使用事件<code>Event</code>进行填充. <code>Buffer</code>的大小<strong>必须是2的幂次方</strong>, 方便移位操作.<li><code>Event</code>: 无指定具体接口, 用户自己实现, 可以携带任何业务数据.<li><code>EventFactory</code>: 产生事件<code>Event</code>的工厂, 由用户自己实现.<li><code>EventTranslator</code>: 事件发布的回调接口, 由用户实现, 负责将业务参数设置到事件中.<li><code>Sequencer</code>: 序列产生器, 也是协调生产者和消费者及实现高并发的核心. 有<code>MultiProducerSequencer</code> 和 <code>SingleProducerSequencer</code>两个实现类.<li><code>SequenceBarrier</code>: 拥有<code>RingBuffer</code>的发布事件<code>Sequence</code>引用和消费者依赖的<code>Sequence</code>引用. 决定消费者消费可消费的<code>Sequence</code>.<li><code>EventHandler</code>: 事件的处理者, 由用户自己实现.<li><code>EventProcessor</code>: 事件的处理器, 单独在一个线程中运行.<li><code>WorkHandler</code>: 事件的处理者, 由用户自己实现.<li><code>WorkProcessor</code>: 事件的处理器, 单独在一个线程中运行.<li><code>WorkerPool</code>: 一组<code>WorkProcessor</code>的处理.<li><code>WaitStrategy</code>: 在消费者比生产者快时, 消费者处理器的等待策略.</ol><h1 id=用例><a href=#用例 class=headerlink title=用例></a>用例</h1><p>按照官方的指南, 一般套路如下:<ol><li>自定义事件类: 例如 <code>LongEvent</code><li>实现<code>EventFactory&lt;T&gt;</code>: 例如<code>LongEventFactory implements EventFactory&lt;LongEvent&gt;</code><li>实现<code>EventHandler&lt;T&gt;</code>（消费者）: 例如<code>LongEventHandler implements EventHandler&lt;LongEvent&gt;</code><li>实现<code>EventTranslatorOneArg&lt;T, E&gt;</code>作为生产者, 将业务转换为事件: 例如<code>LongEventTranslatorOneArg implements EventTranslatorOneArg&lt;LongEvent, ByteBuffer&gt;</code><li>提供线程池或线程工厂<li>定义buffer大小, 它<strong>必须是2的幂</strong>, 否则会在初始化时抛出异常. 因为重点在于使用逻辑二进制运算符有着更好的性能；(例如:mod运算)<li>构建<code>Disruptor&lt;T&gt;</code><li>启动<code>disruptor</code>, <code>disruptor.start()</code><li>发布事件, 驱动自行流转</ol><h2 id=基础事件生产与消费><a href=#基础事件生产与消费 class=headerlink title=基础事件生产与消费></a>基础事件生产与消费</h2><h2 id=自定义事件><a href=#自定义事件 class=headerlink title=自定义事件></a>自定义事件</h2><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.yangbingdong.springbootdisruptor.basic;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> lombok.Data;</span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * <span class=doctag>@author</span> ybd</span></span><br><span class=line><span class=comment> * <span class=doctag>@date</span> 18-1-31</span></span><br><span class=line><span class=comment> * <span class=doctag>@contact</span> yangbingdong@1994.gmail</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=meta>@Data</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>LongEvent</span> </span>&#123;</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>long</span> value;</span><br><span class=line>&#125;</span><br></pre></table></figure><h2 id=定义事件工厂><a href=#定义事件工厂 class=headerlink title=定义事件工厂></a>定义事件工厂</h2><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.yangbingdong.springbootdisruptor.basic;</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>import</span> com.lmax.disruptor.EventFactory;</span><br><span class=line><span class=keyword>import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * <span class=doctag>@author</span> ybd</span></span><br><span class=line><span class=comment> * <span class=doctag>@date</span> 18-1-31</span></span><br><span class=line><span class=comment> * <span class=doctag>@contact</span> yangbingdong@1994.gmail</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=meta>@Slf</span>4j</span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>LongEventFactory</span> <span class=keyword>implements</span> <span class=title>EventFactory</span>&lt;<span class=title>LongEvent</span>&gt; </span>&#123;</span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=function><span class=keyword>public</span> LongEvent <span class=title>newInstance</span><span class=params>()</span> </span>&#123;</span><br><span class=line>		log.info(<span class=string>"logEventFactory create LongEvent..."</span>);</span><br><span class=line>		<span class=keyword>return</span> <span class=keyword>new</span> LongEvent();</span><br><span class=line>	&#125;</span><br><span class=line>&#125;</span><br></pre></table></figure><h2 id=定义消费者><a href=#定义消费者 class=headerlink title=定义消费者></a>定义消费者</h2><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.yangbingdong.springbootdisruptor.basic;</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>import</span> com.lmax.disruptor.EventHandler;</span><br><span class=line><span class=keyword>import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * <span class=doctag>@author</span> ybd</span></span><br><span class=line><span class=comment> * <span class=doctag>@date</span> 18-1-31</span></span><br><span class=line><span class=comment> * <span class=doctag>@contact</span> yangbingdong@1994.gmail</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=meta>@Slf</span>4j</span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>LongEventHandler</span> <span class=keyword>implements</span> <span class=title>EventHandler</span>&lt;<span class=title>LongEvent</span>&gt; </span>&#123;</span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>onEvent</span><span class=params>(LongEvent event, <span class=keyword>long</span> sequence, <span class=keyword>boolean</span> endOfBatch)</span> </span>&#123;</span><br><span class=line>		log.info(<span class=string>"handle event: "</span> + event);</span><br><span class=line>	&#125;</span><br><span class=line>&#125;</span><br></pre></table></figure><h2 id=定义生产者><a href=#定义生产者 class=headerlink title=定义生产者></a>定义生产者</h2><h3 id=3-0版本之前><a href=#3-0版本之前 class=headerlink title=3.0版本之前></a>3.0版本之前</h3><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.yangbingdong.springbootdisruptor.basic;</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>import</span> com.lmax.disruptor.RingBuffer;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> java.nio.ByteBuffer;</span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * <span class=doctag>@author</span> ybd</span></span><br><span class=line><span class=comment> * <span class=doctag>@date</span> 18-1-31</span></span><br><span class=line><span class=comment> * <span class=doctag>@contact</span> yangbingdong@1994.gmail</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>LongEventProducer</span> </span>&#123;</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> RingBuffer&lt;LongEvent&gt; ringBuffer;</span><br><span class=line></span><br><span class=line>	<span class=function><span class=keyword>public</span> <span class=title>LongEventProducer</span><span class=params>(RingBuffer&lt;LongEvent&gt; ringBuffer)</span> </span>&#123;</span><br><span class=line>		<span class=keyword>this</span>.ringBuffer = ringBuffer;</span><br><span class=line>	&#125;</span><br><span class=line></span><br><span class=line>	<span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>onData</span><span class=params>(ByteBuffer bb)</span> </span>&#123;</span><br><span class=line>		<span class=comment>// Grab the next sequence</span></span><br><span class=line>		<span class=keyword>long</span> sequence = ringBuffer.next();</span><br><span class=line>		<span class=keyword>try</span> &#123;</span><br><span class=line>			<span class=comment>// Get the entry in the Disruptor</span></span><br><span class=line>			LongEvent event = ringBuffer.get(sequence);</span><br><span class=line>			<span class=comment>// for the sequence</span></span><br><span class=line>			<span class=comment>// Fill with data</span></span><br><span class=line>			event.setValue(bb.getLong(<span class=number>0</span>));</span><br><span class=line>		&#125; <span class=keyword>finally</span> &#123;</span><br><span class=line>			ringBuffer.publish(sequence);</span><br><span class=line>		&#125;</span><br><span class=line>	&#125;</span><br><span class=line>&#125;</span><br></pre></table></figure><h3 id=3-0版本之后使用Translators><a href=#3-0版本之后使用Translators class=headerlink title=3.0版本之后使用Translators></a>3.0版本之后使用Translators</h3><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.yangbingdong.springbootdisruptor.basic;</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>import</span> com.lmax.disruptor.EventTranslatorOneArg;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> java.nio.ByteBuffer;</span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * <span class=doctag>@author</span> ybd</span></span><br><span class=line><span class=comment> * <span class=doctag>@date</span> 18-1-31</span></span><br><span class=line><span class=comment> * <span class=doctag>@contact</span> yangbingdong@1994.gmail</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>LongEventProducerWithTranslator</span> <span class=keyword>implements</span> <span class=title>EventTranslatorOneArg</span>&lt;<span class=title>LongEvent</span>, <span class=title>ByteBuffer</span>&gt;</span>&#123;</span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>translateTo</span><span class=params>(LongEvent event, <span class=keyword>long</span> sequence, ByteBuffer bb)</span> </span>&#123;</span><br><span class=line>		event.setValue(bb.getLong(<span class=number>0</span>));</span><br><span class=line>	&#125;</span><br><span class=line>&#125;</span><br></pre></table></figure><h2 id=测试实例><a href=#测试实例 class=headerlink title=测试实例></a>测试实例</h2><h3 id=单生产者-单消费者><a href=#单生产者-单消费者 class=headerlink title="单生产者, 单消费者"></a>单生产者, 单消费者</h3><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br></pre><td class=code><pre><span class=line><span class=meta>@Test</span></span><br><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>singleProducerLongEventDefaultTest</span><span class=params>()</span> <span class=keyword>throws</span> InterruptedException </span>&#123;</span><br><span class=line>	<span class=comment>// Executor that will be used to construct new threads for consumers</span></span><br><span class=line>	Executor executor = Executors.newCachedThreadPool();</span><br><span class=line></span><br><span class=line>	<span class=comment>// The factory for the event</span></span><br><span class=line>	LongEventFactory factory = <span class=keyword>new</span> LongEventFactory();</span><br><span class=line></span><br><span class=line>	<span class=comment>// Specify the size of the ring buffer, must be power of 2.</span></span><br><span class=line>	<span class=keyword>int</span> bufferSize = <span class=number>1</span> &lt;&lt; <span class=number>3</span>;</span><br><span class=line></span><br><span class=line>	<span class=comment>// Construct the Disruptor</span></span><br><span class=line>	Disruptor&lt;LongEvent&gt; disruptor = <span class=keyword>new</span> Disruptor&lt;&gt;(factory, bufferSize, executor, ProducerType.SINGLE, <span class=keyword>new</span> BlockingWaitStrategy());</span><br><span class=line></span><br><span class=line>	<span class=comment>// Connect the handler</span></span><br><span class=line>	disruptor.handleEventsWith(<span class=keyword>new</span> LongEventHandler());</span><br><span class=line></span><br><span class=line>	<span class=comment>// Start the Disruptor, starts all threads running</span></span><br><span class=line>	disruptor.start();</span><br><span class=line></span><br><span class=line>	<span class=comment>// Get the ring buffer from the Disruptor to be used for publishing.</span></span><br><span class=line>	RingBuffer&lt;LongEvent&gt; ringBuffer = disruptor.getRingBuffer();</span><br><span class=line></span><br><span class=line>	LongEventProducer producer = <span class=keyword>new</span> LongEventProducer(ringBuffer);</span><br><span class=line></span><br><span class=line>	ByteBuffer bb = ByteBuffer.allocate(<span class=number>8</span>);</span><br><span class=line>	<span class=keyword>for</span> (<span class=keyword>long</span> l = <span class=number>0</span>; l &lt; <span class=number>100</span>; l++) &#123;</span><br><span class=line>		bb.putLong(<span class=number>0</span>, l);</span><br><span class=line>		producer.onData(bb);</span><br><span class=line>		Thread.sleep(<span class=number>10</span>);</span><br><span class=line>	&#125;</span><br><span class=line>&#125;</span><br></pre></table></figure><p>新版的Disruptor不建议我们使用<code>Executor</code>, 而使用<code>ThreadFactory</code>代替:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br></pre><td class=code><pre><span class=line><span class=meta>@Test</span></span><br><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>singleProducerLongEventUseThreadFactoryTest</span><span class=params>()</span> <span class=keyword>throws</span> InterruptedException </span>&#123;</span><br><span class=line>	ThreadFactory threadFactory = <span class=keyword>new</span> ThreadFactory() &#123;</span><br><span class=line>		<span class=keyword>private</span> <span class=keyword>final</span> AtomicInteger index = <span class=keyword>new</span> AtomicInteger(<span class=number>1</span>);</span><br><span class=line>		<span class=meta>@Override</span></span><br><span class=line>		<span class=function><span class=keyword>public</span> Thread <span class=title>newThread</span><span class=params>(Runnable r)</span> </span>&#123;</span><br><span class=line>			<span class=keyword>return</span> <span class=keyword>new</span> Thread(<span class=keyword>null</span>, r, <span class=string>"disruptor-thread-"</span> + index.getAndIncrement());</span><br><span class=line>		&#125;</span><br><span class=line>	&#125;;</span><br><span class=line></span><br><span class=line>	LongEventFactory factory = <span class=keyword>new</span> LongEventFactory();</span><br><span class=line></span><br><span class=line>	<span class=keyword>int</span> bufferSize = <span class=number>1</span> &lt;&lt; <span class=number>3</span>;</span><br><span class=line></span><br><span class=line>	Disruptor&lt;LongEvent&gt; disruptor = <span class=keyword>new</span> Disruptor&lt;&gt;(factory, bufferSize, threadFactory, ProducerType.SINGLE, <span class=keyword>new</span> BlockingWaitStrategy());</span><br><span class=line></span><br><span class=line>	disruptor.handleEventsWith(<span class=keyword>new</span> LongEventHandler());</span><br><span class=line></span><br><span class=line>	disruptor.start();</span><br><span class=line></span><br><span class=line>	RingBuffer&lt;LongEvent&gt; ringBuffer = disruptor.getRingBuffer();</span><br><span class=line></span><br><span class=line>	LongEventProducer producer = <span class=keyword>new</span> LongEventProducer(ringBuffer);</span><br><span class=line></span><br><span class=line>	ByteBuffer bb = ByteBuffer.allocate(<span class=number>8</span>);</span><br><span class=line>	<span class=keyword>for</span> (<span class=keyword>long</span> l = <span class=number>0</span>; l &lt; <span class=number>100</span>; l++) &#123;</span><br><span class=line>		bb.putLong(<span class=number>0</span>, l);</span><br><span class=line>		producer.onData(bb);</span><br><span class=line>		Thread.sleep(<span class=number>10</span>);</span><br><span class=line>	&#125;</span><br><span class=line>&#125;</span><br></pre></table></figure><p>新版Disruptor使用Translators:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br></pre><td class=code><pre><span class=line><span class=meta>@Test</span></span><br><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>singleProducerLongEventUseTranslatorsTest</span><span class=params>()</span> <span class=keyword>throws</span> InterruptedException </span>&#123;</span><br><span class=line>	ThreadFactory threadFactory = <span class=keyword>new</span> ThreadFactory() &#123;</span><br><span class=line>		<span class=keyword>private</span> <span class=keyword>final</span> AtomicInteger index = <span class=keyword>new</span> AtomicInteger(<span class=number>1</span>);</span><br><span class=line>		<span class=meta>@Override</span></span><br><span class=line>		<span class=function><span class=keyword>public</span> Thread <span class=title>newThread</span><span class=params>(Runnable r)</span> </span>&#123;</span><br><span class=line>			<span class=keyword>return</span> <span class=keyword>new</span> Thread(<span class=keyword>null</span>, r, <span class=string>"disruptor-thread-"</span> + index.getAndIncrement());</span><br><span class=line>		&#125;</span><br><span class=line>	&#125;;</span><br><span class=line></span><br><span class=line>	LongEventFactory factory = <span class=keyword>new</span> LongEventFactory();</span><br><span class=line></span><br><span class=line>	<span class=keyword>int</span> bufferSize = <span class=number>1</span> &lt;&lt; <span class=number>3</span>;</span><br><span class=line></span><br><span class=line>	Disruptor&lt;LongEvent&gt; disruptor = <span class=keyword>new</span> Disruptor&lt;&gt;(factory, bufferSize, threadFactory, ProducerType.SINGLE, <span class=keyword>new</span> BlockingWaitStrategy());</span><br><span class=line></span><br><span class=line>	disruptor.handleEventsWith(<span class=keyword>new</span> LongEventHandler());</span><br><span class=line></span><br><span class=line>	disruptor.start();</span><br><span class=line></span><br><span class=line>	RingBuffer&lt;LongEvent&gt; ringBuffer = disruptor.getRingBuffer();</span><br><span class=line></span><br><span class=line>	LongEventProducerWithTranslator longEventProducerWithTranslator = <span class=keyword>new</span> LongEventProducerWithTranslator();</span><br><span class=line></span><br><span class=line>	ByteBuffer bb = ByteBuffer.allocate(<span class=number>8</span>);</span><br><span class=line>	<span class=keyword>for</span> (<span class=keyword>long</span> l = <span class=number>0</span>; l &lt; <span class=number>100</span>; l++) &#123;</span><br><span class=line>		bb.putLong(<span class=number>0</span>, l);</span><br><span class=line>		ringBuffer.publishEvent(longEventProducerWithTranslator, bb);</span><br><span class=line>		Thread.sleep(<span class=number>10</span>);</span><br><span class=line>	&#125;</span><br><span class=line>&#125;</span><br></pre></table></figure><p><img src=https://cdn.yangbingdong.com/img/disruptor-learning/simple-test01.jpg alt><p>java8版:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line><span class=meta>@SuppressWarnings</span>(<span class=string>"unchecked"</span>)</span><br><span class=line><span class=meta>@Test</span></span><br><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>singleProducerLongEventJava8Test</span><span class=params>()</span> </span>&#123;</span><br><span class=line>	<span class=keyword>int</span> bufferSize = <span class=number>1</span> &lt;&lt; <span class=number>3</span>;</span><br><span class=line></span><br><span class=line>	Disruptor&lt;LongEvent&gt; disruptor = <span class=keyword>new</span> Disruptor&lt;&gt;(LongEvent::<span class=keyword>new</span>, bufferSize, (ThreadFactory) Thread::<span class=keyword>new</span>, ProducerType.SINGLE, <span class=keyword>new</span> BlockingWaitStrategy());</span><br><span class=line></span><br><span class=line>	disruptor.handleEventsWith((event, sequence, endOfBatch) -&gt; log.info(<span class=string>"handle event: "</span> + event));</span><br><span class=line></span><br><span class=line>	disruptor.start();</span><br><span class=line></span><br><span class=line>	RingBuffer&lt;LongEvent&gt; ringBuffer = disruptor.getRingBuffer();</span><br><span class=line></span><br><span class=line>	ByteBuffer bb = ByteBuffer.allocate(<span class=number>8</span>);</span><br><span class=line>	LongStream.range(<span class=number>0</span>, <span class=number>100</span>)</span><br><span class=line>			  .forEach(tryLongConsumer(l -&gt; &#123;</span><br><span class=line>				  bb.putLong(<span class=number>0</span>, l);</span><br><span class=line>				  ringBuffer.publishEvent((event, sequence, buffer) -&gt; event.setValue(buffer.getLong(<span class=number>0</span>)), bb);</span><br><span class=line>				  Thread.sleep(<span class=number>10</span>);</span><br><span class=line>			  &#125;));</span><br><span class=line>&#125;</span><br></pre></table></figure><p><img src=https://cdn.yangbingdong.com/img/disruptor-learning/simple-test02.jpg alt><h3 id=多生产者-单消费者><a href=#多生产者-单消费者 class=headerlink title="多生产者, 单消费者"></a>多生产者, 单消费者</h3><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br></pre><td class=code><pre><span class=line><span class=meta>@SuppressWarnings</span>(<span class=string>"unchecked"</span>)</span><br><span class=line><span class=meta>@Test</span></span><br><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>multiProducerOneCustomerTest</span><span class=params>()</span> <span class=keyword>throws</span> InterruptedException </span>&#123;</span><br><span class=line>	CountDownLatch countDownLatch = <span class=keyword>new</span> CountDownLatch(<span class=number>30</span>);</span><br><span class=line></span><br><span class=line>	<span class=keyword>int</span> bufferSize = <span class=number>1</span> &lt;&lt; <span class=number>6</span>;</span><br><span class=line></span><br><span class=line>	Disruptor&lt;LongEvent&gt; disruptor = <span class=keyword>new</span> Disruptor&lt;&gt;(LongEvent::<span class=keyword>new</span>, bufferSize, Executors.defaultThreadFactory(), ProducerType.MULTI, <span class=keyword>new</span> SleepingWaitStrategy());</span><br><span class=line></span><br><span class=line>	disruptor.handleEventsWith((event, sequence, endOfBatch) -&gt; &#123;</span><br><span class=line>		log.info(<span class=string>"handle event: &#123;&#125;, sequence: &#123;&#125;, endOfBatch: &#123;&#125;"</span>, event, sequence, endOfBatch);</span><br><span class=line>		countDownLatch.countDown();</span><br><span class=line>	&#125;);</span><br><span class=line></span><br><span class=line>	LongEventProducerWithTranslator longEventProducerWithTranslator = <span class=keyword>new</span> LongEventProducerWithTranslator();</span><br><span class=line></span><br><span class=line>	disruptor.start();</span><br><span class=line></span><br><span class=line>	<span class=keyword>new</span> Thread(() -&gt; produce(disruptor, longEventProducerWithTranslator, <span class=number>0</span>, <span class=number>10</span>)).start();</span><br><span class=line>	<span class=keyword>new</span> Thread(() -&gt; produce(disruptor, longEventProducerWithTranslator, <span class=number>10</span>, <span class=number>20</span>)).start();</span><br><span class=line>	<span class=keyword>new</span> Thread(() -&gt; produce(disruptor, longEventProducerWithTranslator, <span class=number>20</span>, <span class=number>30</span>)).start();</span><br><span class=line></span><br><span class=line>	countDownLatch.await();</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>private</span> <span class=keyword>void</span> <span class=title>produce</span><span class=params>(Disruptor&lt;LongEvent&gt; disruptor, LongEventProducerWithTranslator longEventProducerWithTranslator, <span class=keyword>int</span> i, <span class=keyword>int</span> i2)</span> </span>&#123;</span><br><span class=line>	<span class=keyword>try</span> &#123;</span><br><span class=line>		RingBuffer&lt;LongEvent&gt; ringBuffer = disruptor.getRingBuffer();</span><br><span class=line></span><br><span class=line>		ByteBuffer bb = ByteBuffer.allocate(<span class=number>8</span>);</span><br><span class=line>		<span class=keyword>for</span> (<span class=keyword>long</span> l = i; l &lt; i2; l++) &#123;</span><br><span class=line>			bb.putLong(<span class=number>0</span>, l);</span><br><span class=line>			ringBuffer.publishEvent(longEventProducerWithTranslator, bb);</span><br><span class=line>			TimeUnit.MILLISECONDS.sleep(<span class=number>20</span>);</span><br><span class=line>		&#125;</span><br><span class=line>	&#125; <span class=keyword>catch</span> (Exception e) &#123;</span><br><span class=line>		e.printStackTrace();</span><br><span class=line>	&#125;</span><br><span class=line>&#125;</span><br></pre></table></figure><h3 id=一个及以上生产者-多个消费者><a href=#一个及以上生产者-多个消费者 class=headerlink title="一个及以上生产者, 多个消费者"></a>一个及以上生产者, 多个消费者</h3><p><img src=https://cdn.yangbingdong.com/img/disruptor-learning/dsl1.png alt><p>先处理完c1和c2才处理c3:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line><span class=meta>@Test</span></span><br><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>multiCustomerOneProducerTest</span><span class=params>()</span> <span class=keyword>throws</span> InterruptedException </span>&#123;</span><br><span class=line>	<span class=keyword>int</span> bufferSize = <span class=number>1</span> &lt;&lt; <span class=number>8</span>;</span><br><span class=line></span><br><span class=line>	Disruptor&lt;LongEvent&gt; disruptor = <span class=keyword>new</span> Disruptor&lt;&gt;(LongEvent::<span class=keyword>new</span>, bufferSize, Executors.defaultThreadFactory(), ProducerType.MULTI, <span class=keyword>new</span> YieldingWaitStrategy());</span><br><span class=line></span><br><span class=line>	LongEventHandler c1 = <span class=keyword>new</span> LongEventHandler();</span><br><span class=line>	LongEventHandler2 c2 = <span class=keyword>new</span> LongEventHandler2();</span><br><span class=line>	LongEventHandler3 c3 = <span class=keyword>new</span> LongEventHandler3();</span><br><span class=line></span><br><span class=line>	disruptor.handleEventsWith(c1, c2).then(c3);</span><br><span class=line></span><br><span class=line>	LongEventProducerWithTranslator longEventProducerWithTranslator = <span class=keyword>new</span> LongEventProducerWithTranslator();</span><br><span class=line></span><br><span class=line>	disruptor.start();</span><br><span class=line></span><br><span class=line>	<span class=keyword>new</span> Thread(() -&gt; produce(disruptor, longEventProducerWithTranslator, <span class=number>0</span>, <span class=number>100</span>)).start();</span><br><span class=line></span><br><span class=line>	TimeUnit.SECONDS.sleep(<span class=number>1</span>);</span><br><span class=line>&#125;</span><br></pre></table></figure><p><img src=https://cdn.yangbingdong.com/img/disruptor-learning/multi-test1.jpg alt><p>从上图结果可以看出来c1和c2的顺序是不确定的, c3总是在最后.<p><img src=https://cdn.yangbingdong.com/img/disruptor-learning/dsl2.png alt><p>如图, 消费者1b消费时, 必须保证消费者1a已经完成对该消息的消费；消费者2b消费时, 必须保证消费者2a已经完成对该消息的消费；消费者c3消费时, 必须保证消费者1b和2b已经完成对该消息的消费.<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line><span class=meta>@SuppressWarnings</span>(<span class=string>"unchecked"</span>)</span><br><span class=line><span class=meta>@Test</span></span><br><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>multiCustomerOneProducerTest2</span><span class=params>()</span> <span class=keyword>throws</span> InterruptedException </span>&#123;</span><br><span class=line>	<span class=keyword>int</span> bufferSize = <span class=number>1</span> &lt;&lt; <span class=number>8</span>;</span><br><span class=line></span><br><span class=line>	Disruptor&lt;LongEvent&gt; disruptor = <span class=keyword>new</span> Disruptor&lt;&gt;(LongEvent::<span class=keyword>new</span>, bufferSize, Executors.defaultThreadFactory(), ProducerType.SINGLE, <span class=keyword>new</span> LiteBlockingWaitStrategy());</span><br><span class=line></span><br><span class=line>	LongEventHandler c1a = <span class=keyword>new</span> LongEventHandler();</span><br><span class=line>	LongEventHandler2 c2a = <span class=keyword>new</span> LongEventHandler2();</span><br><span class=line>	LongEventHandler3 c1b = <span class=keyword>new</span> LongEventHandler3();</span><br><span class=line>	LongEventHandler4 c2b = <span class=keyword>new</span> LongEventHandler4();</span><br><span class=line></span><br><span class=line>	disruptor.handleEventsWith(c1a, c2a);</span><br><span class=line>	disruptor.after(c1a).then(c1b);</span><br><span class=line>	disruptor.after(c2a).then(c2b);</span><br><span class=line>	disruptor.after(c1b, c2b).then((EventHandler&lt;LongEvent&gt;) (event, sequence, endOfBatch) -&gt; System.out.println(<span class=string>"last costumer \n"</span>));</span><br><span class=line></span><br><span class=line>	LongEventProducerWithTranslator longEventProducerWithTranslator = <span class=keyword>new</span> LongEventProducerWithTranslator();</span><br><span class=line></span><br><span class=line>	disruptor.start();</span><br><span class=line></span><br><span class=line>	<span class=keyword>new</span> Thread(() -&gt; produce(disruptor, longEventProducerWithTranslator, <span class=number>0</span>, <span class=number>30</span>)).start();</span><br><span class=line></span><br><span class=line>	TimeUnit.SECONDS.sleep(<span class=number>1</span>);</span><br><span class=line>&#125;</span><br></pre></table></figure><p><img src=https://cdn.yangbingdong.com/img/disruptor-learning/multi-test2.jpg alt><p>再来一个复杂点的:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br></pre><td class=code><pre><span class=line><span class=meta>@SuppressWarnings</span>(<span class=string>"unchecked"</span>)</span><br><span class=line><span class=meta>@Test</span></span><br><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>multiCustomerOneProducerTest3</span><span class=params>()</span> <span class=keyword>throws</span> InterruptedException </span>&#123;</span><br><span class=line>	<span class=keyword>int</span> bufferSize = <span class=number>1</span> &lt;&lt; <span class=number>8</span>;</span><br><span class=line></span><br><span class=line>	Disruptor&lt;LongEvent&gt; disruptor = <span class=keyword>new</span> Disruptor&lt;&gt;(LongEvent::<span class=keyword>new</span>, bufferSize, Executors.defaultThreadFactory(), ProducerType.SINGLE, <span class=keyword>new</span> LiteBlockingWaitStrategy());</span><br><span class=line></span><br><span class=line>	EventHandler a = (EventHandler&lt;LongEvent&gt;) (event, sequence, endOfBatch) -&gt; System.out.println(<span class=string>"process a... event: "</span> + event);</span><br><span class=line>	EventHandler b = (EventHandler&lt;LongEvent&gt;) (event, sequence, endOfBatch) -&gt; System.out.println(<span class=string>"process b... event: "</span> + event);</span><br><span class=line>	EventHandler c = (EventHandler&lt;LongEvent&gt;) (event, sequence, endOfBatch) -&gt; System.out.println(<span class=string>"process c... event: "</span> + event);</span><br><span class=line>	EventHandler d = (EventHandler&lt;LongEvent&gt;) (event, sequence, endOfBatch) -&gt; System.out.println(<span class=string>"process d... event: "</span> + event);</span><br><span class=line>	EventHandler e = (EventHandler&lt;LongEvent&gt;) (event, sequence, endOfBatch) -&gt; System.out.println(<span class=string>"process e... a,b,c has completed, event: "</span> + event + <span class=string>"\n"</span>);</span><br><span class=line>	EventHandler f = (EventHandler&lt;LongEvent&gt;) (event, sequence, endOfBatch) -&gt; System.out.println(<span class=string>"process f... d has completed, event: "</span> + event + <span class=string>"\n"</span>);</span><br><span class=line>	EventHandler g = (EventHandler&lt;LongEvent&gt;) (event, sequence, endOfBatch) -&gt; System.out.println(<span class=string>"process g... e,f has completed, event: "</span> + event + <span class=string>"\n\n"</span>);</span><br><span class=line></span><br><span class=line>	disruptor.handleEventsWith(a, b, c, d);</span><br><span class=line>	disruptor.after(a, b, c).then(e);</span><br><span class=line>	disruptor.after(d).then(f);</span><br><span class=line>	disruptor.after(e, f).then(g);</span><br><span class=line></span><br><span class=line>	LongEventProducerWithTranslator longEventProducerWithTranslator = <span class=keyword>new</span> LongEventProducerWithTranslator();</span><br><span class=line></span><br><span class=line>	disruptor.start();</span><br><span class=line></span><br><span class=line>	<span class=keyword>new</span> Thread(() -&gt; produce(disruptor, longEventProducerWithTranslator, <span class=number>0</span>, <span class=number>2</span>)).start();</span><br><span class=line></span><br><span class=line>	TimeUnit.SECONDS.sleep(<span class=number>1</span>);</span><br><span class=line>&#125;</span><br></pre></table></figure><p><img src=https://cdn.yangbingdong.com/img/disruptor-learning/multi-test3.jpg alt><h2 id=异常处理><a href=#异常处理 class=headerlink title=异常处理></a>异常处理</h2><p>Disruptor默认会把异常包装成<code>RuntimeException</code>并抛出去, 导致线程挂掉或阻塞, 我们需要自定义异常处理器:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line>disruptor.setDefaultExceptionHandler(<span class=keyword>new</span> ExceptionHandler&lt;LongEvent&gt;() &#123;</span><br><span class=line>			<span class=meta>@Override</span></span><br><span class=line>			<span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>handleEventException</span><span class=params>(Throwable ex, <span class=keyword>long</span> sequence, LongEvent event)</span> </span>&#123;</span><br><span class=line>				System.out.println(<span class=string>"捕捉异常: "</span> + ex.getMessage());</span><br><span class=line>				System.out.println(<span class=string>"处理异常逻辑..."</span>);</span><br><span class=line>			&#125;</span><br><span class=line></span><br><span class=line>			<span class=meta>@Override</span></span><br><span class=line>			<span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>handleOnStartException</span><span class=params>(Throwable ex)</span> </span>&#123;</span><br><span class=line>				System.out.println(<span class=string>"handleOnStartException"</span>);</span><br><span class=line>			&#125;</span><br><span class=line></span><br><span class=line>			<span class=meta>@Override</span></span><br><span class=line>			<span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>handleOnShutdownException</span><span class=params>(Throwable ex)</span> </span>&#123;</span><br><span class=line>				System.out.println(<span class=string>"handleOnShutdownException"</span>);</span><br><span class=line>			&#125;</span><br><span class=line>		&#125;);</span><br></pre></table></figure><h1 id=从RingBuffer中移除对象><a href=#从RingBuffer中移除对象 class=headerlink title=从RingBuffer中移除对象></a>从RingBuffer中移除对象</h1><blockquote><p>来自官方翻译: 当通过Disruptor传递数据时, 对象可能比预期寿命更长. 为避免发生这种情况, 可能需要在处理事件后清除事件. 如果你有一个单一的事件处理程序清除在同一个处理程序中的值是足够的. 如果你有一连串的事件处理程序, 那么你可能需要一个特定的处理程序放置在链的末尾来处理对象.</blockquote><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>ObjectEvent</span>&lt;<span class=title>T</span>&gt;</span></span><br><span class=line><span class=class></span>&#123;</span><br><span class=line>    T val;</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>clear</span><span class=params>()</span></span></span><br><span class=line><span class=function>    </span>&#123;</span><br><span class=line>        val = <span class=keyword>null</span>;</span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>ClearingEventHandler</span>&lt;<span class=title>T</span>&gt; <span class=keyword>implements</span> <span class=title>EventHandler</span>&lt;<span class=title>ObjectEvent</span>&lt;<span class=title>T</span>&gt;&gt;</span></span><br><span class=line><span class=class></span>&#123;</span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>onEvent</span><span class=params>(ObjectEvent&lt;T&gt; event, <span class=keyword>long</span> sequence, <span class=keyword>boolean</span> endOfBatch)</span></span></span><br><span class=line><span class=function>    </span>&#123;</span><br><span class=line>        <span class=comment>// Failing to call clear here will result in the </span></span><br><span class=line>        <span class=comment>// object associated with the event to live until</span></span><br><span class=line>        <span class=comment>// it is overwritten once the ring buffer has wrapped</span></span><br><span class=line>        <span class=comment>// around to the beginning.</span></span><br><span class=line>        event.clear(); </span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span></span></span><br><span class=line><span class=function></span>&#123;</span><br><span class=line>    Disruptor&lt;ObjectEvent&lt;String&gt;&gt; disruptor = <span class=keyword>new</span> Disruptor&lt;&gt;(</span><br><span class=line>        () -&gt; ObjectEvent&lt;String&gt;(), bufferSize, executor);</span><br><span class=line></span><br><span class=line>    disruptor</span><br><span class=line>        .handleEventsWith(<span class=keyword>new</span> ProcessingEventHandler())</span><br><span class=line>        .then(<span class=keyword>new</span> ClearingObjectHandler());</span><br><span class=line>&#125;</span><br></pre></table></figure><h1 id=消费者分片><a href=#消费者分片 class=headerlink title=消费者分片></a>消费者分片</h1><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>final</span> <span class=class><span class=keyword>class</span> <span class=title>MyHandler</span> <span class=keyword>implements</span> <span class=title>EventHandler</span>&lt;<span class=title>ValueEvent</span>&gt;</span></span><br><span class=line><span class=class></span>&#123;</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> <span class=keyword>long</span> ordinal;</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> <span class=keyword>long</span> numberOfConsumers;</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=title>MyHandler</span><span class=params>(<span class=keyword>final</span> <span class=keyword>long</span> ordinal, <span class=keyword>final</span> <span class=keyword>long</span> numberOfConsumers)</span></span></span><br><span class=line><span class=function>    </span>&#123;</span><br><span class=line>        <span class=keyword>this</span>.ordinal = ordinal;</span><br><span class=line>        <span class=keyword>this</span>.numberOfConsumers = numberOfConsumers;</span><br><span class=line>    &#125;</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>onEvent</span><span class=params>(<span class=keyword>final</span> ValueEvent entry, <span class=keyword>final</span> <span class=keyword>long</span> sequence, <span class=keyword>final</span> <span class=keyword>boolean</span> onEndOfBatch)</span></span></span><br><span class=line><span class=function>    </span>&#123;</span><br><span class=line>        <span class=keyword>if</span> ((sequence % numberOfConsumers) == ordinal)</span><br><span class=line>        &#123;</span><br><span class=line>            <span class=comment>// Process the event</span></span><br><span class=line>        &#125;</span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br></pre></table></figure><p>使用<code>disruptor.handleEventsWithWorkerPool(...)</code>也可以实现这种类似消费者组的功能.<p>或者更简单地实现<code>WorkHandler</code>也可以:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>DisruptorInnerShardingHandler</span>&lt;<span class=title>S</span>&gt; <span class=keyword>implements</span> <span class=title>WorkHandler</span>&lt;<span class=title>DisruptorEvent</span>&lt;<span class=title>S</span>&gt;&gt; </span>&#123;</span><br><span class=line></span><br><span class=line>	<span class=keyword>private</span> Map&lt;Class, DisruptorEventSourceHandler&lt;S&gt;&gt; handlerMap;</span><br><span class=line></span><br><span class=line>	<span class=function><span class=keyword>public</span> <span class=title>DisruptorInnerShardingHandler</span><span class=params>(Map&lt;Class, DisruptorEventSourceHandler&lt;S&gt;&gt; handlerMap)</span> </span>&#123;</span><br><span class=line>		<span class=keyword>this</span>.handlerMap = handlerMap;</span><br><span class=line>	&#125;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>onEvent</span><span class=params>(DisruptorEvent&lt;S&gt; event)</span> <span class=keyword>throws</span> Exception </span>&#123;</span><br><span class=line>		<span class=keyword>try</span> &#123;</span><br><span class=line>			Class sourceClass = event.getSourceClass();</span><br><span class=line>			DisruptorEventSourceHandler&lt;S&gt; sourceHandler = handlerMap.get(sourceClass);</span><br><span class=line>			notNull(sourceHandler, <span class=string>"Source handler not found: "</span> + sourceClass);</span><br><span class=line>			sourceHandler.handlerSource(event.getSource());</span><br><span class=line>		&#125; <span class=keyword>finally</span> &#123;</span><br><span class=line>			event.clean();</span><br><span class=line>		&#125;</span><br><span class=line>	&#125;</span><br><span class=line>&#125;</span><br></pre></table></figure><h1 id=避免伪缓存><a href=#避免伪缓存 class=headerlink title=避免伪缓存></a>避免伪缓存</h1><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>FalseSharing</span> </span>&#123;</span><br><span class=line></span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> <span class=keyword>throws</span> Exception </span>&#123;</span><br><span class=line>        testPointer();</span><br><span class=line>    &#125;</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>private</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>testPointer</span><span class=params>()</span> <span class=keyword>throws</span> Exception </span>&#123;</span><br><span class=line>        Pointer pointer = <span class=keyword>new</span> Pointer();</span><br><span class=line>        <span class=keyword>long</span> start = System.currentTimeMillis();</span><br><span class=line>        Thread t1 = <span class=keyword>new</span> Thread(() -&gt; &#123;</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i &lt; <span class=number>100000000</span>; i++) &#123;</span><br><span class=line>                pointer.x++;</span><br><span class=line>            &#125;</span><br><span class=line>        &#125;);</span><br><span class=line></span><br><span class=line>        Thread t2 = <span class=keyword>new</span> Thread(() -&gt; &#123;</span><br><span class=line>            <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i &lt; <span class=number>100000000</span>; i++) &#123;</span><br><span class=line>                pointer.y++;</span><br><span class=line>            &#125;</span><br><span class=line>        &#125;);</span><br><span class=line></span><br><span class=line>        t1.start();</span><br><span class=line>        t2.start();</span><br><span class=line>        t1.join();</span><br><span class=line>        t2.join();</span><br><span class=line>        System.out.println(System.currentTimeMillis() - start);</span><br><span class=line>        System.out.println(pointer);</span><br><span class=line>    &#125;</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=class><span class=keyword>class</span> <span class=title>Pointer</span> </span>&#123;</span><br><span class=line>        <span class=keyword>volatile</span> <span class=keyword>long</span> x;</span><br><span class=line>        </span><br><span class=line>        <span class=keyword>volatile</span> <span class=keyword>long</span> y;</span><br><span class=line>    &#125;</span><br><span class=line></span><br><span class=line>&#125;</span><br></pre></table></figure><p>上述代码中x跟y会加载到同一个缓存行, 运行时间为 <strong>3581ms</strong>.<p>下面通过填充内存解决伪缓存:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>private</span> <span class=keyword>static</span> <span class=class><span class=keyword>class</span> <span class=title>Pointer</span> </span>&#123;</span><br><span class=line>    <span class=keyword>volatile</span> <span class=keyword>long</span> x;</span><br><span class=line>    <span class=keyword>long</span> p1, p2, p3, p4, p5;</span><br><span class=line>    <span class=keyword>volatile</span> <span class=keyword>long</span> y;</span><br><span class=line>&#125;</span><br></pre></table></figure><p>因为缓存行为64个字节, 可以填充5个long类型的字段(Java对象头16个字节), 运行时间为 <strong>586ms</strong>.<p>或者使用Java8提供的 <a href="mailto:`@sun.misc.Contended" rel="external nofollow noopener noreferrer" target=_blank>`@sun.misc.Contended</a>` 注解:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>private</span> <span class=keyword>static</span> <span class=class><span class=keyword>class</span> <span class=title>Pointer</span> </span>&#123;</span><br><span class=line>    MyLong x = <span class=keyword>new</span> MyLong();</span><br><span class=line>    MyLong y = <span class=keyword>new</span> MyLong();</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=meta>@Contended</span></span><br><span class=line><span class=keyword>private</span> <span class=keyword>static</span> <span class=class><span class=keyword>class</span> <span class=title>MyLong</span> </span>&#123;</span><br><span class=line>    <span class=keyword>volatile</span> <span class=keyword>long</span> value;</span><br><span class=line>&#125;</span><br></pre></table></figure><p><strong>注意: 需要在启动参数中加上 <code>-XX:-RestrictContended</code> 才能生效.</strong><h1 id=总结><a href=#总结 class=headerlink title=总结></a>总结</h1><blockquote><p>代码: <a href=https://github.com/masteranthoneyd/spring-boot-learning/tree/master/spring-boot-disruptor rel="external nofollow noopener noreferrer" target=_blank>https://github.com/masteranthoneyd/spring-boot-learning/tree/master/spring-boot-disruptor</a><p>来自某大神的点评:<br>“当对性能的追求达到这样的程度, 以致对现代硬件构成的理解变得越来越重要. ”这句话恰当地形容了Disruptor/LMAX在对性能方面的追求和失败. 咦, 失败？为什么会这么说呢？Disruptor当然是一个优秀的框架, 我说的失败指的是在开发它的过程中, LMAX曽试图提高并发程序效率, 优化、使用锁或借助其他模型, 但是这些尝试最终失败了——然后他们构建了Disruptor. 再提问: 一个Java程序员在尝试提高他的程序性能的时候, 需要了解很多硬件知识吗？我想很多人都会回答“不需要”, 构建Disruptor的过程中, 最初开发人员对这个问题的回答可能也是“不需要”, 但是尝试失败后他们决定另辟蹊径. 总的看下Disruptor的设计: 锁到CAS、缓冲行填充、避免GC等, 我感觉这些设计都在刻意“迁就”或者“依赖”硬件设计, 这些设计更像是一种“(ugly)hack”（毫无疑问, Disruptor还是目前最优秀的方案之一）.</blockquote><p>Disruptor可以说是工程级别的项目, 通过各种高级的优化达到了性能的极致:<ul><li>可选锁无关<code>lock-free</code>, 没有竞争所以非常快<li>所有访问者都记录自己的序号的实现方式, 允许多个生产者与多个消费者共享相同的数据结构<li>在每个对象中都能跟踪序列号, 没有为伪共享和非预期的竞争<li>增加缓存行补齐, 提升<code>cache</code>缓存命中率<li>环形数组中的元素不会被删除</ul></div><div style=text-align:center;color:#ccc;font-size:14px>---------------- The End ----------------</div><div><div id=wechat_subscriber style="display:block;padding:10px 0;margin:20px auto;width:100%;text-align:center"><img id=wechat_subscriber_qcode src=/images/wechat/gongzhonghao.jpg alt="ookamiAntD wechat" style=width:200px;max-width:100%><div>欢迎您扫一扫上面的微信公众号，订阅我的博客！</div></div></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>谢谢大爷～</div><button id=rewardButton disable=enable onclick="var qr=document.getElementById('QR');if(qr.style.display==='none'){qr.style.display='block';}else{qr.style.display='none'}">
<span>赏</span></button><div id=QR style=display:none><div id=wechat style=display:inline-block><img id=wechat_qr src=/images/donate/wechat.png alt="ookamiAntD WeChat Pay"><p>微信打赏</div><div id=alipay style=display:inline-block><img id=alipay_qr src=/images/donate/alipay.jpg alt="ookamiAntD Alipay"><p>支付宝打赏</div></div></div></div><div><p id=div-border-left-red>Author：<b>ookamiAntD Yang</b><br>Link：<a href=/2018/disruptor-learning/ title="极致的追求, 高性能并发框架 Disruptor">http://yangbingdong.com/2018/disruptor-learning/</a><br>Contact：<a>yangbingdong1994@gmail.com</a><br><b>本文基于<a target=_blank title="Creative Commons Attribution-ShareAlike 4.0 International (CC BY-SA 4.0)" href=http://creativecommons.org/licenses/by-sa/4.0/ rel="external nofollow noopener noreferrer"> 知识共享署名-相同方式共享 4.0 </a>国际许可协议发布</b><br><b>转载请注明出处，谢谢！</b></div><footer class=post-footer><div class=post-tags><a href=/tags/Java/ rel=tag><i class="fa fa-tag"></i>Java</a>
<a href=/tags/Disruptor/ rel=tag><i class="fa fa-tag"></i>Disruptor</a></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/2018/micro-service-ddd-notice/ rel=next title=关于微服务的一些调研零散笔记><i class="fa fa-chevron-left"></i>关于微服务的一些调研零散笔记</a></div><span class=post-nav-divider></span><div class="post-nav-prev post-nav-item"><a href=/2018/mysql-related-learning/ rel=prev title="MySQL 杂谈">MySQL 杂谈 <i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class=post-spread><div class=-hoofoo-share-title>分享到：</div><div class=-hoofoo-share-buttons><div class="-mob-share-weibo -hoofoo-share-weibo -hoofoo-share-ui-button"><i class="fa fa-weibo" aria-hidden=true></i></div><div class="-mob-share-weixin -hoofoo-share-weixin -hoofoo-share-ui-button"><i class="fa fa-weixin" aria-hidden=true></i></div><div class="-mob-share-qq -hoofoo-share-qq -hoofoo-share-ui-button"><i class="fa fa-qq" aria-hidden=true></i></div><div class="-mob-share-twitter -hoofoo-share-twitter -hoofoo-share-ui-button"><i class="fa fa-twitter" aria-hidden=true></i></div><div class="-hoofoo-share-more -hoofoo-share-ui-button -mob-share-open"><i class="fa fa-ellipsis-h" aria-hidden=true></i></div></div><div class=-mob-share-ui style=display:none><ul class=-mob-share-list><li class=-mob-share-weibo><p>新浪微博<li class=-mob-share-weixin><p>微信<li class=-mob-share-qzone><p>QQ空间<li class=-mob-share-qq><p>QQ好友<li class=-mob-share-tencentweibo><p>腾讯微博<li class=-mob-share-renren><p>人人网<li class=-mob-share-kaixin><p>开心网<li class=-mob-share-douban><p>豆瓣<li class=-mob-share-youdao><p>有道云笔记<li class=-mob-share-mingdao><p>明道<li class=-mob-share-pengyou><p>朋友网<li class=-mob-share-facebook><p>Facebook<li class=-mob-share-twitter><p>Twitter<li class=-mob-share-pocket><p>Pocket<li class=-mob-share-google><p>Google+<li class=-mob-share-tumblr><p>Tumblr<li class=-mob-share-instapaper><p>Instapaper<li class=-mob-share-linkedin><p>Linkedin</ul><div class=-mob-share-close>取消</div></div><div class=-mob-share-ui-bg></div><script id=-mob-share src="https://f1.webshare.mob.com/code/mob-share.js?appkey=21aa3b13ad233"></script></div></div></div><div class=comments id=comments><div style=text-align:center></div><div id=disqus_proxy_thread></div><div id=disqus_thread></div><script>window.disqusProxy={username:'ookamiantd',server:'disqus-proxy.yangbingdong.com',port:'',defaultAvatar:'/images/avatar/avatar-default.jpg',adminAvatar:'/images/avatar/avatar-admin.jpg',identifier:'2018/disruptor-learning/'};window.disqus_config=function(){this.page.url='http://yangbingdong.com/2018/disruptor-learning/';this.page.identifier='2018/disruptor-learning/';};window.onload=function(){var s=document.createElement('script');s.src="/static/js/main.0d0338ae.js";s.async=true;document.body.appendChild(s);}</script><link rel=stylesheet href=/static/css/main.0603c539.css></div></div><div class=sidebar-toggle><div class=sidebar-toggle-line-wrap><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id=sidebar class=sidebar><div class=sidebar-inner><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target=post-toc-wrap>Table of Contents<li class=sidebar-nav-overview data-target=site-overview>Overview</ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image src=/images/avatar/avatar-admin.jpg alt=ookamiAntD><p class=site-author-name itemprop=name>ookamiAntD<p class="site-description motion-element" itemprop=description>码渣 | rocker | 二次元 | 美剧 | 宅</div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href=/archives><span class=site-state-item-count>50</span>
<span class=site-state-item-name>posts</span></a></div><div class="site-state-item site-state-categories"><a href=/categories><span class=site-state-item-count>19</span>
<span class=site-state-item-name>categories</span></a></div><div class="site-state-item site-state-tags"><a href=/tags><span class=site-state-item-count>48</span>
<span class=site-state-item-name>tags</span></a></div></nav><div class="feed-link motion-element"><a href=/atom.xml rel=alternate><i class="fa fa-rss"></i>RSS</a></div><div class="links-of-author motion-element"><span class=links-of-author-item><a href=https://github.com/masteranthoneyd target=_blank rel="external nofollow noopener noreferrer" title=GitHub><i class="fa fa-fw fa-github"></i>GitHub</a></span>
<span class=links-of-author-item><a href="https://www.facebook.com/profile.php?id=100014869064462" target=_blank rel="external nofollow noopener noreferrer" title=Facebook><i class="fa fa-fw fa-facebook"></i>Facebook</a></span>
<span class=links-of-author-item><a href=https://twitter.com/ookamiAntD target=_blank rel="external nofollow noopener noreferrer" title=Twitter><i class="fa fa-fw fa-twitter"></i>Twitter</a></span></div><div class="cc-license motion-element" itemprop=license><a href=https://creativecommons.org/licenses/by-sa/4.0/ class=cc-opacity target=_blank rel="external nofollow noopener noreferrer"><img src=/images/cc-by-sa.svg alt="Creative Commons"></a></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class=links-of-blogroll-title><i class="fa  fa-fw fa-globe"></i>大神们的博客</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://mercyblitz.github.io/ title=mercyblitz(Java劝退师) target=_blank rel="external nofollow noopener noreferrer">mercyblitz(Java劝退师)</a><li class=links-of-blogroll-item><a href=https://muyinchen.github.io/ title=知秋大神(真·大神) target=_blank rel="external nofollow noopener noreferrer">知秋大神(真·大神)</a><li class=links-of-blogroll-item><a href=http://crossoverjie.top/ title="crossoverJie's Blog" target=_blank rel="external nofollow noopener noreferrer">crossoverJie's Blog</a><li class=links-of-blogroll-item><a href=http://yemengying.com/ title="Giraffe's Home" target=_blank rel="external nofollow noopener noreferrer">Giraffe's Home</a></ul></div><div id=days></div><script>function show_date_time(){window.setTimeout("show_date_time()",1000);BirthDay=new Date("01/10/2017 12:34:56");today=new Date();timeold=(today.getTime()-BirthDay.getTime());sectimeold=timeold/1000
secondsold=Math.floor(sectimeold);msPerDay=24*60*60*1000
e_daysold=timeold/msPerDay
daysold=Math.floor(e_daysold);e_hrsold=(e_daysold-daysold)*24;hrsold=setzero(Math.floor(e_hrsold));e_minsold=(e_hrsold-hrsold)*60;minsold=setzero(Math.floor((e_hrsold-hrsold)*60));seconds=setzero(Math.floor((e_minsold-minsold)*60));document.getElementById('days').innerHTML="已运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒";}
function setzero(i){if(i<10)
{i="0"+i};return i;}
show_date_time();</script></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class=post-toc><div class=post-toc-content><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#Preface><span class=nav-number>1.</span> <span class=nav-text>Preface</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#核心概念><span class=nav-number>2.</span> <span class=nav-text>核心概念</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#Java内置队列><span class=nav-number>3.</span> <span class=nav-text>Java内置队列</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#ArrayBlockingQueue的问题><span class=nav-number>4.</span> <span class=nav-text>ArrayBlockingQueue的问题</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#加锁><span class=nav-number>4.1.</span> <span class=nav-text>加锁</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#关于锁和CAS><span class=nav-number>4.1.1.</span> <span class=nav-text>关于锁和CAS</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#锁><span class=nav-number>4.1.1.1.</span> <span class=nav-text>锁</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#原子变量><span class=nav-number>4.1.1.2.</span> <span class=nav-text>原子变量</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#伪共享><span class=nav-number>4.2.</span> <span class=nav-text>伪共享</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#什么是共享><span class=nav-number>4.2.1.</span> <span class=nav-text>什么是共享</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#缓存行><span class=nav-number>4.2.2.</span> <span class=nav-text>缓存行</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#什么是伪共享><span class=nav-number>4.2.3.</span> <span class=nav-text>什么是伪共享</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#Disruptor的设计方案><span class=nav-number>5.</span> <span class=nav-text>Disruptor的设计方案</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#一个生产者><span class=nav-number>5.1.</span> <span class=nav-text>一个生产者</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#写数据><span class=nav-number>5.1.1.</span> <span class=nav-text>写数据</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#多个生产者><span class=nav-number>5.2.</span> <span class=nav-text>多个生产者</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#读数据><span class=nav-number>5.2.1.</span> <span class=nav-text>读数据</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#写数据-1><span class=nav-number>5.2.2.</span> <span class=nav-text>写数据</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#等待策略><span class=nav-number>6.</span> <span class=nav-text>等待策略</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#生产者的等待策略><span class=nav-number>6.1.</span> <span class=nav-text>生产者的等待策略</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#消费者的等待策略><span class=nav-number>6.2.</span> <span class=nav-text>消费者的等待策略</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#核心对象><span class=nav-number>7.</span> <span class=nav-text>核心对象</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#用例><span class=nav-number>8.</span> <span class=nav-text>用例</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#基础事件生产与消费><span class=nav-number>8.1.</span> <span class=nav-text>基础事件生产与消费</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#自定义事件><span class=nav-number>8.2.</span> <span class=nav-text>自定义事件</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#定义事件工厂><span class=nav-number>8.3.</span> <span class=nav-text>定义事件工厂</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#定义消费者><span class=nav-number>8.4.</span> <span class=nav-text>定义消费者</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#定义生产者><span class=nav-number>8.5.</span> <span class=nav-text>定义生产者</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-0版本之前><span class=nav-number>8.5.1.</span> <span class=nav-text>3.0版本之前</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-0版本之后使用Translators><span class=nav-number>8.5.2.</span> <span class=nav-text>3.0版本之后使用Translators</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#测试实例><span class=nav-number>8.6.</span> <span class=nav-text>测试实例</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#单生产者-单消费者><span class=nav-number>8.6.1.</span> <span class=nav-text>单生产者, 单消费者</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#多生产者-单消费者><span class=nav-number>8.6.2.</span> <span class=nav-text>多生产者, 单消费者</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#一个及以上生产者-多个消费者><span class=nav-number>8.6.3.</span> <span class=nav-text>一个及以上生产者, 多个消费者</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#异常处理><span class=nav-number>8.7.</span> <span class=nav-text>异常处理</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#从RingBuffer中移除对象><span class=nav-number>9.</span> <span class=nav-text>从RingBuffer中移除对象</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#消费者分片><span class=nav-number>10.</span> <span class=nav-text>消费者分片</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#避免伪缓存><span class=nav-number>11.</span> <span class=nav-text>避免伪缓存</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#总结><span class=nav-number>12.</span> <span class=nav-text>总结</span></a></ol></div></div></section></div></aside></div></main><footer id=footer class=footer><div class=footer-inner><div class=busuanzi-count><script async src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span class=site-uv><i class="fa fa-user">本站访客数</i><span class=busuanzi-value id=busuanzi_value_site_uv></span>人次</span>
<span class=site-pv><i class="fa fa-eye">本站总访问量</i><span class=busuanzi-value id=busuanzi_value_site_pv></span>次</span></div><div class=copyright>&copy; 2016 -
<span itemprop=copyrightYear>2020</span>
<span class=with-love><i class="fa fa-flash"></i></span><span class=author itemprop=copyrightHolder>Hosted by <a href=https://pages.coding.me style=font-weight:700 rel="external nofollow noopener noreferrer" target=_blank>Coding Pages</a></span> | <span class=post-count>共290.0k字</span></div><div class=theme-info><a target=_blank href=http://www.miibeian.gov.cn/ rel=nofollow style=color:#555>粤ICP备18135202号-1</a></div><div style="width:300px;margin:0 auto"><a target=_blank href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44010602005896" style=display:inline-block;text-decoration:none;height:20px;line-height:20px><img src=https://cdn.yangbingdong.com/img/beian/beian.png style=float:left><p style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#555">粤公网安备 44010602005896号</p></a></div></div></footer><div class=back-to-top><i class="fa fa-arrow-up"></i></div></div><script>if(Object.prototype.toString.call(window.Promise)!=='[object Function]'){window.Promise=null;}</script><script src="/lib/jquery/index.js?v=2.1.3"></script><script src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script src="/js/src/utils.js?v=5.1.0"></script><script src="/js/src/motion.js?v=5.1.0"></script><script src="/js/src/scrollspy.js?v=5.1.0"></script><script src="/js/src/post-details.js?v=5.1.0"></script><script src="/js/src/bootstrap.js?v=5.1.0"></script><script>var disqus_shortname='ookamiantd';var disqus_identifier='2018/disruptor-learning/';var disqus_title="极致的追求, 高性能并发框架 Disruptor";function run_disqus_script(disqus_script){var dsq=document.createElement('script');dsq.type='text/javascript';dsq.async=true;dsq.src='//'+disqus_shortname+'.disqus.com/'+disqus_script;(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(dsq);}
var disqus={load:function disqus(){if(typeof DISQUS!=='object'){(function(){var s=document.createElement('script');s.async=true;s.type='text/javascript';s.src='//'+disqus_shortname+'.disqus.com/embed.js';(document.getElementsByTagName('HEAD')[0]||document.getElementsByTagName('BODY')[0]).appendChild(s);}());$('#load-disqus').html("评论加载中，请确保你有梯子，若评论长时间未加载则你可能翻墙失败...").fadeOut(9000);}}}</script><script>var isfetched=false;var search_path="search.xml";if(search_path.length==0){search_path="search.xml";}
var path="/"+search_path;function proceedsearch(){$("body").append('<div class="popoverlay">').css('overflow','hidden');$('.popup').toggle();}
var searchFunc=function(path,search_id,content_id){'use strict';$.ajax({url:path,dataType:"xml",async:true,success:function(xmlResponse){isfetched=true;$('.popup').detach().appendTo('.header-inner');var datas=$("entry",xmlResponse).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()};}).get();var $input=document.getElementById(search_id);var $resultContent=document.getElementById(content_id);$input.addEventListener('input',function(){var matchcounts=0;var str='<ul class=\"search-result-list\">';var keywords=this.value.trim().toLowerCase().split(/[\s\-]+/);$resultContent.innerHTML="";if(this.value.trim().length>1){datas.forEach(function(data){var isMatch=false;var content_index=[];var data_title=data.title.trim().toLowerCase();var data_content=data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();var data_url=decodeURIComponent(data.url);var index_title=-1;var index_content=-1;var first_occur=-1;if(data_title!=''){keywords.forEach(function(keyword,i){index_title=data_title.indexOf(keyword);index_content=data_content.indexOf(keyword);if(index_title>=0||index_content>=0){isMatch=true;if(i==0){first_occur=index_content;}}});}
if(isMatch){matchcounts+=1;str+="<li><a href='"+data_url+"' class='search-result-title'>"+data_title+"</a>";var content=data.content.trim().replace(/<[^>]+>/g,"");if(first_occur>=0){var start=first_occur-20;var end=first_occur+80;if(start<0){start=0;}
if(start==0){end=50;}
if(end>content.length){end=content.length;}
var match_content=content.substring(start,end);keywords.forEach(function(keyword){var regS=new RegExp(keyword,"gi");match_content=match_content.replace(regS,"<b class=\"search-keyword\">"+keyword+"</b>");});str+="<p class=\"search-result\">"+match_content+"...</p>"}
str+="</li>";}})};str+="</ul>";if(matchcounts==0){str='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'}
if(keywords==""){str='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'}
$resultContent.innerHTML=str;});proceedsearch();}});}
$('.popup-trigger').click(function(e){e.stopPropagation();if(isfetched==false){searchFunc(path,'local-search-input','local-search-result');}else{proceedsearch();};});$('.popup-btn-close').click(function(e){$('.popup').hide();$(".popoverlay").remove();$('body').css('overflow','');});$('.popup').click(function(e){e.stopPropagation();});</script><script src=https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js></script><script>AV.initialize("usE0s6JGUeOiMcsVoRuHuv2B-gzGzoHsz","ewm6NEF07r83HbnOr63ptuKH");</script><script>function showTime(Counter){var query=new AV.Query(Counter);var entries=[];var $visitors=$(".leancloud_visitors");$visitors.each(function(){entries.push($(this).attr("id").trim());});query.containedIn('url',entries);query.find().done(function(results){var COUNT_CONTAINER_REF='.leancloud-visitors-count';if(results.length===0){$visitors.find(COUNT_CONTAINER_REF).text(0);return;}
for(var i=0;i<results.length;i++){var item=results[i];var url=item.get('url');var time=item.get('time');var element=document.getElementById(url);$(element).find(COUNT_CONTAINER_REF).text(time);}
for(var i=0;i<entries.length;i++){var url=entries[i];var element=document.getElementById(url);var countSpan=$(element).find(COUNT_CONTAINER_REF);if(countSpan.text()==''){countSpan.text(0);}}}).fail(function(object,error){console.log("Error: "+error.code+" "+error.message);});}
function addCount(Counter){var $visitors=$(".leancloud_visitors");var url=$visitors.attr('id').trim();var title=$visitors.attr('data-flag-title').trim();var query=new AV.Query(Counter);query.equalTo("url",url);query.find({success:function(results){if(results.length>0){var counter=results[0];counter.fetchWhenSave(true);counter.increment("time");counter.save(null,{success:function(counter){var $element=$(document.getElementById(url));$element.find('.leancloud-visitors-count').text(counter.get('time'));},error:function(counter,error){console.log('Failed to save Visitor num, with error message: '+error.message);}});}else{var newcounter=new Counter();var acl=new AV.ACL();acl.setPublicReadAccess(true);acl.setPublicWriteAccess(true);newcounter.setACL(acl);newcounter.set("title",title);newcounter.set("url",url);newcounter.set("time",1);newcounter.save(null,{success:function(newcounter){var $element=$(document.getElementById(url));$element.find('.leancloud-visitors-count').text(newcounter.get('time'));},error:function(newcounter,error){console.log('Failed to create');}});}},error:function(error){console.log('Error:'+error.code+" "+error.message);}});}
$(function(){var Counter=AV.Object.extend("Counter");if($('.leancloud_visitors').length==1){addCount(Counter);}else if($('.post-title-link').length>1){showTime(Counter);}});</script><script>(function(){var bp=document.createElement('script');var curProtocol=window.location.protocol.split(':')[0];if(curProtocol==='https'){bp.src='https://zz.bdstatic.com/linksubmit/push.js';}
else{bp.src='http://push.zhanzhang.baidu.com/push.js';}
var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script><script color=255,0,204 opacity=0.5 zindex=-2 count=40 src=//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js></script><script>$('body').delegate('.-mob-share-weixin-qrcode-bg','click',function(){$(".-mob-share-weixin-qrcode-close").trigger("click");});</script><canvas class=fireworks style=position:fixed;left:0;top:0;z-index:1;pointer-events:none></canvas>
<script src=//cdn.bootcss.com/animejs/2.2.0/anime.min.js></script><script src=/js/src/fireworks.js></script><script src=/js/src/dytitle.js></script></div></footer></div><script src=/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"superSample":2,"width":88,"height":88,"position":"left"},"mobile":{"show":false},"react":{"opacityDefault":0.9,"opacityOnHover":0.5},"log":false});</script>