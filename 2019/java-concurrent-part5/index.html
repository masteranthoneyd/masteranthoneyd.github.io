<!doctype html><html class="theme-next muse use-motion" lang=en><meta name=generator content="Hexo 3.9.0"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content=no-transform><meta http-equiv=cache-control content=no-siteapp><meta http-equiv=content-language content=zh-cn><script src=//cdn.bootcss.com/pace/1.0.2/pace.min.js></script><link href=//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css rel=stylesheet><style>.pace .pace-progress{background:#ff009e;height:2px}.pace .pace-progress-inner{box-shadow:0 0 10px #e6006b,0 0 5px #ff009e}.pace .pace-activity{border-top-color:#ff009e;border-left-color:#ff009e}</style><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel=stylesheet><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel=stylesheet><link href="/css/main.css?v=5.1.0" rel=stylesheet><meta name=keywords content=Java,Concurrent,><link rel=alternate href=/atom.xml title="ookamiAntD's Blog" type=application/atom+xml><link rel="shortcut icon" type=image/x-icon href="/favicon.png?v=5.1.0"><meta name=description content="Preface 并发领域中也有诸多的设计模式."><meta name=keywords content=Java,Concurrent><meta property=og:type content=article><meta property=og:title content=并发设计模式><meta property=og:url content=http://yangbingdong.com/2019/java-concurrent-part5/index.html><meta property=og:site_name content="ookamiAntD's Blog"><meta property=og:description content="Preface 并发领域中也有诸多的设计模式."><meta property=og:locale content=en><meta property=og:image content=https://cdn.yangbingdong.com/img/concurrent/java-concurrent-part5-banner.jpg><meta property=og:image content=https://cdn.yangbingdong.com/img/concurrent/java-concurrent-part5-long-cache.png><meta property=og:image content=https://cdn.yangbingdong.com/img/concurrent/java-concurrent-threadlocal.png><meta property=og:image content=https://cdn.yangbingdong.com/img/concurrent/java-concurrent-guarded-suspension.png><meta property=og:image content=https://cdn.yangbingdong.com/img/concurrent/java-concurrent-guarded-suspension-struct.png><meta property=og:image content=https://cdn.yangbingdong.com/img/concurrent/java-concurrent-two-phase-terminal.png><meta property=og:image content=https://cdn.yangbingdong.com/img/concurrent/java-concurrent-two-phase-terminal2.png><meta property=og:updated_time content=2020-04-07T10:15:47.010Z><meta name=twitter:card content=summary><meta name=twitter:title content=并发设计模式><meta name=twitter:description content="Preface 并发领域中也有诸多的设计模式."><meta name=twitter:image content=https://cdn.yangbingdong.com/img/concurrent/java-concurrent-part5-banner.jpg><script id=hexo.configurations>var NexT=window.NexT||{};var CONFIG={root:'/',scheme:'Muse',sidebar:{"position":"right","display":"always"},fancybox:true,motion:true,duoshuo:{userId:'undefined',author:'Author'},algolia:{applicationID:'RI3NF6GUI0',apiKey:'3d33fa60ba30d3b17f37220bb1a36749',indexName:'blogIndex',hits:{"per_page":10},labels:{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}}};</script><link rel=canonical href=http://yangbingdong.com/2019/java-concurrent-part5/><script>(function(){if(''){if(prompt('请输入文章密码')!==''){alert('密码错误！');history.back();}}})();</script><title>并发设计模式 | ookamiAntD's Blog</title><body itemscope itemtype=http://schema.org/WebPage lang=en><script>var _hmt=_hmt||[];(function(){var hm=document.createElement("script");hm.src="https://hm.baidu.com/hm.js?e9505ac4e11d464329d615553a72b526";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script><div class="container one-collumn sidebar-position-right page-post-detail"><div class=headband></div><a href=https://github.com/masteranthoneyd/blog rel="external nofollow noopener noreferrer" target=_blank><img style=position:absolute;top:0;left:0;border:0 src=https://camo.githubusercontent.com/82b228a3648bf44fc1163ef44c62fcc60081495e/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f7265645f6161303030302e706e67 alt="Fork me on GitHub" data-canonical-src=https://s3.amazonaws.com/github/ribbons/forkme_left_red_aa0000.png></a><header id=header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-meta><div class=custom-logo-site-title><a href=/ class=brand rel=start><span class=logo-line-before><i></i></span><span class=site-title>ookamiAntD's Blog</span>
<span class=logo-line-after><i></i></span></a></div><h1 class=site-subtitle itemprop=description>Easy coding,easy life.</h1></div><div class=site-nav-toggle><button>
<span class=btn-bar></span><span class=btn-bar></span><span class=btn-bar></span></button></div><nav class=site-nav><ul id=menu class=menu><li class="menu-item menu-item-home"><a href=/ rel=section><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a><li class="menu-item menu-item-archives"><a href=/archives rel=section><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a><li class="menu-item menu-item-categories"><a href=/categories rel=section><i class="menu-item-icon fa fa-fw fa-th"></i><br>Categories</a><li class="menu-item menu-item-tags"><a href=/tags rel=section><i class="menu-item-icon fa fa-fw fa-tags"></i><br>Tags</a><li class="menu-item menu-item-about"><a href=/about rel=section><i class="menu-item-icon fa fa-fw fa-user"></i><br>About</a><li class="menu-item menu-item-guestbook"><a href=/guestbook rel=section><i class="menu-item-icon fa fa-fw fa-commenting"></i><br>Message</a><li class="menu-item menu-item-search"><a href=javascript:; class=popup-trigger><i class="menu-item-icon fa fa-search fa-fw"></i><br>Search</a></ul><div class=site-search><div class=popup><span class="search-icon fa fa-search"></span><input id=local-search-input><div id=local-search-result></div><span class=popup-btn-close>close</span></div></div></nav></div></header><main id=main class=main><div class=main-inner><div class=content-wrap><div id=content class=content><div id=posts class=posts-expand><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><link itemprop=mainEntityOfPage href=http://yangbingdong.com/2019/java-concurrent-part5/><span style=display:none itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=name content=ookamiAntD><meta itemprop=description content><meta itemprop=image content=/images/avatar/avatar-admin.jpg></span><span style=display:none itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="ookamiAntD's Blog"><span style=display:none itemprop=logo itemscope itemtype=http://schema.org/ImageObject><img style=display:none itemprop="url image" alt="ookamiAntD's Blog" src></span></span><header class=post-header><h2 class=post-title itemprop="name headline">并发设计模式</h2><div class=post-meta><span class=post-time><span class=post-meta-item-icon><i class="fa fa-calendar-o"></i></span><span class=post-meta-item-text>Posted on</span>
<time title="Post created" itemprop="dateCreated datePublished" datetime=2019-10-29T11:45:41+08:00>2019-10-29</time></span>
<span class=post-category><span class=post-meta-divider>|</span>
<span class=post-meta-item-icon><i class="fa fa-folder-o"></i></span><span class=post-meta-item-text>In</span>
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/Programming/ itemprop=url rel=index><span itemprop=name>Programming</span></a></span>
,
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/Programming/Java/ itemprop=url rel=index><span itemprop=name>Java</span></a></span>
,
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/Programming/Java/Concurrent/ itemprop=url rel=index><span itemprop=name>Concurrent</span></a></span></span>
<span id=/2019/java-concurrent-part5/ class=leancloud_visitors data-flag-title=并发设计模式><span class=post-meta-divider>|</span>
<span class=post-meta-item-icon><i class="fa fa-eye"></i></span><span class=post-meta-item-text>Visitors</span>
<span class=leancloud-visitors-count></span></span><br><span class=post-time><span class=post-meta-item-icon><i class="fa fa-edit"></i></span><span class=post-meta-item-text>WordCount:</span>
<span class=post-count>5,770字</span>
<span class=post-meta-divider>|</span>
<span class=post-meta-item-text>min2read:</span>
<span class=post-count>23分钟</span></span></div></header><div class=post-body itemprop=articleBody><link rel=stylesheet href=https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css><p><img src=https://cdn.yangbingdong.com/img/concurrent/java-concurrent-part5-banner.jpg alt><h1 id=Preface><a href=#Preface class=headerlink title=Preface></a>Preface</h1><blockquote><p>并发领域中也有诸多的设计模式.</blockquote><a id=more></a><h1 id=Immutability模式><a href=#Immutability模式 class=headerlink title=Immutability模式></a>Immutability模式</h1><p>解决并发问题，其实最简单的办法就是让共享变量<strong>只有读操作</strong>，而<strong>没有写操作</strong>。这个办法如此重要，以至于被上升到了一种解决并发问题的设计模式：<strong>不变性（Immutability）模式</strong>。所谓不变性，简单来讲，就是<strong>对象一旦被创建之后，状态就不再发生变化</strong>。换句话说，就是变量一旦被赋值，就不允许修改了（没有写操作）；没有修改操作，也就是保持了不变性。<p>实现一个具备不可变性的类，还是挺简单的。<strong>将一个类所有的属性都设置成 final 的，并且只允许存在只读方法，那么这个类基本上就具备不可变性了</strong>。更严格的做法是<strong>这个类本身也是 final 的</strong>，也就是不允许继承。因为子类可以覆盖父类的方法，有可能改变不可变性，所以推荐你在实际工作中，使用这种更严格的做法。<p>Java 中非常经典的例子就是 <code>String</code>、<code>Integer</code>、<code>Long</code> 以及 <code>Double</code> 等基础类型的包装类. 它们都严格遵守不可变类的三点要求：类和属性都是 final 的，所有方法均是只读的。<p>但是 <code>String</code> 中有一些方法类似 <code>replace()</code> 这种操作这种操作是怎么实现的? 很简单, <strong>对象不可变那就返回一个新的对象</strong>. 那是不是有点浪费内存呢? 确实会的, 但是可以通过一种<strong>享元模式(Flyweight Pattern)</strong>来使这个消耗减小. Java 语言里面 <code>Long</code>、<code>Integer</code>、<code>Short</code>、<code>Byte</code> 等这些基本数据类型的包装类都用到了享元模式, <strong>享元模式本质上其实就是一个对象池</strong>:<p><img src=https://cdn.yangbingdong.com/img/concurrent/java-concurrent-part5-long-cache.png alt><p>之前有提过, 基本上所有的基础类型的包装类都不适合做锁, 因为这些类基本都使用了享元模式, 看上去是私有, 但实际上可能是公共的, 以下就是错误示范:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>A</span> </span>&#123;</span><br><span class=line>  Long al=Long.valueOf(<span class=number>1</span>);</span><br><span class=line>  <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>setAX</span><span class=params>()</span></span>&#123;</span><br><span class=line>    <span class=keyword>synchronized</span> (al) &#123;</span><br><span class=line>      <span class=comment>//省略代码无数</span></span><br><span class=line>    &#125;</span><br><span class=line>  &#125;</span><br><span class=line>&#125;</span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>B</span> </span>&#123;</span><br><span class=line>  Long bl=Long.valueOf(<span class=number>1</span>);</span><br><span class=line>  <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>setBY</span><span class=params>()</span></span>&#123;</span><br><span class=line>    <span class=keyword>synchronized</span> (bl) &#123;</span><br><span class=line>      <span class=comment>//省略代码无数</span></span><br><span class=line>    &#125;</span><br><span class=line>  &#125;</span><br><span class=line>&#125;</span><br></pre></table></figure><p>在使用 <code>Immutability</code> 模式的时候，需要注意以下两点：<ul><li>对象的所有属性都是 final 的，并不能保证不可变性(对象属性也可能是一个对象)；<li>不可变对象也需要正确发布。</ul><h1 id=Copy-on-Write模式><a href=#Copy-on-Write模式 class=headerlink title=Copy-on-Write模式></a>Copy-on-Write模式</h1><p>上面说到 String 这个类在实现 <code>replace()</code> 方法的时候，并没有更改原字符串里面 <code>value[]</code> 数组的内容，而是<strong>创建了一个新字符串</strong>，这种方法在解决不可变对象的修改问题时经常用到, 这本质上是 <strong>Copy-on-Write</strong> 方法, 也就是<strong>写时复制</strong>.<p>Java 并发包中比较经典的实现就是 <code>CopyOnWriteArrayList</code> 和 <code>CopyOnWriteArraySet</code> 这两个类. 当然, 这并不是 Java 独有的模式, 这个模式也普遍存在与其他的领域, 比如类 Unix 操作系统中的 fork 子进程, 文件系统中的Btrfs (B-Tree File System), Docker 容器镜像, 甚至分布式源码管理系统 Git 背后的设计思想都有 Copy-on-Write…<p>不过，<strong>Copy-on-Write 最大的应用领域还是在函数式编程领域</strong>。函数式编程的基础是不可变性（Immutability），所以函数式编程里面所有的修改操作都需要 Copy-on-Write 来解决。你或许会有疑问，“所有数据的修改都需要复制一份，性能是不是会成为瓶颈呢?”你的担忧是有道理的，之所以函数式编程早年间没有兴起，性能绝对拖了后腿。但是随着硬件性能的提升，性能问题已经慢慢变得可以接受了。而且，Copy-on-Write 也远不像 Java 里的 <code>CopyOnWriteArrayList</code> 那样笨：整个数组都复制一遍。<p><code>CopyOnWriteArrayList</code> 和 <code>CopyOnWriteArraySet</code> 这两个 Copy-on-Write 容器在修改的时候会复制整个数组，所以如果容器经常被修改或者这个数组本身就非常大的时候，是不建议使用的。反之，如果是修改非常少、数组数量也不大，并且对读性能要求苛刻的场景，使用 Copy-on-Write 容器效果就非常好了。一个比较经典的场景就是 RPC 框架的注册路由表, 对读的要求很高, 写比较少, 对一致性要求不高:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br></pre><td class=code><pre><span class=line></span><br><span class=line><span class=comment>//路由信息</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>final</span> <span class=class><span class=keyword>class</span> <span class=title>Router</span></span>&#123;</span><br><span class=line>  <span class=keyword>private</span> <span class=keyword>final</span> String  ip;</span><br><span class=line>  <span class=keyword>private</span> <span class=keyword>final</span> Integer port;</span><br><span class=line>  <span class=keyword>private</span> <span class=keyword>final</span> String  iface;</span><br><span class=line>  <span class=comment>//构造函数</span></span><br><span class=line>  <span class=function><span class=keyword>public</span> <span class=title>Router</span><span class=params>(String ip, </span></span></span><br><span class=line><span class=function><span class=params>      Integer port, String iface)</span></span>&#123;</span><br><span class=line>    <span class=keyword>this</span>.ip = ip;</span><br><span class=line>    <span class=keyword>this</span>.port = port;</span><br><span class=line>    <span class=keyword>this</span>.iface = iface;</span><br><span class=line>  &#125;</span><br><span class=line>  <span class=comment>//重写equals方法</span></span><br><span class=line>  <span class=function><span class=keyword>public</span> <span class=keyword>boolean</span> <span class=title>equals</span><span class=params>(Object obj)</span></span>&#123;</span><br><span class=line>    <span class=keyword>if</span> (obj <span class=keyword>instanceof</span> Router) &#123;</span><br><span class=line>      Router r = (Router)obj;</span><br><span class=line>      <span class=keyword>return</span> iface.equals(r.iface) &amp;&amp;</span><br><span class=line>             ip.equals(r.ip) &amp;&amp;</span><br><span class=line>             port.equals(r.port);</span><br><span class=line>    &#125;</span><br><span class=line>    <span class=keyword>return</span> <span class=keyword>false</span>;</span><br><span class=line>  &#125;</span><br><span class=line>  <span class=function><span class=keyword>public</span> <span class=keyword>int</span> <span class=title>hashCode</span><span class=params>()</span> </span>&#123;</span><br><span class=line>    <span class=comment>//省略hashCode相关代码</span></span><br><span class=line>  &#125;</span><br><span class=line>&#125;</span><br><span class=line><span class=comment>//路由表信息</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>RouterTable</span> </span>&#123;</span><br><span class=line>  <span class=comment>//Key:接口名</span></span><br><span class=line>  <span class=comment>//Value:路由集合</span></span><br><span class=line>  ConcurrentHashMap&lt;String, CopyOnWriteArraySet&lt;Router&gt;&gt; </span><br><span class=line>    rt = <span class=keyword>new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class=line>  <span class=comment>//根据接口名获取路由表</span></span><br><span class=line>  <span class=function><span class=keyword>public</span> Set&lt;Router&gt; <span class=title>get</span><span class=params>(String iface)</span></span>&#123;</span><br><span class=line>    <span class=keyword>return</span> rt.get(iface);</span><br><span class=line>  &#125;</span><br><span class=line>  <span class=comment>//删除路由</span></span><br><span class=line>  <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>remove</span><span class=params>(Router router)</span> </span>&#123;</span><br><span class=line>    Set&lt;Router&gt; set=rt.get(router.iface);</span><br><span class=line>    <span class=keyword>if</span> (set != <span class=keyword>null</span>) &#123;</span><br><span class=line>      set.remove(router);</span><br><span class=line>    &#125;</span><br><span class=line>  &#125;</span><br><span class=line>  <span class=comment>//增加路由</span></span><br><span class=line>  <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>add</span><span class=params>(Router router)</span> </span>&#123;</span><br><span class=line>    Set&lt;Router&gt; set = rt.computeIfAbsent(</span><br><span class=line>      route.iface, r -&gt; </span><br><span class=line>        <span class=keyword>new</span> CopyOnWriteArraySet&lt;&gt;());</span><br><span class=line>    set.add(router);</span><br><span class=line>  &#125;</span><br><span class=line>&#125;</span><br></pre></table></figure><p>Copy-on-Write 是一项非常通用的技术方案，在很多领域都有着广泛的应用。不过，它也有缺点的，那就是<strong>消耗内存，每次修改都需要复制一个新的对象出来</strong>，好在随着自动垃圾回收（GC）算法的成熟以及硬件的发展，这种内存消耗已经渐渐可以接受了。<h1 id=线程本地存储模式><a href=#线程本地存储模式 class=headerlink title=线程本地存储模式></a>线程本地存储模式</h1><p>之前提到过<strong>线程封闭</strong>这个概念, 其本质上就是避免共享, Java 中提供了 <code>ThreadLocal</code> 类来实现这个东西.<p><code>ThreadLocal</code> 基本原理如下:<p><img src=https://cdn.yangbingdong.com/img/concurrent/java-concurrent-threadlocal.png alt><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Thread</span> </span>&#123;</span><br><span class=line>  <span class=comment>//内部持有ThreadLocalMap</span></span><br><span class=line>  ThreadLocal.ThreadLocalMap </span><br><span class=line>    threadLocals;</span><br><span class=line>&#125;</span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>ThreadLocal</span>&lt;<span class=title>T</span>&gt;</span>&#123;</span><br><span class=line>  <span class=function><span class=keyword>public</span> T <span class=title>get</span><span class=params>()</span> </span>&#123;</span><br><span class=line>    <span class=comment>//首先获取线程持有的</span></span><br><span class=line>    <span class=comment>//ThreadLocalMap</span></span><br><span class=line>    ThreadLocalMap map =</span><br><span class=line>      Thread.currentThread()</span><br><span class=line>        .threadLocals;</span><br><span class=line>    <span class=comment>//在ThreadLocalMap中</span></span><br><span class=line>    <span class=comment>//查找变量</span></span><br><span class=line>    Entry e = </span><br><span class=line>      map.getEntry(<span class=keyword>this</span>);</span><br><span class=line>    <span class=keyword>return</span> e.value;  </span><br><span class=line>  &#125;</span><br><span class=line>  <span class=keyword>static</span> <span class=class><span class=keyword>class</span> <span class=title>ThreadLocalMap</span></span>&#123;</span><br><span class=line>    <span class=comment>//内部是数组而不是Map</span></span><br><span class=line>    Entry[] table;</span><br><span class=line>    <span class=comment>//根据ThreadLocal查找Entry</span></span><br><span class=line>    <span class=function>Entry <span class=title>getEntry</span><span class=params>(ThreadLocal key)</span></span>&#123;</span><br><span class=line>      <span class=comment>//省略查找逻辑</span></span><br><span class=line>    &#125;</span><br><span class=line>    <span class=comment>//Entry定义</span></span><br><span class=line>    <span class=keyword>static</span> <span class=class><span class=keyword>class</span> <span class=title>Entry</span> <span class=keyword>extends</span></span></span><br><span class=line><span class=class>    <span class=title>WeakReference</span>&lt;<span class=title>ThreadLocal</span>&gt;</span>&#123;</span><br><span class=line>      Object value;</span><br><span class=line>    &#125;</span><br><span class=line>  &#125;</span><br><span class=line>&#125;</span><br></pre></table></figure><p>这里要注意一点, 最好采用 <code>try{}finally{}</code> 手动释放资源<strong>避免内存泄露</strong>.<p>线程本地存储模式本质上是一种<strong>避免共享</strong>的方案，由于没有共享，所以自然也就没有并发问题。如果你需要在并发场景中使用一个线程不安全的工具类，最简单的方案就是避免共享。避免共享有两种方案，一种方案是将这个工具类作为局部变量使用，另外一种方案就是线程本地存储模式。这两种方案，局部变量方案的缺点是在高并发场景下会频繁创建对象，而线程本地存储方案，每个线程只需要创建一个工具类的实例，所以不存在频繁创建对象的问题。<h1 id=Guarded-Suspension模式><a href=#Guarded-Suspension模式 class=headerlink title="Guarded Suspension模式"></a>Guarded Suspension模式</h1><p>假设有这么一个场景, 服务调用是通过MQ来调用的, 比如需要Web端请求一个文件, 服务A发送MessageA, 服务B消费MessageA并发送MessageB, 但是A消费MessageB是异步的, 但是对于Web端来说这个请求是同步的.<p><img src=https://cdn.yangbingdong.com/img/concurrent/java-concurrent-guarded-suspension.png alt><p>伪代码如下:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Message</span></span>&#123;</span><br><span class=line>  String id;</span><br><span class=line>  String content;</span><br><span class=line>&#125;</span><br><span class=line><span class=comment>//该方法可以发送消息</span></span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>send</span><span class=params>(Message msg)</span></span>&#123;</span><br><span class=line>  <span class=comment>//省略相关代码</span></span><br><span class=line>&#125;</span><br><span class=line><span class=comment>//MQ消息返回后会调用该方法</span></span><br><span class=line><span class=comment>//该方法的执行线程不同于</span></span><br><span class=line><span class=comment>//发送消息的线程</span></span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>onMessage</span><span class=params>(Message msg)</span></span>&#123;</span><br><span class=line>  <span class=comment>//省略相关代码</span></span><br><span class=line>&#125;</span><br><span class=line><span class=comment>//处理浏览器发来的请求</span></span><br><span class=line><span class=function>Respond <span class=title>handleWebReq</span><span class=params>()</span></span>&#123;</span><br><span class=line>  <span class=comment>//创建一消息</span></span><br><span class=line>  Message msg1 = <span class=keyword>new</span> </span><br><span class=line>    Message(<span class=string>"1"</span>,<span class=string>"&#123;...&#125;"</span>);</span><br><span class=line>  <span class=comment>//发送消息</span></span><br><span class=line>  send(msg1);</span><br><span class=line>  <span class=comment>//如何等待MQ返回的消息呢？</span></span><br><span class=line>  String result = ...;</span><br><span class=line>&#125;</span><br></pre></table></figure><p>对于MQ返回消息需要等待服务提供方消费完成, 本质上是<strong>等待一个条件满足</strong>. 这类需求可以通过 Lock 与 Condition 来实现. 前人将其总结成一个模式: <strong>Guarded Suspension</strong>, 直译过来就是”保护性地暂停”.<p>下图就是 Guarded Suspension 模式的结构图，非常简单，一个对象 <code>GuardedObject</code>，内部有一个成员变量——受保护的对象，以及两个成员方法——<code>get(Predicate p)</code>和<code>onChanged(T obj)</code>方法。<p><img src=https://cdn.yangbingdong.com/img/concurrent/java-concurrent-guarded-suspension-struct.png alt><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>GuardedObject</span>&lt;<span class=title>T</span>&gt;</span>&#123;</span><br><span class=line>  <span class=comment>//受保护的对象</span></span><br><span class=line>  T obj;</span><br><span class=line>  <span class=keyword>final</span> Lock lock = </span><br><span class=line>    <span class=keyword>new</span> ReentrantLock();</span><br><span class=line>  <span class=keyword>final</span> Condition done =</span><br><span class=line>    lock.newCondition();</span><br><span class=line>  <span class=keyword>final</span> <span class=keyword>int</span> timeout=<span class=number>1</span>;</span><br><span class=line>  <span class=comment>//获取受保护对象  </span></span><br><span class=line>  <span class=function>T <span class=title>get</span><span class=params>(Predicate&lt;T&gt; p)</span> </span>&#123;</span><br><span class=line>    lock.lock();</span><br><span class=line>    <span class=keyword>try</span> &#123;</span><br><span class=line>      <span class=comment>//MESA管程推荐写法</span></span><br><span class=line>      <span class=keyword>while</span>(!p.test(obj))&#123;</span><br><span class=line>        done.await(timeout, </span><br><span class=line>          TimeUnit.SECONDS);</span><br><span class=line>      &#125;</span><br><span class=line>    &#125;<span class=keyword>catch</span>(InterruptedException e)&#123;</span><br><span class=line>      <span class=keyword>throw</span> <span class=keyword>new</span> RuntimeException(e);</span><br><span class=line>    &#125;<span class=keyword>finally</span>&#123;</span><br><span class=line>      lock.unlock();</span><br><span class=line>    &#125;</span><br><span class=line>    <span class=comment>//返回非空的受保护对象</span></span><br><span class=line>    <span class=keyword>return</span> obj;</span><br><span class=line>  &#125;</span><br><span class=line>  <span class=comment>//事件通知方法</span></span><br><span class=line>  <span class=function><span class=keyword>void</span> <span class=title>onChanged</span><span class=params>(T obj)</span> </span>&#123;</span><br><span class=line>    lock.lock();</span><br><span class=line>    <span class=keyword>try</span> &#123;</span><br><span class=line>      <span class=keyword>this</span>.obj = obj;</span><br><span class=line>      done.signalAll();</span><br><span class=line>    &#125; <span class=keyword>finally</span> &#123;</span><br><span class=line>      lock.unlock();</span><br><span class=line>    &#125;</span><br><span class=line>  &#125;</span><br><span class=line>&#125;</span><br></pre></table></figure><p>对于上面场景, 我们可以这样实现:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=comment>//处理浏览器发来的请求</span></span><br><span class=line><span class=function>Respond <span class=title>handleWebReq</span><span class=params>()</span></span>&#123;</span><br><span class=line>  <span class=comment>//创建一消息</span></span><br><span class=line>  Message msg1 = <span class=keyword>new</span> </span><br><span class=line>    Message(<span class=string>"1"</span>,<span class=string>"&#123;...&#125;"</span>);</span><br><span class=line>  <span class=comment>//发送消息</span></span><br><span class=line>  send(msg1);</span><br><span class=line>  <span class=comment>//利用GuardedObject实现等待</span></span><br><span class=line>  GuardedObject&lt;Message&gt; go</span><br><span class=line>    =<span class=keyword>new</span> GuardObjec&lt;&gt;();</span><br><span class=line>  Message r = go.get(</span><br><span class=line>    t-&gt;t != <span class=keyword>null</span>);</span><br><span class=line>&#125;</span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>onMessage</span><span class=params>(Message msg)</span></span>&#123;</span><br><span class=line>  <span class=comment>//如何找到匹配的go？</span></span><br><span class=line>  GuardedObject&lt;Message&gt; go=???</span><br><span class=line>  go.onChanged(msg);</span><br><span class=line>&#125;</span><br></pre></table></figure><p>但是这里的问题就是, <code>GuardedObject</code> 是在 <code>handleWebReq()</code> 方法中new出来的, 如何传递到 <code>onMessage()</code> 方法?<p>很简单, 做一个消息的映射就行了, <code>Dubbo</code> 中 <code>DefaultFuture</code> 这个类也是采用的这种方式的.<h1 id=Balking模式><a href=#Balking模式 class=headerlink title=Balking模式></a>Balking模式</h1><p>我们经常会遇到<strong>防御性 return</strong> 的场景, 比如只加载一次或者只执行一次, 伪代码如下:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>if</span>(condition) &#123;</span><br><span class=line>  <span class=keyword>return</span>;</span><br><span class=line>&#125;</span><br></pre></table></figure><p>但往往会有多个线程去执行这段逻辑, 这又变成了另外一种”多线程版本的 if”, 叫做 <strong>Balking 模式</strong>.<p>Balking 模式和 Guarded Suspension 模式从实现上看似乎没有多大的关系，Balking 模式只需要用互斥锁就能解决，而 Guarded Suspension 模式则要用到管程这种高级的并发原语；但是从应用的角度来看，它们解决的都是”线程安全的 if”语义，不同之处在于，Guarded Suspension 模式会等待 if 条件为真，而 Balking 模式不会等待。<h1 id=Thread-Per-Message模式><a href=#Thread-Per-Message模式 class=headerlink title=Thread-Per-Message模式></a>Thread-Per-Message模式</h1><p>这个模式说白了就是就是每个请求都委托给一个新的线程, Thread-Per-Message 模式的一个最经典的应用场景是<strong>网络编程里服务端的实现</strong>，服务端为每个客户端请求创建一个独立的线程，当线程处理完请求后，自动销毁，这是一种最简单的并发处理网络请求的方法。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br></pre><td class=code><pre><span class=line><span class=keyword>final</span> ServerSocketChannel ssc = </span><br><span class=line>  ServerSocketChannel.open().bind(</span><br><span class=line>    <span class=keyword>new</span> InetSocketAddress(<span class=number>8080</span>));</span><br><span class=line><span class=comment>//处理请求    </span></span><br><span class=line><span class=keyword>try</span> &#123;</span><br><span class=line>  <span class=keyword>while</span> (<span class=keyword>true</span>) &#123;</span><br><span class=line>    <span class=comment>// 接收请求</span></span><br><span class=line>    SocketChannel sc = ssc.accept();</span><br><span class=line>    <span class=comment>// 每个请求都创建一个线程</span></span><br><span class=line>    <span class=keyword>new</span> Thread(()-&gt;&#123;</span><br><span class=line>      <span class=keyword>try</span> &#123;</span><br><span class=line>        <span class=comment>// 读Socket</span></span><br><span class=line>        ByteBuffer rb = ByteBuffer</span><br><span class=line>          .allocateDirect(<span class=number>1024</span>);</span><br><span class=line>        sc.read(rb);</span><br><span class=line>        <span class=comment>//模拟处理请求</span></span><br><span class=line>        Thread.sleep(<span class=number>2000</span>);</span><br><span class=line>        <span class=comment>// 写Socket</span></span><br><span class=line>        ByteBuffer wb = </span><br><span class=line>          (ByteBuffer)rb.flip();</span><br><span class=line>        sc.write(wb);</span><br><span class=line>        <span class=comment>// 关闭Socket</span></span><br><span class=line>        sc.close();</span><br><span class=line>      &#125;<span class=keyword>catch</span>(Exception e)&#123;</span><br><span class=line>        <span class=keyword>throw</span> <span class=keyword>new</span> UncheckedIOException(e);</span><br><span class=line>      &#125;</span><br><span class=line>    &#125;).start();</span><br><span class=line>  &#125;</span><br><span class=line>&#125; <span class=keyword>finally</span> &#123;</span><br><span class=line>  ssc.close();</span><br><span class=line>&#125;</span><br></pre></table></figure><p>上面方案显然不适用于生产环境, 毕竟 Java 中的线程是一个重量级的对象，创建成本很高，一方面创建线程比较耗时，另一方面线程占用的内存也比较大.<p>Thread-Per-Message 在 Java 中的知名度不大, 是因为线程的成本很高, 但是在别的语言当中却很响亮, 业界中有一种方案叫<strong>轻量级线程</strong>, 也叫<strong>协程</strong>, Go 语言、Lua 语言当中都有实现. 幸运的是, ava 语言目前也已经意识到轻量级线程的重要性了，OpenJDK 有个 Loom 项目，就是要解决 Java 语言的轻量级线程问题，在这个项目中，轻量级线程被叫做 Fiber。<blockquote><p>有一个java库叫Quasar Fiber ，通过javaagent技术可以实现轻量级线程<br>官网: <strong><em><a href=http://www.paralleluniverse.co/quasar/ rel="external nofollow noopener noreferrer" target=_blank>http://www.paralleluniverse.co/quasar/</a></em></strong><p>阿里也有一个 wisp2, 不过目前没开源.</blockquote><h1 id=Worker-Thread模式><a href=#Worker-Thread模式 class=headerlink title="Worker Thread模式"></a>Worker Thread模式</h1><p>这个模式的经典实现就是 JDK 中的线程池了, 关于线程池的东西这里也不多说了, 主要还是重复一下注意事项吧:<ul><li><strong>使用有界队列</strong><li><strong>拒绝策略要慎重使用</strong><li><strong>异常处理的问题</strong><li><strong>有意义的线程名称</strong></ul><p>还有一个问题需要注意, <strong>死锁</strong>. 如果提交到相同线程池的任务不是相互独立的，而是有依赖关系的，那么就有可能导致线程死锁。实际工作中，我就亲历过这种线程死锁的场景。具体现象是应用每运行一段时间偶尔就会处于无响应的状态，监控数据看上去一切都正常，但是实际上已经不能正常工作了。<p>以下是一段死锁代码:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line><span class=comment>//L1、L2阶段共用的线程池</span></span><br><span class=line>ExecutorService es = Executors.</span><br><span class=line>  newFixedThreadPool(<span class=number>2</span>);</span><br><span class=line><span class=comment>//L1阶段的闭锁    </span></span><br><span class=line>CountDownLatch l1=<span class=keyword>new</span> CountDownLatch(<span class=number>2</span>);</span><br><span class=line><span class=keyword>for</span> (<span class=keyword>int</span> i=<span class=number>0</span>; i&lt;<span class=number>2</span>; i++)&#123;</span><br><span class=line>  System.out.println(<span class=string>"L1"</span>);</span><br><span class=line>  <span class=comment>//执行L1阶段任务</span></span><br><span class=line>  es.execute(()-&gt;&#123;</span><br><span class=line>    <span class=comment>//L2阶段的闭锁 </span></span><br><span class=line>    CountDownLatch l2=<span class=keyword>new</span> CountDownLatch(<span class=number>2</span>);</span><br><span class=line>    <span class=comment>//执行L2阶段子任务</span></span><br><span class=line>    <span class=keyword>for</span> (<span class=keyword>int</span> j=<span class=number>0</span>; j&lt;<span class=number>2</span>; j++)&#123;</span><br><span class=line>      es.execute(()-&gt;&#123;</span><br><span class=line>        System.out.println(<span class=string>"L2"</span>);</span><br><span class=line>        l2.countDown();</span><br><span class=line>      &#125;);</span><br><span class=line>    &#125;</span><br><span class=line>    <span class=comment>//等待L2阶段任务执行完</span></span><br><span class=line>    l2.await();</span><br><span class=line>    l1.countDown();</span><br><span class=line>  &#125;);</span><br><span class=line>&#125;</span><br><span class=line><span class=comment>//等着L1阶段任务执行完</span></span><br><span class=line>l1.await();</span><br><span class=line>System.out.println(<span class=string>"end"</span>);</span><br></pre></table></figure><p>当应用出现类似问题时，首选的诊断方法是查看线程栈。下图是上面示例代码停止响应后的线程栈，你会发现线程池中的两个线程全部都阻塞在 <code>l2.await();</code> 这行代码上了，也就是说，线程池里所有的线程都在等待 L2 阶段的任务执行完，那 L2 阶段的子任务什么时候能够执行完呢？永远都没那一天了，为什么呢？因为线程池里的线程都阻塞了，没有空闲的线程执行 L2 阶段的任务了。其实这种问题通用的解决方案是<strong>为不同的任务创建不同的线程池</strong>。<p>最后再次强调一下：<strong>提交到相同线程池中的任务一定是相互独立的，否则就一定要慎重</strong>。<h1 id=两阶段终止模式><a href=#两阶段终止模式 class=headerlink title=两阶段终止模式></a>两阶段终止模式</h1><p>Java 语言的 Thread 类中曾经提供了一个 <code>stop()</code> 方法，用来终止线程，可是早已不建议使用了，原因是这个方法用的就是一剑封喉的做法，<strong>被终止的线程没有机会料理后事</strong>。<p>前辈们经过认真对比分析，已经总结出了一套成熟的方案，叫做<strong>两阶段终止模式</strong>。顾名思义，就是将终止过程分成两个阶段，其中第一个阶段主要是线程 T1 向线程 T2<strong>发送终止指令</strong>，而第二阶段则是线程 T2<strong>响应终止指令</strong>。<p><img src=https://cdn.yangbingdong.com/img/concurrent/java-concurrent-two-phase-terminal.png alt><p>在 Java 中我们可以使用 Thread 提供的 interrupt() 以及自定义标志位来实现, 举个例子: 实际工作中，有些监控系统需要动态地采集一些数据，一般都是监控系统发送采集指令给被监控系统的监控代理，监控代理接收到指令之后，从监控目标收集数据，然后回传给监控系统，详细过程如下图所示。出于对性能的考虑（有些监控项对系统性能影响很大，所以不能一直持续监控），动态采集功能一般都会有终止操作。<p><img src=https://cdn.yangbingdong.com/img/concurrent/java-concurrent-two-phase-terminal2.png alt><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Proxy</span> </span>&#123;</span><br><span class=line>  <span class=comment>//线程终止标志位</span></span><br><span class=line>  <span class=keyword>volatile</span> <span class=keyword>boolean</span> terminated = <span class=keyword>false</span>;</span><br><span class=line>  <span class=keyword>boolean</span> started = <span class=keyword>false</span>;</span><br><span class=line>  <span class=comment>//采集线程</span></span><br><span class=line>  Thread rptThread;</span><br><span class=line>  <span class=comment>//启动采集功能</span></span><br><span class=line>  <span class=function><span class=keyword>synchronized</span> <span class=keyword>void</span> <span class=title>start</span><span class=params>()</span></span>&#123;</span><br><span class=line>    <span class=comment>//不允许同时启动多个采集线程</span></span><br><span class=line>    <span class=keyword>if</span> (started) &#123;</span><br><span class=line>      <span class=keyword>return</span>;</span><br><span class=line>    &#125;</span><br><span class=line>    started = <span class=keyword>true</span>;</span><br><span class=line>    terminated = <span class=keyword>false</span>;</span><br><span class=line>    rptThread = <span class=keyword>new</span> Thread(()-&gt;&#123;</span><br><span class=line>      <span class=keyword>while</span> (!terminated)&#123;</span><br><span class=line>        <span class=comment>//省略采集、回传实现</span></span><br><span class=line>        report();</span><br><span class=line>        <span class=comment>//每隔两秒钟采集、回传一次数据</span></span><br><span class=line>        <span class=keyword>try</span> &#123;</span><br><span class=line>          Thread.sleep(<span class=number>2000</span>);</span><br><span class=line>        &#125; <span class=keyword>catch</span> (InterruptedException e)&#123;</span><br><span class=line>          <span class=comment>//重新设置线程中断状态</span></span><br><span class=line>          Thread.currentThread().interrupt();</span><br><span class=line>        &#125;</span><br><span class=line>      &#125;</span><br><span class=line>      <span class=comment>//执行到此处说明线程马上终止</span></span><br><span class=line>      started = <span class=keyword>false</span>;</span><br><span class=line>    &#125;);</span><br><span class=line>    rptThread.start();</span><br><span class=line>  &#125;</span><br><span class=line>  <span class=comment>//终止采集功能</span></span><br><span class=line>  <span class=function><span class=keyword>synchronized</span> <span class=keyword>void</span> <span class=title>stop</span><span class=params>()</span></span>&#123;</span><br><span class=line>    <span class=comment>//设置中断标志位</span></span><br><span class=line>    terminated = <span class=keyword>true</span>;</span><br><span class=line>    <span class=comment>//中断线程rptThread</span></span><br><span class=line>    rptThread.interrupt();</span><br><span class=line>  &#125;</span><br><span class=line>&#125;</span><br></pre></table></figure><p>这里要注意两点, 第一是没有使用 <code>Thread.currentThread().isInterrupted()</code> 来判断是因为代码中有可能会使用到第三方类库, 而我们没有办法保证第三方类库正确处理了线程的中断异常，例如第三方类库在捕获到 <code>Thread.sleep()</code> 方法抛出的中断异常后，没有重新设置线程的中断状态，那么就会导致线程不能够正常终止。还有一点是 <code>terminated</code> 标志位使用了 <code>volatile</code> 修饰来保证可见性.<h1 id=生产者-消费者模式><a href=#生产者-消费者模式 class=headerlink title=生产者-消费者模式></a>生产者-消费者模式</h1><p>这个的经典实现就是线程池了, 这里不在多说.<h1 id=STM-amp-MVCC><a href=#STM-amp-MVCC class=headerlink title=STM&amp;MVCC></a>STM&amp;MVCC</h1><p>STM: Software Transactional Memory(<strong>软件事务内存</strong>), 也是解决并发方面问题的一种模式, 在数据库中见的比较多. 其中一种实现是 MVCC(Multi-Version Concurrency Control), 也就是<strong>多版本并发控制</strong>.<p>MVCC 可以简单地理解为数据库事务在开启的时候，会给数据库打一个快照，以后所有的读写都是基于这个快照的。当提交事务的时候，如果所有读写过的数据在该事务执行期间没有发生过变化，那么就可以提交；如果发生了变化，说明该事务和有其他事务读写的数据冲突了，这个时候是不可以提交的。<p>为了记录数据是否发生了变化，可以给每条数据增加一个版本号，这样每次成功修改数据都会增加版本号的值。有不少 STM 的实现方案都是基于 MVCC 的，例如知名的 Clojure STM。<p>代码示例:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br><span class=line>93</span><br><span class=line>94</span><br><span class=line>95</span><br><span class=line>96</span><br><span class=line>97</span><br><span class=line>98</span><br><span class=line>99</span><br><span class=line>100</span><br><span class=line>101</span><br><span class=line>102</span><br><span class=line>103</span><br><span class=line>104</span><br><span class=line>105</span><br><span class=line>106</span><br><span class=line>107</span><br><span class=line>108</span><br><span class=line>109</span><br><span class=line>110</span><br><span class=line>111</span><br><span class=line>112</span><br><span class=line>113</span><br><span class=line>114</span><br><span class=line>115</span><br><span class=line>116</span><br><span class=line>117</span><br><span class=line>118</span><br><span class=line>119</span><br><span class=line>120</span><br><span class=line>121</span><br><span class=line>122</span><br><span class=line>123</span><br><span class=line>124</span><br><span class=line>125</span><br><span class=line>126</span><br><span class=line>127</span><br><span class=line>128</span><br><span class=line>129</span><br></pre><td class=code><pre><span class=line><span class=comment>//带版本号的对象引用</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>final</span> <span class=class><span class=keyword>class</span> <span class=title>VersionedRef</span>&lt;<span class=title>T</span>&gt; </span>&#123;</span><br><span class=line>    <span class=keyword>final</span> T value;</span><br><span class=line>    <span class=keyword>final</span> <span class=keyword>long</span> version;</span><br><span class=line></span><br><span class=line>    <span class=comment>//构造方法</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=title>VersionedRef</span><span class=params>(T value, <span class=keyword>long</span> version)</span> </span>&#123;</span><br><span class=line>        <span class=keyword>this</span>.value = value;</span><br><span class=line>        <span class=keyword>this</span>.version = version;</span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=comment>//支持事务的引用</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>TxnRef</span>&lt;<span class=title>T</span>&gt; </span>&#123;</span><br><span class=line>    <span class=comment>//当前数据，带版本号</span></span><br><span class=line>    <span class=keyword>volatile</span> VersionedRef curRef;</span><br><span class=line></span><br><span class=line>    <span class=comment>//构造方法</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=title>TxnRef</span><span class=params>(T value)</span> </span>&#123;</span><br><span class=line>        <span class=keyword>this</span>.curRef = <span class=keyword>new</span> VersionedRef(value, <span class=number>0L</span>);</span><br><span class=line>    &#125;</span><br><span class=line></span><br><span class=line>    <span class=comment>//获取当前事务中的数据</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> T <span class=title>getValue</span><span class=params>(Txn txn)</span> </span>&#123;</span><br><span class=line>        <span class=keyword>return</span> txn.get(<span class=keyword>this</span>);</span><br><span class=line>    &#125;</span><br><span class=line></span><br><span class=line>    <span class=comment>//在当前事务中设置数据</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>setValue</span><span class=params>(T value, Txn txn)</span> </span>&#123;</span><br><span class=line>        txn.set(<span class=keyword>this</span>, value);</span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=comment>//事务接口</span></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>interface</span> <span class=title>Txn</span> </span>&#123;</span><br><span class=line>    &lt;T&gt; <span class=function>T <span class=title>get</span><span class=params>(TxnRef&lt;T&gt; ref)</span></span>;</span><br><span class=line>    &lt;T&gt; <span class=function><span class=keyword>void</span> <span class=title>set</span><span class=params>(TxnRef&lt;T&gt; ref, T value)</span></span>;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=comment>//STM事务实现类</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>final</span> <span class=class><span class=keyword>class</span> <span class=title>STMTxn</span> <span class=keyword>implements</span> <span class=title>Txn</span> </span>&#123;</span><br><span class=line>    <span class=comment>//事务ID生成器</span></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> AtomicLong txnSeq = <span class=keyword>new</span> AtomicLong(<span class=number>0</span>);</span><br><span class=line></span><br><span class=line>    <span class=comment>//当前事务所有的相关数据</span></span><br><span class=line>    <span class=keyword>private</span> Map&lt;TxnRef, VersionedRef&gt; inTxnMap = <span class=keyword>new</span> HashMap&lt;&gt;();</span><br><span class=line>    <span class=comment>//当前事务所有需要修改的数据</span></span><br><span class=line>    <span class=keyword>private</span> Map&lt;TxnRef, Object&gt; writeMap = <span class=keyword>new</span> HashMap&lt;&gt;();</span><br><span class=line>    <span class=comment>//当前事务ID</span></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>long</span> txnId;</span><br><span class=line></span><br><span class=line>    <span class=comment>//构造函数，自动生成当前事务ID</span></span><br><span class=line>    STMTxn() &#123;</span><br><span class=line>        txnId = txnSeq.incrementAndGet();</span><br><span class=line>    &#125;</span><br><span class=line></span><br><span class=line>    <span class=comment>//获取当前事务中的数据</span></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> &lt;T&gt; <span class=function>T <span class=title>get</span><span class=params>(TxnRef&lt;T&gt; ref)</span> </span>&#123;</span><br><span class=line>        <span class=comment>//将需要读取的数据，加入inTxnMap</span></span><br><span class=line>        <span class=keyword>if</span> (!inTxnMap.containsKey(ref)) &#123;</span><br><span class=line>            inTxnMap.put(ref, ref.curRef);</span><br><span class=line>        &#125;</span><br><span class=line>        <span class=keyword>return</span> (T) inTxnMap.get(ref).value;</span><br><span class=line>    &#125;</span><br><span class=line></span><br><span class=line>    <span class=comment>//在当前事务中修改数据</span></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> &lt;T&gt; <span class=function><span class=keyword>void</span> <span class=title>set</span><span class=params>(TxnRef&lt;T&gt; ref, T value)</span> </span>&#123;</span><br><span class=line>        <span class=comment>//将需要修改的数据，加入inTxnMap</span></span><br><span class=line>        <span class=keyword>if</span> (!inTxnMap.containsKey(ref)) &#123;</span><br><span class=line>            inTxnMap.put(ref, ref.curRef);</span><br><span class=line>        &#125;</span><br><span class=line>        writeMap.put(ref, value);</span><br><span class=line>    &#125;</span><br><span class=line></span><br><span class=line>    <span class=comment>//提交事务</span></span><br><span class=line>    <span class=function><span class=keyword>boolean</span> <span class=title>commit</span><span class=params>()</span> </span>&#123;</span><br><span class=line>        <span class=keyword>synchronized</span> (STM.commitLock) &#123;</span><br><span class=line>            <span class=comment>//是否校验通过</span></span><br><span class=line>            <span class=keyword>boolean</span> isValid = <span class=keyword>true</span>;</span><br><span class=line>            <span class=comment>//校验所有读过的数据是否发生过变化</span></span><br><span class=line>            <span class=keyword>for</span> (Map.Entry&lt;TxnRef, VersionedRef&gt; entry : inTxnMap.entrySet()) &#123;</span><br><span class=line>                VersionedRef curRef = entry.getKey().curRef;</span><br><span class=line>                VersionedRef readRef = entry.getValue();</span><br><span class=line>                <span class=comment>//通过版本号来验证数据是否发生过变化</span></span><br><span class=line>                <span class=keyword>if</span> (curRef.version != readRef.version) &#123;</span><br><span class=line>                    isValid = <span class=keyword>false</span>;</span><br><span class=line>                    <span class=keyword>break</span>;</span><br><span class=line>                &#125;</span><br><span class=line>            &#125;</span><br><span class=line>            <span class=comment>//如果校验通过，则所有更改生效</span></span><br><span class=line>            <span class=keyword>if</span> (isValid) &#123;</span><br><span class=line>                writeMap.forEach((k, v) -&gt; &#123;</span><br><span class=line>                    k.curRef = <span class=keyword>new</span> VersionedRef(v, txnId);</span><br><span class=line>                &#125;);</span><br><span class=line>            &#125;</span><br><span class=line>            <span class=keyword>return</span> isValid;</span><br><span class=line>        &#125;</span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>interface</span> <span class=title>TxnRunnable</span> </span>&#123;</span><br><span class=line>    <span class=function><span class=keyword>void</span> <span class=title>run</span><span class=params>(Txn txn)</span></span>;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=comment>//STM</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>final</span> <span class=class><span class=keyword>class</span> <span class=title>STM</span> </span>&#123;</span><br><span class=line>    <span class=comment>//私有化构造方法</span></span><br><span class=line>    <span class=function><span class=keyword>private</span> <span class=title>STM</span><span class=params>()</span> </span>&#123;</span><br><span class=line>    &#125;</span><br><span class=line></span><br><span class=line>    <span class=comment>//提交数据需要用到的全局锁</span></span><br><span class=line>    <span class=keyword>static</span> <span class=keyword>final</span> Object commitLock = <span class=keyword>new</span> Object();</span><br><span class=line></span><br><span class=line>    <span class=comment>//原子化提交方法</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>atomic</span><span class=params>(TxnRunnable action)</span> </span>&#123;</span><br><span class=line>        <span class=keyword>boolean</span> committed = <span class=keyword>false</span>;</span><br><span class=line>        <span class=comment>//如果没有提交成功，则一直重试</span></span><br><span class=line>        <span class=keyword>while</span> (!committed) &#123;</span><br><span class=line>            <span class=comment>//创建新的事务</span></span><br><span class=line>            STMTxn txn = <span class=keyword>new</span> STMTxn();</span><br><span class=line>            <span class=comment>//执行业务逻辑</span></span><br><span class=line>            action.run(txn);</span><br><span class=line>            <span class=comment>//提交事务</span></span><br><span class=line>            committed = txn.commit();</span><br><span class=line>        &#125;</span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br></pre></table></figure><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>Account</span> </span>&#123;</span><br><span class=line>    <span class=comment>//余额</span></span><br><span class=line>    <span class=keyword>private</span> TxnRef&lt;Integer&gt; balance;</span><br><span class=line></span><br><span class=line>    <span class=comment>//构造方法</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=title>Account</span><span class=params>(<span class=keyword>int</span> balance)</span> </span>&#123;</span><br><span class=line>        <span class=keyword>this</span>.balance = <span class=keyword>new</span> TxnRef&lt;&gt;(balance);</span><br><span class=line>    &#125;</span><br><span class=line></span><br><span class=line>    <span class=comment>//转账操作</span></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>transfer</span><span class=params>(Account target, <span class=keyword>int</span> amt)</span> </span>&#123;</span><br><span class=line>        STM.atomic((txn) -&gt; &#123;</span><br><span class=line>            Integer from = balance.getValue(txn);</span><br><span class=line>            balance.setValue(from - amt, txn);</span><br><span class=line>            Integer to = target.balance.getValue(txn);</span><br><span class=line>            target.balance.setValue(to + amt, txn);</span><br><span class=line>        &#125;);</span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br></pre></table></figure><p>总的来说其实就是通过版本号来控制并发, 只不过这里面还多了个<strong>副本</strong>的概念.<p>STM 借鉴的是数据库的经验，数据库虽然复杂，但仅仅存储数据，而编程语言除了有共享变量之外，还会执行各种 I/O 操作，<strong>很显然 I/O 操作是很难支持回滚的</strong>。所以，STM 也不是万能的。目前支持 STM 的编程语言主要是函数式语言，函数式语言里的数据天生具备不可变性，利用这种不可变性实现 STM 相对来说更简单。<h1 id=总结><a href=#总结 class=headerlink title=总结></a>总结</h1><p><strong>Immutability 模式</strong>、<strong>Copy-on-Write 模式</strong>和<strong>线程本地存储模式</strong>本质上都是为了<strong>避免共享</strong>，只是实现手段不同而已。这 3 种设计模式的实现都很简单，但是实现过程中有些细节还是需要格外注意的。例如，<strong>使用 Immutability 模式需要注意对象属性的不可变性</strong>，<strong>使用 Copy-on-Write 模式需要注意性能问题</strong>，<strong>使用线程本地存储模式需要注意异步执行问题</strong>。<p><strong>Guarded Suspension 模式</strong>和 <strong>Balking 模式</strong>都可以简单地理解为”多线程版本的 if”，但它们的区别在于前者会等待 if 条件变为真，而后者则不需要等待。<p><strong>Thread-Per-Message 模式</strong>、<strong>Worker Thread 模式</strong>和<strong>生产者 - 消费者模式</strong>是三种<strong>最简单实用的多线程分工方法</strong>。Thread-Per-Message 模式在实现的时候需要注意是否存在线程的频繁创建、销毁以及是否可能导致 <strong>OOM</strong>。Worker Thread 模式的实现，需要注意潜在的线程<strong>死锁问题</strong>, 以及<strong>任务之间没有依赖关系</strong>这个因素要慎重考虑。</div><div style=text-align:center;color:#ccc;font-size:14px>---------------- The End ----------------</div><div><div id=wechat_subscriber style="display:block;padding:10px 0;margin:20px auto;width:100%;text-align:center"><img id=wechat_subscriber_qcode src=/images/wechat/gongzhonghao.jpg alt="ookamiAntD wechat" style=width:200px;max-width:100%><div>欢迎您扫一扫上面的微信公众号，订阅我的博客！</div></div></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>谢谢大爷～</div><button id=rewardButton disable=enable onclick="var qr=document.getElementById('QR');if(qr.style.display==='none'){qr.style.display='block';}else{qr.style.display='none'}">
<span>赏</span></button><div id=QR style=display:none><div id=wechat style=display:inline-block><img id=wechat_qr src=/images/donate/wechat.png alt="ookamiAntD WeChat Pay"><p>微信打赏</div><div id=alipay style=display:inline-block><img id=alipay_qr src=/images/donate/alipay.jpg alt="ookamiAntD Alipay"><p>支付宝打赏</div></div></div></div><div><p id=div-border-left-red>Author：<b>ookamiAntD Yang</b><br>Link：<a href=/2019/java-concurrent-part5/ title=并发设计模式>http://yangbingdong.com/2019/java-concurrent-part5/</a><br>Contact：<a>yangbingdong1994@gmail.com</a><br><b>本文基于<a target=_blank title="Creative Commons Attribution-ShareAlike 4.0 International (CC BY-SA 4.0)" href=http://creativecommons.org/licenses/by-sa/4.0/ rel="external nofollow noopener noreferrer"> 知识共享署名-相同方式共享 4.0 </a>国际许可协议发布</b><br><b>转载请注明出处，谢谢！</b></div><footer class=post-footer><div class=post-tags><a href=/tags/Java/ rel=tag><i class="fa fa-tag"></i>Java</a>
<a href=/tags/Concurrent/ rel=tag><i class="fa fa-tag"></i>Concurrent</a></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/2019/java-concurrent-part4/ rel=next title="Java 并发拾遗-并发工具(下)"><i class="fa fa-chevron-left"></i>Java 并发拾遗-并发工具(下)</a></div><span class=post-nav-divider></span><div class="post-nav-prev post-nav-item"><a href=/2020/spring-security-mvc-interceptor/ rel=prev title="Spring Security 与 HandlerInterceptor 的认证鉴权">Spring Security 与 HandlerInterceptor 的认证鉴权 <i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class=post-spread><div class=-hoofoo-share-title>分享到：</div><div class=-hoofoo-share-buttons><div class="-mob-share-weibo -hoofoo-share-weibo -hoofoo-share-ui-button"><i class="fa fa-weibo" aria-hidden=true></i></div><div class="-mob-share-weixin -hoofoo-share-weixin -hoofoo-share-ui-button"><i class="fa fa-weixin" aria-hidden=true></i></div><div class="-mob-share-qq -hoofoo-share-qq -hoofoo-share-ui-button"><i class="fa fa-qq" aria-hidden=true></i></div><div class="-mob-share-twitter -hoofoo-share-twitter -hoofoo-share-ui-button"><i class="fa fa-twitter" aria-hidden=true></i></div><div class="-hoofoo-share-more -hoofoo-share-ui-button -mob-share-open"><i class="fa fa-ellipsis-h" aria-hidden=true></i></div></div><div class=-mob-share-ui style=display:none><ul class=-mob-share-list><li class=-mob-share-weibo><p>新浪微博<li class=-mob-share-weixin><p>微信<li class=-mob-share-qzone><p>QQ空间<li class=-mob-share-qq><p>QQ好友<li class=-mob-share-tencentweibo><p>腾讯微博<li class=-mob-share-renren><p>人人网<li class=-mob-share-kaixin><p>开心网<li class=-mob-share-douban><p>豆瓣<li class=-mob-share-youdao><p>有道云笔记<li class=-mob-share-mingdao><p>明道<li class=-mob-share-pengyou><p>朋友网<li class=-mob-share-facebook><p>Facebook<li class=-mob-share-twitter><p>Twitter<li class=-mob-share-pocket><p>Pocket<li class=-mob-share-google><p>Google+<li class=-mob-share-tumblr><p>Tumblr<li class=-mob-share-instapaper><p>Instapaper<li class=-mob-share-linkedin><p>Linkedin</ul><div class=-mob-share-close>取消</div></div><div class=-mob-share-ui-bg></div><script id=-mob-share src="https://f1.webshare.mob.com/code/mob-share.js?appkey=21aa3b13ad233"></script></div></div></div><div class=comments id=comments><div style=text-align:center></div><div id=disqus_proxy_thread></div><div id=disqus_thread></div><script>window.disqusProxy={username:'ookamiantd',server:'disqus-proxy.yangbingdong.com',port:'',defaultAvatar:'/images/avatar/avatar-default.jpg',adminAvatar:'/images/avatar/avatar-admin.jpg',identifier:'2019/java-concurrent-part5/'};window.disqus_config=function(){this.page.url='http://yangbingdong.com/2019/java-concurrent-part5/';this.page.identifier='2019/java-concurrent-part5/';};window.onload=function(){var s=document.createElement('script');s.src="/static/js/main.0d0338ae.js";s.async=true;document.body.appendChild(s);}</script><link rel=stylesheet href=/static/css/main.0603c539.css></div></div><div class=sidebar-toggle><div class=sidebar-toggle-line-wrap><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id=sidebar class=sidebar><div class=sidebar-inner><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target=post-toc-wrap>Table of Contents<li class=sidebar-nav-overview data-target=site-overview>Overview</ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image src=/images/avatar/avatar-admin.jpg alt=ookamiAntD><p class=site-author-name itemprop=name>ookamiAntD<p class="site-description motion-element" itemprop=description>码渣 | rocker | 二次元 | 美剧 | 宅</div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href=/archives><span class=site-state-item-count>46</span>
<span class=site-state-item-name>posts</span></a></div><div class="site-state-item site-state-categories"><a href=/categories><span class=site-state-item-count>17</span>
<span class=site-state-item-name>categories</span></a></div><div class="site-state-item site-state-tags"><a href=/tags><span class=site-state-item-count>43</span>
<span class=site-state-item-name>tags</span></a></div></nav><div class="feed-link motion-element"><a href=/atom.xml rel=alternate><i class="fa fa-rss"></i>RSS</a></div><div class="links-of-author motion-element"><span class=links-of-author-item><a href=https://github.com/masteranthoneyd target=_blank rel="external nofollow noopener noreferrer" title=GitHub><i class="fa fa-fw fa-github"></i>GitHub</a></span>
<span class=links-of-author-item><a href="https://www.facebook.com/profile.php?id=100014869064462" target=_blank rel="external nofollow noopener noreferrer" title=Facebook><i class="fa fa-fw fa-facebook"></i>Facebook</a></span>
<span class=links-of-author-item><a href=https://twitter.com/ookamiAntD target=_blank rel="external nofollow noopener noreferrer" title=Twitter><i class="fa fa-fw fa-twitter"></i>Twitter</a></span></div><div class="cc-license motion-element" itemprop=license><a href=https://creativecommons.org/licenses/by-sa/4.0/ class=cc-opacity target=_blank rel="external nofollow noopener noreferrer"><img src=/images/cc-by-sa.svg alt="Creative Commons"></a></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class=links-of-blogroll-title><i class="fa  fa-fw fa-globe"></i>大神们的博客</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://mercyblitz.github.io/ title=mercyblitz(Java劝退师) target=_blank rel="external nofollow noopener noreferrer">mercyblitz(Java劝退师)</a><li class=links-of-blogroll-item><a href=https://muyinchen.github.io/ title=知秋大神(真·大神) target=_blank rel="external nofollow noopener noreferrer">知秋大神(真·大神)</a><li class=links-of-blogroll-item><a href=http://crossoverjie.top/ title="crossoverJie's Blog" target=_blank rel="external nofollow noopener noreferrer">crossoverJie's Blog</a><li class=links-of-blogroll-item><a href=http://yemengying.com/ title="Giraffe's Home" target=_blank rel="external nofollow noopener noreferrer">Giraffe's Home</a></ul></div><div id=days></div><script>function show_date_time(){window.setTimeout("show_date_time()",1000);BirthDay=new Date("01/10/2017 12:34:56");today=new Date();timeold=(today.getTime()-BirthDay.getTime());sectimeold=timeold/1000
secondsold=Math.floor(sectimeold);msPerDay=24*60*60*1000
e_daysold=timeold/msPerDay
daysold=Math.floor(e_daysold);e_hrsold=(e_daysold-daysold)*24;hrsold=setzero(Math.floor(e_hrsold));e_minsold=(e_hrsold-hrsold)*60;minsold=setzero(Math.floor((e_hrsold-hrsold)*60));seconds=setzero(Math.floor((e_minsold-minsold)*60));document.getElementById('days').innerHTML="已运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒";}
function setzero(i){if(i<10)
{i="0"+i};return i;}
show_date_time();</script></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class=post-toc><div class=post-toc-content><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#Preface><span class=nav-number>1.</span> <span class=nav-text>Preface</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#Immutability模式><span class=nav-number>2.</span> <span class=nav-text>Immutability模式</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#Copy-on-Write模式><span class=nav-number>3.</span> <span class=nav-text>Copy-on-Write模式</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#线程本地存储模式><span class=nav-number>4.</span> <span class=nav-text>线程本地存储模式</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#Guarded-Suspension模式><span class=nav-number>5.</span> <span class=nav-text>Guarded Suspension模式</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#Balking模式><span class=nav-number>6.</span> <span class=nav-text>Balking模式</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#Thread-Per-Message模式><span class=nav-number>7.</span> <span class=nav-text>Thread-Per-Message模式</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#Worker-Thread模式><span class=nav-number>8.</span> <span class=nav-text>Worker Thread模式</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#两阶段终止模式><span class=nav-number>9.</span> <span class=nav-text>两阶段终止模式</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#生产者-消费者模式><span class=nav-number>10.</span> <span class=nav-text>生产者-消费者模式</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#STM-amp-MVCC><span class=nav-number>11.</span> <span class=nav-text>STM&amp;MVCC</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#总结><span class=nav-number>12.</span> <span class=nav-text>总结</span></a></ol></div></div></section></div></aside></div></main><footer id=footer class=footer><div class=footer-inner><div class=busuanzi-count><script async src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span class=site-uv><i class="fa fa-user">本站访客数</i><span class=busuanzi-value id=busuanzi_value_site_uv></span>人次</span>
<span class=site-pv><i class="fa fa-eye">本站总访问量</i><span class=busuanzi-value id=busuanzi_value_site_pv></span>次</span></div><div class=copyright>&copy; 2016 -
<span itemprop=copyrightYear>2020</span>
<span class=with-love><i class="fa fa-flash"></i></span><span class=author itemprop=copyrightHolder>Hosted by <a href=https://pages.coding.me style=font-weight:700 rel="external nofollow noopener noreferrer" target=_blank>Coding Pages</a></span> | <span class=post-count>共277.3k字</span></div><div class=theme-info><a target=_blank href=http://www.miibeian.gov.cn/ rel=nofollow style=color:#555>粤ICP备18135202号-1</a></div><div style="width:300px;margin:0 auto"><a target=_blank href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44010602005896" style=display:inline-block;text-decoration:none;height:20px;line-height:20px><img src=https://cdn.yangbingdong.com/img/beian/beian.png style=float:left><p style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#555">粤公网安备 44010602005896号</p></a></div></div></footer><div class=back-to-top><i class="fa fa-arrow-up"></i></div></div><script>if(Object.prototype.toString.call(window.Promise)!=='[object Function]'){window.Promise=null;}</script><script src="/lib/jquery/index.js?v=2.1.3"></script><script src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script src="/js/src/utils.js?v=5.1.0"></script><script src="/js/src/motion.js?v=5.1.0"></script><script src="/js/src/scrollspy.js?v=5.1.0"></script><script src="/js/src/post-details.js?v=5.1.0"></script><script src="/js/src/bootstrap.js?v=5.1.0"></script><script>var disqus_shortname='ookamiantd';var disqus_identifier='2019/java-concurrent-part5/';var disqus_title="并发设计模式";function run_disqus_script(disqus_script){var dsq=document.createElement('script');dsq.type='text/javascript';dsq.async=true;dsq.src='//'+disqus_shortname+'.disqus.com/'+disqus_script;(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(dsq);}
var disqus={load:function disqus(){if(typeof DISQUS!=='object'){(function(){var s=document.createElement('script');s.async=true;s.type='text/javascript';s.src='//'+disqus_shortname+'.disqus.com/embed.js';(document.getElementsByTagName('HEAD')[0]||document.getElementsByTagName('BODY')[0]).appendChild(s);}());$('#load-disqus').html("评论加载中，请确保你有梯子，若评论长时间未加载则你可能翻墙失败...").fadeOut(9000);}}}</script><script>var isfetched=false;var search_path="search.xml";if(search_path.length==0){search_path="search.xml";}
var path="/"+search_path;function proceedsearch(){$("body").append('<div class="popoverlay">').css('overflow','hidden');$('.popup').toggle();}
var searchFunc=function(path,search_id,content_id){'use strict';$.ajax({url:path,dataType:"xml",async:true,success:function(xmlResponse){isfetched=true;$('.popup').detach().appendTo('.header-inner');var datas=$("entry",xmlResponse).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()};}).get();var $input=document.getElementById(search_id);var $resultContent=document.getElementById(content_id);$input.addEventListener('input',function(){var matchcounts=0;var str='<ul class=\"search-result-list\">';var keywords=this.value.trim().toLowerCase().split(/[\s\-]+/);$resultContent.innerHTML="";if(this.value.trim().length>1){datas.forEach(function(data){var isMatch=false;var content_index=[];var data_title=data.title.trim().toLowerCase();var data_content=data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();var data_url=decodeURIComponent(data.url);var index_title=-1;var index_content=-1;var first_occur=-1;if(data_title!=''){keywords.forEach(function(keyword,i){index_title=data_title.indexOf(keyword);index_content=data_content.indexOf(keyword);if(index_title>=0||index_content>=0){isMatch=true;if(i==0){first_occur=index_content;}}});}
if(isMatch){matchcounts+=1;str+="<li><a href='"+data_url+"' class='search-result-title'>"+data_title+"</a>";var content=data.content.trim().replace(/<[^>]+>/g,"");if(first_occur>=0){var start=first_occur-20;var end=first_occur+80;if(start<0){start=0;}
if(start==0){end=50;}
if(end>content.length){end=content.length;}
var match_content=content.substring(start,end);keywords.forEach(function(keyword){var regS=new RegExp(keyword,"gi");match_content=match_content.replace(regS,"<b class=\"search-keyword\">"+keyword+"</b>");});str+="<p class=\"search-result\">"+match_content+"...</p>"}
str+="</li>";}})};str+="</ul>";if(matchcounts==0){str='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'}
if(keywords==""){str='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'}
$resultContent.innerHTML=str;});proceedsearch();}});}
$('.popup-trigger').click(function(e){e.stopPropagation();if(isfetched==false){searchFunc(path,'local-search-input','local-search-result');}else{proceedsearch();};});$('.popup-btn-close').click(function(e){$('.popup').hide();$(".popoverlay").remove();$('body').css('overflow','');});$('.popup').click(function(e){e.stopPropagation();});</script><script src=https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js></script><script>AV.initialize("usE0s6JGUeOiMcsVoRuHuv2B-gzGzoHsz","ewm6NEF07r83HbnOr63ptuKH");</script><script>function showTime(Counter){var query=new AV.Query(Counter);var entries=[];var $visitors=$(".leancloud_visitors");$visitors.each(function(){entries.push($(this).attr("id").trim());});query.containedIn('url',entries);query.find().done(function(results){var COUNT_CONTAINER_REF='.leancloud-visitors-count';if(results.length===0){$visitors.find(COUNT_CONTAINER_REF).text(0);return;}
for(var i=0;i<results.length;i++){var item=results[i];var url=item.get('url');var time=item.get('time');var element=document.getElementById(url);$(element).find(COUNT_CONTAINER_REF).text(time);}
for(var i=0;i<entries.length;i++){var url=entries[i];var element=document.getElementById(url);var countSpan=$(element).find(COUNT_CONTAINER_REF);if(countSpan.text()==''){countSpan.text(0);}}}).fail(function(object,error){console.log("Error: "+error.code+" "+error.message);});}
function addCount(Counter){var $visitors=$(".leancloud_visitors");var url=$visitors.attr('id').trim();var title=$visitors.attr('data-flag-title').trim();var query=new AV.Query(Counter);query.equalTo("url",url);query.find({success:function(results){if(results.length>0){var counter=results[0];counter.fetchWhenSave(true);counter.increment("time");counter.save(null,{success:function(counter){var $element=$(document.getElementById(url));$element.find('.leancloud-visitors-count').text(counter.get('time'));},error:function(counter,error){console.log('Failed to save Visitor num, with error message: '+error.message);}});}else{var newcounter=new Counter();var acl=new AV.ACL();acl.setPublicReadAccess(true);acl.setPublicWriteAccess(true);newcounter.setACL(acl);newcounter.set("title",title);newcounter.set("url",url);newcounter.set("time",1);newcounter.save(null,{success:function(newcounter){var $element=$(document.getElementById(url));$element.find('.leancloud-visitors-count').text(newcounter.get('time'));},error:function(newcounter,error){console.log('Failed to create');}});}},error:function(error){console.log('Error:'+error.code+" "+error.message);}});}
$(function(){var Counter=AV.Object.extend("Counter");if($('.leancloud_visitors').length==1){addCount(Counter);}else if($('.post-title-link').length>1){showTime(Counter);}});</script><script>(function(){var bp=document.createElement('script');var curProtocol=window.location.protocol.split(':')[0];if(curProtocol==='https'){bp.src='https://zz.bdstatic.com/linksubmit/push.js';}
else{bp.src='http://push.zhanzhang.baidu.com/push.js';}
var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script><script color=255,0,204 opacity=0.5 zindex=-2 count=40 src=//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js></script><script>$('body').delegate('.-mob-share-weixin-qrcode-bg','click',function(){$(".-mob-share-weixin-qrcode-close").trigger("click");});</script><canvas class=fireworks style=position:fixed;left:0;top:0;z-index:1;pointer-events:none></canvas>
<script src=//cdn.bootcss.com/animejs/2.2.0/anime.min.js></script><script src=/js/src/fireworks.js></script><script src=/js/src/dytitle.js></script></div></footer></div><script src=/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"superSample":2,"width":88,"height":88,"position":"left"},"mobile":{"show":false},"react":{"opacityDefault":0.9,"opacityOnHover":0.5},"log":false});</script>