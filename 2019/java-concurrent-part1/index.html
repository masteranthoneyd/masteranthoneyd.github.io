<!doctype html><html class="theme-next muse use-motion" lang=en><meta name=generator content="Hexo 3.9.0"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content=no-transform><meta http-equiv=cache-control content=no-siteapp><meta http-equiv=content-language content=zh-cn><script src=//cdn.bootcss.com/pace/1.0.2/pace.min.js></script><link href=//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css rel=stylesheet><style>.pace .pace-progress{background:#ff009e;height:2px}.pace .pace-progress-inner{box-shadow:0 0 10px #e6006b,0 0 5px #ff009e}.pace .pace-activity{border-top-color:#ff009e;border-left-color:#ff009e}</style><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel=stylesheet><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel=stylesheet><link href="/css/main.css?v=5.1.0" rel=stylesheet><meta name=keywords content=Java,Concurrent,><link rel=alternate href=/atom.xml title="ookamiAntD's Blog" type=application/atom+xml><link rel="shortcut icon" type=image/x-icon href="/favicon.png?v=5.1.0"><meta name=description content="时代在进步, 硬件也在进步, 为了提高 CPU 以及 IO 的利用率, 并发编程已经慢慢成为一项必备技能. 过往总对并发编程感到恐惧, 应为对其的陌生导致了编码方面的困难以及诸多的 BUG, 学习并发编程, 一定需要有一个系统性的学习过程."><meta name=keywords content=Java,Concurrent><meta property=og:type content=article><meta property=og:title content="Java 并发拾遗-并发理论基础"><meta property=og:url content=http://yangbingdong.com/2019/java-concurrent-part1/index.html><meta property=og:site_name content="ookamiAntD's Blog"><meta property=og:description content="时代在进步, 硬件也在进步, 为了提高 CPU 以及 IO 的利用率, 并发编程已经慢慢成为一项必备技能. 过往总对并发编程感到恐惧, 应为对其的陌生导致了编码方面的困难以及诸多的 BUG, 学习并发编程, 一定需要有一个系统性的学习过程."><meta property=og:locale content=en><meta property=og:image content=https://cdn.yangbingdong.com/img/concurrent/java-concurrnt-part1-banner.jpeg><meta property=og:image content=https://cdn.yangbingdong.com/img/concurrent/java-concurrent-generalization.png><meta property=og:image content=https://cdn.yangbingdong.com/img/concurrent/java-sync-lock-module.png><meta property=og:image content=https://cdn.yangbingdong.com/img/concurrent/java-sync-dead-lock.png><meta property=og:image content=https://cdn.yangbingdong.com/img/concurrent/java-break-dead-lock.png><meta property=og:image content=https://cdn.yangbingdong.com/img/concurrent/java-break-dead-lock02.png><meta property=og:image content=https://cdn.yangbingdong.com/img/concurrent/monitor-module01.png><meta property=og:image content=https://cdn.yangbingdong.com/img/concurrent/general-thread-module.png><meta property=og:image content=https://cdn.yangbingdong.com/img/concurrent/java-thread-module.png><meta property=og:image content=https://cdn.yangbingdong.com/img/concurrent/method-stack.png><meta property=og:updated_time content=2020-04-07T10:15:47.010Z><meta name=twitter:card content=summary><meta name=twitter:title content="Java 并发拾遗-并发理论基础"><meta name=twitter:description content="时代在进步, 硬件也在进步, 为了提高 CPU 以及 IO 的利用率, 并发编程已经慢慢成为一项必备技能. 过往总对并发编程感到恐惧, 应为对其的陌生导致了编码方面的困难以及诸多的 BUG, 学习并发编程, 一定需要有一个系统性的学习过程."><meta name=twitter:image content=https://cdn.yangbingdong.com/img/concurrent/java-concurrnt-part1-banner.jpeg><script id=hexo.configurations>var NexT=window.NexT||{};var CONFIG={root:'/',scheme:'Muse',sidebar:{"position":"right","display":"always"},fancybox:true,motion:true,duoshuo:{userId:'undefined',author:'Author'},algolia:{applicationID:'RI3NF6GUI0',apiKey:'3d33fa60ba30d3b17f37220bb1a36749',indexName:'blogIndex',hits:{"per_page":10},labels:{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}}};</script><link rel=canonical href=http://yangbingdong.com/2019/java-concurrent-part1/><script>(function(){if(''){if(prompt('请输入文章密码')!==''){alert('密码错误！');history.back();}}})();</script><title>Java 并发拾遗-并发理论基础 | ookamiAntD's Blog</title><body itemscope itemtype=http://schema.org/WebPage lang=en><script>var _hmt=_hmt||[];(function(){var hm=document.createElement("script");hm.src="https://hm.baidu.com/hm.js?e9505ac4e11d464329d615553a72b526";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script><div class="container one-collumn sidebar-position-right page-post-detail"><div class=headband></div><a href=https://github.com/masteranthoneyd/blog rel="external nofollow noopener noreferrer" target=_blank><img style=position:absolute;top:0;left:0;border:0 src=https://camo.githubusercontent.com/82b228a3648bf44fc1163ef44c62fcc60081495e/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f7265645f6161303030302e706e67 alt="Fork me on GitHub" data-canonical-src=https://s3.amazonaws.com/github/ribbons/forkme_left_red_aa0000.png></a><header id=header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-meta><div class=custom-logo-site-title><a href=/ class=brand rel=start><span class=logo-line-before><i></i></span><span class=site-title>ookamiAntD's Blog</span>
<span class=logo-line-after><i></i></span></a></div><h1 class=site-subtitle itemprop=description>Easy coding,easy life.</h1></div><div class=site-nav-toggle><button>
<span class=btn-bar></span><span class=btn-bar></span><span class=btn-bar></span></button></div><nav class=site-nav><ul id=menu class=menu><li class="menu-item menu-item-home"><a href=/ rel=section><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a><li class="menu-item menu-item-archives"><a href=/archives rel=section><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a><li class="menu-item menu-item-categories"><a href=/categories rel=section><i class="menu-item-icon fa fa-fw fa-th"></i><br>Categories</a><li class="menu-item menu-item-tags"><a href=/tags rel=section><i class="menu-item-icon fa fa-fw fa-tags"></i><br>Tags</a><li class="menu-item menu-item-about"><a href=/about rel=section><i class="menu-item-icon fa fa-fw fa-user"></i><br>About</a><li class="menu-item menu-item-guestbook"><a href=/guestbook rel=section><i class="menu-item-icon fa fa-fw fa-commenting"></i><br>Message</a><li class="menu-item menu-item-search"><a href=javascript:; class=popup-trigger><i class="menu-item-icon fa fa-search fa-fw"></i><br>Search</a></ul><div class=site-search><div class=popup><span class="search-icon fa fa-search"></span><input id=local-search-input><div id=local-search-result></div><span class=popup-btn-close>close</span></div></div></nav></div></header><main id=main class=main><div class=main-inner><div class=content-wrap><div id=content class=content><div id=posts class=posts-expand><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><link itemprop=mainEntityOfPage href=http://yangbingdong.com/2019/java-concurrent-part1/><span style=display:none itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=name content=ookamiAntD><meta itemprop=description content><meta itemprop=image content=/images/avatar/avatar-admin.jpg></span><span style=display:none itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="ookamiAntD's Blog"><span style=display:none itemprop=logo itemscope itemtype=http://schema.org/ImageObject><img style=display:none itemprop="url image" alt="ookamiAntD's Blog" src></span></span><header class=post-header><h2 class=post-title itemprop="name headline">Java 并发拾遗-并发理论基础</h2><div class=post-meta><span class=post-time><span class=post-meta-item-icon><i class="fa fa-calendar-o"></i></span><span class=post-meta-item-text>Posted on</span>
<time title="Post created" itemprop="dateCreated datePublished" datetime=2019-08-28T16:58:19+08:00>2019-08-28</time></span>
<span class=post-category><span class=post-meta-divider>|</span>
<span class=post-meta-item-icon><i class="fa fa-folder-o"></i></span><span class=post-meta-item-text>In</span>
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/Programming/ itemprop=url rel=index><span itemprop=name>Programming</span></a></span>
,
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/Programming/Java/ itemprop=url rel=index><span itemprop=name>Java</span></a></span>
,
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/Programming/Java/Concurrent/ itemprop=url rel=index><span itemprop=name>Concurrent</span></a></span></span>
<span id=/2019/java-concurrent-part1/ class=leancloud_visitors data-flag-title="Java 并发拾遗-并发理论基础"><span class=post-meta-divider>|</span>
<span class=post-meta-item-icon><i class="fa fa-eye"></i></span><span class=post-meta-item-text>Visitors</span>
<span class=leancloud-visitors-count></span></span><br><span class=post-time><span class=post-meta-item-icon><i class="fa fa-edit"></i></span><span class=post-meta-item-text>WordCount:</span>
<span class=post-count>5,117字</span>
<span class=post-meta-divider>|</span>
<span class=post-meta-item-text>min2read:</span>
<span class=post-count>20分钟</span></span></div></header><div class=post-body itemprop=articleBody><link rel=stylesheet href=https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css><p><img src=https://cdn.yangbingdong.com/img/concurrent/java-concurrnt-part1-banner.jpeg alt><blockquote><p>时代在进步, 硬件也在进步, 为了提高 CPU 以及 IO 的利用率, 并发编程已经慢慢成为一项必备技能. 过往总对并发编程感到恐惧, 应为对其的陌生导致了编码方面的困难以及诸多的 BUG, 学习并发编程, 一定需要有一个系统性的学习过程.</blockquote><a id=more></a><p>并发编程可以总结为三个核心问题: <strong>分工</strong>、<strong>同步</strong>、<strong>互斥</strong>.<p>所谓分工指的是如何高效地拆解任务并分配给线程, 而同步指的是线程之间如何协作, 互斥则是保证同一时刻只允许一个线程访问共享资源.<ul><li><p>分工 -&gt; <code>Executor</code>、<code>Fork/Join</code>、<code>Future</code>等<li><p>同步(核心技术是<strong>管程</strong>) -&gt; <code>CountDownLatch</code>、<code>CyclicBarrier</code>、<code>Phaser</code>、<code>Exchanger</code> 等<li><p>互斥(线程安全) -&gt; <code>synchronized</code>、<code>ReadWriteLock</code>、<code>StampedLock</code>、<code>ThreadLocal</code> 等</ul><p><img src=https://cdn.yangbingdong.com/img/concurrent/java-concurrent-generalization.png alt><h1 id=并发编程Bug的源头><a href=#并发编程Bug的源头 class=headerlink title=并发编程Bug的源头></a>并发编程Bug的源头</h1><p>现代CPU, 内存以及硬盘之间的速度差了个天跟地, 为了弥补短板, 计算机体系以及操作系统作出了重大贡献:<ul><li>CPU 增加了缓存, 以均衡与内存的速度差异;<li>操作系统增加了进程、线程, 以分时复用 CPU, 进而均衡 CPU 与 I/O 设备的速度差异;<li>编译程序优化指令执行次序, 使得缓存能够得到更加合理地利用.</ul><p><strong>源头之一: 缓存导致的可见性问题</strong>.<p>两核两个线程同时对变量i进行10000次+1操作, 但结果并不是20000, 而是小于20000. 因为CPU-A加完后的结果对CPU-B并不是马上可见的.<p><strong>源头之二: 线程切换带来的原子性问题.</strong><p>执行count += 1, 至少需要三条 CPU 指令:<ul><li>指令 1: 首先, 需要把变量 count 从内存加载到 CPU 的寄存器;<li>指令 2: 之后, 在寄存器中执行 +1 操作;<li>指令 3: 最后, 将结果写入内存(缓存机制导致可能写入的是 CPU 缓存而不是内存).</ul><p>有可能执行到指令1就发生了线程切换, 导致执行结果不符合预期.<p>操作系统做任务切换, 可以发生在<strong>任何一条CPU 指令</strong>执行完, 是的, 是 CPU 指令, 而不是高级语言里的一条语句CPU , 能保证的原子操作是 CPU 指令级别的.<p><strong>源头之三: 编译优化带来的有序性问题</strong>.<p>编译器为了优化性能, 有时候会改变程序中语句的先后顺序, 例如程序中: “a=6; b=7; “编译器优化后可能变成”b=7; a=6; “, 在这个例子中, 编译器调整了语句的顺序, 但是不影响程序的最终结果.<p>在 Java 领域一个经典的案例就是利用双重检查创建单例对象:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>Singleton</span> </span>&#123;</span><br><span class=line>    <span class=keyword>static</span> Singleton instance;</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>static</span> Singleton <span class=title>getInstance</span><span class=params>()</span> </span>&#123;</span><br><span class=line>        <span class=keyword>if</span> (instance == <span class=keyword>null</span>) &#123;</span><br><span class=line>            <span class=keyword>synchronized</span> (Singleton<span class=class>.<span class=keyword>class</span>) </span>&#123;</span><br><span class=line>                <span class=keyword>if</span> (instance == <span class=keyword>null</span>) instance = <span class=keyword>new</span> Singleton();</span><br><span class=line>            &#125;</span><br><span class=line>        &#125;</span><br><span class=line>        <span class=keyword>return</span> instance;</span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br></pre></table></figure><p>关键点在 new 上面:<ol><li>分配一块内存 M;<li>在内存 M 上初始化 Singleton 对象;<li>然后 M 的地址赋值给 instance 变量.</ol><p>但是实际上优化后的执行路径却是这样的:<ol><li>分配一块内存 M;<li>将 M 的地址赋值给 instance 变量;<li>最后在内存 M 上初始化 Singleton 对象.</ol><h1 id=Java-内存模型><a href=#Java-内存模型 class=headerlink title="Java 内存模型"></a>Java 内存模型</h1><p>上面说到了并发编程 Bug 源头的其中两个就是可见性与有序性, 那么解决这两个问题最直接的办法就是<strong>禁用缓存和编译优化</strong>.<p>Java 内存模型通过定义多项规则对编译器和处理器进行限制, 主要是针对可见性和有序性. 这是个很复杂的规范, 可以从不同的视角来解读, 站在我们这些程序员的视角, 本质上可以理解为, Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法. 具体来说, 这些方法包括 <code>volatile</code>、<code>synchronized</code> 和 <code>final</code> 三个关键字, 以及 <strong>Happens-Before</strong> 规则.<p>先来看一段代码(假设线程A调用writer, 线程B调用reader方法):<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>VolatileExample</span> </span>&#123;</span><br><span class=line>  <span class=keyword>int</span> x = <span class=number>0</span>;</span><br><span class=line>  <span class=keyword>volatile</span> <span class=keyword>boolean</span> v = <span class=keyword>false</span>;</span><br><span class=line>  <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>writer</span><span class=params>()</span> </span>&#123;</span><br><span class=line>    x = <span class=number>42</span>;</span><br><span class=line>    v = <span class=keyword>true</span>;</span><br><span class=line>  &#125;</span><br><span class=line>  <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>reader</span><span class=params>()</span> </span>&#123;</span><br><span class=line>    <span class=keyword>if</span> (v == <span class=keyword>true</span>) &#123;</span><br><span class=line>      <span class=comment>// 这里x会是多少呢？</span></span><br><span class=line>    &#125;</span><br><span class=line>  &#125;</span><br><span class=line>&#125;</span><br></pre></table></figure><p>Happens-Before 的几条规则:<ul><li>程序的顺序性规则: 在一个线程内, 按照程序代码顺序, 书写在前面的操作先行发生于书写在后面的操作. 准确地说, 应该是控制流顺序而不是程序代码顺序, 因为要考虑分支、循环等结构.<li>volatile 变量规则: 如果 A Happens-Before B, 且 B Happens-Before C, 那么 A Happens-Before C.<li>管程中锁的规则(<strong>管程</strong>是一种通用的同步原语, 在 Java 中指的就是 synchronized, synchronized 是 Java 里对管程的实现): 对一个锁的解锁 Happens-Before 于后续对这个锁的加锁.<li>线程 <code>start()</code> 规则: 主线程 A 启动子线程 B 后, 子线程 B 能够看到主线程在启动子线程 B 前的操作.<li>线程 <code>join()</code> 规则: 主线程 A 等待子线程 B 完成(主线程 A 通过调用子线程 B 的 <code>join()</code> 方法实现), 当子线程 B 完成后(主线程 A 中 <code>join()</code> 方法返回), 主线程能够看到子线程的操作. 当然所谓的”看到”, 指的是对共享变量的操作.<li>线程中断规则: 对线程 <code>interrupt()</code> 方法的调用先行发生于被中断线程的代码检测到中断事件的发生, 可以通过 <code>Thread.interrupted()</code> 方法检测到是否有中断发生.<li>对象终结规则: 一个对象的初始化完成(构造函数执行结束)先行发生于它的 <code>finalize()</code> 方法的开始.</ul><h1 id=互斥锁><a href=#互斥锁 class=headerlink title=互斥锁></a>互斥锁</h1><blockquote><p><strong>锁, 应是私有的、不可变的、不可重用的.</strong></blockquote><p>原子性问题的源头是<strong>线程切换</strong>, 在单核时代, 可以通过禁用线程切换做到, 但并不适合多核 CPU.<p>32 位 CPU 上执行 long 型变量的写操作, long 型变量是 64 位, 在 32 位 CPU 上执行写操作会被拆分成两次写操作, 单核 CPU 可以通过禁止 CPU 中断保证原子性. 但在多核 CPU 上, 此时禁止 CPU 中断, 只能保证 CPU 上的线程连续执行, 并不能保证同一时刻只有一个线程执行.<p>互斥是为了<strong>同一时刻只有一个线程执行</strong>, 保证原子性. 如果我们能够保证对共享变量的修改是互斥的, 那么, 无论是单核 CPU 还是多核 CPU, 就都能保证原子性了.<p>Java 中通过 <code>synchronized</code> 关键字提供锁技术.<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>X</span> </span>&#123;</span><br><span class=line>  <span class=comment>// 修饰非静态方法</span></span><br><span class=line>  <span class=function><span class=keyword>synchronized</span> <span class=keyword>void</span> <span class=title>foo</span><span class=params>()</span> </span>&#123;</span><br><span class=line>    <span class=comment>// 临界区</span></span><br><span class=line>  &#125;</span><br><span class=line>  <span class=comment>// 修饰静态方法</span></span><br><span class=line>  <span class=function><span class=keyword>synchronized</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>bar</span><span class=params>()</span> </span>&#123;</span><br><span class=line>    <span class=comment>// 临界区</span></span><br><span class=line>  &#125;</span><br><span class=line>  <span class=comment>// 修饰代码块</span></span><br><span class=line>  Object obj = <span class=keyword>new</span> Object(); </span><br><span class=line>  <span class=function><span class=keyword>void</span> <span class=title>baz</span><span class=params>()</span> </span>&#123;</span><br><span class=line>    <span class=keyword>synchronized</span>(obj) &#123;</span><br><span class=line>      <span class=comment>// 临界区</span></span><br><span class=line>    &#125;</span><br><span class=line>  &#125;</span><br><span class=line>&#125;</span><br></pre></table></figure><p><img src=https://cdn.yangbingdong.com/img/concurrent/java-sync-lock-module.png alt><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Account</span> </span>&#123;</span><br><span class=line>  <span class=keyword>private</span> <span class=keyword>int</span> balance;</span><br><span class=line>  <span class=comment>// 转账</span></span><br><span class=line>  <span class=function><span class=keyword>synchronized</span> <span class=keyword>void</span> <span class=title>transfer</span><span class=params>(</span></span></span><br><span class=line><span class=function><span class=params>      Account target, <span class=keyword>int</span> amt)</span></span>&#123;</span><br><span class=line>    <span class=keyword>if</span> (<span class=keyword>this</span>.balance &gt; amt) &#123;</span><br><span class=line>      <span class=keyword>this</span>.balance -= amt;</span><br><span class=line>      target.balance += amt;</span><br><span class=line>    &#125;</span><br><span class=line>  &#125; </span><br><span class=line>&#125;</span><br></pre></table></figure><p>以上代码只能对 <code>this.balance</code> 进行临界保护, 但 <code>target.balance</code> 可能会出现并发问题. 可采取使用同一个锁(在构造函数中传入)或者直接将 <code>Account.class</code> 作为锁对象(性能慢).<p><strong>一个合理的受保护资源与锁之间的关联关系应该是 N:1</strong>.<h2 id=错误的加锁方式><a href=#错误的加锁方式 class=headerlink title=错误的加锁方式></a>错误的加锁方式</h2><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>SafeCalc</span> </span>&#123;</span><br><span class=line>  <span class=keyword>long</span> value = <span class=number>0L</span>;</span><br><span class=line>  <span class=function><span class=keyword>long</span> <span class=title>get</span><span class=params>()</span> </span>&#123;</span><br><span class=line>    <span class=keyword>synchronized</span> (<span class=keyword>new</span> Object()) &#123;</span><br><span class=line>      <span class=keyword>return</span> value;</span><br><span class=line>    &#125;</span><br><span class=line>  &#125;</span><br><span class=line>  <span class=function><span class=keyword>void</span> <span class=title>addOne</span><span class=params>()</span> </span>&#123;</span><br><span class=line>    <span class=keyword>synchronized</span> (<span class=keyword>new</span> Object()) &#123;</span><br><span class=line>      value += <span class=number>1</span>;</span><br><span class=line>    &#125;</span><br><span class=line>  &#125;</span><br><span class=line>&#125;</span><br></pre></table></figure><p>上面的 <code>synchronized (new Object())</code> 代码, 每次加锁都是不同的锁, 相当于无锁, JVM 开启逃逸分析之后, <code>synchronized (new Object())</code> 这行代码在实际执行的时候会被优化掉, 也就是说在真实执行的时候, 这行代码压根就不存在.<p>再来看一段代码:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Account</span> </span>&#123;</span><br><span class=line>  <span class=comment>// 账户余额  </span></span><br><span class=line>  <span class=keyword>private</span> Integer balance;</span><br><span class=line>  <span class=comment>// 账户密码</span></span><br><span class=line>  <span class=keyword>private</span> String password;</span><br><span class=line>  <span class=comment>// 取款</span></span><br><span class=line>  <span class=function><span class=keyword>void</span> <span class=title>withdraw</span><span class=params>(Integer amt)</span> </span>&#123;</span><br><span class=line>    <span class=keyword>synchronized</span>(balance) &#123;</span><br><span class=line>      <span class=keyword>if</span> (<span class=keyword>this</span>.balance &gt; amt)&#123;</span><br><span class=line>        <span class=keyword>this</span>.balance -= amt;</span><br><span class=line>      &#125;</span><br><span class=line>    &#125;</span><br><span class=line>  &#125; </span><br><span class=line>  <span class=comment>// 更改密码</span></span><br><span class=line>  <span class=function><span class=keyword>void</span> <span class=title>updatePassword</span><span class=params>(String pw)</span></span>&#123;</span><br><span class=line>    <span class=keyword>synchronized</span>(password) &#123;</span><br><span class=line>      <span class=keyword>this</span>.password = pw;</span><br><span class=line>    &#125;</span><br><span class=line>  &#125; </span><br><span class=line>&#125;</span><br></pre></table></figure><p>上面代码有两个核心问题:<ul><li><code>balance</code> 以及 <code>password</code> 是可变的, 一变化就是去了互斥的功能.<li>Integer 以及 String 都是可能被重用, 如果别的代码锁住没有释放的完了.</ul><h2 id=死锁><a href=#死锁 class=headerlink title=死锁></a>死锁</h2><p>上面提到的同步方案中将 <code>Account.class</code> 作为所对象, 相当于串行化了, 性能大打折扣, 为了取得更高的性能, 可以采用细粒度锁, 使用细粒度锁可以提高并行度, 是性能优化的一个重要手段.<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Account</span> </span>&#123;</span><br><span class=line>  <span class=keyword>private</span> <span class=keyword>int</span> balance;</span><br><span class=line>  <span class=comment>// 转账</span></span><br><span class=line>  <span class=function><span class=keyword>void</span> <span class=title>transfer</span><span class=params>(Account target, <span class=keyword>int</span> amt)</span></span>&#123;</span><br><span class=line>    <span class=comment>// 锁定转出账户</span></span><br><span class=line>    <span class=keyword>synchronized</span>(<span class=keyword>this</span>) &#123;              </span><br><span class=line>      <span class=comment>// 锁定转入账户</span></span><br><span class=line>      <span class=keyword>synchronized</span>(target) &#123;           </span><br><span class=line>        <span class=keyword>if</span> (<span class=keyword>this</span>.balance &gt; amt) &#123;</span><br><span class=line>          <span class=keyword>this</span>.balance -= amt;</span><br><span class=line>          target.balance += amt;</span><br><span class=line>        &#125;</span><br><span class=line>      &#125;</span><br><span class=line>    &#125;</span><br><span class=line>  &#125; </span><br><span class=line>&#125;</span><br></pre></table></figure><p>以上代码会出现死锁, 如果两个线程分别调用 Account-A 以及 Account-B 转账操作, 会出现相互等待的情况.<p><img src=https://cdn.yangbingdong.com/img/concurrent/java-sync-dead-lock.png alt><p>只有以下这四个条件都发生时才会出现死锁:<ol><li>互斥, 共享资源 X 和 Y 只能被一个线程占用;<li>占有且等待, 线程 T1 已经取得共享资源 X, 在等待共享资源 Y 的时候, 不释放共享资源 X;<li>不可抢占, 其他线程不能强行抢占线程 T1 占有的资源;<li>循环等待, 线程 T1 等待线程 T2 占有的资源, 线程 T2 等待线程 T1 占有的资源, 就是循环等待.</ol><p><strong>只要破坏其中一个, 就可以成功避免死锁的发生.</strong><p>其中互斥不能破坏, 其他三个都是可破坏的.<ol><li><p>对于”占用且等待”, 我们可以一次性申请所有的资源.<li><p>对于”不可抢占”这个条件, 占用部分资源的线程进一步申请其他资源时, 如果申请不到, 可以主动释放它占有的资源.<li><p>对于”循环等待”这个条件, 可以靠按序申请资源来预防(加锁顺序一直).</ol><p>对于破坏占用且等待条件(增加一个管理员, 只有同时拿到两个资源才能执行转账操作):<p><img src=https://cdn.yangbingdong.com/img/concurrent/java-break-dead-lock.png alt><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Allocator</span> </span>&#123;</span><br><span class=line>  <span class=keyword>private</span> List&lt;Object&gt; als =</span><br><span class=line>    <span class=keyword>new</span> ArrayList&lt;&gt;();</span><br><span class=line>  <span class=comment>// 一次性申请所有资源</span></span><br><span class=line>  <span class=function><span class=keyword>synchronized</span> <span class=keyword>boolean</span> <span class=title>apply</span><span class=params>(</span></span></span><br><span class=line><span class=function><span class=params>    Object from, Object to)</span></span>&#123;</span><br><span class=line>    <span class=keyword>if</span>(als.contains(from) ||</span><br><span class=line>         als.contains(to))&#123;</span><br><span class=line>      <span class=keyword>return</span> <span class=keyword>false</span>;  </span><br><span class=line>    &#125; <span class=keyword>else</span> &#123;</span><br><span class=line>      als.add(from);</span><br><span class=line>      als.add(to);  </span><br><span class=line>    &#125;</span><br><span class=line>    <span class=keyword>return</span> <span class=keyword>true</span>;</span><br><span class=line>  &#125;</span><br><span class=line>  <span class=comment>// 归还资源</span></span><br><span class=line>  <span class=function><span class=keyword>synchronized</span> <span class=keyword>void</span> <span class=title>free</span><span class=params>(</span></span></span><br><span class=line><span class=function><span class=params>    Object from, Object to)</span></span>&#123;</span><br><span class=line>    als.remove(from);</span><br><span class=line>    als.remove(to);</span><br><span class=line>  &#125;</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line><span class=class><span class=keyword>class</span> <span class=title>Account</span> </span>&#123;</span><br><span class=line>  <span class=comment>// actr应该为单例</span></span><br><span class=line>  <span class=keyword>private</span> Allocator actr;</span><br><span class=line>  <span class=keyword>private</span> <span class=keyword>int</span> balance;</span><br><span class=line>  <span class=comment>// 转账</span></span><br><span class=line>  <span class=function><span class=keyword>void</span> <span class=title>transfer</span><span class=params>(Account target, <span class=keyword>int</span> amt)</span></span>&#123;</span><br><span class=line>    <span class=comment>// 一次性申请转出账户和转入账户, 直到成功</span></span><br><span class=line>    <span class=keyword>while</span>(!actr.apply(<span class=keyword>this</span>, target))</span><br><span class=line>      ; </span><br><span class=line>    <span class=keyword>try</span>&#123;</span><br><span class=line>      <span class=comment>// 锁定转出账户</span></span><br><span class=line>      <span class=keyword>synchronized</span>(<span class=keyword>this</span>)&#123;              </span><br><span class=line>        <span class=comment>// 锁定转入账户</span></span><br><span class=line>        <span class=keyword>synchronized</span>(target)&#123;           </span><br><span class=line>          <span class=keyword>if</span> (<span class=keyword>this</span>.balance &gt; amt)&#123;</span><br><span class=line>            <span class=keyword>this</span>.balance -= amt;</span><br><span class=line>            target.balance += amt;</span><br><span class=line>          &#125;</span><br><span class=line>        &#125;</span><br><span class=line>      &#125;</span><br><span class=line>    &#125; <span class=keyword>finally</span> &#123;</span><br><span class=line>      actr.free(<span class=keyword>this</span>, target)</span><br><span class=line>    &#125;</span><br><span class=line>  &#125; </span><br><span class=line>&#125;</span><br></pre></table></figure><h1 id=等待-通知><a href=#等待-通知 class=headerlink title=等待-通知></a>等待-通知</h1><p>在上面<strong>破坏占用且等待条件</strong>的时候, 使用了死循环的方式来循环等待, 核心代码如下:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=comment>// 一次性申请转出账户和转入账户, 直到成功</span></span><br><span class=line><span class=keyword>while</span>(!actr.apply(<span class=keyword>this</span>, target))</span><br><span class=line>  ;</span><br></pre></table></figure><p>这种写法太消耗性能, 比较好的做法就是不满足条件, 则等待, 满足后, 同时等待的线程重新执行.<p>类比(就医流程):<ol><li>患者先去挂号, 然后到就诊门口分诊, 等待叫号;<li>当叫到自己的号时, 患者就可以找大夫就诊了;<li>就诊过程中, 大夫可能会让患者去做检查, 同时叫下一位患者;<li>当患者做完检查后, 拿检测报告重新分诊, 等待叫号;<li>当大夫再次叫到自己的号时, 患者再去找大夫就诊.</ol><p>在 Java 语言里, 等待 - 通知机制可以有多种实现方式, 比如 Java 语言内置的 <code>synchronized</code> 配合 <code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code> 这三个方法就能轻松实现.<p><img src=https://cdn.yangbingdong.com/img/concurrent/java-break-dead-lock02.png alt><p>这个等待队列和互斥锁是一对一的关系, 每个互斥锁都有自己独立的等待队列.<p><code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code> 都是在 <code>synchronized{}</code>内部被调用的. 如果在 <code>synchronized{}</code>外部调用, 或者锁定的 <code>this</code>, 而用 <code>target.wait()</code> 调用的话, JVM 会抛出一个运行时异常: <code>java.lang.IllegalMonitorStateException</code>.<p>将之前的 <code>Allocator</code> 改造一下:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Allocator</span> </span>&#123;</span><br><span class=line>  <span class=keyword>private</span> List&lt;Object&gt; als;</span><br><span class=line>  <span class=comment>// 一次性申请所有资源</span></span><br><span class=line>  <span class=function><span class=keyword>synchronized</span> <span class=keyword>void</span> <span class=title>apply</span><span class=params>(</span></span></span><br><span class=line><span class=function><span class=params>    Object from, Object to)</span></span>&#123;</span><br><span class=line>    <span class=comment>// 经典写法</span></span><br><span class=line>    <span class=keyword>while</span>(als.contains(from) ||</span><br><span class=line>         als.contains(to))&#123;</span><br><span class=line>      <span class=keyword>try</span>&#123;</span><br><span class=line>        wait();</span><br><span class=line>      &#125;<span class=keyword>catch</span>(Exception e)&#123;</span><br><span class=line>      &#125;   </span><br><span class=line>    &#125; </span><br><span class=line>    als.add(from);</span><br><span class=line>    als.add(to);  </span><br><span class=line>  &#125;</span><br><span class=line>  <span class=comment>// 归还资源</span></span><br><span class=line>  <span class=function><span class=keyword>synchronized</span> <span class=keyword>void</span> <span class=title>free</span><span class=params>(</span></span></span><br><span class=line><span class=function><span class=params>    Object from, Object to)</span></span>&#123;</span><br><span class=line>    als.remove(from);</span><br><span class=line>    als.remove(to);</span><br><span class=line>    notifyAll();</span><br><span class=line>  &#125;</span><br><span class=line>&#125;</span><br></pre></table></figure><p>wait与sleep区别在于:<ol><li>wait会释放所有锁而sleep不会释放锁资源.<li>wait只能在同步方法和同步块中使用, 而sleep任何地方都可以.<li>wait无需捕捉异常, 而sleep需要.<li>sleep是Thread的方法, 而wait是Object类的方法.</ol><p>两者相同点: 都会让渡CPU执行时间, 等待再次调度！<h1 id=安全性、活跃性以及性能问题><a href=#安全性、活跃性以及性能问题 class=headerlink title=安全性、活跃性以及性能问题></a>安全性、活跃性以及性能问题</h1><p><strong>安全性</strong>:<ul><li>数据竞争: 多个线程同时访问一个数据, 并且至少有一个线程会写这个数据.<li>竞态条件: 程序的执行结果依赖程序执行的顺序.</ul><p><strong>活跃性</strong>:<ul><li>死锁: 破坏造成死锁的条件,<ol><li>使用等待-通知机制的Allocator;<li>主动释放占有的资源;<li>按顺序获取资源.</ol><li>活锁: 虽然没有发生阻塞, 但仍会存在执行不下去的情况(两个线程相互谦让). 解决办法, 等待随机的时间, 例如Raft算法中重新选举leader.<li>饥饿: 我想到了没有引入时间片概念时, cpu处理作业. 如果遇到长作业, 会导致短作业饥饿. 如果优先处理短作业, 则会饿死长作业. 长作业就可以类比持有锁的时间过长, 而时间片可以让cpu资源公平地分配给各个作业. 当然, 如果有无穷多的cpu, 就可以让每个作业得以执行, 就不存在饥饿了.</ul><p><strong>性能</strong>:<p>核心就是在保证安全性和活跃性的前提下, 根据实际情况, 尽量降低锁的粒度. 即尽量减少持有锁的时间. JDK的并发包里, 有很多特定场景针对并发性能的设计. 还有很多无锁化的设计, 例如MVCC, TLS, COW等, 可以根据不同的场景选用不同的数据结构或设计.<p><strong>并发编程是一个复杂的技术领域, 微观上涉及到原子性问题、可见性问题和有序性问题, 宏观则表现为安全性、活跃性以及性能问题.</strong><h1 id=管程><a href=#管程 class=headerlink title=管程></a>管程</h1><p>管程是一种<strong>概念</strong>, 任何语言都可以通用, 对应的英文是 Monitor, 很多 Javaer 都喜欢将其翻译成”监视器”, 这是直译.<p>所谓管程, 指的是<strong>管理共享变量以及对共享变量的操作过程</strong>, 让他们支持并发.<p>在管程的发展史上, 先后出现过三种不同的管程模型, 分别是: Hasen 模型、Hoare 模型和 MESA 模型. 其中, 现在广泛应用的是 MESA 模型, 并且 Java 管程的实现参考的也是 MESA 模型.<p><img src=https://cdn.yangbingdong.com/img/concurrent/monitor-module01.png alt><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>BlockedQueue</span>&lt;<span class=title>T</span>&gt;</span>&#123;</span><br><span class=line>  <span class=keyword>final</span> Lock lock =</span><br><span class=line>    <span class=keyword>new</span> ReentrantLock();</span><br><span class=line>  <span class=comment>// 条件变量: 队列不满  </span></span><br><span class=line>  <span class=keyword>final</span> Condition notFull =</span><br><span class=line>    lock.newCondition();</span><br><span class=line>  <span class=comment>// 条件变量: 队列不空  </span></span><br><span class=line>  <span class=keyword>final</span> Condition notEmpty =</span><br><span class=line>    lock.newCondition();</span><br><span class=line></span><br><span class=line>  <span class=comment>// 入队</span></span><br><span class=line>  <span class=function><span class=keyword>void</span> <span class=title>enq</span><span class=params>(T x)</span> </span>&#123;</span><br><span class=line>    lock.lock();</span><br><span class=line>    <span class=keyword>try</span> &#123;</span><br><span class=line>      <span class=keyword>while</span> (队列已满)&#123;</span><br><span class=line>        <span class=comment>// 等待队列不满 </span></span><br><span class=line>        notFull.await();</span><br><span class=line>      &#125;  </span><br><span class=line>      <span class=comment>// 省略入队操作...</span></span><br><span class=line>      <span class=comment>//入队后,通知可出队</span></span><br><span class=line>      notEmpty.signal();</span><br><span class=line>    &#125;<span class=keyword>finally</span> &#123;</span><br><span class=line>      lock.unlock();</span><br><span class=line>    &#125;</span><br><span class=line>  &#125;</span><br><span class=line>  <span class=comment>// 出队</span></span><br><span class=line>  <span class=function><span class=keyword>void</span> <span class=title>deq</span><span class=params>()</span></span>&#123;</span><br><span class=line>    lock.lock();</span><br><span class=line>    <span class=keyword>try</span> &#123;</span><br><span class=line>      <span class=keyword>while</span> (队列已空)&#123;</span><br><span class=line>        <span class=comment>// 等待队列不空</span></span><br><span class=line>        notEmpty.await();</span><br><span class=line>      &#125;</span><br><span class=line>      <span class=comment>// 省略出队操作...</span></span><br><span class=line>      <span class=comment>//出队后, 通知可入队</span></span><br><span class=line>      notFull.signal();</span><br><span class=line>    &#125;<span class=keyword>finally</span> &#123;</span><br><span class=line>      lock.unlock();</span><br><span class=line>    &#125;  </span><br><span class=line>  &#125;</span><br><span class=line>&#125;</span><br></pre></table></figure><h1 id=Java-线程><a href=#Java-线程 class=headerlink title="Java 线程"></a>Java 线程</h1><p>在 Java 领域, 实现并发程序的主要手段就是多线程. 线程是操作系统里的一个概念, 虽然各种不同的开发语言如 Java、C# 等都对其进行了封装, 但是万变不离操作系统. Java 语言里的线程本质上就是操作系统的线程, 它们是一一对应的.<p>通用的线程生命周期:<p><img src=https://cdn.yangbingdong.com/img/concurrent/general-thread-module.png alt><p>Java 中线程的生命周期(对应 Thread.State 枚举类):<p><img src=https://cdn.yangbingdong.com/img/concurrent/java-thread-module.png alt><ul><li>RUNNABLE 与 BLOCKED 的状态转换: 只有一种场景会触发这种转换, 就是线程等待 synchronized 的隐式锁.<li>RUNNABLE 与 WAITING 的状态转换(三种场景):<ul><li>第一种场景, 获得 <code>synchronized</code> 隐式锁的线程, 调用无参数的 Object.wait() 方法;<li>第二种场景, 调用无参数的 <code>Thread.join()</code> 方法;<li>第三种场景, 调用 <code>LockSupport.park()</code> 方法.</ul><li>RUNNABLE 与 TIMED_WAITING 的状态转换(五种场景):<ul><li>调用<strong>带超时参数</strong>的 <code>Thread.sleep(long millis)</code> 方法;<li>获得 synchronized 隐式锁的线程, 调用<strong>带超时参数</strong>的 <code>Object.wait(long timeout)</code> 方法;<li>调用<strong>带超时参数</strong>的 <code>Thread.join(long millis)</code> 方法;<li>调用<strong>带超时参数</strong>的 <code>LockSupport.parkNanos(Object blocker, long deadline)</code> 方法;<li>调用<strong>带超时参数</strong>的 <code>LockSupport.parkUntil(long deadline)</code> 方法.</ul><li>从 NEW 到 RUNNABLE 状态: 调用了 <code>Thread.start()</code> 实例方法.<li>从 RUNNABLE 到 TERMINATED 状态:<ul><li><code>run()</code> 方法跑完;<li>程序异常退出终止;<li>调用 <code>interrupt()</code> 抛出 throws InterruptedException 异常.</ul></ul><p><strong>stop() 和 interrupt() 方法的主要区别</strong>:<p><code>stop()</code> 方法会真的<strong>杀死</strong>线程, 不给线程喘息的机会, 如果线程持有 <code>ReentrantLock</code> 锁, 被 <code>stop()</code> 的线程并不会自动调用 <code>ReentrantLock</code> 的 <code>unlock()</code> 去释放锁, 那其他线程就再也没机会获得 <code>ReentrantLock</code> 锁, 这实在是太危险了. 所以该方法就不建议使用了, 类似的方法还有 <code>suspend()</code> 和 <code>resume()</code> 方法, 这两个方法同样也都不建议使用了.<p>而 interrupt 是一个状态, 当线程 A 处于 WAITING、TIMED_WAITING 状态时, 如果其他线程调用线程 A 的 <code>interrupt()</code> 方法, 会使线程 A 返回到 RUNNABLE 状态, 同时线程 A 的代码会触发 <code>InterruptedException</code> 异常. 上面我们提到转换到 WAITING、TIMED_WAITING 状态的触发条件, 都是调用了类似 <code>wait()</code>、<code>join()</code>、<code>sleep()</code> 这样的方法, 我们看这些方法的签名, 发现都会 <code>throws InterruptedException</code> 这个异常. 这个异常的触发条件就是: 其他线程调用了该线程的 <code>interrupt()</code> 方法.<h2 id=创建多少线程才合适><a href=#创建多少线程才合适 class=headerlink title=创建多少线程才合适></a>创建多少线程才合适</h2><p>多线程的本质就是提高 CPU 以及 IO 的利用率, 但是对于设置多少线程, 对于不同的场景计算方式不一样.<p>对于 <strong>CPU 密集型</strong>的计算场景, 理论上”线程的数量 =CPU 核数”就是最合适的. 不过在工程上, 线程的数量一般会设置为”<strong>CPU 核数 +1</strong>“, 这样的话, 当线程因为偶尔的内存页失效或其他原因导致阻塞时, 这个额外的线程可以顶上, 从而保证 CPU 的利用率.<p>对于 <strong>IO 密集型</strong>的场景, 最佳线程数 = CPU 核数 * [ 1 +(I/O 耗时 / CPU 耗时)].<h2 id=为什么局部变量是线程安全的><a href=#为什么局部变量是线程安全的 class=headerlink title=为什么局部变量是线程安全的></a>为什么局部变量是线程安全的</h2><p>CPU 去哪里找到调用方法的参数和返回地址: 通过 CPU 的<strong>堆栈寄存器</strong>, CPU 支持一种栈结构, 就像手枪的弹夹, 先入后出. 因为这个栈是和方法调用相关的, 因此经常被称为<strong>调用栈</strong>.<p>每个方法在调用栈里都有自己的独立空间, 称为<strong>栈帧</strong>, 每个栈帧里都有对应方法需要的参数和返回地址. 当<strong>调用</strong>方法时, 会创建新的栈帧, 并<strong>压入</strong>调用栈; 当方法<strong>返回</strong>时, 对应的栈帧就会被自动<strong>弹出</strong>. 也就是说, <strong>栈帧和方法是同生共死的</strong>.<p>局部变量的<strong>作用域是方法内部</strong>, 而方法与调用栈共存亡, 所以<strong>局部变量就是放到了调用栈里</strong>.<p><img src=https://cdn.yangbingdong.com/img/concurrent/method-stack.png alt><p><strong>调用栈与线程的关系</strong>: 每个线程都有自己独立的调用栈. 因为每个线程都有自己的调用栈, 局部变量保存在线程各自的调用栈里面, <strong>不会共享</strong>, 所以自然也就没有并发问题. 没有共享, 就没有伤害.<h1 id=Finally><a href=#Finally class=headerlink title=Finally></a>Finally</h1><blockquote><p>参考: <strong><em><a href=https://time.geekbang.org/column/intro/159 rel="external nofollow noopener noreferrer" target=_blank>https://time.geekbang.org/column/intro/159</a></em></strong></blockquote></div><div style=text-align:center;color:#ccc;font-size:14px>---------------- The End ----------------</div><div><div id=wechat_subscriber style="display:block;padding:10px 0;margin:20px auto;width:100%;text-align:center"><img id=wechat_subscriber_qcode src=/images/wechat/gongzhonghao.jpg alt="ookamiAntD wechat" style=width:200px;max-width:100%><div>欢迎您扫一扫上面的微信公众号，订阅我的博客！</div></div></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>谢谢大爷～</div><button id=rewardButton disable=enable onclick="var qr=document.getElementById('QR');if(qr.style.display==='none'){qr.style.display='block';}else{qr.style.display='none'}">
<span>赏</span></button><div id=QR style=display:none><div id=wechat style=display:inline-block><img id=wechat_qr src=/images/donate/wechat.png alt="ookamiAntD WeChat Pay"><p>微信打赏</div><div id=alipay style=display:inline-block><img id=alipay_qr src=/images/donate/alipay.jpg alt="ookamiAntD Alipay"><p>支付宝打赏</div></div></div></div><div><p id=div-border-left-red>Author：<b>ookamiAntD Yang</b><br>Link：<a href=/2019/java-concurrent-part1/ title="Java 并发拾遗-并发理论基础">http://yangbingdong.com/2019/java-concurrent-part1/</a><br>Contact：<a>yangbingdong1994@gmail.com</a><br><b>本文基于<a target=_blank title="Creative Commons Attribution-ShareAlike 4.0 International (CC BY-SA 4.0)" href=http://creativecommons.org/licenses/by-sa/4.0/ rel="external nofollow noopener noreferrer"> 知识共享署名-相同方式共享 4.0 </a>国际许可协议发布</b><br><b>转载请注明出处，谢谢！</b></div><footer class=post-footer><div class=post-tags><a href=/tags/Java/ rel=tag><i class="fa fa-tag"></i>Java</a>
<a href=/tags/Concurrent/ rel=tag><i class="fa fa-tag"></i>Concurrent</a></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/2019/spring-boot-data-jpa-learning/ rel=next title="Spring Data JPA 拾遗"><i class="fa fa-chevron-left"></i>Spring Data JPA 拾遗</a></div><span class=post-nav-divider></span><div class="post-nav-prev post-nav-item"><a href=/2019/java-concurrent-part2/ rel=prev title="Java 并发拾遗-并发工具(上)">Java 并发拾遗-并发工具(上) <i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class=post-spread><div class=-hoofoo-share-title>分享到：</div><div class=-hoofoo-share-buttons><div class="-mob-share-weibo -hoofoo-share-weibo -hoofoo-share-ui-button"><i class="fa fa-weibo" aria-hidden=true></i></div><div class="-mob-share-weixin -hoofoo-share-weixin -hoofoo-share-ui-button"><i class="fa fa-weixin" aria-hidden=true></i></div><div class="-mob-share-qq -hoofoo-share-qq -hoofoo-share-ui-button"><i class="fa fa-qq" aria-hidden=true></i></div><div class="-mob-share-twitter -hoofoo-share-twitter -hoofoo-share-ui-button"><i class="fa fa-twitter" aria-hidden=true></i></div><div class="-hoofoo-share-more -hoofoo-share-ui-button -mob-share-open"><i class="fa fa-ellipsis-h" aria-hidden=true></i></div></div><div class=-mob-share-ui style=display:none><ul class=-mob-share-list><li class=-mob-share-weibo><p>新浪微博<li class=-mob-share-weixin><p>微信<li class=-mob-share-qzone><p>QQ空间<li class=-mob-share-qq><p>QQ好友<li class=-mob-share-tencentweibo><p>腾讯微博<li class=-mob-share-renren><p>人人网<li class=-mob-share-kaixin><p>开心网<li class=-mob-share-douban><p>豆瓣<li class=-mob-share-youdao><p>有道云笔记<li class=-mob-share-mingdao><p>明道<li class=-mob-share-pengyou><p>朋友网<li class=-mob-share-facebook><p>Facebook<li class=-mob-share-twitter><p>Twitter<li class=-mob-share-pocket><p>Pocket<li class=-mob-share-google><p>Google+<li class=-mob-share-tumblr><p>Tumblr<li class=-mob-share-instapaper><p>Instapaper<li class=-mob-share-linkedin><p>Linkedin</ul><div class=-mob-share-close>取消</div></div><div class=-mob-share-ui-bg></div><script id=-mob-share src="https://f1.webshare.mob.com/code/mob-share.js?appkey=21aa3b13ad233"></script></div></div></div><div class=comments id=comments><div style=text-align:center></div><div id=disqus_proxy_thread></div><div id=disqus_thread></div><script>window.disqusProxy={username:'ookamiantd',server:'disqus-proxy.yangbingdong.com',port:'',defaultAvatar:'/images/avatar/avatar-default.jpg',adminAvatar:'/images/avatar/avatar-admin.jpg',identifier:'2019/java-concurrent-part1/'};window.disqus_config=function(){this.page.url='http://yangbingdong.com/2019/java-concurrent-part1/';this.page.identifier='2019/java-concurrent-part1/';};window.onload=function(){var s=document.createElement('script');s.src="/static/js/main.0d0338ae.js";s.async=true;document.body.appendChild(s);}</script><link rel=stylesheet href=/static/css/main.0603c539.css></div></div><div class=sidebar-toggle><div class=sidebar-toggle-line-wrap><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id=sidebar class=sidebar><div class=sidebar-inner><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target=post-toc-wrap>Table of Contents<li class=sidebar-nav-overview data-target=site-overview>Overview</ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image src=/images/avatar/avatar-admin.jpg alt=ookamiAntD><p class=site-author-name itemprop=name>ookamiAntD<p class="site-description motion-element" itemprop=description>码渣 | rocker | 二次元 | 美剧 | 宅</div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href=/archives><span class=site-state-item-count>46</span>
<span class=site-state-item-name>posts</span></a></div><div class="site-state-item site-state-categories"><a href=/categories><span class=site-state-item-count>17</span>
<span class=site-state-item-name>categories</span></a></div><div class="site-state-item site-state-tags"><a href=/tags><span class=site-state-item-count>43</span>
<span class=site-state-item-name>tags</span></a></div></nav><div class="feed-link motion-element"><a href=/atom.xml rel=alternate><i class="fa fa-rss"></i>RSS</a></div><div class="links-of-author motion-element"><span class=links-of-author-item><a href=https://github.com/masteranthoneyd target=_blank rel="external nofollow noopener noreferrer" title=GitHub><i class="fa fa-fw fa-github"></i>GitHub</a></span>
<span class=links-of-author-item><a href="https://www.facebook.com/profile.php?id=100014869064462" target=_blank rel="external nofollow noopener noreferrer" title=Facebook><i class="fa fa-fw fa-facebook"></i>Facebook</a></span>
<span class=links-of-author-item><a href=https://twitter.com/ookamiAntD target=_blank rel="external nofollow noopener noreferrer" title=Twitter><i class="fa fa-fw fa-twitter"></i>Twitter</a></span></div><div class="cc-license motion-element" itemprop=license><a href=https://creativecommons.org/licenses/by-sa/4.0/ class=cc-opacity target=_blank rel="external nofollow noopener noreferrer"><img src=/images/cc-by-sa.svg alt="Creative Commons"></a></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class=links-of-blogroll-title><i class="fa  fa-fw fa-globe"></i>大神们的博客</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://mercyblitz.github.io/ title=mercyblitz(Java劝退师) target=_blank rel="external nofollow noopener noreferrer">mercyblitz(Java劝退师)</a><li class=links-of-blogroll-item><a href=https://muyinchen.github.io/ title=知秋大神(真·大神) target=_blank rel="external nofollow noopener noreferrer">知秋大神(真·大神)</a><li class=links-of-blogroll-item><a href=http://crossoverjie.top/ title="crossoverJie's Blog" target=_blank rel="external nofollow noopener noreferrer">crossoverJie's Blog</a><li class=links-of-blogroll-item><a href=http://yemengying.com/ title="Giraffe's Home" target=_blank rel="external nofollow noopener noreferrer">Giraffe's Home</a></ul></div><div id=days></div><script>function show_date_time(){window.setTimeout("show_date_time()",1000);BirthDay=new Date("01/10/2017 12:34:56");today=new Date();timeold=(today.getTime()-BirthDay.getTime());sectimeold=timeold/1000
secondsold=Math.floor(sectimeold);msPerDay=24*60*60*1000
e_daysold=timeold/msPerDay
daysold=Math.floor(e_daysold);e_hrsold=(e_daysold-daysold)*24;hrsold=setzero(Math.floor(e_hrsold));e_minsold=(e_hrsold-hrsold)*60;minsold=setzero(Math.floor((e_hrsold-hrsold)*60));seconds=setzero(Math.floor((e_minsold-minsold)*60));document.getElementById('days').innerHTML="已运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒";}
function setzero(i){if(i<10)
{i="0"+i};return i;}
show_date_time();</script></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class=post-toc><div class=post-toc-content><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#并发编程Bug的源头><span class=nav-number>1.</span> <span class=nav-text>并发编程Bug的源头</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#Java-内存模型><span class=nav-number>2.</span> <span class=nav-text>Java 内存模型</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#互斥锁><span class=nav-number>3.</span> <span class=nav-text>互斥锁</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#错误的加锁方式><span class=nav-number>3.1.</span> <span class=nav-text>错误的加锁方式</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#死锁><span class=nav-number>3.2.</span> <span class=nav-text>死锁</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#等待-通知><span class=nav-number>4.</span> <span class=nav-text>等待-通知</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#安全性、活跃性以及性能问题><span class=nav-number>5.</span> <span class=nav-text>安全性、活跃性以及性能问题</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#管程><span class=nav-number>6.</span> <span class=nav-text>管程</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#Java-线程><span class=nav-number>7.</span> <span class=nav-text>Java 线程</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#创建多少线程才合适><span class=nav-number>7.1.</span> <span class=nav-text>创建多少线程才合适</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#为什么局部变量是线程安全的><span class=nav-number>7.2.</span> <span class=nav-text>为什么局部变量是线程安全的</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#Finally><span class=nav-number>8.</span> <span class=nav-text>Finally</span></a></ol></div></div></section></div></aside></div></main><footer id=footer class=footer><div class=footer-inner><div class=busuanzi-count><script async src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span class=site-uv><i class="fa fa-user">本站访客数</i><span class=busuanzi-value id=busuanzi_value_site_uv></span>人次</span>
<span class=site-pv><i class="fa fa-eye">本站总访问量</i><span class=busuanzi-value id=busuanzi_value_site_pv></span>次</span></div><div class=copyright>&copy; 2016 -
<span itemprop=copyrightYear>2020</span>
<span class=with-love><i class="fa fa-flash"></i></span><span class=author itemprop=copyrightHolder>Hosted by <a href=https://pages.coding.me style=font-weight:700 rel="external nofollow noopener noreferrer" target=_blank>Coding Pages</a></span> | <span class=post-count>共279.3k字</span></div><div class=theme-info><a target=_blank href=http://www.miibeian.gov.cn/ rel=nofollow style=color:#555>粤ICP备18135202号-1</a></div><div style="width:300px;margin:0 auto"><a target=_blank href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44010602005896" style=display:inline-block;text-decoration:none;height:20px;line-height:20px><img src=https://cdn.yangbingdong.com/img/beian/beian.png style=float:left><p style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#555">粤公网安备 44010602005896号</p></a></div></div></footer><div class=back-to-top><i class="fa fa-arrow-up"></i></div></div><script>if(Object.prototype.toString.call(window.Promise)!=='[object Function]'){window.Promise=null;}</script><script src="/lib/jquery/index.js?v=2.1.3"></script><script src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script src="/js/src/utils.js?v=5.1.0"></script><script src="/js/src/motion.js?v=5.1.0"></script><script src="/js/src/scrollspy.js?v=5.1.0"></script><script src="/js/src/post-details.js?v=5.1.0"></script><script src="/js/src/bootstrap.js?v=5.1.0"></script><script>var disqus_shortname='ookamiantd';var disqus_identifier='2019/java-concurrent-part1/';var disqus_title="Java 并发拾遗-并发理论基础";function run_disqus_script(disqus_script){var dsq=document.createElement('script');dsq.type='text/javascript';dsq.async=true;dsq.src='//'+disqus_shortname+'.disqus.com/'+disqus_script;(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(dsq);}
var disqus={load:function disqus(){if(typeof DISQUS!=='object'){(function(){var s=document.createElement('script');s.async=true;s.type='text/javascript';s.src='//'+disqus_shortname+'.disqus.com/embed.js';(document.getElementsByTagName('HEAD')[0]||document.getElementsByTagName('BODY')[0]).appendChild(s);}());$('#load-disqus').html("评论加载中，请确保你有梯子，若评论长时间未加载则你可能翻墙失败...").fadeOut(9000);}}}</script><script>var isfetched=false;var search_path="search.xml";if(search_path.length==0){search_path="search.xml";}
var path="/"+search_path;function proceedsearch(){$("body").append('<div class="popoverlay">').css('overflow','hidden');$('.popup').toggle();}
var searchFunc=function(path,search_id,content_id){'use strict';$.ajax({url:path,dataType:"xml",async:true,success:function(xmlResponse){isfetched=true;$('.popup').detach().appendTo('.header-inner');var datas=$("entry",xmlResponse).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()};}).get();var $input=document.getElementById(search_id);var $resultContent=document.getElementById(content_id);$input.addEventListener('input',function(){var matchcounts=0;var str='<ul class=\"search-result-list\">';var keywords=this.value.trim().toLowerCase().split(/[\s\-]+/);$resultContent.innerHTML="";if(this.value.trim().length>1){datas.forEach(function(data){var isMatch=false;var content_index=[];var data_title=data.title.trim().toLowerCase();var data_content=data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();var data_url=decodeURIComponent(data.url);var index_title=-1;var index_content=-1;var first_occur=-1;if(data_title!=''){keywords.forEach(function(keyword,i){index_title=data_title.indexOf(keyword);index_content=data_content.indexOf(keyword);if(index_title>=0||index_content>=0){isMatch=true;if(i==0){first_occur=index_content;}}});}
if(isMatch){matchcounts+=1;str+="<li><a href='"+data_url+"' class='search-result-title'>"+data_title+"</a>";var content=data.content.trim().replace(/<[^>]+>/g,"");if(first_occur>=0){var start=first_occur-20;var end=first_occur+80;if(start<0){start=0;}
if(start==0){end=50;}
if(end>content.length){end=content.length;}
var match_content=content.substring(start,end);keywords.forEach(function(keyword){var regS=new RegExp(keyword,"gi");match_content=match_content.replace(regS,"<b class=\"search-keyword\">"+keyword+"</b>");});str+="<p class=\"search-result\">"+match_content+"...</p>"}
str+="</li>";}})};str+="</ul>";if(matchcounts==0){str='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'}
if(keywords==""){str='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'}
$resultContent.innerHTML=str;});proceedsearch();}});}
$('.popup-trigger').click(function(e){e.stopPropagation();if(isfetched==false){searchFunc(path,'local-search-input','local-search-result');}else{proceedsearch();};});$('.popup-btn-close').click(function(e){$('.popup').hide();$(".popoverlay").remove();$('body').css('overflow','');});$('.popup').click(function(e){e.stopPropagation();});</script><script src=https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js></script><script>AV.initialize("usE0s6JGUeOiMcsVoRuHuv2B-gzGzoHsz","ewm6NEF07r83HbnOr63ptuKH");</script><script>function showTime(Counter){var query=new AV.Query(Counter);var entries=[];var $visitors=$(".leancloud_visitors");$visitors.each(function(){entries.push($(this).attr("id").trim());});query.containedIn('url',entries);query.find().done(function(results){var COUNT_CONTAINER_REF='.leancloud-visitors-count';if(results.length===0){$visitors.find(COUNT_CONTAINER_REF).text(0);return;}
for(var i=0;i<results.length;i++){var item=results[i];var url=item.get('url');var time=item.get('time');var element=document.getElementById(url);$(element).find(COUNT_CONTAINER_REF).text(time);}
for(var i=0;i<entries.length;i++){var url=entries[i];var element=document.getElementById(url);var countSpan=$(element).find(COUNT_CONTAINER_REF);if(countSpan.text()==''){countSpan.text(0);}}}).fail(function(object,error){console.log("Error: "+error.code+" "+error.message);});}
function addCount(Counter){var $visitors=$(".leancloud_visitors");var url=$visitors.attr('id').trim();var title=$visitors.attr('data-flag-title').trim();var query=new AV.Query(Counter);query.equalTo("url",url);query.find({success:function(results){if(results.length>0){var counter=results[0];counter.fetchWhenSave(true);counter.increment("time");counter.save(null,{success:function(counter){var $element=$(document.getElementById(url));$element.find('.leancloud-visitors-count').text(counter.get('time'));},error:function(counter,error){console.log('Failed to save Visitor num, with error message: '+error.message);}});}else{var newcounter=new Counter();var acl=new AV.ACL();acl.setPublicReadAccess(true);acl.setPublicWriteAccess(true);newcounter.setACL(acl);newcounter.set("title",title);newcounter.set("url",url);newcounter.set("time",1);newcounter.save(null,{success:function(newcounter){var $element=$(document.getElementById(url));$element.find('.leancloud-visitors-count').text(newcounter.get('time'));},error:function(newcounter,error){console.log('Failed to create');}});}},error:function(error){console.log('Error:'+error.code+" "+error.message);}});}
$(function(){var Counter=AV.Object.extend("Counter");if($('.leancloud_visitors').length==1){addCount(Counter);}else if($('.post-title-link').length>1){showTime(Counter);}});</script><script>(function(){var bp=document.createElement('script');var curProtocol=window.location.protocol.split(':')[0];if(curProtocol==='https'){bp.src='https://zz.bdstatic.com/linksubmit/push.js';}
else{bp.src='http://push.zhanzhang.baidu.com/push.js';}
var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script><script color=255,0,204 opacity=0.5 zindex=-2 count=40 src=//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js></script><script>$('body').delegate('.-mob-share-weixin-qrcode-bg','click',function(){$(".-mob-share-weixin-qrcode-close").trigger("click");});</script><canvas class=fireworks style=position:fixed;left:0;top:0;z-index:1;pointer-events:none></canvas>
<script src=//cdn.bootcss.com/animejs/2.2.0/anime.min.js></script><script src=/js/src/fireworks.js></script><script src=/js/src/dytitle.js></script></div></footer></div><script src=/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"superSample":2,"width":88,"height":88,"position":"left"},"mobile":{"show":false},"react":{"opacityDefault":0.9,"opacityOnHover":0.5},"log":false});</script>