<!doctype html><html class="theme-next muse use-motion" lang=en><meta name=generator content="Hexo 3.9.0"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=cache-control content=no-transform><meta http-equiv=cache-control content=no-siteapp><meta http-equiv=content-language content=zh-cn><script src=//cdn.bootcss.com/pace/1.0.2/pace.min.js></script><link href=//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css rel=stylesheet><style>.pace .pace-progress{background:#ff009e;height:2px}.pace .pace-progress-inner{box-shadow:0 0 10px #e6006b,0 0 5px #ff009e}.pace .pace-activity{border-top-color:#ff009e;border-left-color:#ff009e}</style><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel=stylesheet><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel=stylesheet><link href="/css/main.css?v=5.1.0" rel=stylesheet><meta name=keywords content=Java,Concurrent,><link rel=alternate href=/atom.xml title="ookamiAntD's Blog" type=application/atom+xml><link rel="shortcut icon" type=image/x-icon href="/favicon.png?v=5.1.0"><meta name=description content="Preface JDK 并发包中有着许许多多的工具类, 将分为上中下三篇回顾这些工具类以及其简单的使用."><meta name=keywords content=Java,Concurrent><meta property=og:type content=article><meta property=og:title content="Java 并发拾遗-并发工具(上)"><meta property=og:url content=http://yangbingdong.com/2019/java-concurrent-part2/index.html><meta property=og:site_name content="ookamiAntD's Blog"><meta property=og:description content="Preface JDK 并发包中有着许许多多的工具类, 将分为上中下三篇回顾这些工具类以及其简单的使用."><meta property=og:locale content=en><meta property=og:image content=https://cdn.yangbingdong.com/img/concurrent/java-concurrent-lock-condition-banner.png><meta property=og:image content=https://cdn.yangbingdong.com/img/concurrent/java-concurrent-semaphore-module.png><meta property=og:image content=https://cdn.yangbingdong.com/img/concurrent/java-concurrent-countdownlatch01.png><meta property=og:image content=https://cdn.yangbingdong.com/img/concurrent/java-concurrent-countdownlatch02.png><meta property=og:image content=https://cdn.yangbingdong.com/img/concurrent/java-concurrent-countdownlatch03.png><meta property=og:image content=https://cdn.yangbingdong.com/img/concurrent/java-concurrent-countdownlatch04.png><meta property=og:image content=https://cdn.yangbingdong.com/img/concurrent/java-concurrent-countdownlatch05.png><meta property=og:image content=https://cdn.yangbingdong.com/img/concurrent/java-concurrent-countdownlatch06.png><meta property=og:updated_time content=2020-04-07T10:15:47.010Z><meta name=twitter:card content=summary><meta name=twitter:title content="Java 并发拾遗-并发工具(上)"><meta name=twitter:description content="Preface JDK 并发包中有着许许多多的工具类, 将分为上中下三篇回顾这些工具类以及其简单的使用."><meta name=twitter:image content=https://cdn.yangbingdong.com/img/concurrent/java-concurrent-lock-condition-banner.png><script id=hexo.configurations>var NexT=window.NexT||{};var CONFIG={root:'/',scheme:'Muse',sidebar:{"position":"right","display":"always"},fancybox:true,motion:true,duoshuo:{userId:'undefined',author:'Author'},algolia:{applicationID:'RI3NF6GUI0',apiKey:'3d33fa60ba30d3b17f37220bb1a36749',indexName:'blogIndex',hits:{"per_page":10},labels:{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}}};</script><link rel=canonical href=http://yangbingdong.com/2019/java-concurrent-part2/><script>(function(){if(''){if(prompt('请输入文章密码')!==''){alert('密码错误！');history.back();}}})();</script><title>Java 并发拾遗-并发工具(上) | ookamiAntD's Blog</title><body itemscope itemtype=http://schema.org/WebPage lang=en><script>var _hmt=_hmt||[];(function(){var hm=document.createElement("script");hm.src="https://hm.baidu.com/hm.js?e9505ac4e11d464329d615553a72b526";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script><div class="container one-collumn sidebar-position-right page-post-detail"><div class=headband></div><a href=https://github.com/masteranthoneyd/blog rel="external nofollow noopener noreferrer" target=_blank><img style=position:absolute;top:0;left:0;border:0 src=https://camo.githubusercontent.com/82b228a3648bf44fc1163ef44c62fcc60081495e/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f7265645f6161303030302e706e67 alt="Fork me on GitHub" data-canonical-src=https://s3.amazonaws.com/github/ribbons/forkme_left_red_aa0000.png></a><header id=header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-meta><div class=custom-logo-site-title><a href=/ class=brand rel=start><span class=logo-line-before><i></i></span><span class=site-title>ookamiAntD's Blog</span>
<span class=logo-line-after><i></i></span></a></div><h1 class=site-subtitle itemprop=description>Easy coding,easy life.</h1></div><div class=site-nav-toggle><button>
<span class=btn-bar></span><span class=btn-bar></span><span class=btn-bar></span></button></div><nav class=site-nav><ul id=menu class=menu><li class="menu-item menu-item-home"><a href=/ rel=section><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a><li class="menu-item menu-item-archives"><a href=/archives rel=section><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a><li class="menu-item menu-item-categories"><a href=/categories rel=section><i class="menu-item-icon fa fa-fw fa-th"></i><br>Categories</a><li class="menu-item menu-item-tags"><a href=/tags rel=section><i class="menu-item-icon fa fa-fw fa-tags"></i><br>Tags</a><li class="menu-item menu-item-about"><a href=/about rel=section><i class="menu-item-icon fa fa-fw fa-user"></i><br>About</a><li class="menu-item menu-item-guestbook"><a href=/guestbook rel=section><i class="menu-item-icon fa fa-fw fa-commenting"></i><br>Message</a><li class="menu-item menu-item-search"><a href=javascript:; class=popup-trigger><i class="menu-item-icon fa fa-search fa-fw"></i><br>Search</a></ul><div class=site-search><div class=popup><span class="search-icon fa fa-search"></span><input id=local-search-input><div id=local-search-result></div><span class=popup-btn-close>close</span></div></div></nav></div></header><main id=main class=main><div class=main-inner><div class=content-wrap><div id=content class=content><div id=posts class=posts-expand><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><link itemprop=mainEntityOfPage href=http://yangbingdong.com/2019/java-concurrent-part2/><span style=display:none itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=name content=ookamiAntD><meta itemprop=description content><meta itemprop=image content=/images/avatar/avatar-admin.jpg></span><span style=display:none itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="ookamiAntD's Blog"><span style=display:none itemprop=logo itemscope itemtype=http://schema.org/ImageObject><img style=display:none itemprop="url image" alt="ookamiAntD's Blog" src></span></span><header class=post-header><h2 class=post-title itemprop="name headline">Java 并发拾遗-并发工具(上)</h2><div class=post-meta><span class=post-time><span class=post-meta-item-icon><i class="fa fa-calendar-o"></i></span><span class=post-meta-item-text>Posted on</span>
<time title="Post created" itemprop="dateCreated datePublished" datetime=2019-09-06T10:45:59+08:00>2019-09-06</time></span>
<span class=post-category><span class=post-meta-divider>|</span>
<span class=post-meta-item-icon><i class="fa fa-folder-o"></i></span><span class=post-meta-item-text>In</span>
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/Programming/ itemprop=url rel=index><span itemprop=name>Programming</span></a></span>
,
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/Programming/Java/ itemprop=url rel=index><span itemprop=name>Java</span></a></span>
,
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/Programming/Java/Concurrent/ itemprop=url rel=index><span itemprop=name>Concurrent</span></a></span></span>
<span id=/2019/java-concurrent-part2/ class=leancloud_visitors data-flag-title="Java 并发拾遗-并发工具(上)"><span class=post-meta-divider>|</span>
<span class=post-meta-item-icon><i class="fa fa-eye"></i></span><span class=post-meta-item-text>Visitors</span>
<span class=leancloud-visitors-count></span></span><br><span class=post-time><span class=post-meta-item-icon><i class="fa fa-edit"></i></span><span class=post-meta-item-text>WordCount:</span>
<span class=post-count>5,351字</span>
<span class=post-meta-divider>|</span>
<span class=post-meta-item-text>min2read:</span>
<span class=post-count>22分钟</span></span></div></header><div class=post-body itemprop=articleBody><link rel=stylesheet href=https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css><p><img src=https://cdn.yangbingdong.com/img/concurrent/java-concurrent-lock-condition-banner.png alt><h1 id=Preface><a href=#Preface class=headerlink title=Preface></a>Preface</h1><blockquote><p>JDK 并发包中有着许许多多的工具类, 将分为上中下三篇回顾这些工具类以及其简单的使用.</blockquote><a id=more></a><h1 id=Lock-amp-Condition><a href=#Lock-amp-Condition class=headerlink title=Lock&amp;Condition></a>Lock&amp;Condition</h1><blockquote><p>在并发编程领域, 有两大核心问题: 一个是<strong>互斥</strong>, 即同一时刻只允许一个线程访问共享资源; 另一个是<strong>同步</strong>, 即线程之间如何通信、协作. 这两大问题, 管程都是能够解决的. <strong>Java SDK 并发包通过 Lock 和 Condition 两个接口来实现管程, 其中 Lock 用于解决互斥问题, Condition 用于解决同步问题.</strong></blockquote><h2 id=Lock><a href=#Lock class=headerlink title=Lock></a>Lock</h2><h3 id=造轮子的理由><a href=#造轮子的理由 class=headerlink title=造轮子的理由></a>造轮子的理由</h3><p>Java 已经提供了管程的相关实现 <code>synchronized</code>, 那么为什么还有一个 <code>Lock</code>, 需要了解一下 <code>synchronized</code> 的局限性. 在 <em><a href=https://yangbingdong.com/2019/java-concurrent-part1/#%E6%AD%BB%E9%94%81>上一篇的死锁问题</a></em> 中, 提出了一个<strong>破坏不可抢占条件</strong>方案, 这个方案 <code>synchronized</code> 没有办法解决. 原因是 <code>synchronized</code> 申请资源的时候, 如果申请不到, 线程直接进入阻塞状态了, 而线程进入阻塞状态, 啥都干不了, 也释放不了线程已经占有的资源.<p>在 Lock 的API 中, 体现了实现这个方案的三个办法:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=comment>// 支持中断的API</span></span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>lockInterruptibly</span><span class=params>()</span> </span></span><br><span class=line><span class=function>  <span class=keyword>throws</span> InterruptedException</span>;</span><br><span class=line><span class=comment>// 支持超时的API</span></span><br><span class=line><span class=function><span class=keyword>boolean</span> <span class=title>tryLock</span><span class=params>(<span class=keyword>long</span> time, TimeUnit unit)</span> </span></span><br><span class=line><span class=function>  <span class=keyword>throws</span> InterruptedException</span>;</span><br><span class=line><span class=comment>// 支持非阻塞获取锁的API</span></span><br><span class=line><span class=function><span class=keyword>boolean</span> <span class=title>tryLock</span><span class=params>()</span></span>;</span><br></pre></table></figure><h3 id=如何保证可见性><a href=#如何保证可见性 class=headerlink title=如何保证可见性></a>如何保证可见性</h3><blockquote><p>Java 里多线程的可见性是<strong>通过 Happens-Before 规则保证的</strong>, 而 <code>synchronized</code> 之所以能够保证可见性, 也是因为有一条 <code>synchronized</code> 相关的规则: <code>synchronized</code> 的解锁 Happens-Before 于后续对这个锁的加锁.</blockquote><p>先来看一段代码:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>X</span> </span>&#123;</span><br><span class=line>  <span class=keyword>private</span> <span class=keyword>final</span> Lock rtl =</span><br><span class=line>  <span class=keyword>new</span> ReentrantLock();</span><br><span class=line>  <span class=keyword>int</span> value;</span><br><span class=line>  <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>addOne</span><span class=params>()</span> </span>&#123;</span><br><span class=line>    <span class=comment>// 获取锁</span></span><br><span class=line>    rtl.lock();  </span><br><span class=line>    <span class=keyword>try</span> &#123;</span><br><span class=line>      value+=<span class=number>1</span>;</span><br><span class=line>    &#125; <span class=keyword>finally</span> &#123;</span><br><span class=line>      <span class=comment>// 保证锁能释放</span></span><br><span class=line>      rtl.unlock();</span><br><span class=line>    &#125;</span><br><span class=line>  &#125;</span><br><span class=line>&#125;</span><br></pre></table></figure><blockquote><p><code>try{}finally{}</code> 是 Lock 使用的经典范式.</blockquote><p>Lock <strong>利用了 <code>volatile</code> 相关的 Happens-Before 规则</strong> 保证可见性. Java SDK 里面的 <code>ReentrantLock</code>, 内部持有一个 <code>volatile</code> 的成员变量 <code>state</code>, 获取锁的时候, 会读写 <code>state</code> 的值; 解锁的时候, 也会读写 <code>state</code> 的值, 简化版代码如下:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>SampleLock</span> </span>&#123;</span><br><span class=line>  <span class=keyword>volatile</span> <span class=keyword>int</span> state;</span><br><span class=line>  <span class=comment>// 加锁</span></span><br><span class=line>  lock() &#123;</span><br><span class=line>    <span class=comment>// 省略代码无数</span></span><br><span class=line>    state = <span class=number>1</span>;</span><br><span class=line>  &#125;</span><br><span class=line>  <span class=comment>// 解锁</span></span><br><span class=line>  unlock() &#123;</span><br><span class=line>    <span class=comment>// 省略代码无数</span></span><br><span class=line>    state = <span class=number>0</span>;</span><br><span class=line>  &#125;</span><br><span class=line>&#125;</span><br></pre></table></figure><p>根据相关的 Happens-Before 规则:<ol><li><strong>顺序性规则</strong>: 对于线程 T1, <code>value+=1</code> Happens-Before 释放锁的操作 <code>unlock()</code>;<li><strong><code>volatile</code> 变量规则</strong>: 由于 <code>state = 1</code> 会先读取 <code>state</code>, 所以线程 T1 的 <code>unlock()</code> 操作 Happens-Before 线程 T2 的 <code>lock()</code> 操作;<li><strong>传递性规则</strong>: 线程 T1 的 <code>value+=1</code> Happens-Before 线程 T2 的 <code>lock()</code> 操作.</ol><h3 id=可重入锁><a href=#可重入锁 class=headerlink title=可重入锁></a>可重入锁</h3><p>上面代码中创建的锁为 <code>ReentrantLock</code>, 翻译过来为可重入锁, 所谓可重入锁, 顾名思义, 指的是<strong>线程可以重复获取同一把锁</strong>.<p>例如下面代码中, 当线程 T1 执行到 ① 处时, 已经获取到了锁 rtl , 当在 ① 处调用 <code>get()</code> 方法时, 会在 ② 再次对锁 rtl 执行加锁操作. 此时, 如果锁 rtl 是可重入的, 那么线程 T1 可以再次加锁成功; 如果锁 rtl 是不可重入的, 那么线程 T1 此时会被阻塞.<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>X</span> </span>&#123;</span><br><span class=line>  <span class=keyword>private</span> <span class=keyword>final</span> Lock rtl =</span><br><span class=line>  <span class=keyword>new</span> ReentrantLock();</span><br><span class=line>  <span class=keyword>int</span> value;</span><br><span class=line>  <span class=function><span class=keyword>public</span> <span class=keyword>int</span> <span class=title>get</span><span class=params>()</span> </span>&#123;</span><br><span class=line>    <span class=comment>// 获取锁</span></span><br><span class=line>    rtl.lock();         ②</span><br><span class=line>    <span class=keyword>try</span> &#123;</span><br><span class=line>      <span class=keyword>return</span> value;</span><br><span class=line>    &#125; <span class=keyword>finally</span> &#123;</span><br><span class=line>      <span class=comment>// 保证锁能释放</span></span><br><span class=line>      rtl.unlock();</span><br><span class=line>    &#125;</span><br><span class=line>  &#125;</span><br><span class=line>  <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>addOne</span><span class=params>()</span> </span>&#123;</span><br><span class=line>    <span class=comment>// 获取锁</span></span><br><span class=line>    rtl.lock();  </span><br><span class=line>    <span class=keyword>try</span> &#123;</span><br><span class=line>      value = <span class=number>1</span> + get(); ①</span><br><span class=line>    &#125; <span class=keyword>finally</span> &#123;</span><br><span class=line>      <span class=comment>// 保证锁能释放</span></span><br><span class=line>      rtl.unlock();</span><br><span class=line>    &#125;</span><br><span class=line>  &#125;</span><br><span class=line>&#125;</span><br></pre></table></figure><h3 id=公平锁与非公平锁><a href=#公平锁与非公平锁 class=headerlink title=公平锁与非公平锁></a>公平锁与非公平锁</h3><p><code>ReentrantLock</code> 这个类有两个构造函数:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=comment>//无参构造函数: 默认非公平锁</span></span><br><span class=line><span class=function><span class=keyword>public</span> <span class=title>ReentrantLock</span><span class=params>()</span> </span>&#123;</span><br><span class=line>    sync = <span class=keyword>new</span> NonfairSync();</span><br><span class=line>&#125;</span><br><span class=line><span class=comment>//根据公平策略参数创建锁</span></span><br><span class=line><span class=function><span class=keyword>public</span> <span class=title>ReentrantLock</span><span class=params>(<span class=keyword>boolean</span> fair)</span></span>&#123;</span><br><span class=line>    sync = fair ? <span class=keyword>new</span> FairSync() </span><br><span class=line>                : <span class=keyword>new</span> NonfairSync();</span><br><span class=line>&#125;</span><br></pre></table></figure><p>锁都对应着一个等待队列, 如果一个线程没有获得锁, 就会进入等待队列, 当有线程释放锁的时候, 就需要从等待队列中唤醒一个等待的线程. 如果是公平锁, 唤醒的策略就是谁等待的时间长, 就唤醒谁, 很公平; 如果是非公平锁, 则不提供这个公平保证, 有可能等待时间短的线程反而先被唤醒.<p>并发大师 Doug Lea《Java 并发编程: 设计原则与模式》一书中, 推荐的三个用锁的最佳实践, 它们分别是:<ul><li>永远只在更新对象的成员变量时加锁;<li>永远只在访问可变的成员变量时加锁;<li>永远不在调用其他对象的方法时加锁.</ul><h2 id=Condition><a href=#Condition class=headerlink title=Condition></a>Condition</h2><p><strong>Condition 实现了管程模型里面的条件变量</strong>, Java 内置的管程实现只支持一个条件变量, 而 Lock&amp;Condition 实现的管程是<strong>支持多个条件变量</strong>的, 这是二者的一个重要区别.<p>在很多并发场景下, 支持多个条件变量能够让我们的并发程序可读性更好, 实现起来也更容易. 例如, 实现一个阻塞队列, 就需要两个条件变量:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br></pre><td class=code><pre><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>BlockedQueue</span>&lt;<span class=title>T</span>&gt;</span>&#123;</span><br><span class=line>  <span class=keyword>final</span> Lock lock =</span><br><span class=line>    <span class=keyword>new</span> ReentrantLock();</span><br><span class=line>  <span class=comment>// 条件变量: 队列不满  </span></span><br><span class=line>  <span class=keyword>final</span> Condition notFull =</span><br><span class=line>    lock.newCondition();</span><br><span class=line>  <span class=comment>// 条件变量: 队列不空  </span></span><br><span class=line>  <span class=keyword>final</span> Condition notEmpty =</span><br><span class=line>    lock.newCondition();</span><br><span class=line></span><br><span class=line>  <span class=comment>// 入队</span></span><br><span class=line>  <span class=function><span class=keyword>void</span> <span class=title>enq</span><span class=params>(T x)</span> </span>&#123;</span><br><span class=line>    lock.lock();</span><br><span class=line>    <span class=keyword>try</span> &#123;</span><br><span class=line>      <span class=keyword>while</span> (队列已满)&#123;</span><br><span class=line>        <span class=comment>// 等待队列不满</span></span><br><span class=line>        notFull.await();</span><br><span class=line>      &#125;  </span><br><span class=line>      <span class=comment>// 省略入队操作...</span></span><br><span class=line>      <span class=comment>//入队后,通知可出队</span></span><br><span class=line>      notEmpty.signal();</span><br><span class=line>    &#125;<span class=keyword>finally</span> &#123;</span><br><span class=line>      lock.unlock();</span><br><span class=line>    &#125;</span><br><span class=line>  &#125;</span><br><span class=line>  <span class=comment>// 出队</span></span><br><span class=line>  <span class=function><span class=keyword>void</span> <span class=title>deq</span><span class=params>()</span></span>&#123;</span><br><span class=line>    lock.lock();</span><br><span class=line>    <span class=keyword>try</span> &#123;</span><br><span class=line>      <span class=keyword>while</span> (队列已空)&#123;</span><br><span class=line>        <span class=comment>// 等待队列不空</span></span><br><span class=line>        notEmpty.await();</span><br><span class=line>      &#125;  </span><br><span class=line>      <span class=comment>// 省略出队操作...</span></span><br><span class=line>      <span class=comment>//出队后, 通知可入队</span></span><br><span class=line>      notFull.signal();</span><br><span class=line>    &#125;<span class=keyword>finally</span> &#123;</span><br><span class=line>      lock.unlock();</span><br><span class=line>    &#125;  </span><br><span class=line>  &#125;</span><br><span class=line>&#125;</span><br></pre></table></figure><h1 id=Semaphore-如何快速实现一个限流器><a href=#Semaphore-如何快速实现一个限流器 class=headerlink title="Semaphore: 如何快速实现一个限流器"></a>Semaphore: 如何快速实现一个限流器</h1><p>一般被翻译为<strong>信号量</strong>, 由大名鼎鼎的计算机科学家迪杰斯特拉(Dijkstra)于 1965 年提出, 在这之后的 15 年, 信号量一直都是并发编程领域的终结者, 直到 1980 年管程被提出来.<p>信号量一般用于<strong>控制资源访问的并发数量</strong>, 比如数据库链接资源, 读取千万条数据, 但是数据库链接就只有20个, 需要控制连接池的并发使用数量.<h2 id=信号量模型><a href=#信号量模型 class=headerlink title=信号量模型></a>信号量模型</h2><p><strong>一个计数器, 一个等待队列, 三个方法.</strong><p><img src=https://cdn.yangbingdong.com/img/concurrent/java-concurrent-semaphore-module.png alt><ul><li><code>init()</code>: 设置计数器的初始值.<li><code>down()</code>: 计数器的值减 1; 如果此时计数器的值小于 0, 则当前线程将被阻塞, 否则当前线程可以继续执行.<li><code>up()</code>: 计数器的值加 1; 如果此时计数器的值小于或者等于 0, 则唤醒等待队列中的一个线程, 并将其从等待队列中移除.</ul><p>这里提到的三个方法都是原子性的, 并且这个原子性是由信号量模型的实现方保证的. 在 Java SDK 里面, 信号量模型是由 <code>java.util.concurrent.Semaphore</code> 实现的, <code>Semaphore</code> 这个类能够保证这三个方法都是原子操作, 其中, <code>down()</code> 和 <code>up()</code> 对应的则是 <code>acquire()</code> 和 <code>release()</code>.<blockquote><p>在信号量模型里面, <code>down()</code>、<code>up()</code> 这两个操作历史上最早称为 P 操作和 V 操作, 所以信号量模型也被称为 <strong>PV 原语</strong>.</blockquote><h2 id=使用><a href=#使用 class=headerlink title=使用></a>使用</h2><p>实现一个停车场停车限制:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=class><span class=keyword>class</span> <span class=title>ParkingSpotManager</span> </span>&#123;</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=keyword>final</span> <span class=keyword>int</span> MAX_SIZE = <span class=number>10</span>;</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> BlockingQueue&lt;ParkingSpot&gt; parkingSpots = <span class=keyword>new</span> LinkedBlockingQueue&lt;&gt;(MAX_SIZE);</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> Semaphore sem = <span class=keyword>new</span> Semaphore(MAX_SIZE);</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=title>ParkingSpotManager</span><span class=params>()</span> </span>&#123;</span><br><span class=line>        ParkingSpot parkingSpot;</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i &lt; MAX_SIZE; i++) &#123;</span><br><span class=line>            parkingSpot = <span class=keyword>new</span> ParkingSpot();</span><br><span class=line>            parkingSpot.setId(i);</span><br><span class=line>            parkingSpots.add(parkingSpot);</span><br><span class=line>        &#125;</span><br><span class=line>    &#125;</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>void</span> <span class=title>park</span><span class=params>(Consumer&lt;ParkingSpot&gt; consumer)</span> </span>&#123;</span><br><span class=line>        ParkingSpot parkingSpot = <span class=keyword>null</span>;</span><br><span class=line>        <span class=keyword>try</span> &#123;</span><br><span class=line>            sem.acquire(<span class=number>1</span>);</span><br><span class=line>            parkingSpot = parkingSpots.remove();</span><br><span class=line>            consumer.accept(parkingSpot);</span><br><span class=line>        &#125; <span class=keyword>catch</span> (InterruptedException e) &#123;</span><br><span class=line>            <span class=keyword>throw</span> <span class=keyword>new</span> RuntimeException(e);</span><br><span class=line>        &#125; <span class=keyword>finally</span> &#123;</span><br><span class=line>            <span class=keyword>if</span> (parkingSpot != <span class=keyword>null</span>) &#123;</span><br><span class=line>                parkingSpots.add(parkingSpot);</span><br><span class=line>            &#125;</span><br><span class=line>            sem.release(<span class=number>1</span>);</span><br><span class=line>        &#125;</span><br><span class=line>    &#125;</span><br><span class=line></span><br><span class=line>    <span class=function><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class=title>main</span><span class=params>(String[] args)</span> </span>&#123;</span><br><span class=line>        ParkingSpotManager parkingSpotManager = <span class=keyword>new</span> ParkingSpotManager();</span><br><span class=line></span><br><span class=line>        ExecutorService executorService = Executors.newFixedThreadPool(<span class=number>50</span>);</span><br><span class=line>        <span class=keyword>for</span> (<span class=keyword>int</span> i = <span class=number>0</span>; i &lt; <span class=number>50</span>; i++) &#123;</span><br><span class=line>            executorService.execute(() -&gt; parkingSpotManager.park(parkingSpot -&gt; &#123;</span><br><span class=line>                System.out.println(Thread.currentThread().getName() + <span class=string>" 拿到车位, 车位号: "</span> + parkingSpot.getId());</span><br><span class=line>                <span class=keyword>try</span> &#123;</span><br><span class=line>                    Thread.sleep(ThreadLocalRandom.current().nextLong(<span class=number>500</span>, <span class=number>1000</span>));</span><br><span class=line>                &#125; <span class=keyword>catch</span> (InterruptedException e) &#123;</span><br><span class=line>                    e.printStackTrace();</span><br><span class=line>                &#125;</span><br><span class=line>            &#125;));</span><br><span class=line>        &#125;</span><br><span class=line>        executorService.shutdown();</span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br></pre></table></figure><h1 id=ReadWriteLock-如何快速实现一个完备的缓存><a href=#ReadWriteLock-如何快速实现一个完备的缓存 class=headerlink title="ReadWriteLock: 如何快速实现一个完备的缓存"></a>ReadWriteLock: 如何快速实现一个完备的缓存</h1><p>Java 已经实现了管程和信号量这两个同步原语, 那么为什么并发包下还有那么多工具? 答案是<strong>分场景优化性能, 提升易用性.</strong><p>有一个常见的应用场景: <strong>读多写少</strong>, 比如缓存. 针对读多写少这种并发场景, Java SDK 并发包提供了<strong>读写锁</strong>——<code>ReadWriteLock</code>.<p>读写锁, 并不是 Java 语言特有的, 而是一个广为使用的通用技术, 所有的读写锁都遵守以下三条基本原则:<ul><li>允许多个线程同时读共享变量;<li>只允许一个线程写共享变量;<li>如果一个写线程正在执行写操作, 此时禁止读线程读共享变量.</ul><p>读写锁与互斥锁的一个重要区别就是<strong>读写锁允许多个线程同时读共享变量</strong>, 而互斥锁是不允许的, 这是读写锁在读多写少场景下性能优于互斥锁的关键. 但<strong>读写锁的写操作是互斥的</strong>, 当一个线程在写共享变量的时候, 是不允许其他线程执行写操作和读操作.<p>一个简单的缓存实现:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Cache</span>&lt;<span class=title>K</span>,<span class=title>V</span>&gt; </span>&#123;</span><br><span class=line>  <span class=keyword>final</span> Map&lt;K, V&gt; m =</span><br><span class=line>    <span class=keyword>new</span> HashMap&lt;&gt;();</span><br><span class=line>  <span class=keyword>final</span> ReadWriteLock rwl =</span><br><span class=line>    <span class=keyword>new</span> ReentrantReadWriteLock();</span><br><span class=line>  <span class=comment>// 读锁</span></span><br><span class=line>  <span class=keyword>final</span> Lock r = rwl.readLock();</span><br><span class=line>  <span class=comment>// 写锁</span></span><br><span class=line>  <span class=keyword>final</span> Lock w = rwl.writeLock();</span><br><span class=line>  <span class=comment>// 读缓存</span></span><br><span class=line>  <span class=function>V <span class=title>get</span><span class=params>(K key)</span> </span>&#123;</span><br><span class=line>    r.lock();</span><br><span class=line>    <span class=keyword>try</span> &#123; <span class=keyword>return</span> m.get(key); &#125;</span><br><span class=line>    <span class=keyword>finally</span> &#123; r.unlock(); &#125;</span><br><span class=line>  &#125;</span><br><span class=line>  <span class=comment>// 写缓存</span></span><br><span class=line>  <span class=function>V <span class=title>put</span><span class=params>(K key, V value)</span> </span>&#123;</span><br><span class=line>    w.lock();</span><br><span class=line>    <span class=keyword>try</span> &#123; <span class=keyword>return</span> m.put(key, v); &#125;</span><br><span class=line>    <span class=keyword>finally</span> &#123; w.unlock(); &#125;</span><br><span class=line>  &#125;</span><br><span class=line>&#125;</span><br></pre></table></figure><p>按需加载, 即当缓存不存在, 再查询数据库:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>Cache</span>&lt;<span class=title>K</span>,<span class=title>V</span>&gt; </span>&#123;</span><br><span class=line>  <span class=keyword>final</span> Map&lt;K, V&gt; m =</span><br><span class=line>    <span class=keyword>new</span> HashMap&lt;&gt;();</span><br><span class=line>  <span class=keyword>final</span> ReadWriteLock rwl = </span><br><span class=line>    <span class=keyword>new</span> ReentrantReadWriteLock();</span><br><span class=line>  <span class=keyword>final</span> Lock r = rwl.readLock();</span><br><span class=line>  <span class=keyword>final</span> Lock w = rwl.writeLock();</span><br><span class=line> </span><br><span class=line>  <span class=function>V <span class=title>get</span><span class=params>(K key)</span> </span>&#123;</span><br><span class=line>    V v = <span class=keyword>null</span>;</span><br><span class=line>    <span class=comment>//读缓存</span></span><br><span class=line>    r.lock();         ①</span><br><span class=line>    <span class=keyword>try</span> &#123;</span><br><span class=line>      v = m.get(key); ②</span><br><span class=line>    &#125; <span class=keyword>finally</span>&#123;</span><br><span class=line>      r.unlock();     ③</span><br><span class=line>    &#125;</span><br><span class=line>    <span class=comment>//缓存中存在, 返回</span></span><br><span class=line>    <span class=keyword>if</span>(v != <span class=keyword>null</span>) &#123;   ④</span><br><span class=line>      <span class=keyword>return</span> v;</span><br><span class=line>    &#125;  </span><br><span class=line>    <span class=comment>//缓存中不存在, 查询数据库</span></span><br><span class=line>    w.lock();         ⑤</span><br><span class=line>    <span class=keyword>try</span> &#123;</span><br><span class=line>      <span class=comment>//再次验证</span></span><br><span class=line>      <span class=comment>//其他线程可能已经查询过数据库</span></span><br><span class=line>      v = m.get(key); ⑥</span><br><span class=line>      <span class=keyword>if</span>(v == <span class=keyword>null</span>)&#123;  ⑦</span><br><span class=line>        <span class=comment>//查询数据库</span></span><br><span class=line>        v=省略代码无数</span><br><span class=line>        m.put(key, v);</span><br><span class=line>      &#125;</span><br><span class=line>    &#125; <span class=keyword>finally</span>&#123;</span><br><span class=line>      w.unlock();</span><br><span class=line>    &#125;</span><br><span class=line>    <span class=keyword>return</span> v; </span><br><span class=line>  &#125;</span><br><span class=line>&#125;</span><br></pre></table></figure><h2 id=锁升级><a href=#锁升级 class=headerlink title=锁升级></a>锁升级</h2><p>先来看一段代码:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=comment>//读缓存</span></span><br><span class=line>r.lock();         ①</span><br><span class=line><span class=keyword>try</span> &#123;</span><br><span class=line>  v = m.get(key); ②</span><br><span class=line>  <span class=keyword>if</span> (v == <span class=keyword>null</span>) &#123;</span><br><span class=line>    w.lock();</span><br><span class=line>    <span class=keyword>try</span> &#123;</span><br><span class=line>      <span class=comment>//再次验证并更新缓存</span></span><br><span class=line>      <span class=comment>//省略详细代码</span></span><br><span class=line>    &#125; <span class=keyword>finally</span>&#123;</span><br><span class=line>      w.unlock();</span><br><span class=line>    &#125;</span><br><span class=line>  &#125;</span><br><span class=line>&#125; <span class=keyword>finally</span>&#123;</span><br><span class=line>  r.unlock();     ③</span><br><span class=line>&#125;</span><br></pre></table></figure><p>在①处获取读锁, 在③处释放读锁, 那是否可以在②处的下面增加验证缓存并更新缓存, 这个叫<strong>锁的升级</strong>.<p>可惜 <code>ReadWriteLock</code> 并不支持这种升级. 在上面的代码示例中, 读锁还没有释放, 此时获取写锁, 会导致写锁永久等待, 最终导致相关线程都被阻塞, 永远也没有机会被唤醒.<p>不过, 虽然锁的升级是不允许的, 但是<strong>锁的降级</strong>却是允许的:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br></pre><td class=code><pre><span class=line><span class=class><span class=keyword>class</span> <span class=title>CachedData</span> </span>&#123;</span><br><span class=line>  Object data;</span><br><span class=line>  <span class=keyword>volatile</span> <span class=keyword>boolean</span> cacheValid;</span><br><span class=line>  <span class=keyword>final</span> ReadWriteLock rwl =</span><br><span class=line>    <span class=keyword>new</span> ReentrantReadWriteLock();</span><br><span class=line>  <span class=comment>// 读锁  </span></span><br><span class=line>  <span class=keyword>final</span> Lock r = rwl.readLock();</span><br><span class=line>  <span class=comment>//写锁</span></span><br><span class=line>  <span class=keyword>final</span> Lock w = rwl.writeLock();</span><br><span class=line>  </span><br><span class=line>  <span class=function><span class=keyword>void</span> <span class=title>processCachedData</span><span class=params>()</span> </span>&#123;</span><br><span class=line>    <span class=comment>// 获取读锁</span></span><br><span class=line>    r.lock();</span><br><span class=line>    <span class=keyword>if</span> (!cacheValid) &#123;</span><br><span class=line>      <span class=comment>// 释放读锁, 因为不允许读锁的升级</span></span><br><span class=line>      r.unlock();</span><br><span class=line>      <span class=comment>// 获取写锁</span></span><br><span class=line>      w.lock();</span><br><span class=line>      <span class=keyword>try</span> &#123;</span><br><span class=line>        <span class=comment>// 再次检查状态  </span></span><br><span class=line>        <span class=keyword>if</span> (!cacheValid) &#123;</span><br><span class=line>          data = ...</span><br><span class=line>          cacheValid = <span class=keyword>true</span>;</span><br><span class=line>        &#125;</span><br><span class=line>        <span class=comment>// 释放写锁前, 降级为读锁</span></span><br><span class=line>        <span class=comment>// 降级是可以的</span></span><br><span class=line>        r.lock(); ①</span><br><span class=line>      &#125; <span class=keyword>finally</span> &#123;</span><br><span class=line>        <span class=comment>// 释放写锁</span></span><br><span class=line>        w.unlock(); </span><br><span class=line>      &#125;</span><br><span class=line>    &#125;</span><br><span class=line>    <span class=comment>// 此处仍然持有读锁</span></span><br><span class=line>    <span class=keyword>try</span> &#123;use(data);&#125; </span><br><span class=line>    <span class=keyword>finally</span> &#123;r.unlock();&#125;</span><br><span class=line>  &#125;</span><br><span class=line>&#125;</span><br></pre></table></figure><p>在代码①处, 获取读锁的时候线程还是持有写锁的, 这种锁的降级是支持的.<blockquote><p>读写锁类似于 <code>ReentrantLock</code>, 也支持公平模式和非公平模式. 读锁和写锁都实现了 <code>java.util.concurrent.locks.Lock</code> 接口, 所以除了支持 <code>lock()</code> 方法外, <code>tryLock()</code>、<code>lockInterruptibly()</code> 等方法也都是支持的. 但是有一点需要注意, 那就是只有写锁支持条件变量, 读锁是不支持条件变量的, 读锁调用 <code>newCondition()</code> 会抛出 <code>UnsupportedOperationException</code> 异常.</blockquote><h1 id=StampedLock-读写锁更快的锁><a href=#StampedLock-读写锁更快的锁 class=headerlink title="StampedLock: 读写锁更快的锁"></a>StampedLock: 读写锁更快的锁</h1><p><code>StampedLock</code> 类, 在 JDK1.8 时引入, 是对读写锁 <code>ReentrantReadWriteLock</code> 的增强, 该类提供了一些功能, 优化了读锁、写锁的访问, 同时使读写锁之间可以互相转换, 更细粒度控制并发. 该类的设计初衷是作为一个内部工具类, 用于辅助开发其它线程安全组件, 用得好, 该类可以提升系统性能, 用不好, 容易产生死锁和其它莫名其妙的问题.<h2 id=特点><a href=#特点 class=headerlink title=特点></a>特点</h2><p>StampedLock的主要特点概括一下, 有以下几点:<ol><li>所有获取锁的方法, 都返回一个邮戳(Stamp), Stamp为0表示获取失败, 其余都表示成功;<li>所有释放锁的方法, 都需要一个邮戳(Stamp), 这个Stamp必须是和成功获取锁时得到的Stamp一致;<li><code>StampedLock</code> 是不可重入的; (如果一个线程已经持有了写锁, 再去获取写锁的话就会造成死锁)<li><code>StampedLock</code> 有三种访问模式:<ul><li>Reading(读模式): 功能和 <code>ReentrantReadWriteLock</code> 的读锁类似;<li>Writing(写模式): 功能和 <code>ReentrantReadWriteLock</code> 的写锁类似;<li>Optimistic reading(<strong>乐观读模式</strong>): 这是一种优化的读模式;</ul><li><code>StampedLock</code> 支持读锁和写锁的相互转换<br>我们知道 RRW 中, 当线程获取到写锁后, 可以降级为读锁, 但是读锁是不能直接升级为写锁的.<br>StampedLock 提供了读锁和写锁相互转换的功能, 使得该类支持更多的应用场景;<li>无论写锁还是读锁, 都不支持 Conditon 等待条件.</ol><p>在 <code>ReentrantReadWriteLock</code> 中, 当读锁被使用时, 如果有线程尝试获取写锁, <strong>该写线程会阻塞</strong>.<br>但是, 在 Optimistic reading 中, 即使读线程获取到了读锁, 写线程尝试获取写锁也不会阻塞, 这相当于对读模式的优化, 但是<strong>可能会导致数据不一致的问题</strong>. 所以, 当使用 Optimistic reading 获取到读锁时, <strong>必须对获取结果进行校验</strong>.<h2 id=乐观读><a href=#乐观读 class=headerlink title=乐观读></a>乐观读</h2><p>读写锁的用法与 <code>ReentrantReadWriteLock</code> 类似, <code>StampedLock</code> 的性能之所以比 <code>ReadWriteLock</code> 还要好, 其关键是 <code>StampedLock</code> 支持乐观读的方式. 注意这里, 用的是”<strong>乐观读</strong>“这个词, 而不是”乐观读锁”, 乐观读这个操作是<strong>无锁</strong>的, 所以相比较 <code>ReadWriteLock</code> 的读锁, 乐观读的性能更好一些.<p>以下是来自官网乐观读的一段代码:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 使用乐观读锁访问共享资源</span></span><br><span class=line><span class=comment> * 注意: 乐观读锁在保证数据一致性上需要拷贝一份要操作的变量到方法栈, 并且在操作数据时候可能其他写线程已经修改了数据, </span></span><br><span class=line><span class=comment> * 而我们操作的是方法栈里面的数据, 也就是一个快照, 所以最多返回的不是最新的数据, 但是一致性还是得到保障的. </span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * <span class=doctag>@return</span></span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=function><span class=keyword>double</span> <span class=title>distanceFromOrigin</span><span class=params>()</span> </span>&#123;</span><br><span class=line>    <span class=keyword>long</span> stamp = sl.tryOptimisticRead();    <span class=comment>// 使用乐观读锁</span></span><br><span class=line>    <span class=keyword>double</span> currentX = x, currentY = y;      <span class=comment>// 拷贝共享资源到本地方法栈中</span></span><br><span class=line>    <span class=keyword>if</span> (!sl.validate(stamp)) &#123;              <span class=comment>// 如果有写锁被占用, 可能造成数据不一致, 所以要切换到普通读锁模式</span></span><br><span class=line>        stamp = sl.readLock();             </span><br><span class=line>        <span class=keyword>try</span> &#123;</span><br><span class=line>            currentX = x;</span><br><span class=line>            currentY = y;</span><br><span class=line>        &#125; <span class=keyword>finally</span> &#123;</span><br><span class=line>            sl.unlockRead(stamp);</span><br><span class=line>        &#125;</span><br><span class=line>    &#125;</span><br><span class=line>    <span class=keyword>return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class=line>&#125;</span><br></pre></table></figure><p>Optimistic reading 的使用必须遵循以下模式:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>long</span> stamp = lock.tryOptimisticRead();  <span class=comment>// 非阻塞获取版本信息</span></span><br><span class=line>copyVaraibale2ThreadMemory();           <span class=comment>// 拷贝变量到线程本地堆栈</span></span><br><span class=line><span class=keyword>if</span>(!lock.validate(stamp))&#123;              <span class=comment>// 校验</span></span><br><span class=line>    <span class=keyword>long</span> stamp = lock.readLock();       <span class=comment>// 获取读锁</span></span><br><span class=line>    <span class=keyword>try</span> &#123;</span><br><span class=line>        copyVaraibale2ThreadMemory();   <span class=comment>// 拷贝变量到线程本地堆栈</span></span><br><span class=line>     &#125; <span class=keyword>finally</span> &#123;</span><br><span class=line>       lock.unlock(stamp);              <span class=comment>// 释放悲观锁</span></span><br><span class=line>    &#125;</span><br><span class=line></span><br><span class=line>&#125;</span><br><span class=line>useThreadMemoryVarables();              <span class=comment>// 使用线程本地堆栈里面的数据进行操作</span></span><br></pre></table></figure><h2 id=锁升级-1><a href=#锁升级-1 class=headerlink title=锁升级></a>锁升级</h2><p><code>StampedLock</code> 支持锁的降级(通过 <code>tryConvertToReadLock()</code> 方法实现)和升级(通过 <code>tryConvertToWriteLock()</code> 方法实现), 但是建议慎重使用. 下面的代码也源自 Java 的官方示例:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>void</span> <span class=title>moveIfAtOrigin</span><span class=params>(<span class=keyword>double</span> newX, <span class=keyword>double</span> newY)</span> </span>&#123; <span class=comment>// upgrade</span></span><br><span class=line>    <span class=comment>// Could instead start with optimistic, not read mode</span></span><br><span class=line>    <span class=keyword>long</span> stamp = sl.readLock();</span><br><span class=line>    <span class=keyword>try</span> &#123;</span><br><span class=line>        <span class=keyword>while</span> (x == <span class=number>0.0</span> &amp;&amp; y == <span class=number>0.0</span>) &#123;</span><br><span class=line>            <span class=keyword>long</span> ws = sl.tryConvertToWriteLock(stamp);  <span class=comment>//读锁转换为写锁</span></span><br><span class=line>            <span class=keyword>if</span> (ws != <span class=number>0L</span>) &#123;</span><br><span class=line>                stamp = ws;</span><br><span class=line>                x = newX;</span><br><span class=line>                y = newY;</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>            &#125; <span class=keyword>else</span> &#123;</span><br><span class=line>                sl.unlockRead(stamp);</span><br><span class=line>                stamp = sl.writeLock();</span><br><span class=line>            &#125;</span><br><span class=line>        &#125;</span><br><span class=line>    &#125; <span class=keyword>finally</span> &#123;</span><br><span class=line>        sl.unlock(stamp);</span><br><span class=line>    &#125;</span><br><span class=line>&#125;</span><br></pre></table></figure><h2 id=注意事项><a href=#注意事项 class=headerlink title=注意事项></a>注意事项</h2><ul><li><code>StampedLock</code> 不支持重入,重入会导致死锁.<li>使用 <code>StampedLock</code> 一定不要调用中断操作, 一定使用可中断的悲观读锁 <code>readLockInterruptibly()</code> 和写锁 <code>writeLockInterruptibly()</code>.</ul><h1 id=CountDownLatch和CyclicBarrier-如何让多线程步调一致><a href=#CountDownLatch和CyclicBarrier-如何让多线程步调一致 class=headerlink title="CountDownLatch和CyclicBarrier: 如何让多线程步调一致"></a>CountDownLatch和CyclicBarrier: 如何让多线程步调一致</h1><p><code>CountDownLatch</code> 和 <code>CyclicBarrier</code> 是 Java 并发包提供的两个非常易用的<strong>线程同步工具类</strong>, 这两个工具类用法的区别在这里还是有必要再强调一下:<ul><li><code>CountDownLatch</code> 主要用来<strong>解决一个线程等待多个线程的场景</strong>, 可以类比旅游团团长要等待所有的游客到齐才能去下一个景点;<li>而 <code>CyclicBarrier</code> 是<strong>一组线程之间互相等待</strong>, 更像是几个驴友之间不离不弃.</ul><p>除此之外 <code>CountDownLatch</code> 的计数器是<strong>不能循环利用</strong>的, 也就是说一旦计数器减到 0, 再有线程调用 await(), 该线程会直接通过. 但 <code>CyclicBarrier</code> 的计数器是<strong>可以循环利用</strong>的, 而且具备<strong>自动重置</strong>的功能, 一旦计数器减到 0 会自动重置到你设置的初始值. 除此之外, <code>CyclicBarrier</code> 还可以设置回调函数, 可以说是功能丰富.<p>举个例子就是做一个对账功能, 首先查询订单, 然后查询派送单, 之后对比订单和派送单, 将差异写入差异库:<p><img src=https://cdn.yangbingdong.com/img/concurrent/java-concurrent-countdownlatch01.png alt><p>抽象代码如下:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>while</span>(存在未对账订单)&#123;</span><br><span class=line>  <span class=comment>// 查询未对账订单</span></span><br><span class=line>  pos = getPOrders();</span><br><span class=line>  <span class=comment>// 查询派送单</span></span><br><span class=line>  dos = getDOrders();</span><br><span class=line>  <span class=comment>// 执行对账操作</span></span><br><span class=line>  diff = check(pos, dos);</span><br><span class=line>  <span class=comment>// 差异写入差异库</span></span><br><span class=line>  save(diff);</span><br><span class=line>&#125;</span><br></pre></table></figure><p>执行流程是这样的:<p><img src=https://cdn.yangbingdong.com/img/concurrent/java-concurrent-countdownlatch02.png alt><p>其实 <code>getPOrders()</code> 与 <code>getDOrders()</code> 是可以并行执行的:<p><img src=https://cdn.yangbingdong.com/img/concurrent/java-concurrent-countdownlatch03.png alt><p>这时候可以使用 <code>CountDownLatch</code> 来实现:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line><span class=comment>// 创建2个线程的线程池</span></span><br><span class=line>Executor executor = </span><br><span class=line>  Executors.newFixedThreadPool(<span class=number>2</span>);</span><br><span class=line><span class=keyword>while</span>(存在未对账订单)&#123;</span><br><span class=line>  <span class=comment>// 计数器初始化为2</span></span><br><span class=line>  CountDownLatch latch = </span><br><span class=line>    <span class=keyword>new</span> CountDownLatch(<span class=number>2</span>);</span><br><span class=line>  <span class=comment>// 查询未对账订单</span></span><br><span class=line>  executor.execute(()-&gt; &#123;</span><br><span class=line>    pos = getPOrders();</span><br><span class=line>    latch.countDown();</span><br><span class=line>  &#125;);</span><br><span class=line>  <span class=comment>// 查询派送单</span></span><br><span class=line>  executor.execute(()-&gt; &#123;</span><br><span class=line>    dos = getDOrders();</span><br><span class=line>    latch.countDown();</span><br><span class=line>  &#125;);</span><br><span class=line>  </span><br><span class=line>  <span class=comment>// 等待两个查询操作结束</span></span><br><span class=line>  latch.await();</span><br><span class=line>  </span><br><span class=line>  <span class=comment>// 执行对账操作</span></span><br><span class=line>  diff = check(pos, dos);</span><br><span class=line>  <span class=comment>// 差异写入差异库</span></span><br><span class=line>  save(diff);</span><br><span class=line>&#125;</span><br></pre></table></figure><p>当然, 我们也可以使用线程的 <code>join()</code> 来实现:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=keyword>while</span>(存在未对账订单)&#123;</span><br><span class=line>  <span class=comment>// 查询未对账订单</span></span><br><span class=line>  Thread T1 = <span class=keyword>new</span> Thread(()-&gt;&#123;</span><br><span class=line>    pos = getPOrders();</span><br><span class=line>  &#125;);</span><br><span class=line>  T1.start();</span><br><span class=line>  <span class=comment>// 查询派送单</span></span><br><span class=line>  Thread T2 = <span class=keyword>new</span> Thread(()-&gt;&#123;</span><br><span class=line>    dos = getDOrders();</span><br><span class=line>  &#125;);</span><br><span class=line>  T2.start();</span><br><span class=line>  <span class=comment>// 等待T1、T2结束</span></span><br><span class=line>  T1.join();</span><br><span class=line>  T2.join();</span><br><span class=line>  <span class=comment>// 执行对账操作</span></span><br><span class=line>  diff = check(pos, dos);</span><br><span class=line>  <span class=comment>// 差异写入差异库</span></span><br><span class=line>  save(diff);</span><br><span class=line>&#125;</span><br></pre></table></figure><p>缺点就是每次都需要创建以及销毁线程, 非常消耗资源.<p>想一想, 还能再优化吗? 我们将 <code>getPOrders()</code> 和 <code>getDOrders()</code> 这两个查询操作并行了, 但这两个查询操作和对账操作 <code>check()</code>、<code>save()</code> 之间还是串行的. 很显然, 这两个查询操作和对账操作也是可以并行的, 也就是说, 在执行对账操作的时候, 可以同时去执行下一轮的查询操作:<p><img src=https://cdn.yangbingdong.com/img/concurrent/java-concurrent-countdownlatch04.png alt><p>两次查询操作能够和对账操作并行, 对账操作还依赖查询操作的结果, 这明显有点生产者 - 消费者的意思. 那么需要两个队列, 并且两个队列的元素之间还有对应关系:<p><img src=https://cdn.yangbingdong.com/img/concurrent/java-concurrent-countdownlatch05.png alt><p>但线程 T1 和线程 T2 的工作要步调一致, 不能一个跑得太快, 一个跑得太慢, 只有这样才能做到各自生产完 1 条数据的时候, 通知线程 T3.<p><img src=https://cdn.yangbingdong.com/img/concurrent/java-concurrent-countdownlatch06.png alt><p>这时候 <code>CyclicBarrier</code> 就派上用场了:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br></pre><td class=code><pre><span class=line><span class=comment>// 订单队列</span></span><br><span class=line>Vector&lt;P&gt; pos;</span><br><span class=line><span class=comment>// 派送单队列</span></span><br><span class=line>Vector&lt;D&gt; dos;</span><br><span class=line><span class=comment>// 执行回调的线程池 </span></span><br><span class=line>Executor executor = </span><br><span class=line>  Executors.newFixedThreadPool(<span class=number>1</span>);</span><br><span class=line><span class=keyword>final</span> CyclicBarrier barrier =</span><br><span class=line>  <span class=keyword>new</span> CyclicBarrier(<span class=number>2</span>, ()-&gt;&#123;</span><br><span class=line>    executor.execute(()-&gt;check());</span><br><span class=line>  &#125;);</span><br><span class=line>  </span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>check</span><span class=params>()</span></span>&#123;</span><br><span class=line>  P p = pos.remove(<span class=number>0</span>);</span><br><span class=line>  D d = dos.remove(<span class=number>0</span>);</span><br><span class=line>  <span class=comment>// 执行对账操作</span></span><br><span class=line>  diff = check(p, d);</span><br><span class=line>  <span class=comment>// 差异写入差异库</span></span><br><span class=line>  save(diff);</span><br><span class=line>&#125;</span><br><span class=line>  </span><br><span class=line><span class=function><span class=keyword>void</span> <span class=title>checkAll</span><span class=params>()</span></span>&#123;</span><br><span class=line>  <span class=comment>// 循环查询订单库</span></span><br><span class=line>  Thread T1 = <span class=keyword>new</span> Thread(()-&gt;&#123;</span><br><span class=line>    <span class=keyword>while</span>(存在未对账订单)&#123;</span><br><span class=line>      <span class=comment>// 查询订单库</span></span><br><span class=line>      pos.add(getPOrders());</span><br><span class=line>      <span class=comment>// 等待</span></span><br><span class=line>      barrier.await();</span><br><span class=line>    &#125;</span><br><span class=line>  &#125;);</span><br><span class=line>  T1.start();  </span><br><span class=line>  <span class=comment>// 循环查询运单库</span></span><br><span class=line>  Thread T2 = <span class=keyword>new</span> Thread(()-&gt;&#123;</span><br><span class=line>    <span class=keyword>while</span>(存在未对账订单)&#123;</span><br><span class=line>      <span class=comment>// 查询运单库</span></span><br><span class=line>      dos.add(getDOrders());</span><br><span class=line>      <span class=comment>// 等待</span></span><br><span class=line>      barrier.await();</span><br><span class=line>    &#125;</span><br><span class=line>  &#125;);</span><br><span class=line>  T2.start();</span><br><span class=line>&#125;</span><br></pre></table></figure><p>这里有两个注意点:<ol><li>为啥要用线程池, 而不是在回调函数中直接调用? 使用线程池是为了异步操作, 否则回掉函数是同步调用的, 也就是本次对账操作执行完才能进行下一轮的检查.<li>线程池为啥使用单线程的? 线程数量固定为1, 防止了多线程并发导致的数据不一致, 因为订单和派送单是两个队列, 只有单线程去两个队列中取消息才不会出现消息不匹配的问题.</ol></div><div style=text-align:center;color:#ccc;font-size:14px>---------------- The End ----------------</div><div><div id=wechat_subscriber style="display:block;padding:10px 0;margin:20px auto;width:100%;text-align:center"><img id=wechat_subscriber_qcode src=/images/wechat/gongzhonghao.jpg alt="ookamiAntD wechat" style=width:200px;max-width:100%><div>欢迎您扫一扫上面的微信公众号，订阅我的博客！</div></div></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>谢谢大爷～</div><button id=rewardButton disable=enable onclick="var qr=document.getElementById('QR');if(qr.style.display==='none'){qr.style.display='block';}else{qr.style.display='none'}">
<span>赏</span></button><div id=QR style=display:none><div id=wechat style=display:inline-block><img id=wechat_qr src=/images/donate/wechat.png alt="ookamiAntD WeChat Pay"><p>微信打赏</div><div id=alipay style=display:inline-block><img id=alipay_qr src=/images/donate/alipay.jpg alt="ookamiAntD Alipay"><p>支付宝打赏</div></div></div></div><div><p id=div-border-left-red>Author：<b>ookamiAntD Yang</b><br>Link：<a href=/2019/java-concurrent-part2/ title="Java 并发拾遗-并发工具(上)">http://yangbingdong.com/2019/java-concurrent-part2/</a><br>Contact：<a>yangbingdong1994@gmail.com</a><br><b>本文基于<a target=_blank title="Creative Commons Attribution-ShareAlike 4.0 International (CC BY-SA 4.0)" href=http://creativecommons.org/licenses/by-sa/4.0/ rel="external nofollow noopener noreferrer"> 知识共享署名-相同方式共享 4.0 </a>国际许可协议发布</b><br><b>转载请注明出处，谢谢！</b></div><footer class=post-footer><div class=post-tags><a href=/tags/Java/ rel=tag><i class="fa fa-tag"></i>Java</a>
<a href=/tags/Concurrent/ rel=tag><i class="fa fa-tag"></i>Concurrent</a></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/2019/java-concurrent-part1/ rel=next title="Java 并发拾遗-并发理论基础"><i class="fa fa-chevron-left"></i>Java 并发拾遗-并发理论基础</a></div><span class=post-nav-divider></span><div class="post-nav-prev post-nav-item"><a href=/2019/java-concurrent-part3/ rel=prev title="Java 并发拾遗-并发工具(中)">Java 并发拾遗-并发工具(中) <i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class=post-spread><div class=-hoofoo-share-title>分享到：</div><div class=-hoofoo-share-buttons><div class="-mob-share-weibo -hoofoo-share-weibo -hoofoo-share-ui-button"><i class="fa fa-weibo" aria-hidden=true></i></div><div class="-mob-share-weixin -hoofoo-share-weixin -hoofoo-share-ui-button"><i class="fa fa-weixin" aria-hidden=true></i></div><div class="-mob-share-qq -hoofoo-share-qq -hoofoo-share-ui-button"><i class="fa fa-qq" aria-hidden=true></i></div><div class="-mob-share-twitter -hoofoo-share-twitter -hoofoo-share-ui-button"><i class="fa fa-twitter" aria-hidden=true></i></div><div class="-hoofoo-share-more -hoofoo-share-ui-button -mob-share-open"><i class="fa fa-ellipsis-h" aria-hidden=true></i></div></div><div class=-mob-share-ui style=display:none><ul class=-mob-share-list><li class=-mob-share-weibo><p>新浪微博<li class=-mob-share-weixin><p>微信<li class=-mob-share-qzone><p>QQ空间<li class=-mob-share-qq><p>QQ好友<li class=-mob-share-tencentweibo><p>腾讯微博<li class=-mob-share-renren><p>人人网<li class=-mob-share-kaixin><p>开心网<li class=-mob-share-douban><p>豆瓣<li class=-mob-share-youdao><p>有道云笔记<li class=-mob-share-mingdao><p>明道<li class=-mob-share-pengyou><p>朋友网<li class=-mob-share-facebook><p>Facebook<li class=-mob-share-twitter><p>Twitter<li class=-mob-share-pocket><p>Pocket<li class=-mob-share-google><p>Google+<li class=-mob-share-tumblr><p>Tumblr<li class=-mob-share-instapaper><p>Instapaper<li class=-mob-share-linkedin><p>Linkedin</ul><div class=-mob-share-close>取消</div></div><div class=-mob-share-ui-bg></div><script id=-mob-share src="https://f1.webshare.mob.com/code/mob-share.js?appkey=21aa3b13ad233"></script></div></div></div><div class=comments id=comments><div style=text-align:center></div><div id=disqus_proxy_thread></div><div id=disqus_thread></div><script>window.disqusProxy={username:'ookamiantd',server:'disqus-proxy.yangbingdong.com',port:'',defaultAvatar:'/images/avatar/avatar-default.jpg',adminAvatar:'/images/avatar/avatar-admin.jpg',identifier:'2019/java-concurrent-part2/'};window.disqus_config=function(){this.page.url='http://yangbingdong.com/2019/java-concurrent-part2/';this.page.identifier='2019/java-concurrent-part2/';};window.onload=function(){var s=document.createElement('script');s.src="/static/js/main.0d0338ae.js";s.async=true;document.body.appendChild(s);}</script><link rel=stylesheet href=/static/css/main.0603c539.css></div></div><div class=sidebar-toggle><div class=sidebar-toggle-line-wrap><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id=sidebar class=sidebar><div class=sidebar-inner><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target=post-toc-wrap>Table of Contents<li class=sidebar-nav-overview data-target=site-overview>Overview</ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image src=/images/avatar/avatar-admin.jpg alt=ookamiAntD><p class=site-author-name itemprop=name>ookamiAntD<p class="site-description motion-element" itemprop=description>码渣 | rocker | 二次元 | 美剧 | 宅</div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href=/archives><span class=site-state-item-count>48</span>
<span class=site-state-item-name>posts</span></a></div><div class="site-state-item site-state-categories"><a href=/categories><span class=site-state-item-count>19</span>
<span class=site-state-item-name>categories</span></a></div><div class="site-state-item site-state-tags"><a href=/tags><span class=site-state-item-count>45</span>
<span class=site-state-item-name>tags</span></a></div></nav><div class="feed-link motion-element"><a href=/atom.xml rel=alternate><i class="fa fa-rss"></i>RSS</a></div><div class="links-of-author motion-element"><span class=links-of-author-item><a href=https://github.com/masteranthoneyd target=_blank rel="external nofollow noopener noreferrer" title=GitHub><i class="fa fa-fw fa-github"></i>GitHub</a></span>
<span class=links-of-author-item><a href="https://www.facebook.com/profile.php?id=100014869064462" target=_blank rel="external nofollow noopener noreferrer" title=Facebook><i class="fa fa-fw fa-facebook"></i>Facebook</a></span>
<span class=links-of-author-item><a href=https://twitter.com/ookamiAntD target=_blank rel="external nofollow noopener noreferrer" title=Twitter><i class="fa fa-fw fa-twitter"></i>Twitter</a></span></div><div class="cc-license motion-element" itemprop=license><a href=https://creativecommons.org/licenses/by-sa/4.0/ class=cc-opacity target=_blank rel="external nofollow noopener noreferrer"><img src=/images/cc-by-sa.svg alt="Creative Commons"></a></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class=links-of-blogroll-title><i class="fa  fa-fw fa-globe"></i>大神们的博客</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://mercyblitz.github.io/ title=mercyblitz(Java劝退师) target=_blank rel="external nofollow noopener noreferrer">mercyblitz(Java劝退师)</a><li class=links-of-blogroll-item><a href=https://muyinchen.github.io/ title=知秋大神(真·大神) target=_blank rel="external nofollow noopener noreferrer">知秋大神(真·大神)</a><li class=links-of-blogroll-item><a href=http://crossoverjie.top/ title="crossoverJie's Blog" target=_blank rel="external nofollow noopener noreferrer">crossoverJie's Blog</a><li class=links-of-blogroll-item><a href=http://yemengying.com/ title="Giraffe's Home" target=_blank rel="external nofollow noopener noreferrer">Giraffe's Home</a></ul></div><div id=days></div><script>function show_date_time(){window.setTimeout("show_date_time()",1000);BirthDay=new Date("01/10/2017 12:34:56");today=new Date();timeold=(today.getTime()-BirthDay.getTime());sectimeold=timeold/1000
secondsold=Math.floor(sectimeold);msPerDay=24*60*60*1000
e_daysold=timeold/msPerDay
daysold=Math.floor(e_daysold);e_hrsold=(e_daysold-daysold)*24;hrsold=setzero(Math.floor(e_hrsold));e_minsold=(e_hrsold-hrsold)*60;minsold=setzero(Math.floor((e_hrsold-hrsold)*60));seconds=setzero(Math.floor((e_minsold-minsold)*60));document.getElementById('days').innerHTML="已运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒";}
function setzero(i){if(i<10)
{i="0"+i};return i;}
show_date_time();</script></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class=post-toc><div class=post-toc-content><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#Preface><span class=nav-number>1.</span> <span class=nav-text>Preface</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#Lock-amp-Condition><span class=nav-number>2.</span> <span class=nav-text>Lock&amp;Condition</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#Lock><span class=nav-number>2.1.</span> <span class=nav-text>Lock</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#造轮子的理由><span class=nav-number>2.1.1.</span> <span class=nav-text>造轮子的理由</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#如何保证可见性><span class=nav-number>2.1.2.</span> <span class=nav-text>如何保证可见性</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#可重入锁><span class=nav-number>2.1.3.</span> <span class=nav-text>可重入锁</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#公平锁与非公平锁><span class=nav-number>2.1.4.</span> <span class=nav-text>公平锁与非公平锁</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#Condition><span class=nav-number>2.2.</span> <span class=nav-text>Condition</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#Semaphore-如何快速实现一个限流器><span class=nav-number>3.</span> <span class=nav-text>Semaphore: 如何快速实现一个限流器</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#信号量模型><span class=nav-number>3.1.</span> <span class=nav-text>信号量模型</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#使用><span class=nav-number>3.2.</span> <span class=nav-text>使用</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#ReadWriteLock-如何快速实现一个完备的缓存><span class=nav-number>4.</span> <span class=nav-text>ReadWriteLock: 如何快速实现一个完备的缓存</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#锁升级><span class=nav-number>4.1.</span> <span class=nav-text>锁升级</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#StampedLock-读写锁更快的锁><span class=nav-number>5.</span> <span class=nav-text>StampedLock: 读写锁更快的锁</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#特点><span class=nav-number>5.1.</span> <span class=nav-text>特点</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#乐观读><span class=nav-number>5.2.</span> <span class=nav-text>乐观读</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#锁升级-1><span class=nav-number>5.3.</span> <span class=nav-text>锁升级</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#注意事项><span class=nav-number>5.4.</span> <span class=nav-text>注意事项</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#CountDownLatch和CyclicBarrier-如何让多线程步调一致><span class=nav-number>6.</span> <span class=nav-text>CountDownLatch和CyclicBarrier: 如何让多线程步调一致</span></a></ol></div></div></section></div></aside></div></main><footer id=footer class=footer><div class=footer-inner><div class=busuanzi-count><script async src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span class=site-uv><i class="fa fa-user">本站访客数</i><span class=busuanzi-value id=busuanzi_value_site_uv></span>人次</span>
<span class=site-pv><i class="fa fa-eye">本站总访问量</i><span class=busuanzi-value id=busuanzi_value_site_pv></span>次</span></div><div class=copyright>&copy; 2016 -
<span itemprop=copyrightYear>2020</span>
<span class=with-love><i class="fa fa-flash"></i></span><span class=author itemprop=copyrightHolder>Hosted by <a href=https://pages.coding.me style=font-weight:700 rel="external nofollow noopener noreferrer" target=_blank>Coding Pages</a></span> | <span class=post-count>共280.0k字</span></div><div class=theme-info><a target=_blank href=http://www.miibeian.gov.cn/ rel=nofollow style=color:#555>粤ICP备18135202号-1</a></div><div style="width:300px;margin:0 auto"><a target=_blank href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44010602005896" style=display:inline-block;text-decoration:none;height:20px;line-height:20px><img src=https://cdn.yangbingdong.com/img/beian/beian.png style=float:left><p style="float:left;height:20px;line-height:20px;margin:0 0 0 5px;color:#555">粤公网安备 44010602005896号</p></a></div></div></footer><div class=back-to-top><i class="fa fa-arrow-up"></i></div></div><script>if(Object.prototype.toString.call(window.Promise)!=='[object Function]'){window.Promise=null;}</script><script src="/lib/jquery/index.js?v=2.1.3"></script><script src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script src="/js/src/utils.js?v=5.1.0"></script><script src="/js/src/motion.js?v=5.1.0"></script><script src="/js/src/scrollspy.js?v=5.1.0"></script><script src="/js/src/post-details.js?v=5.1.0"></script><script src="/js/src/bootstrap.js?v=5.1.0"></script><script>var disqus_shortname='ookamiantd';var disqus_identifier='2019/java-concurrent-part2/';var disqus_title="Java 并发拾遗-并发工具(上)";function run_disqus_script(disqus_script){var dsq=document.createElement('script');dsq.type='text/javascript';dsq.async=true;dsq.src='//'+disqus_shortname+'.disqus.com/'+disqus_script;(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(dsq);}
var disqus={load:function disqus(){if(typeof DISQUS!=='object'){(function(){var s=document.createElement('script');s.async=true;s.type='text/javascript';s.src='//'+disqus_shortname+'.disqus.com/embed.js';(document.getElementsByTagName('HEAD')[0]||document.getElementsByTagName('BODY')[0]).appendChild(s);}());$('#load-disqus').html("评论加载中，请确保你有梯子，若评论长时间未加载则你可能翻墙失败...").fadeOut(9000);}}}</script><script>var isfetched=false;var search_path="search.xml";if(search_path.length==0){search_path="search.xml";}
var path="/"+search_path;function proceedsearch(){$("body").append('<div class="popoverlay">').css('overflow','hidden');$('.popup').toggle();}
var searchFunc=function(path,search_id,content_id){'use strict';$.ajax({url:path,dataType:"xml",async:true,success:function(xmlResponse){isfetched=true;$('.popup').detach().appendTo('.header-inner');var datas=$("entry",xmlResponse).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()};}).get();var $input=document.getElementById(search_id);var $resultContent=document.getElementById(content_id);$input.addEventListener('input',function(){var matchcounts=0;var str='<ul class=\"search-result-list\">';var keywords=this.value.trim().toLowerCase().split(/[\s\-]+/);$resultContent.innerHTML="";if(this.value.trim().length>1){datas.forEach(function(data){var isMatch=false;var content_index=[];var data_title=data.title.trim().toLowerCase();var data_content=data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();var data_url=decodeURIComponent(data.url);var index_title=-1;var index_content=-1;var first_occur=-1;if(data_title!=''){keywords.forEach(function(keyword,i){index_title=data_title.indexOf(keyword);index_content=data_content.indexOf(keyword);if(index_title>=0||index_content>=0){isMatch=true;if(i==0){first_occur=index_content;}}});}
if(isMatch){matchcounts+=1;str+="<li><a href='"+data_url+"' class='search-result-title'>"+data_title+"</a>";var content=data.content.trim().replace(/<[^>]+>/g,"");if(first_occur>=0){var start=first_occur-20;var end=first_occur+80;if(start<0){start=0;}
if(start==0){end=50;}
if(end>content.length){end=content.length;}
var match_content=content.substring(start,end);keywords.forEach(function(keyword){var regS=new RegExp(keyword,"gi");match_content=match_content.replace(regS,"<b class=\"search-keyword\">"+keyword+"</b>");});str+="<p class=\"search-result\">"+match_content+"...</p>"}
str+="</li>";}})};str+="</ul>";if(matchcounts==0){str='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'}
if(keywords==""){str='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'}
$resultContent.innerHTML=str;});proceedsearch();}});}
$('.popup-trigger').click(function(e){e.stopPropagation();if(isfetched==false){searchFunc(path,'local-search-input','local-search-result');}else{proceedsearch();};});$('.popup-btn-close').click(function(e){$('.popup').hide();$(".popoverlay").remove();$('body').css('overflow','');});$('.popup').click(function(e){e.stopPropagation();});</script><script src=https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js></script><script>AV.initialize("usE0s6JGUeOiMcsVoRuHuv2B-gzGzoHsz","ewm6NEF07r83HbnOr63ptuKH");</script><script>function showTime(Counter){var query=new AV.Query(Counter);var entries=[];var $visitors=$(".leancloud_visitors");$visitors.each(function(){entries.push($(this).attr("id").trim());});query.containedIn('url',entries);query.find().done(function(results){var COUNT_CONTAINER_REF='.leancloud-visitors-count';if(results.length===0){$visitors.find(COUNT_CONTAINER_REF).text(0);return;}
for(var i=0;i<results.length;i++){var item=results[i];var url=item.get('url');var time=item.get('time');var element=document.getElementById(url);$(element).find(COUNT_CONTAINER_REF).text(time);}
for(var i=0;i<entries.length;i++){var url=entries[i];var element=document.getElementById(url);var countSpan=$(element).find(COUNT_CONTAINER_REF);if(countSpan.text()==''){countSpan.text(0);}}}).fail(function(object,error){console.log("Error: "+error.code+" "+error.message);});}
function addCount(Counter){var $visitors=$(".leancloud_visitors");var url=$visitors.attr('id').trim();var title=$visitors.attr('data-flag-title').trim();var query=new AV.Query(Counter);query.equalTo("url",url);query.find({success:function(results){if(results.length>0){var counter=results[0];counter.fetchWhenSave(true);counter.increment("time");counter.save(null,{success:function(counter){var $element=$(document.getElementById(url));$element.find('.leancloud-visitors-count').text(counter.get('time'));},error:function(counter,error){console.log('Failed to save Visitor num, with error message: '+error.message);}});}else{var newcounter=new Counter();var acl=new AV.ACL();acl.setPublicReadAccess(true);acl.setPublicWriteAccess(true);newcounter.setACL(acl);newcounter.set("title",title);newcounter.set("url",url);newcounter.set("time",1);newcounter.save(null,{success:function(newcounter){var $element=$(document.getElementById(url));$element.find('.leancloud-visitors-count').text(newcounter.get('time'));},error:function(newcounter,error){console.log('Failed to create');}});}},error:function(error){console.log('Error:'+error.code+" "+error.message);}});}
$(function(){var Counter=AV.Object.extend("Counter");if($('.leancloud_visitors').length==1){addCount(Counter);}else if($('.post-title-link').length>1){showTime(Counter);}});</script><script>(function(){var bp=document.createElement('script');var curProtocol=window.location.protocol.split(':')[0];if(curProtocol==='https'){bp.src='https://zz.bdstatic.com/linksubmit/push.js';}
else{bp.src='http://push.zhanzhang.baidu.com/push.js';}
var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(bp,s);})();</script><script color=255,0,204 opacity=0.5 zindex=-2 count=40 src=//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js></script><script>$('body').delegate('.-mob-share-weixin-qrcode-bg','click',function(){$(".-mob-share-weixin-qrcode-close").trigger("click");});</script><canvas class=fireworks style=position:fixed;left:0;top:0;z-index:1;pointer-events:none></canvas>
<script src=//cdn.bootcss.com/animejs/2.2.0/anime.min.js></script><script src=/js/src/fireworks.js></script><script src=/js/src/dytitle.js></script></div></footer></div><script src=/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"superSample":2,"width":88,"height":88,"position":"left"},"mobile":{"show":false},"react":{"opacityDefault":0.9,"opacityOnHover":0.5},"log":false});</script>